              	; --------------------------------------
              	; zasm: assemble "config_nfs_hybrid.asm"
              	; date: 2023-06-12 00:09:13
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0035:         	mem	equ	53		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
D400:         	#code	_TEXT,(mem)*1024
F930:         	#data	_BSS,_TEXT_end
FF00:         	#data	_JUMP_TABLE,0xFF00
FF00: 00000000	intvec:	defs	16
FF04: 00...   	
FF10: 00000000	dircbuf:defs	128
FF14: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "../CPM22.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	;
              	;   set origin for cp/m
              	;
              	;	org	(mem)*1024
              	;
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
D400: C364D7  	cbase:	jp	command		;execute command processor (ccp).
D403: C360D7  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
D406: 7F      	inbuff:	defb	127		;length of input buffer.
D407: 00      		defb	0		;current length of contents.
D408: 494E4954		defb	'INIT '
D40C: 20      	
D40D: FF000000		defb	255,0,0,0
D411: 20313937		defb	' 1979 (c) by Digital Research      '
D415: 39202863	
D419: 29206279	
D41D: 20446967	
D421: 6974616C	
D425: 20526573	
D429: 65617263	
D42D: 68202020	
D431: 202020  	
D434: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D438: 00...   	
D44B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D44F: 00...   	
D462: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D466: 00...   	
D479: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D47D: 00...   	
D488: 08D4    	inpoint:defw	inbuff+2	;input line pointer
D48A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
D48C: 5F      	print:	ld	e,a		;setup bdos call.
D48D: 0E02    		ld	c,2
D48F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
D492: C5      	printb:	push	bc
D493: CD8CD4  		call	print
D496: C1      		pop	bc
D497: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
D498: 3E0D    	crlf:	ld	a,cr
D49A: CD92D4  		call	printb
D49D: 3E0A    		ld	a,lf
D49F: 18F1    		jr	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
D4A1: 3E20    	space:	ld	a,' '
D4A3: C392D4  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
D4A6: C5      	pline:	push	bc
D4A7: CD98D4  		call	crlf
D4AA: E1      		pop	hl
D4AB: 7E      	pline2:	ld	a,(hl)
D4AC: B7      		or	a
D4AD: C8      		ret	z
D4AE: 23      		inc	hl
D4AF: E5      		push	hl
D4B0: CD8CD4  		call	print
D4B3: E1      		pop	hl
D4B4: C3ABD4  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
D4B7: 0E0D    	resdsk:	ld	c,13
D4B9: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
D4BC: 5F      	dsksel:	ld	e,a
D4BD: 0E0E    		ld	c,14
D4BF: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
D4C2: CD0500  	entry1:	call	entry
D4C5: 32FBDB  		ld	(rtncode),a	;save return code.
D4C8: 3C      		inc	a		;set zero if 0ffh returned.
D4C9: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
D4CA: 0E0F    	open:	ld	c,15
D4CC: C3C2D4  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
D4CF: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
D4D0: 32FADB  		ld	(fcb+32),a
D4D3: 11DADB  		ld	de,fcb
D4D6: C3CAD4  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
D4D9: 0E10    	close:	ld	c,16
D4DB: C3C2D4  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
D4DE: 0E11    	srchfst:ld	c,17
D4E0: C3C2D4  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
D4E3: 0E12    	srchnxt:ld	c,18
D4E5: C3C2D4  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
D4E8: 11DADB  	srchfcb:ld	de,fcb
D4EB: C3DED4  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
D4EE: 0E13    	delete:	ld	c,19
D4F0: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
D4F3: CD0500  	entry2:	call	entry
D4F6: B7      		or	a		;set zero flag if appropriate.
D4F7: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
D4F8: 0E14    	rdrec:	ld	c,20
D4FA: C3F3D4  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
D4FD: 11DADB  	readfcb:ld	de,fcb
D500: C3F8D4  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
D503: 0E15    	wrtrec:	ld	c,21
D505: C3F3D4  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
D508: 0E16    	create:	ld	c,22
D50A: C3C2D4  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
D50D: 0E17    	renam:	ld	c,23
D50F: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
D512: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
D514: 0E20    	getsetuc: ld	c,32
D516: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
D519: CD12D5  	setcdrv:call	getusr		;get user number
D51C: 87      		add	a,a		;and shift into the upper 4 bits.
D51D: 87      		add	a,a
D51E: 87      		add	a,a
D51F: 87      		add	a,a
D520: 21FCDB  		ld	hl,cdrive	;now add in the current drive number.
D523: B6      		or	(hl)
D524: 320400  		ld	(tdrive),a	;and save.
D527: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
D528: 3AFCDB  	movecd:	ld	a,(cdrive)
D52B: 320400  		ld	(tdrive),a
D52E: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
D52F: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
D531: D8      		ret	c
D532: FE7B    		cp	'{'
D534: D0      		ret	nc
D535: E65F    		and	5fh		;convert it if found.
D537: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
D538: 3AB8DB  	getinp:	ld	a,(batch)	;if =0, then use console input.
D53B: B7      		or	a
D53C: CAA0D5  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
D53F: 3AFCDB  		ld	a,(cdrive)	;select drive 0 if need be.
D542: B7      		or	a
D543: 3E00    		ld	a,0		;always use drive a for submit.
D545: C4BCD4  		call	nz,dsksel	;select it if required.
D548: 11B9DB  		ld	de,batchfcb
D54B: CDCAD4  		call	open		;look for it.
D54E: CAA0D5  		jp	z,getinp1	;if not there, use normal input.
D551: 3AC8DB  		ld	a,(batchfcb+15)	;get last record number+1.
D554: 3D      	getinp0:dec	a
D555: 32D9DB  		ld	(batchfcb+32),a
D558: 11B9DB  		ld	de,batchfcb
D55B: F5      		push	af
D55C: CDF8D4  		call	rdrec		;read last record.
D55F: D1      		pop	de
D560: C2A0D5  		jp	nz,getinp1	;quit on end of file.
D563: 218000  		ld	hl,tbuff	;data was read into buffer here.
D566: AF      		xor	a		;skip if entry has nothing in it
D567: BE      		cp	(hl)
D568: 7A      		ld	a,d
D569: 28E9    		jr	z,getinp0
              	
              	;   move this record into input buffer.
              	;
D56B: 1107D4  		ld	de,inbuff+1
D56E: 0680    		ld	b,128		;all 128 characters may be used.
D570: E5      		push	hl		;save tbuff
D571: CD4FD8  		call	hl2de		;(hl) to (de), (b) bytes.
D574: E1      		pop	hl		;zero out first in tbuff
D575: 3600    		ld	(hl),0
D577: 21D9DB  		ld	hl,batchfcb+32
D57A: 35      		dec	(hl)		;decrement the record count.
D57B: 11B9DB  		ld	de,batchfcb	;close the batch file now.
D57E: D5      		push	de
D57F: CD03D5  		call	wrtrec		;write out record
D582: D1      		pop	de
D583: CDD9D4  		call	close
D586: 2818    		jr	z,getinp1	;quit on an error.
D588: 3AFCDB  		ld	a,(cdrive)	;re-select previous drive if need be.
D58B: B7      		or	a
D58C: C4BCD4  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
D58F: 2108D4  		ld	hl,inbuff+2
D592: CDABD4  		call	pline2
D595: CDCAD5  		call	chkcon		;check console, quit on a key.
D598: 2817    		jr	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
D59A: CDE5D5  		call	delbatch	;delete the batch file.
D59D: C387D7  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
D5A0: CDE5D5  	getinp1:call	delbatch	;delete file ($$$.sub).
D5A3: CD19D5  		call	setcdrv		;reset active disk.
D5A6: 0E0A    		ld	c,10		;get line from console device.
D5A8: 1106D4  		ld	de,inbuff
D5AB: CD0500  		call	entry
D5AE: CD28D5  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
D5B1: 2107D4  	getinp2:ld	hl,inbuff+1
D5B4: 46      		ld	b,(hl)		;(b)=character counter.
D5B5: 23      	getinp3:inc	hl
D5B6: 78      		ld	a,b		;end of the line?
D5B7: B7      		or	a
D5B8: 2808    		jr	z,getinp4
D5BA: 7E      		ld	a,(hl)		;convert to upper case.
D5BB: CD2FD5  		call	upper
D5BE: 77      		ld	(hl),a
D5BF: 05      		dec	b		;adjust character count.
D5C0: 18F3    		jr	getinp3
D5C2: 77      	getinp4:ld	(hl),a		;add trailing null.
D5C3: 2108D4  		ld	hl,inbuff+2
D5C6: 2288D4  		ld	(inpoint),hl	;reset input line pointer.
D5C9: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
D5CA: 0E0B    	chkcon:	ld	c,11		;check console.
D5CC: CD0500  		call	entry
D5CF: B7      		or	a
D5D0: C8      		ret	z		;return if nothing.
D5D1: 0E01    		ld	c,1		;else get character.
D5D3: CD0500  		call	entry
D5D6: B7      		or	a		;clear zero flag and return.
D5D7: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
D5D8: 0E19    	getdsk:	ld	c,25
D5DA: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
D5DD: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
D5E0: 0E1A    	dmaset:	ld	c,26
D5E2: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
D5E5: 21B8DB  	delbatch: ld	hl,batch	;is batch active?
D5E8: 7E      		ld	a,(hl)
D5E9: B7      		or	a
D5EA: C8      		ret	z
D5EB: 3600    		ld	(hl),0		;yes, de-activate it.
D5ED: AF      		xor	a
D5EE: CDBCD4  		call	dsksel		;select drive 0 for sure.
D5F1: 11B9DB  		ld	de,batchfcb	;and delete this file.
D5F4: CDEED4  		call	delete
D5F7: 3AFCDB  		ld	a,(cdrive)	;reset current drive.
D5FA: C3BCD4  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
D5FD: 1132D7  	verify:	ld	de,pattrn1+2	;these are the serial number bytes.
D600: 2102DC  		ld	hl,pattrn2+2	;ditto, but how could they be different?
D603: 0604    		ld	b,4		;6 bytes each.
D605: 1A      	verify1:ld	a,(de)
D606: BE      		cp	(hl)
D607: C2DCD7  		jp	nz,halt		;jump to halt routine.
D60A: 13      		inc	de
D60B: 23      		inc	hl
D60C: 05      		dec	b
D60D: C205D6  		jp	nz,verify1
D610: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
D611: CD98D4  	synerr:	call	crlf		;end current line.
D614: 2A8AD4  		ld	hl,(namepnt)	;this points to name in error.
D617: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
D618: FE20    		cp	' '
D61A: CA2AD6  		jp	z,synerr2
D61D: B7      		or	a
D61E: CA2AD6  		jp	z,synerr2
D621: E5      		push	hl
D622: CD8CD4  		call	print
D625: E1      		pop	hl
D626: 23      		inc	hl
D627: C317D6  		jp	synerr1
D62A: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
D62C: CD8CD4  		call	print
D62F: CD98D4  		call	crlf
D632: CDE5D5  		call	delbatch	;delete any batch file.
D635: C387D7  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
D638: 1A      	check:	ld	a,(de)
D639: B7      		or	a
D63A: C8      		ret	z
D63B: FE20    		cp	' '		;control characters are not legal here.
D63D: DA11D6  		jp	c,synerr
D640: C8      		ret	z		;check for valid delimiter.
D641: FE3D    		cp	'='
D643: C8      		ret	z
D644: FE5F    		cp	'_'
D646: C8      		ret	z
D647: FE2E    		cp	'.'
D649: C8      		ret	z
D64A: FE3A    		cp	':'
D64C: C8      		ret	z
D64D: FE3B    		cp	';'
D64F: C8      		ret	z
D650: FE3C    		cp	'<'
D652: C8      		ret	z
D653: FE3E    		cp	'>'
D655: C8      		ret	z
D656: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
D657: 1A      	nonblank: ld	a,(de)
D658: B7      		or	a		;string ends with a null.
D659: C8      		ret	z
D65A: FE20    		cp	' '
D65C: C0      		ret	nz
D65D: 13      		inc	de
D65E: C357D6  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
D661: 85      	addhl:	add	a,l
D662: 6F      		ld	l,a
D663: D0      		ret	nc		;take care of any carry.
D664: 24      		inc	h
D665: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
D666: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
D668: 21DADB  	convert:ld	hl,fcb
D66B: CD61D6  		call	addhl
D66E: E5      		push	hl
D66F: E5      		push	hl
D670: AF      		xor	a
D671: 32FDDB  		ld	(chgdrv),a	;initialize drive change flag.
D674: 2A88D4  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
D677: EB      		ex	de,hl
D678: CD57D6  		call	nonblank	;get next non-blank character.
D67B: EB      		ex	de,hl
D67C: 228AD4  		ld	(namepnt),hl	;save pointer here for any error message.
D67F: EB      		ex	de,hl
D680: E1      		pop	hl
D681: 1A      		ld	a,(de)		;get first character.
D682: B7      		or	a
D683: CA91D6  		jp	z,convrt1
D686: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
D688: 47      		ld	b,a		;and save.
D689: 13      		inc	de		;check next character for a ':'.
D68A: 1A      		ld	a,(de)
D68B: FE3A    		cp	':'
D68D: CA98D6  		jp	z,convrt2
D690: 1B      		dec	de		;nope, move pointer back to the start of the line.
D691: 3AFCDB  	convrt1:ld	a,(cdrive)
D694: 77      		ld	(hl),a
D695: C39ED6  		jp	convrt3
D698: 78      	convrt2:ld	a,b
D699: 32FDDB  		ld	(chgdrv),a	;set change in drives flag.
D69C: 70      		ld	(hl),b
D69D: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
D69E: 0608    	convrt3:ld	b,08h
D6A0: CD38D6  	convrt4:call	check
D6A3: CAC1D6  		jp	z,convrt8
D6A6: 23      		inc	hl
D6A7: FE2A    		cp	'*'		;note that an '*' will fill the remaining
D6A9: C2B1D6  		jp	nz,convrt5	;field with '?'.
D6AC: 363F    		ld	(hl),'?'
D6AE: C3B3D6  		jp	convrt6
D6B1: 77      	convrt5:ld	(hl),a
D6B2: 13      		inc	de
D6B3: 05      	convrt6:dec	b
D6B4: C2A0D6  		jp	nz,convrt4
D6B7: CD38D6  	convrt7:call	check		;get next delimiter.
D6BA: CAC8D6  		jp	z,getext
D6BD: 13      		inc	de
D6BE: C3B7D6  		jp	convrt7
D6C1: 23      	convrt8:inc	hl		;blank fill the file name.
D6C2: 3620    		ld	(hl),' '
D6C4: 05      		dec	b
D6C5: C2C1D6  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
D6C8: 0603    	getext:	ld	b,03h
D6CA: FE2E    		cp	'.'
D6CC: C2F1D6  		jp	nz,getext5
D6CF: 13      		inc	de
D6D0: CD38D6  	getext1:call	check
D6D3: CAF1D6  		jp	z,getext5
D6D6: 23      		inc	hl
D6D7: FE2A    		cp	'*'
D6D9: C2E1D6  		jp	nz,getext2
D6DC: 363F    		ld	(hl),'?'
D6DE: C3E3D6  		jp	getext3
D6E1: 77      	getext2:ld	(hl),a
D6E2: 13      		inc	de
D6E3: 05      	getext3:dec	b
D6E4: C2D0D6  		jp	nz,getext1
D6E7: CD38D6  	getext4:call	check
D6EA: CAF8D6  		jp	z,getext6
D6ED: 13      		inc	de
D6EE: C3E7D6  		jp	getext4
D6F1: 23      	getext5:inc	hl
D6F2: 3620    		ld	(hl),' '
D6F4: 05      		dec	b
D6F5: C2F1D6  		jp	nz,getext5
D6F8: 0603    	getext6:ld	b,3
D6FA: 23      	getext7:inc	hl
D6FB: 3600    		ld	(hl),0
D6FD: 05      		dec	b
D6FE: C2FAD6  		jp	nz,getext7
D701: EB      		ex	de,hl
D702: 2288D4  		ld	(inpoint),hl	;save input line pointer.
D705: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
D706: 010B00  		ld	bc,11		;set name length.
D709: 23      	getext8:inc	hl
D70A: 7E      		ld	a,(hl)
D70B: FE3F    		cp	'?'		;any question marks?
D70D: C211D7  		jp	nz,getext9
D710: 04      		inc	b		;count them.
D711: 0D      	getext9:dec	c
D712: C209D7  		jp	nz,getext8
D715: 78      		ld	a,b
D716: B7      		or	a
D717: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
D718: 44495220	cmdtbl:	defb	'DIR '
D71C: 45524120		defb	'ERA '
D720: 54595045		defb	'TYPE'
D724: 53415645		defb	'SAVE'
D728: 52454E20		defb	'REN '
D72C: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
D730: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
D734: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
D736: 2118D7  	search:	ld	hl,cmdtbl
D739: 0E00    		ld	c,0
D73B: 79      	search1:ld	a,c
D73C: FE06    		cp	numcmds		;this commands exists.
D73E: D0      		ret	nc
D73F: 11DBDB  		ld	de,fcb+1	;check this one.
D742: 0604    		ld	b,4		;max command length.
D744: 1A      	search2:ld	a,(de)
D745: BE      		cp	(hl)
D746: C257D7  		jp	nz,search3	;not a match.
D749: 13      		inc	de
D74A: 23      		inc	hl
D74B: 05      		dec	b
D74C: C244D7  		jp	nz,search2
D74F: 1A      		ld	a,(de)		;allow a 3 character command to match.
D750: FE20    		cp	' '
D752: C25CD7  		jp	nz,search4
D755: 79      		ld	a,c		;set return register for this command.
D756: C9      		ret	
D757: 23      	search3:inc	hl
D758: 05      		dec	b
D759: C257D7  		jp	nz,search3
D75C: 0C      	search4:inc	c
D75D: C33BD7  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
D760: AF      	clearbuf: xor	a
D761: 3207D4  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
D764: 31B8DB  	command:ld	sp,ccpstack	;setup stack area.
D767: C5      		push	bc		;note that (c) should be equal to:
D768: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
D769: 1F      		rra			;and 'dddd' is the drive number.
D76A: 1F      		rra	
D76B: 1F      		rra	
D76C: 1F      		rra	
D76D: E60F    		and	0fh		;isolate the user number.
D76F: 5F      		ld	e,a
D770: CD14D5  		call	getsetuc	;and set it.
D773: CDB7D4  		call	resdsk		;reset the disk system.
              		;ld	(batch),a	;clear batch mode flag.
D776: C1      		pop	bc
D777: 79      		ld	a,c
D778: E60F    		and	0fh		;isolate the drive number.
D77A: 32FCDB  		ld	(cdrive),a	;and save.
D77D: CDBCD4  		call	dsksel		;...and select.
D780: 3A07D4  		ld	a,(inbuff+1)
D783: B7      		or	a		;anything in input buffer already?
D784: C2A5D7  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
D787: 31B8DB  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
D78A: CD98D4  		call	crlf		;start a new line on the screen.
D78D: CDD8D5  		call	getdsk		;get current drive.
D790: C641    		add	a,'A'
D792: CD8CD4  		call	print		;print current drive.
D795: CD12D5  		call	getusr		;get current user.
D798: C630    		add	a,'0'
D79A: CD98DB  		call	printdc		;print current user.
D79D: 3E3E    		ld	a,'>'
D79F: CD8CD4  		call	print		;and add prompt.
D7A2: CD38D5  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
D7A5: 118000  	cmmnd2:	ld	de,tbuff
D7A8: CDE0D5  		call	dmaset		;set standard dma address.
D7AB: CDD8D5  		call	getdsk
D7AE: 32FCDB  		ld	(cdrive),a	;set current drive.
D7B1: CD66D6  		call	convfst		;convert name typed in.
D7B4: C411D6  		call	nz,synerr	;wild cards are not allowed.
D7B7: 3AFDDB  		ld	a,(chgdrv)	;if a change in drives was indicated,
D7BA: B7      		or	a		;then treat this as an unknown command
D7BB: C2AEDA  		jp	nz,unknown	;which gets executed.
D7BE: CD36D7  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
D7C1: 21CED7  		ld	hl,cmdadr	;now, look thru our address table for command (a).
D7C4: 5F      		ld	e,a		;set (de) to command number.
D7C5: 1600    		ld	d,0
D7C7: 19      		add	hl,de
D7C8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
D7C9: 7E      		ld	a,(hl)		;now pick out this address.
D7CA: 23      		inc	hl
D7CB: 66      		ld	h,(hl)
D7CC: 6F      		ld	l,a
D7CD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
D7CE: 84D82CD9	cmdadr:	defw	direct,erase,type,save
D7D2: 6AD9BAD9	
D7D6: 1DDA99DA		defw	rename,user,unknown
D7DA: AEDA    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
D7DC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
D7DF: 2200D4  		ld	(cbase),hl
D7E2: 2100D4  		ld	hl,cbase
D7E5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
D7E6: 01ECD7  	rderror:ld	bc,rderr
D7E9: C3A6D4  		jp	pline
D7EC: 72656164	rderr:	defb	'read error',0
D7F0: 20657272	
D7F4: 6F7200  	
              	;
              	;   required file was not located.
              	;
D7F7: 01FDD7  	none:	ld	bc,nofile
D7FA: C3A6D4  		jp	pline
D7FD: 6E6F2066	nofile:	defb	'no file',0
D801: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
D805: CD66D6  	decode:	call	convfst		;convert filename.
D808: 3AFDDB  		ld	a,(chgdrv)	;do not allow a drive to be specified.
D80B: B7      		or	a
D80C: C211D6  		jp	nz,synerr
D80F: 21DBDB  		ld	hl,fcb+1	;convert number now.
D812: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
D815: 7E      	decode1:ld	a,(hl)
D816: FE20    		cp	' '		;a space terminates the numeral.
D818: CA40D8  		jp	z,decode3
D81B: 23      		inc	hl
D81C: D630    		sub	'0'		;make binary from ascii.
D81E: FE0A    		cp	10		;legal digit?
D820: D211D6  		jp	nc,synerr
D823: 57      		ld	d,a		;yes, save it in (d).
D824: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
D825: E6E0    		and	0e0h
D827: C211D6  		jp	nz,synerr
D82A: 78      		ld	a,b
D82B: 07      		rlca	
D82C: 07      		rlca	
D82D: 07      		rlca			;(a)=(b)*8
D82E: 80      		add	a,b		;.......*9
D82F: DA11D6  		jp	c,synerr
D832: 80      		add	a,b		;.......*10
D833: DA11D6  		jp	c,synerr
D836: 82      		add	a,d		;add in new digit now.
D837: DA11D6  	decode2:jp	c,synerr
D83A: 47      		ld	b,a		;and save result.
D83B: 0D      		dec	c		;only look at 11 digits.
D83C: C215D8  		jp	nz,decode1
D83F: C9      		ret	
D840: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
D841: FE20    		cp	' '
D843: C211D6  		jp	nz,synerr
D846: 23      		inc	hl
D847: 0D      	decode4:dec	c
D848: C240D8  		jp	nz,decode3
D84B: 78      		ld	a,b		;set (a)=the numeric value entered.
D84C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
D84D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
D84F: 7E      	hl2de:	ld	a,(hl)
D850: 12      		ld	(de),a
D851: 23      		inc	hl
D852: 13      		inc	de
D853: 05      		dec	b
D854: C24FD8  		jp	nz,hl2de
D857: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
D858: 218000  	extract:ld	hl,tbuff
D85B: 81      		add	a,c
D85C: CD61D6  		call	addhl
D85F: 7E      		ld	a,(hl)
D860: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
D861: AF      	dselect:xor	a		;null out first byte of fcb.
D862: 32DADB  		ld	(fcb),a
D865: 3AFDDB  		ld	a,(chgdrv)	;a drive change indicated?
D868: B7      		or	a
D869: C8      		ret	z
D86A: 3D      		dec	a		;yes, is it the same as the current drive?
D86B: 21FCDB  		ld	hl,cdrive
D86E: BE      		cp	(hl)
D86F: C8      		ret	z
D870: C3BCD4  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
D873: 3AFDDB  	resetdr:ld	a,(chgdrv)	;drive change indicated?
D876: B7      		or	a
D877: C8      		ret	z
D878: 3D      		dec	a		;yes, was it a different drive?
D879: 21FCDB  		ld	hl,cdrive
D87C: BE      		cp	(hl)
D87D: C8      		ret	z
D87E: 3AFCDB  		ld	a,(cdrive)	;yes, re-select our old drive.
D881: C3BCD4  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
D884: CD66D6  	direct:	call	convfst		;convert file name.
D887: CD61D8  		call	dselect		;select indicated drive.
D88A: 21DBDB  		ld	hl,fcb+1	;was any file indicated?
D88D: 7E      		ld	a,(hl)
D88E: FE20    		cp	' '
D890: C29CD8  		jp	nz,direct2
D893: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
D895: 363F    	direct1:ld	(hl),'?'
D897: 23      		inc	hl
D898: 05      		dec	b
D899: C295D8  		jp	nz,direct1
D89C: 1E00    	direct2:ld	e,0		;set initial cursor position.
D89E: D5      		push	de
D89F: CDE8D4  		call	srchfcb		;get first file name.
D8A2: CCF7D7  		call	z,none		;none found at all?
D8A5: CA28D9  	direct3:jp	z,direct9	;terminate if no more names.
D8A8: 3AFBDB  		ld	a,(rtncode)	;get file's position in segment (0-3).
D8AB: 0F      		rrca	
D8AC: 0F      		rrca	
D8AD: 0F      		rrca	
D8AE: E660    		and	60h		;(a)=position*32
D8B0: 4F      		ld	c,a
D8B1: 3E0A    		ld	a,10
D8B3: CD58D8  		call	extract		;extract the tenth entry in fcb.
D8B6: 17      		rla			;check system file status bit.
D8B7: DA1CD9  		jp	c,direct8	;we don't list them.
D8BA: D1      		pop	de
D8BB: 7B      		ld	a,e		;bump name count.
D8BC: 1C      		inc	e
D8BD: D5      		push	de
D8BE: E603    		and	03h		;at end of line?
D8C0: F5      		push	af
D8C1: C2D9D8  		jp	nz,direct4
D8C4: CD98D4  		call	crlf		;yes, end this line and start another.
D8C7: C5      		push	bc
D8C8: CDD8D5  		call	getdsk		;start line with ('a:').
D8CB: C1      		pop	bc
D8CC: C641    		add	a,'A'
D8CE: CD92D4  		call	printb
D8D1: 3E3A    		ld	a,':'
D8D3: CD92D4  		call	printb
D8D6: C3E1D8  		jp	direct5
D8D9: CDA1D4  	direct4:call	space		;add seperator between file names.
D8DC: 3E3A    		ld	a,':'
D8DE: CD92D4  		call	printb
D8E1: CDA1D4  	direct5:call	space
D8E4: 0601    		ld	b,1		;'extract' each file name character at a time.
D8E6: 78      	direct6:ld	a,b
D8E7: CD58D8  		call	extract
D8EA: E67F    		and	7fh		;strip bit 7 (status bit).
D8EC: FE20    		cp	' '		;are we at the end of the name?
D8EE: C206D9  		jp	nz,drect65
D8F1: F1      		pop	af		;yes, don't print spaces at the end of a line.
D8F2: F5      		push	af
D8F3: FE03    		cp	3
D8F5: C204D9  		jp	nz,drect63
D8F8: 3E09    		ld	a,9		;first check for no extension.
D8FA: CD58D8  		call	extract
D8FD: E67F    		and	7fh
D8FF: FE20    		cp	' '
D901: CA1BD9  		jp	z,direct7	;don't print spaces.
D904: 3E20    	drect63:ld	a,' '		;else print them.
D906: CD92D4  	drect65:call	printb
D909: 04      		inc	b		;bump to next character psoition.
D90A: 78      		ld	a,b
D90B: FE0C    		cp	12		;end of the name?
D90D: D21BD9  		jp	nc,direct7
D910: FE09    		cp	9		;nope, starting extension?
D912: C2E6D8  		jp	nz,direct6
D915: CDA1D4  		call	space		;yes, add seperating space.
D918: C3E6D8  		jp	direct6
D91B: F1      	direct7:pop	af		;get the next file name.
D91C: CDCAD5  	direct8:call	chkcon		;first check console, quit on anything.
D91F: C228D9  		jp	nz,direct9
D922: CDE3D4  		call	srchnxt		;get next name.
D925: C3A5D8  		jp	direct3		;and continue with our list.
D928: D1      	direct9:pop	de		;restore the stack and return to command level.
D929: C383DB  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D92C: CD66D6  	erase:	call	convfst		;convert file name.
D92F: FE0B    		cp	11		;was '*.*' entered?
D931: C24FD9  		jp	nz,erase1
D934: 015FD9  		ld	bc,yesno	;yes, ask for confirmation.
D937: CDA6D4  		call	pline
D93A: CD38D5  		call	getinp
D93D: 2107D4  		ld	hl,inbuff+1
D940: 35      		dec	(hl)		;must be exactly 'y'.
D941: C287D7  		jp	nz,cmmnd1
D944: 23      		inc	hl
D945: 7E      		ld	a,(hl)
D946: FE79    		cp	'y'
D948: C287D7  		jp	nz,cmmnd1
D94B: 23      		inc	hl
D94C: 2288D4  		ld	(inpoint),hl	;save input line pointer.
D94F: CD61D8  	erase1:	call	dselect		;select desired disk.
D952: 11DADB  		ld	de,fcb
D955: CDEED4  		call	delete		;delete the file.
D958: 3C      		inc	a
D959: CCF7D7  		call	z,none		;not there?
D95C: C383DB  		jp	getback		;return to command level now.
D95F: 616C6C20	yesno:	defb	'all (y/n)?',0
D963: 28792F6E	
D967: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D96A: CD66D6  	type:	call	convfst		;convert file name.
D96D: C211D6  		jp	nz,synerr	;wild cards not allowed.
D970: CD61D8  		call	dselect		;select indicated drive.
D973: CDCFD4  		call	openfcb		;open the file.
D976: CAB4D9  		jp	z,type5		;not there?
D979: CD98D4  		call	crlf		;ok, start a new line on the screen.
D97C: 21FEDB  		ld	hl,nbytes	;initialize byte counter.
D97F: 36FF    		ld	(hl),0ffh	;set to read first sector.
D981: 21FEDB  	type1:	ld	hl,nbytes
D984: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
D985: FE80    		cp	128
D987: DA94D9  		jp	c,type3
D98A: E5      		push	hl		;yes, read in the next one.
D98B: CDFDD4  		call	readfcb
D98E: E1      		pop	hl
D98F: C2ADD9  		jp	nz,type4	;end or error?
D992: AF      		xor	a		;ok, clear byte counter.
D993: 77      		ld	(hl),a
D994: 34      	type3:	inc	(hl)		;count this byte.
D995: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
D998: CD61D6  		call	addhl
D99B: 7E      		ld	a,(hl)
D99C: FE1A    		cp	cntrlz		;end of file mark?
D99E: CA83DB  		jp	z,getback
D9A1: CD8CD4  		call	print		;no, print it.
D9A4: CDCAD5  		call	chkcon		;check console, quit if anything ready.
D9A7: C283DB  		jp	nz,getback
D9AA: C381D9  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
D9AD: 3D      	type4:	dec	a		;read error?
D9AE: CA83DB  		jp	z,getback
D9B1: CDE6D7  		call	rderror		;yes, print message.
D9B4: CD73D8  	type5:	call	resetdr		;and reset proper drive
D9B7: C311D6  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D9BA: CD05D8  	save:	call	decode		;get numeric number that follows save.
D9BD: F5      		push	af		;save number of pages to write.
D9BE: CD66D6  		call	convfst		;convert file name.
D9C1: C211D6  		jp	nz,synerr	;wild cards not allowed.
D9C4: CD61D8  		call	dselect		;select specified drive.
D9C7: 11DADB  		ld	de,fcb		;now delete this file.
D9CA: D5      		push	de
D9CB: CDEED4  		call	delete
D9CE: D1      		pop	de
D9CF: CD08D5  		call	create		;and create it again.
D9D2: CA08DA  		jp	z,save3		;can't create?
D9D5: AF      		xor	a		;clear record number byte.
D9D6: 32FADB  		ld	(fcb+32),a
D9D9: F1      		pop	af		;convert pages to sectors.
D9DA: 6F      		ld	l,a
D9DB: 2600    		ld	h,0
D9DD: 29      		add	hl,hl		;(hl)=number of sectors to write.
D9DE: 110001  		ld	de,tbase	;and we start from here.
D9E1: 7C      	save1:	ld	a,h		;done yet?
D9E2: B5      		or	l
D9E3: CAFED9  		jp	z,save2
D9E6: 2B      		dec	hl		;nope, count this and compute the start
D9E7: E5      		push	hl		;of the next 128 byte sector.
D9E8: 218000  		ld	hl,128
D9EB: 19      		add	hl,de
D9EC: E5      		push	hl		;save it and set the transfer address.
D9ED: CDE0D5  		call	dmaset
D9F0: 11DADB  		ld	de,fcb		;write out this sector now.
D9F3: CD03D5  		call	wrtrec
D9F6: D1      		pop	de		;reset (de) to the start of the last sector.
D9F7: E1      		pop	hl		;restore sector count.
D9F8: C208DA  		jp	nz,save3	;write error?
D9FB: C3E1D9  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
D9FE: 11DADB  	save2:	ld	de,fcb		;now close the file.
DA01: CDD9D4  		call	close
DA04: 3C      		inc	a		;did it close ok?
DA05: C20EDA  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
DA08: 0114DA  	save3:	ld	bc,nospace
DA0B: CDA6D4  		call	pline
DA0E: CDDDD5  	save4:	call	stddma		;reset the standard dma address.
DA11: C383DB  		jp	getback
DA14: 6E6F2073	nospace:defb	'no space',0
DA18: 70616365	
DA1C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DA1D: CD66D6  	rename:	call	convfst		;convert first file name.
DA20: C211D6  		jp	nz,synerr	;wild cards not allowed.
DA23: 3AFDDB  		ld	a,(chgdrv)	;remember any change in drives specified.
DA26: F5      		push	af
DA27: CD61D8  		call	dselect		;and select this drive.
DA2A: CDE8D4  		call	srchfcb		;is this file present?
DA2D: C284DA  		jp	nz,rename6	;yes, print error message.
DA30: 21DADB  		ld	hl,fcb		;yes, move this name into second slot.
DA33: 11EADB  		ld	de,fcb+16
DA36: 0610    		ld	b,16
DA38: CD4FD8  		call	hl2de
DA3B: 2A88D4  		ld	hl,(inpoint)	;get input pointer.
DA3E: EB      		ex	de,hl
DA3F: CD57D6  		call	nonblank	;get next non blank character.
DA42: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
DA44: CA4CDA  		jp	z,rename1
DA47: FE5F    		cp	'_'
DA49: C27EDA  		jp	nz,rename5
DA4C: EB      	rename1:ex	de,hl
DA4D: 23      		inc	hl		;ok, skip seperator.
DA4E: 2288D4  		ld	(inpoint),hl	;save input line pointer.
DA51: CD66D6  		call	convfst		;convert this second file name now.
DA54: C27EDA  		jp	nz,rename5	;again, no wild cards.
DA57: F1      		pop	af		;if a drive was specified, then it
DA58: 47      		ld	b,a		;must be the same as before.
DA59: 21FDDB  		ld	hl,chgdrv
DA5C: 7E      		ld	a,(hl)
DA5D: B7      		or	a
DA5E: CA65DA  		jp	z,rename2
DA61: B8      		cp	b
DA62: 70      		ld	(hl),b
DA63: 2019    		jr	nz,rename5	;they were different, error.
DA65: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
DA66: AF      		xor	a
DA67: 32DADB  		ld	(fcb),a		;clear the drive byte of the fcb.
DA6A: CDE8D4  	rename3:call	srchfcb		;and go look for second file.
DA6D: 2809    		jr	z,rename4	;doesn't exist?
DA6F: 11DADB  		ld	de,fcb
DA72: CD0DD5  		call	renam		;ok, rename the file.
DA75: C383DB  		jp	getback
              	;
              	;   process rename errors here.
              	;
DA78: CDF7D7  	rename4:call	none		;file not there.
DA7B: C383DB  		jp	getback
DA7E: CD73D8  	rename5:call	resetdr		;bad command format.
DA81: C311D6  	synerrt:jp	synerr
DA84: 018DDA  	rename6:ld	bc,exists	;destination file already exists.
DA87: CDA6D4  		call	pline
DA8A: C383DB  		jp	getback
DA8D: 66696C65	exists:	defb	'file exists',0
DA91: 20657869	
DA95: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
DA99: CD05D8  	user:	call	decode		;get numeric value following command.
DA9C: FE10    		cp	16		;legal user number?
DA9E: 30E1    		jr	nc,synerrt
DAA0: 5F      		ld	e,a		;yes but is there anything else?
DAA1: 3ADBDB  		ld	a,(fcb+1)
DAA4: FE20    		cp	' '
DAA6: 28D9    		jr	z,synerrt	;yes, that is not allowed.
DAA8: CD14D5  		call	getsetuc	;ok, set user code.
DAAB: C386DB  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
DAAE: CDFDD5  	unknown:call	verify		;check for valid system (why?).
DAB1: 3ADBDB  		ld	a,(fcb+1)	;anything to execute?
DAB4: FE20    		cp	' '
DAB6: 2014    		jr	nz,unkwn1
DAB8: 3AFDDB  		ld	a,(chgdrv)	;nope, only a drive change?
DABB: B7      		or	a
DABC: CA86DB  		jp	z,getback1	;neither???
DABF: 3D      		dec	a
DAC0: 32FCDB  		ld	(cdrive),a	;ok, store new drive.
DAC3: CD28D5  		call	movecd		;set (tdrive) also.
DAC6: CDBCD4  		call	dsksel		;and select this drive.
DAC9: C386DB  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
DACC: 11E3DB  	unkwn1:	ld	de,fcb+9	;an extension specified?
DACF: 1A      		ld	a,(de)
DAD0: FE20    		cp	' '
DAD2: 20AD    		jr	nz,synerrt	;yes, not allowed.
DAD4: D5      	unkwn2:	push	de
DAD5: CD61D8  		call	dselect		;select specified drive.
DAD8: D1      		pop	de
DAD9: 2180DB  		ld	hl,comfile	;set the extension to 'com'.
DADC: CD4DD8  		call	move3
DADF: CDCFD4  		call	openfcb		;and open this file.
DAE2: CA69DB  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
DAE5: 210001  		ld	hl,tbase	;store the program starting here.
DAE8: E5      	unkwn3:	push	hl
DAE9: EB      		ex	de,hl
DAEA: CDE0D5  		call	dmaset		;set transfer address.
DAED: 11DADB  		ld	de,fcb		;and read the next record.
DAF0: CDF8D4  		call	rdrec
DAF3: 2010    		jr	nz,unkwn4	;end of file or read error?
DAF5: E1      		pop	hl		;nope, bump pointer for next sector.
DAF6: 118000  		ld	de,128
DAF9: 19      		add	hl,de
DAFA: 1100D4  		ld	de,cbase	;enough room for the whole file?
DAFD: 7D      		ld	a,l
DAFE: 93      		sub	e
DAFF: 7C      		ld	a,h
DB00: 9A      		sbc	a,d
DB01: 306C    		jr	nc,unkwn0	;no, it can't fit.
DB03: 18E3    		jr	unkwn3
              	;
              	;   get here after finished reading.
              	;
DB05: E1      	unkwn4:	pop	hl
DB06: 3D      		dec	a		;normal end of file?
DB07: 2066    		jr	nz,unkwn0
DB09: CD73D8  		call	resetdr		;yes, reset previous drive.
DB0C: CD66D6  		call	convfst		;convert the first file name that follows
DB0F: 21FDDB  		ld	hl,chgdrv	;command name.
DB12: E5      		push	hl
DB13: 7E      		ld	a,(hl)		;set drive code in default fcb.
DB14: 32DADB  		ld	(fcb),a
DB17: 3E10    		ld	a,16		;put second name 16 bytes later.
DB19: CD68D6  		call	convert		;convert second file name.
DB1C: E1      		pop	hl
DB1D: 7E      		ld	a,(hl)		;and set the drive for this second file.
DB1E: 32EADB  		ld	(fcb+16),a
DB21: AF      		xor	a		;clear record byte in fcb.
DB22: 32FADB  		ld	(fcb+32),a
DB25: 115C00  		ld	de,tfcb		;move it into place at(005ch).
DB28: 21DADB  		ld	hl,fcb
DB2B: 0621    		ld	b,33
DB2D: CD4FD8  		call	hl2de
DB30: 2108D4  		ld	hl,inbuff+2	;now move the remainder of the input
DB33: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
DB34: B7      		or	a		;or a null.
DB35: 2807    		jr	z,unkwn6
DB37: FE20    		cp	' '
DB39: 2803    		jr	z,unkwn6
DB3B: 23      		inc	hl
DB3C: 18F5    		jr	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
DB3E: 0600    	unkwn6:	ld	b,0		;keep a character count.
DB40: 118100  		ld	de,tbuff+1	;data gets put here.
DB43: 7E      	unkwn7:	ld	a,(hl)		;move it now.
DB44: 12      		ld	(de),a
DB45: B7      		or	a
DB46: 2805    		jr	z,unkwn8
DB48: 04      		inc	b
DB49: 23      		inc	hl
DB4A: 13      		inc	de
DB4B: 18F6    		jr	unkwn7
DB4D: 78      	unkwn8:	ld	a,b		;now store the character count.
DB4E: 328000  		ld	(tbuff),a
DB51: CD98D4  		call	crlf		;clean up the screen.
DB54: CDDDD5  		call	stddma		;set standard transfer address.
DB57: CD19D5  		call	setcdrv		;reset current drive.
DB5A: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
DB5D: 31B8DB  		ld	sp,batch	;set stack first off.
DB60: CD28D5  		call	movecd		;move current drive into place (tdrive).
DB63: CDBCD4  		call	dsksel		;and reselect it.
DB66: C387D7  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
DB69: CD73D8  	unkwn9:	call	resetdr		;inproper format.
DB6C: C311D6  		jp	synerr
DB6F: 0177DB  	unkwn0:	ld	bc,badload	;read error or won't fit.
DB72: CDA6D4  		call	pline
DB75: 180C    		jr	getback
DB77: 42616420	badload:defb	'Bad load',0
DB7B: 6C6F6164	
DB7F: 00      	
DB80: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
DB83: CD73D8  	getback:call	resetdr		;reset previous drive.
DB86: CD66D6  	getback1: call	convfst		;convert first name in (fcb).
DB89: 3ADBDB  		ld	a,(fcb+1)	;if this was just a drive change request,
DB8C: D620    		sub	' '		;make sure it was valid.
DB8E: 21FDDB  		ld	hl,chgdrv
DB91: B6      		or	(hl)
DB92: C211D6  		jp	nz,synerr
DB95: C387D7  		jp	cmmnd1		;ok, return to command level.
              		
              	; Small routine to print a decimal 0-19
DB98: FE3A    	printdc:cp	':'
DB9A: DA8CD4  		jp	c,print
DB9D: D60A    		sub	10
DB9F: F5      		push	af
DBA0: 3E31    		ld	a,'1'
DBA2: CD8CD4  		call	print
DBA5: F1      		pop	af
DBA6: 18F0    		jr	printdc
              	;
              	;   ccp stack area.
              	;
DBA8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DBAC: 00...   	
DBB8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
DBB8: 00      	batch:	defb	0		;batch mode flag (0=not active).
DBB9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DBBD: 20202020	
DBC1: 20535542	
DBC5: 00000000	
DBC9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
DBDA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
DBDE: 20202020	
DBE2: 20202020	
DBE6: 00000000	
DBEA: 00202020	
DBEE: 20202020	
DBF2: 20202020	
DBF6: 00000000	
DBFA: 00      	
DBFB: 00      	rtncode:defb	0		;status returned from bdos call.
DBFC: 00      	cdrive:	defb	0		;currently active drive.
DBFD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
DBFE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
DC00: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
DC04: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
DC06: C314DC  	fbase:	jp	fbase1
DC09: C33AEA  		jp	boot
              	;
              	;   bdos error table.
              	;
DC0C: 9FDC    	badsctr:defw	error1		;bad sector on read or write.
DC0E: ABDC    	badslct:defw	error2		;bad disk select.
DC10: B1DC    	rodisk:	defw	error3		;disk is read only.
DC12: B7DC    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
DC14: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
DC15: 224EDF  		ld	(params),hl
DC18: EB      		ex	de,hl
DC19: 7B      		ld	a,e		;and save register (e) in particular.
DC1A: 32E1E9  		ld	(eparam),a
DC1D: 210000  		ld	hl,0
DC20: 2250DF  		ld	(status),hl	;clear return status.
DC23: 39      		add	hl,sp
DC24: 221ADF  		ld	(usrstack),hl	;save users stack pointer.
DC27: 314CDF  		ld	sp,stkarea	;and set our own.
DC2A: AF      		xor	a		;clear auto select storage space.
DC2B: 32EBE9  		ld	(autoflag),a
DC2E: 32E9E9  		ld	(auto),a
DC31: 217FE9  		ld	hl,goback	;set return address.
DC34: E5      		push	hl
DC35: CD63EB  		call	syshook		; see if anyone wants to intercept the call
DC38: 79      		ld	a,c		;get function number.
DC39: FE29    		cp	nfuncts		;valid function number?
DC3B: D0      		ret	nc
DC3C: 4B      		ld	c,e		;keep single register function here.
DC3D: 214DDC  		ld	hl,functns	;now look thru the function table.
DC40: 5F      		ld	e,a
DC41: 1600    		ld	d,0		;(de)=function number.
DC43: 19      		add	hl,de
DC44: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
DC45: 5E      		ld	e,(hl)
DC46: 23      		inc	hl
DC47: 56      		ld	d,(hl)		;now (de)=address for this function.
DC48: 2A4EDF  		ld	hl,(params)	;retrieve parameters.
DC4B: EB      		ex	de,hl		;now (de) has the original parameters.
DC4C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
DC4D: 48EAD3DE	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
DC51: 9BDDD9DE	
DC55: C9EAC5EA	
DC59: DFDEF8DE	
DC5D: FEDE03DF		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
DC61: ECDD09DF	
DC65: 89E88EE8	
DC69: 50E8A7E8	
DC6D: B0E8B6E8		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
DC71: D3E8E2E8	
DC75: EBE8F1E8	
DC79: F7E8    	
DC7B: 00E909E9		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
DC7F: 0FE915E9	
DC83: 1CE937E1	
DC87: 22E928E9	
DC8B: 31E938E9		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
DC8F: 4CE952E9	
DC93: 58E919E8	
DC97: 5EE90FDF	
DC9B: 0FDFA6E9		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
DC9F: 21D5DC  	error1:	ld	hl,badsec	;bad sector message.
DCA2: CDF0DC  		call	prterr		;print it and get a 1 char responce.
DCA5: FE03    		cp	cntrlc		;re-boot request (control-c)?
DCA7: CA0000  		jp	z,0		;yes.
DCAA: C9      		ret			;no, return to retry i/o function.
              	;
DCAB: 21E0DC  	error2:	ld	hl,badsel	;bad drive selected.
DCAE: C3BADC  		jp	error5
              	;
DCB1: 21ECDC  	error3:	ld	hl,diskro	;disk is read only.
DCB4: C3BADC  		jp	error5
              	;
DCB7: 21E7DC  	error4:	ld	hl,filero	;file is read only.
              	;
DCBA: 3E00    	error5:	ld	a,default
DCBC: 320400  		ld	(tdrive),a
DCBF: CDF0DC  		call	prterr
DCC2: C30000  		jp	0		;always reboot on these errors.
              	;
DCC5: 42646F73	bdoserr:defb	'Bdos Err on '
DCC9: 20457272	
DCCD: 206F6E20	
DCD1: 203A2024	bdosdrv:defb	' : $'
DCD5: 42616420	badsec:	defb	'Bad Sector$'
DCD9: 53656374	
DCDD: 6F7224  	
DCE0: 53656C65	badsel:	defb	'Select$'
DCE4: 637424  	
DCE7: 46696C65	filero:	defb	'File '
DCEB: 20      	
DCEC: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
DCF0: E5      	prterr:	push	hl		;save second message pointer.
DCF1: CDD4DD  		call	outcrlf		;send (cr)(lf).
DCF4: 3A4DDF  		ld	a,(active)	;get active drive.
DCF7: C641    		add	a,'A'		;make ascii.
DCF9: 32D1DC  		ld	(bdosdrv),a	;and put in message.
DCFC: 01C5DC  		ld	bc,bdoserr	;and print it.
DCFF: CDDEDD  		call	prtmesg
DD02: C1      		pop	bc		;print second message line now.
DD03: CDDEDD  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
DD06: 2119DF  	getchar:ld	hl,charbuf	;check character buffer.
DD09: 7E      		ld	a,(hl)		;anything present already?
DD0A: 3600    		ld	(hl),0		;...either case clear it.
DD0C: B7      		or	a
DD0D: C0      		ret	nz		;yes, use it.
DD0E: C3ADEA  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
DD11: CD06DD  	getecho:call	getchar		;input a character.
DD14: CD1FDD  		call	chkchar		;carriage control?
DD17: D8      		ret	c		;no, a regular control char so don't echo.
DD18: F5      		push	af		;ok, save character now.
DD19: 4F      		ld	c,a
DD1A: CD9BDD  		call	outcon		;and echo it.
DD1D: F1      		pop	af		;get character and return.
DD1E: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
DD1F: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
DD21: C8      		ret	z		;or a tab.
DD22: FE0A    		cp	lf
DD24: C8      		ret	z
DD25: FE09    		cp	tab
DD27: C8      		ret	z
DD28: FE08    		cp	bs
DD2A: C8      		ret	z
DD2B: FE20    		cp	' '		;other control char? set carry flag.
DD2D: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
DD2E: 3A19DF  	ckconsol: ld	a,(charbuf)	;check buffer.
DD31: B7      		or	a		;if anything, just return without checking.
DD32: C250DD  		jp	nz,ckcon2
DD35: CDA2EA  		call	const		;nothing in buffer. check console.
DD38: E601    		and	01h		;look at bit 0.
DD3A: C8      		ret	z		;return if nothing.
DD3B: CDADEA  		call	conin		;ok, get it.
DD3E: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
DD40: C24DDD  		jp	nz,ckcon1
DD43: CDADEA  		call	conin		;halt processing until another char
DD46: FE03    		cp	cntrlc		;is typed. control-c?
DD48: CA0000  		jp	z,0		;yes, reboot now.
DD4B: AF      		xor	a		;no, just pretend nothing was ever ready.
DD4C: C9      		ret	
DD4D: 3219DF  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
DD50: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
DD52: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
DD53: 3A15DF  	outchar:ld	a,(outflag)	;check output flag.
DD56: B7      		or	a		;anything and we won't generate output.
DD57: C26DDD  		jp	nz,outchr1
DD5A: C5      		push	bc
DD5B: CD2EDD  		call	ckconsol	;check console (we don't care whats there).
DD5E: C1      		pop	bc
DD5F: C5      		push	bc
DD60: CDB9EA  		call	conout		;output (c) to the screen.
DD63: C1      		pop	bc
DD64: C5      		push	bc
DD65: 3A18DF  		ld	a,(prtflag)	;check printer flip-flop flag.
DD68: B7      		or	a
DD69: C4C5EA  		call	nz,list		;print it also if non-zero.
DD6C: C1      		pop	bc
DD6D: 79      	outchr1:ld	a,c		;update cursors position.
DD6E: 2117DF  		ld	hl,curpos
DD71: FE7F    		cp	del		;rubouts don't do anything here.
DD73: C8      		ret	z
DD74: 34      		inc	(hl)		;bump line pointer.
DD75: FE20    		cp	' '		;and return if a normal character.
DD77: D0      		ret	nc
DD78: 35      		dec	(hl)		;restore and check for the start of the line.
DD79: 7E      		ld	a,(hl)
DD7A: B7      		or	a
DD7B: C8      		ret	z		;ingnore control characters at the start of the line.
DD7C: 79      		ld	a,c
DD7D: FE08    		cp	bs		;is it a backspace?
DD7F: C284DD  		jp	nz,outchr2
DD82: 35      		dec	(hl)		;yes, backup pointer.
DD83: C9      		ret	
DD84: FE0A    	outchr2:cp	lf		;is it a line feed?
DD86: C0      		ret	nz		;ignore anything else.
DD87: 3600    		ld	(hl),0		;reset pointer to start of line.
DD89: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
DD8A: 79      	showit:	ld	a,c
DD8B: CD1FDD  		call	chkchar		;check character.
DD8E: D29BDD  		jp	nc,outcon	;not a control, use normal output.
DD91: F5      		push	af
DD92: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
DD94: CD53DD  		call	outchar
DD97: F1      		pop	af
DD98: F640    		or	'@'		;and then use the letter equivelant.
DD9A: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
DD9B: 79      	outcon:	ld	a,c
DD9C: FE09    		cp	tab		;is it a tab?
DD9E: C253DD  		jp	nz,outchar	;use regular output.
DDA1: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
DDA3: CD53DD  		call	outchar
DDA6: 3A17DF  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
DDA9: E607    		and	07h		;position.
DDAB: C2A1DD  		jp	nz,outcon1
DDAE: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
DDAF: CDB7DD  	backup:	call	backup1		;backup the screen 1 place.
DDB2: 0E20    		ld	c,' '		;then blank that character.
DDB4: CDB9EA  		call	conout
DDB7: 0E08    	backup1:ld	c,bs		;then back space once more.
DDB9: C3B9EA  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
DDBC: 0E23    	newline:ld	c,'#'
DDBE: CD53DD  		call	outchar		;print this.
DDC1: CDD4DD  		call	outcrlf		;start new line.
DDC4: 3A17DF  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
DDC7: 2116DF  		ld	hl,starting
DDCA: BE      		cp	(hl)
DDCB: D0      		ret	nc		;there yet?
DDCC: 0E20    		ld	c,' '
DDCE: CD53DD  		call	outchar		;nope, keep going.
DDD1: C3C4DD  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
DDD4: 0E0D    	outcrlf:ld	c,cr
DDD6: CD53DD  		call	outchar
DDD9: 0E0A    		ld	c,lf
DDDB: C353DD  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
DDDE: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
DDDF: FE24    		cp	'$'
DDE1: C8      		ret	z
DDE2: 03      		inc	bc
DDE3: C5      		push	bc		;otherwise, bump pointer and print it.
DDE4: 4F      		ld	c,a
DDE5: CD9BDD  		call	outcon
DDE8: C1      		pop	bc
DDE9: C3DEDD  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
DDEC: 3A17DF  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
DDEF: 3216DF  		ld	(starting),a
DDF2: 2A4EDF  		ld	hl,(params)	;get the maximum buffer space.
DDF5: 4E      		ld	c,(hl)
DDF6: 23      		inc	hl		;point to first available space.
DDF7: E5      		push	hl		;and save.
DDF8: 0600    		ld	b,0		;keep a character count.
DDFA: C5      	rdbuf1:	push	bc
DDFB: E5      		push	hl
DDFC: CD06DD  	rdbuf2:	call	getchar		;get the next input character.
DDFF: E67F    		and	7fh		;strip bit 7.
DE01: E1      		pop	hl		;reset registers.
DE02: C1      		pop	bc
DE03: FE0D    		cp	cr		;en of the line?
DE05: CACCDE  		jp	z,rdbuf17
DE08: FE0A    		cp	lf
DE0A: CACCDE  		jp	z,rdbuf17
DE0D: FE08    		cp	bs		;how about a backspace?
DE0F: C221DE  		jp	nz,rdbuf3
DE12: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
DE13: B7      		or	a
DE14: CAFADD  		jp	z,rdbuf1
DE17: 05      		dec	b		;ok, update counter.
DE18: 3A17DF  		ld	a,(curpos)	;if we backspace to the start of the line,
DE1B: 3215DF  		ld	(outflag),a	;treat as a cancel (control-x).
DE1E: C37BDE  		jp	rdbuf10
DE21: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
DE23: C231DE  		jp	nz,rdbuf4
DE26: 78      		ld	a,b		;ignore at the start of the line.
DE27: B7      		or	a
DE28: CAFADD  		jp	z,rdbuf1
DE2B: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
DE2C: 05      		dec	b		;and reset pointers (counters).
DE2D: 2B      		dec	hl
DE2E: C3B4DE  		jp	rdbuf15
DE31: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
DE33: C242DE  		jp	nz,rdbuf5
DE36: C5      		push	bc		;yes, do it.
DE37: E5      		push	hl
DE38: CDD4DD  		call	outcrlf
DE3B: AF      		xor	a		;and update starting position.
DE3C: 3216DF  		ld	(starting),a
DE3F: C3FCDD  		jp	rdbuf2
DE42: FE10    	rdbuf5:	cp	cntrlp		;control-p?
DE44: C253DE  		jp	nz,rdbuf6
DE47: E5      		push	hl		;yes, flip the print flag filp-flop byte.
DE48: 2118DF  		ld	hl,prtflag
DE4B: 3E01    		ld	a,1		;prtflag=1-prtflag
DE4D: 96      		sub	(hl)
DE4E: 77      		ld	(hl),a
DE4F: E1      		pop	hl
DE50: C3FADD  		jp	rdbuf1
DE53: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
DE55: C26ADE  		jp	nz,rdbuf8
DE58: E1      		pop	hl
DE59: 3A16DF  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
DE5C: 2117DF  		ld	hl,curpos
DE5F: BE      		cp	(hl)
DE60: D2ECDD  		jp	nc,rdbuff	;done yet?
DE63: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
DE64: CDAFDD  		call	backup
DE67: C359DE  		jp	rdbuf7
DE6A: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
DE6C: C276DE  		jp	nz,rdbuf9
DE6F: CDBCDD  		call	newline		;start a new line.
DE72: E1      		pop	hl
DE73: C3ECDD  		jp	rdbuff
DE76: FE12    	rdbuf9:	cp	cntrlr		;control-r?
DE78: C2B1DE  		jp	nz,rdbuf14
DE7B: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
DE7C: CDBCDD  		call	newline
DE7F: C1      		pop	bc
DE80: E1      		pop	hl
DE81: E5      		push	hl
DE82: C5      		push	bc
DE83: 78      	rdbuf11:ld	a,b		;done whole line yet?
DE84: B7      		or	a
DE85: CA95DE  		jp	z,rdbuf12
DE88: 23      		inc	hl		;nope, get next character.
DE89: 4E      		ld	c,(hl)
DE8A: 05      		dec	b		;count it.
DE8B: C5      		push	bc
DE8C: E5      		push	hl
DE8D: CD8ADD  		call	showit		;and display it.
DE90: E1      		pop	hl
DE91: C1      		pop	bc
DE92: C383DE  		jp	rdbuf11
DE95: E5      	rdbuf12:push	hl		;done with line. if we were displaying
DE96: 3A15DF  		ld	a,(outflag)	;then update cursor position.
DE99: B7      		or	a
DE9A: CAFCDD  		jp	z,rdbuf2
DE9D: 2117DF  		ld	hl,curpos	;because this line is shorter, we must
DEA0: 96      		sub	(hl)		;back up the cursor (not the screen however)
DEA1: 3215DF  		ld	(outflag),a	;some number of positions.
DEA4: CDAFDD  	rdbuf13:call	backup		;note that as long as (outflag) is non
DEA7: 2115DF  		ld	hl,outflag	;zero, the screen will not be changed.
DEAA: 35      		dec	(hl)
DEAB: C2A4DE  		jp	nz,rdbuf13
DEAE: C3FCDD  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
DEB1: 23      	rdbuf14:inc	hl
DEB2: 77      		ld	(hl),a		;store character.
DEB3: 04      		inc	b		;and count it.
DEB4: C5      	rdbuf15:push	bc
DEB5: E5      		push	hl
DEB6: 4F      		ld	c,a		;echo it now.
DEB7: CD8ADD  		call	showit
DEBA: E1      		pop	hl
DEBB: C1      		pop	bc
DEBC: 7E      		ld	a,(hl)		;was it an abort request?
DEBD: FE03    		cp	cntrlc		;control-c abort?
DEBF: 78      		ld	a,b
DEC0: C2C8DE  		jp	nz,rdbuf16
DEC3: FE01    		cp	1		;only if at start of line.
DEC5: CA0000  		jp	z,0
DEC8: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
DEC9: DAFADD  		jp	c,rdbuf1
DECC: E1      	rdbuf17:pop	hl		;yes end the line and return.
DECD: 70      		ld	(hl),b
DECE: 0E0D    		ld	c,cr
DED0: C353DD  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
DED3: CD11DD  	getcon:	call	getecho		;get and echo.
DED6: C30CDF  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
DED9: CDCDEA  	getrdr:	call	reader		;get a character from reader, set status and return.
DEDC: C30CDF  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
DEDF: 79      	dircio:	ld	a,c		;test for (ff).
DEE0: 3C      		inc	a
DEE1: CAEBDE  		jp	z,dirc1
DEE4: 3C      		inc	a		;test for (fe).
DEE5: CAA2EA  		jp	z,const
DEE8: C3B9EA  		jp	conout		;just output (c).
DEEB: CDA2EA  	dirc1:	call	const		;this is an input request.
DEEE: B7      		or	a
DEEF: CA9CE9  		jp	z,goback1	;not ready? just return (directly).
DEF2: CDADEA  		call	conin		;yes, get character.
DEF5: C30CDF  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
DEF8: 3A0300  	getiob:	ld	a,(iobyte)
DEFB: C30CDF  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
DEFE: 210300  	setiob:	ld	hl,iobyte
DF01: 71      		ld	(hl),c
DF02: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
DF03: EB      	prtstr:	ex	de,hl
DF04: 4D      		ld	c,l
DF05: 44      		ld	b,h		;now (bc) points to it.
DF06: C3DEDD  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
DF09: CD2EDD  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
DF0C: 3250DF  	setstat:ld	(status),a
DF0F: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
DF10: 3E01    	ioerr1:	ld	a,1
DF12: C30CDF  		jp	setstat
              	;
DF15: 00      	outflag:defb	0		;output flag (non zero means no output).
DF16: 02      	starting: defb	2		;starting position for cursor.
DF17: 00      	curpos:	defb	0		;cursor position (0=start of line).
DF18: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
DF19: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
DF1A: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
DF1C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF20: 00...   	
DF34: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF38: 00...   	
DF4C:         	stkarea equ	$		;end of stack area.
              	;
DF4C: 00      	userno:	defb	0		;current user number.
DF4D: 00      	active:	defb	0		;currently active drive.
DF4E: 0000    	params:	defw	0		;save (de) parameters here on entry.
DF50: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
DF52: 210EDC  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
DF55: 5E      	jumphl:	ld	e,(hl)
DF56: 23      		inc	hl
DF57: 56      		ld	d,(hl)		;now (de) contain the desired address.
DF58: EB      		ex	de,hl
DF59: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
DF5A: 0C      	de2hl:	inc	c		;is count down to zero?
DF5B: 0D      	de2hl1:	dec	c
DF5C: C8      		ret	z		;yes, we are done.
DF5D: 1A      		ld	a,(de)		;no, move one more byte.
DF5E: 77      		ld	(hl),a
DF5F: 13      		inc	de
DF60: 23      		inc	hl
DF61: C35BDF  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
DF64: 3A4DDF  	select:	ld	a,(active)	;get active disk.
DF67: 4F      		ld	c,a
DF68: CDE0EA  		call	seldsk		;select it.
DF6B: 7C      		ld	a,h		;valid drive?
DF6C: B5      		or	l		;valid drive?
DF6D: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
DF6E: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
DF6F: 23      		inc	hl
DF70: 56      		ld	d,(hl)
DF71: 23      		inc	hl
DF72: 22BEE9  		ld	(scratch1),hl	;save pointers to scratch areas.
DF75: 23      		inc	hl
DF76: 23      		inc	hl
DF77: 22C0E9  		ld	(scratch2),hl	;ditto.
DF7A: 23      		inc	hl
DF7B: 23      		inc	hl
DF7C: 22C2E9  		ld	(scratch3),hl	;ditto.
DF7F: 23      		inc	hl
DF80: 23      		inc	hl
DF81: EB      		ex	de,hl		;now save the translation table address.
DF82: 22DBE9  		ld	(xlate),hl
DF85: 21C4E9  		ld	hl,dirbuf	;put the next 8 bytes here.
DF88: 0E08    		ld	c,8		;they consist of the directory buffer
DF8A: CD5ADF  		call	de2hl		;pointer, parameter block pointer,
DF8D: 2AC6E9  		ld	hl,(diskpb)	;check and allocation vectors.
DF90: EB      		ex	de,hl
DF91: 21CCE9  		ld	hl,sectors	;move parameter block into our ram.
DF94: 0E0F    		ld	c,15		;it is 15 bytes long.
DF96: CD5ADF  		call	de2hl
DF99: 2AD1E9  		ld	hl,(dsksize)	;check disk size.
DF9C: 7C      		ld	a,h		;more than 256 blocks on this?
DF9D: 21E8E9  		ld	hl,bigdisk
DFA0: 36FF    		ld	(hl),0ffh	;set to samll.
DFA2: B7      		or	a
DFA3: CAA8DF  		jp	z,select1
DFA6: 3600    		ld	(hl),0		;wrong, set to large.
DFA8: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
DFAA: B7      		or	a
DFAB: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
DFAC: CDDBEA  	homedrv:call	home		;home the head.
DFAF: AF      		xor	a
DFB0: 2AC0E9  		ld	hl,(scratch2)	;set our track pointer also.
DFB3: 77      		ld	(hl),a
DFB4: 23      		inc	hl
DFB5: 77      		ld	(hl),a
DFB6: 2AC2E9  		ld	hl,(scratch3)	;and our sector pointer.
DFB9: 77      		ld	(hl),a
DFBA: 23      		inc	hl
DFBB: 77      		ld	(hl),a
DFBC: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
DFBD: CD0CEB  	doread:	call	read
DFC0: C3C6DF  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
DFC3: CD10EB  	dowrite:call	write
DFC6: B7      	ioret:	or	a
DFC7: C8      		ret	z		;return unless an error occured.
DFC8: 210CDC  		ld	hl,badsctr	;bad read/write on this sector.
DFCB: C355DF  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
DFCE: 2AF5E9  	trksec:	ld	hl,(filepos)	;get position of last accessed file
DFD1: 0E02    		ld	c,2		;in directory and compute sector #.
DFD3: CDF5E0  		call	shiftr		;sector #=file-position/4.
DFD6: 22F0E9  		ld	(blknmbr),hl	;save this as the block number of interest.
DFD9: 22F7E9  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
DFDC: 21F0E9  	trksec1:ld	hl,blknmbr
DFDF: 4E      		ld	c,(hl)		;move sector number into (bc).
DFE0: 23      		inc	hl
DFE1: 46      		ld	b,(hl)
DFE2: 2AC2E9  		ld	hl,(scratch3)	;get current sector number and
DFE5: 5E      		ld	e,(hl)		;move this into (de).
DFE6: 23      		inc	hl
DFE7: 56      		ld	d,(hl)
DFE8: 2AC0E9  		ld	hl,(scratch2)	;get current track number.
DFEB: 7E      		ld	a,(hl)		;and this into (hl).
DFEC: 23      		inc	hl
DFED: 66      		ld	h,(hl)
DFEE: 6F      		ld	l,a
DFEF: 79      	trksec2:ld	a,c		;is desired sector before current one?
DFF0: 93      		sub	e
DFF1: 78      		ld	a,b
DFF2: 9A      		sbc	a,d
DFF3: D205E0  		jp	nc,trksec3
DFF6: E5      		push	hl		;yes, decrement sectors by one track.
DFF7: 2ACCE9  		ld	hl,(sectors)	;get sectors per track.
DFFA: 7B      		ld	a,e
DFFB: 95      		sub	l
DFFC: 5F      		ld	e,a
DFFD: 7A      		ld	a,d
DFFE: 9C      		sbc	a,h
DFFF: 57      		ld	d,a		;now we have backed up one full track.
E000: E1      		pop	hl
E001: 2B      		dec	hl		;adjust track counter.
E002: C3EFDF  		jp	trksec2
E005: E5      	trksec3:push	hl		;desired sector is after current one.
E006: 2ACCE9  		ld	hl,(sectors)	;get sectors per track.
E009: 19      		add	hl,de		;bump sector pointer to next track.
E00A: DA1AE0  		jp	c,trksec4
E00D: 79      		ld	a,c		;is desired sector now before current one?
E00E: 95      		sub	l
E00F: 78      		ld	a,b
E010: 9C      		sbc	a,h
E011: DA1AE0  		jp	c,trksec4
E014: EB      		ex	de,hl		;not yes, increment track counter
E015: E1      		pop	hl		;and continue until it is.
E016: 23      		inc	hl
E017: C305E0  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E01A: E1      	trksec4:pop	hl		;get track number (hl).
E01B: C5      		push	bc
E01C: D5      		push	de
E01D: E5      		push	hl
E01E: EB      		ex	de,hl
E01F: 2AD9E9  		ld	hl,(offset)	;adjust for first track offset.
E022: 19      		add	hl,de
E023: 44      		ld	b,h
E024: 4D      		ld	c,l
E025: CDFEEA  		call	settrk		;select this track.
E028: D1      		pop	de		;reset current track pointer.
E029: 2AC0E9  		ld	hl,(scratch2)
E02C: 73      		ld	(hl),e
E02D: 23      		inc	hl
E02E: 72      		ld	(hl),d
E02F: D1      		pop	de
E030: 2AC2E9  		ld	hl,(scratch3)	;reset the first sector on this track.
E033: 73      		ld	(hl),e
E034: 23      		inc	hl
E035: 72      		ld	(hl),d
E036: C1      		pop	bc
E037: 79      		ld	a,c		;now subtract the desired one.
E038: 93      		sub	e		;to make it relative (1-# sectors/track).
E039: 4F      		ld	c,a
E03A: 78      		ld	a,b
E03B: 9A      		sbc	a,d
E03C: 47      		ld	b,a
E03D: 2ADBE9  		ld	hl,(xlate)	;translate this sector according to this table.
E040: EB      		ex	de,hl
E041: CD17EB  		call	sectrn		;let the bios translate it.
E044: 4D      		ld	c,l
E045: 44      		ld	b,h
E046: C302EB  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E049: 21CEE9  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E04C: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E04D: 3AEEE9  		ld	a,(savnrec)	;get record number.
E050: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E051: 1F      		rra	
E052: 0D      		dec	c
E053: C250E0  		jp	nz,getblk1
E056: 47      		ld	b,a		;save result in (b).
E057: 3E08    		ld	a,8
E059: 96      		sub	(hl)
E05A: 4F      		ld	c,a		;compute (c)=8-blkshft.
E05B: 3AEDE9  		ld	a,(savext)
E05E: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E05F: CA67E0  		jp	z,getblk3
E062: B7      		or	a
E063: 17      		rla	
E064: C35EE0  		jp	getblk2
E067: 80      	getblk3:add	a,b
E068: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E069: 2A4EDF  	extblk:	ld	hl,(params)	;get fcb address.
E06C: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E06F: 19      		add	hl,de
E070: 09      		add	hl,bc
E071: 3AE8E9  		ld	a,(bigdisk)	;are we using a big-disk?
E074: B7      		or	a
E075: CA7CE0  		jp	z,extblk1
E078: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E079: 2600    		ld	h,0
E07B: C9      		ret	
E07C: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E07D: 5E      		ld	e,(hl)
E07E: 23      		inc	hl
E07F: 56      		ld	d,(hl)
E080: EB      		ex	de,hl		;return in (hl).
E081: C9      		ret	
              	;
              	;   compute block number.
              	;
E082: CD49E0  	comblk:	call	getblock
E085: 4F      		ld	c,a
E086: 0600    		ld	b,0
E088: CD69E0  		call	extblk
E08B: 22F0E9  		ld	(blknmbr),hl
E08E: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E08F: 2AF0E9  	chkblk:	ld	hl,(blknmbr)
E092: 7D      		ld	a,l		;is it zero?
E093: B4      		or	h
E094: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E095: 3ACEE9  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E098: 2AF0E9  		ld	hl,(blknmbr)	;get physical sector desired.
E09B: 29      	logicl1:add	hl,hl		;compute logical sector number.
E09C: 3D      		dec	a		;note logical sectors are 128 bytes long.
E09D: C29BE0  		jp	nz,logicl1
E0A0: 22F2E9  		ld	(logsect),hl	;save logical sector.
E0A3: 3ACFE9  		ld	a,(blkmask)	;get block mask.
E0A6: 4F      		ld	c,a
E0A7: 3AEEE9  		ld	a,(savnrec)	;get next sector to access.
E0AA: A1      		and	c		;extract the relative position within physical block.
E0AB: B5      		or	l		;and add it too logical sector.
E0AC: 6F      		ld	l,a
E0AD: 22F0E9  		ld	(blknmbr),hl	;and store.
E0B0: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E0B1: 2A4EDF  	setext:	ld	hl,(params)
E0B4: 110C00  		ld	de,12		;it is the twelth byte.
E0B7: 19      		add	hl,de
E0B8: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E0B9: 2A4EDF  	sethlde:ld	hl,(params)
E0BC: 110F00  		ld	de,15		;record count byte (#15).
E0BF: 19      		add	hl,de
E0C0: EB      		ex	de,hl
E0C1: 211100  		ld	hl,17		;next record number (#32).
E0C4: 19      		add	hl,de
E0C5: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E0C6: CDB9E0  	strdata:call	sethlde
E0C9: 7E      		ld	a,(hl)		;get and store record count byte.
E0CA: 32EEE9  		ld	(savnrec),a
E0CD: EB      		ex	de,hl
E0CE: 7E      		ld	a,(hl)		;get and store next record number byte.
E0CF: 32ECE9  		ld	(savnxt),a
E0D2: CDB1E0  		call	setext		;point to extent byte.
E0D5: 3AD0E9  		ld	a,(extmask)	;get extent mask.
E0D8: A6      		and	(hl)
E0D9: 32EDE9  		ld	(savext),a	;and save extent here.
E0DC: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E0DD: CDB9E0  	setnrec:call	sethlde
E0E0: 3AE0E9  		ld	a,(mode)	;get sequential flag (=1).
E0E3: FE02    		cp	2		;a 2 indicates that no adder is needed.
E0E5: C2E9E0  		jp	nz,stnrec1
E0E8: AF      		xor	a		;clear adder (random access?).
E0E9: 4F      	stnrec1:ld	c,a
E0EA: 3AEEE9  		ld	a,(savnrec)	;get last record number.
E0ED: 81      		add	a,c		;increment record count.
E0EE: 77      		ld	(hl),a		;and set fcb's next record byte.
E0EF: EB      		ex	de,hl
E0F0: 3AECE9  		ld	a,(savnxt)	;get next record byte from storage.
E0F3: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E0F4: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E0F5: 0C      	shiftr:	inc	c
E0F6: 0D      	shiftr1:dec	c
E0F7: C8      		ret	z
E0F8: 7C      		ld	a,h
E0F9: B7      		or	a
E0FA: 1F      		rra	
E0FB: 67      		ld	h,a
E0FC: 7D      		ld	a,l
E0FD: 1F      		rra	
E0FE: 6F      		ld	l,a
E0FF: C3F6E0  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E102: 0E80    	checksum: ld	c,128		;length of buffer.
E104: 2AC4E9  		ld	hl,(dirbuf)	;get its location.
E107: AF      		xor	a		;clear summation byte.
E108: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E109: 23      		inc	hl
E10A: 0D      		dec	c
E10B: C208E1  		jp	nz,chksum1
E10E: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E10F: 0C      	shiftl:	inc	c
E110: 0D      	shiftl1:dec	c
E111: C8      		ret	z
E112: 29      		add	hl,hl		;shift left 1 bit.
E113: C310E1  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E116: C5      	setbit:	push	bc		;save 16 bit word.
E117: 3A4DDF  		ld	a,(active)	;get active drive.
E11A: 4F      		ld	c,a
E11B: 210100  		ld	hl,1
E11E: CD0FE1  		call	shiftl		;shift bit 0 into place.
E121: C1      		pop	bc		;now 'or' this with the original word.
E122: 79      		ld	a,c
E123: B5      		or	l
E124: 6F      		ld	l,a		;low byte done, do high byte.
E125: 78      		ld	a,b
E126: B4      		or	h
E127: 67      		ld	h,a
E128: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E129: 2AB8E9  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E12C: 3A4DDF  		ld	a,(active)	;which drive is current?
E12F: 4F      		ld	c,a
E130: CDF5E0  		call	shiftr		;shift status such that bit 0 is the
E133: 7D      		ld	a,l		;one of interest for this drive.
E134: E601    		and	01h		;and isolate it.
E136: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E137: 21B8E9  	wrtprtd:ld	hl,wrtprt	;point to status word.
E13A: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E13B: 23      		inc	hl
E13C: 46      		ld	b,(hl)
E13D: CD16E1  		call	setbit		;and set this bit according to current drive.
E140: 22B8E9  		ld	(wrtprt),hl	;then save.
E143: 2AD3E9  		ld	hl,(dirsize)	;now save directory size limit.
E146: 23      		inc	hl		;remember the last one.
E147: EB      		ex	de,hl
E148: 2ABEE9  		ld	hl,(scratch1)	;and store it here.
E14B: 73      		ld	(hl),e		;put low byte.
E14C: 23      		inc	hl
E14D: 72      		ld	(hl),d		;then high byte.
E14E: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E14F: CD69E1  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E152: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E155: 19      		add	hl,de
E156: 7E      		ld	a,(hl)
E157: 17      		rla	
E158: D0      		ret	nc		;return if ok.
E159: 2112DC  		ld	hl,rofile	;else, print error message and terminate.
E15C: C355DF  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E15F: CD29E1  	chkwprt:call	getwprt
E162: C8      		ret	z		;return if ok.
E163: 2110DC  		ld	hl,rodisk	;else print message and terminate.
E166: C355DF  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E169: 2AC4E9  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E16C: 3AF4E9  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E16F: 85      	adda2hl:add	a,l
E170: 6F      		ld	l,a
E171: D0      		ret	nc
E172: 24      		inc	h		;take care of any carry.
E173: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E174: 2A4EDF  	gets2:	ld	hl,(params)	;get address of fcb.
E177: 110E00  		ld	de,14		;relative position of 's2'.
E17A: 19      		add	hl,de
E17B: 7E      		ld	a,(hl)		;extract this byte.
E17C: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E17D: CD74E1  	clears2:call	gets2		;this sets (hl) pointing to it.
E180: 3600    		ld	(hl),0		;now clear it.
E182: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E183: CD74E1  	sets2b7:call	gets2		;get the byte.
E186: F680    		or	80h		;and set bit 7.
E188: 77      		ld	(hl),a		;then store.
E189: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E18A: 2AF5E9  	morefls:ld	hl,(filepos)	;we are here.
E18D: EB      		ex	de,hl
E18E: 2ABEE9  		ld	hl,(scratch1)	;and don't go past here.
E191: 7B      		ld	a,e		;compute difference but don't keep.
E192: 96      		sub	(hl)
E193: 23      		inc	hl
E194: 7A      		ld	a,d
E195: 9E      		sbc	a,(hl)		;set carry if no more names.
E196: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E197: CD8AE1  	chknmbr:call	morefls		;scratch1 too big?
E19A: D8      		ret	c
E19B: 13      		inc	de		;yes, reset it to (filepos).
E19C: 72      		ld	(hl),d
E19D: 2B      		dec	hl
E19E: 73      		ld	(hl),e
E19F: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E1A0: 7B      	subhl:	ld	a,e		;compute difference.
E1A1: 95      		sub	l
E1A2: 6F      		ld	l,a		;store low byte.
E1A3: 7A      		ld	a,d
E1A4: 9C      		sbc	a,h
E1A5: 67      		ld	h,a		;and then high byte.
E1A6: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E1A7: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E1A9: 2AF7E9  	checkdir: ld	hl,(cksumtbl)
E1AC: EB      		ex	de,hl
E1AD: 2AD7E9  		ld	hl,(alloc1)
E1B0: CDA0E1  		call	subhl
E1B3: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E1B4: C5      		push	bc
E1B5: CD02E1  		call	checksum	;else compute checksum.
E1B8: 2AC8E9  		ld	hl,(chkvect)	;get address of checksum table.
E1BB: EB      		ex	de,hl
E1BC: 2AF7E9  		ld	hl,(cksumtbl)
E1BF: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E1C0: C1      		pop	bc
E1C1: 0C      		inc	c		;set or check ?
E1C2: CACFE1  		jp	z,chkdir1
E1C5: BE      		cp	(hl)		;check them.
E1C6: C8      		ret	z		;return if they are the same.
E1C7: CD8AE1  		call	morefls		;not the same, do we care?
E1CA: D0      		ret	nc
E1CB: CD37E1  		call	wrtprtd		;yes, mark this as write protected.
E1CE: C9      		ret	
E1CF: 77      	chkdir1:ld	(hl),a		;just set the byte.
E1D0: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E1D1: CDA7E1  	dirwrite: call	setdir		;set checksum byte.
E1D4: CDEBE1  		call	dirdma		;set directory dma address.
E1D7: 0E01    		ld	c,1		;tell the bios to actually write.
E1D9: CDC3DF  		call	dowrite		;then do the write.
E1DC: C3E5E1  		jp	defdma
              	;
              	;   read from the directory.
              	;
E1DF: CDEBE1  	dirread:call	dirdma		;set the directory dma address.
E1E2: CDBDDF  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E1E5: 21BCE9  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E1E8: C3EEE1  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E1EB: 21C4E9  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E1EE: 4E      	dirdma1:ld	c,(hl)
E1EF: 23      		inc	hl
E1F0: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E1F1: C306EB  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E1F4: 2AC4E9  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E1F7: EB      		ex	de,hl
E1F8: 2ABCE9  		ld	hl,(userdma)	; put it here.
E1FB: 0E80    		ld	c,128		;this is its length.
E1FD: C35ADF  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E200: 21F5E9  	ckfilpos: ld	hl,filepos
E203: 7E      		ld	a,(hl)
E204: 23      		inc	hl
E205: BE      		cp	(hl)		;are both bytes the same?
E206: C0      		ret	nz
E207: 3C      		inc	a		;yes, but are they each 0ffh?
E208: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E209: 21FFFF  	stfilpos: ld	hl,0ffffh
E20C: 22F5E9  		ld	(filepos),hl
E20F: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
E210: 2AD3E9  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
E213: EB      		ex	de,hl
E214: 2AF5E9  		ld	hl,(filepos)	;get current count.
E217: 23      		inc	hl		;go on to the next one.
E218: 22F5E9  		ld	(filepos),hl
E21B: CDA0E1  		call	subhl		;(hl)=(dirsize)-(filepos)
E21E: D224E2  		jp	nc,nxent1	;is there more room left?
E221: C309E2  		jp	stfilpos	;no. set this flag and return.
E224: 3AF5E9  	nxent1:	ld	a,(filepos)	;get file position within directory.
E227: E603    		and	03h		;only look within this sector (only 4 entries fit).
E229: 0605    		ld	b,5		;convert to relative position (32 bytes each).
E22B: 87      	nxent2:	add	a,a		;note that this is not efficient code.
E22C: 05      		dec	b		;5 'add a's would be better.
E22D: C22BE2  		jp	nz,nxent2
E230: 32F4E9  		ld	(fcbpos),a	;save it as position of fcb.
E233: B7      		or	a
E234: C0      		ret	nz		;return if we are within buffer.
E235: C5      		push	bc
E236: CDCEDF  		call	trksec		;we need the next directory sector.
E239: CDDFE1  		call	dirread
E23C: C1      		pop	bc
E23D: C3A9E1  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
E240: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
E241: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
E243: 3C      		inc	a
E244: 5F      		ld	e,a		;save particular bit number.
E245: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
E246: 79      		ld	a,c
E247: 0F      		rrca			;now shift right 3 bits.
E248: 0F      		rrca	
E249: 0F      		rrca	
E24A: E61F    		and	1fh		;and clear bits 7,6,5.
E24C: 4F      		ld	c,a
E24D: 78      		ld	a,b
E24E: 87      		add	a,a		;now shift (b) into bits 7,6,5.
E24F: 87      		add	a,a
E250: 87      		add	a,a
E251: 87      		add	a,a
E252: 87      		add	a,a
E253: B1      		or	c		;and add in (c).
E254: 4F      		ld	c,a		;ok, (c) ha been completed.
E255: 78      		ld	a,b		;is there a better way of doing this?
E256: 0F      		rrca	
E257: 0F      		rrca	
E258: 0F      		rrca	
E259: E61F    		and	1fh
E25B: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
E25C: 2ACAE9  		ld	hl,(alocvect)
E25F: 09      		add	hl,bc
E260: 7E      		ld	a,(hl)		;now get correct byte.
E261: 07      	ckbmap1:rlca			;get correct bit into position 0.
E262: 1D      		dec	e
E263: C261E2  		jp	nz,ckbmap1
E266: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
E267: D5      	stbitmap: push	de
E268: CD40E2  		call	ckbitmap	;get the byte of interest.
E26B: E6FE    		and	0feh		;clear the affected bit.
E26D: C1      		pop	bc
E26E: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
E26F: 0F      	stbmap1:rrca			;restore original bit position.
E270: 15      		dec	d
E271: C26FE2  		jp	nz,stbmap1
E274: 77      		ld	(hl),a		;and stor byte in table.
E275: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
E276: CD69E1  	setfile:call	fcb2hl		;get address of fcb
E279: 111000  		ld	de,16
E27C: 19      		add	hl,de		;get to block number bytes.
E27D: C5      		push	bc
E27E: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
E280: D1      	setfl1:	pop	de
E281: 0D      		dec	c		;done all bytes yet?
E282: C8      		ret	z
E283: D5      		push	de
E284: 3AE8E9  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
E287: B7      		or	a
E288: CA93E2  		jp	z,setfl2
E28B: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
E28C: E5      		push	hl
E28D: 4E      		ld	c,(hl)		;get low byte from table, always
E28E: 0600    		ld	b,0		;set high byte to zero.
E290: C399E2  		jp	setfl3
E293: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
E294: C5      		push	bc
E295: 4E      		ld	c,(hl)		;now get both the low and high bytes.
E296: 23      		inc	hl
E297: 46      		ld	b,(hl)
E298: E5      		push	hl
E299: 79      	setfl3:	ld	a,c		;block used?
E29A: B0      		or	b
E29B: CAA8E2  		jp	z,setfl4
E29E: 2AD1E9  		ld	hl,(dsksize)	;is this block number within the
E2A1: 7D      		ld	a,l		;space on the disk?
E2A2: 91      		sub	c
E2A3: 7C      		ld	a,h
E2A4: 98      		sbc	a,b
E2A5: D467E2  		call	nc,stbitmap	;yes, set the proper bit.
E2A8: E1      	setfl4:	pop	hl		;point to next block number in fcb.
E2A9: 23      		inc	hl
E2AA: C1      		pop	bc
E2AB: C380E2  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
E2AE: 2AD1E9  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
E2B1: 0E03    		ld	c,3
E2B3: CDF5E0  		call	shiftr		;(hl)=(hl)/8.
E2B6: 23      		inc	hl		;at lease 1 byte.
E2B7: 44      		ld	b,h
E2B8: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
E2B9: 2ACAE9  		ld	hl,(alocvect)	;now zero out the table now.
E2BC: 3600    	bitmap1:ld	(hl),0
E2BE: 23      		inc	hl
E2BF: 0B      		dec	bc
E2C0: 78      		ld	a,b
E2C1: B1      		or	c
E2C2: C2BCE2  		jp	nz,bitmap1
E2C5: 2AD5E9  		ld	hl,(alloc0)	;get initial space used by directory.
E2C8: EB      		ex	de,hl
E2C9: 2ACAE9  		ld	hl,(alocvect)	;and put this into map.
E2CC: 73      		ld	(hl),e
E2CD: 23      		inc	hl
E2CE: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
E2CF: CDACDF  		call	homedrv		;now home the drive.
E2D2: 2ABEE9  		ld	hl,(scratch1)
E2D5: 3603    		ld	(hl),3		;force next directory request to read
E2D7: 23      		inc	hl		;in a sector.
E2D8: 3600    		ld	(hl),0
E2DA: CD09E2  		call	stfilpos	;clear initial file position also.
E2DD: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
E2DF: CD10E2  		call	nxentry		;and set checksum byte.
E2E2: CD00E2  		call	ckfilpos	;is there another file?
E2E5: C8      		ret	z
E2E6: CD69E1  		call	fcb2hl		;yes, get its address.
E2E9: 3EE5    		ld	a,0e5h
E2EB: BE      		cp	(hl)		;empty file entry?
E2EC: CADDE2  		jp	z,bitmap2
E2EF: 3A4CDF  		ld	a,(userno)	;no, correct user number?
E2F2: BE      		cp	(hl)
E2F3: C201E3  		jp	nz,bitmap3
E2F6: 23      		inc	hl
E2F7: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
E2F8: D624    		sub	'$'
E2FA: C201E3  		jp	nz,bitmap3
E2FD: 3D      		dec	a		;yes, set atatus to minus one.
E2FE: 3250DF  		ld	(status),a
E301: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
E303: CD76E2  		call	setfile
E306: CD97E1  		call	chknmbr		;keep (scratch1) in bounds.
E309: C3DDE2  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
E30C: 3ADFE9  	ststatus: ld	a,(fndstat)
E30F: C30CDF  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
E312: C5      	samext:	push	bc
E313: F5      		push	af
E314: 3AD0E9  		ld	a,(extmask)	;get extent mask and use it to
E317: 2F      		cpl			;to compare both extent numbers.
E318: 47      		ld	b,a		;save resulting mask here.
E319: 79      		ld	a,c		;mask first extent and save in (c).
E31A: A0      		and	b
E31B: 4F      		ld	c,a
E31C: F1      		pop	af		;now mask second extent and compare
E31D: A0      		and	b		;with the first one.
E31E: 91      		sub	c
E31F: E61F    		and	1fh		;(* only check buts 0-4 *)
E321: C1      		pop	bc		;the zero flag is set if they are the same.
E322: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
E323: 3EFF    	findfst:ld	a,0ffh
E325: 32DFE9  		ld	(fndstat),a
E328: 21E3E9  		ld	hl,counter	;save character count.
E32B: 71      		ld	(hl),c
E32C: 2A4EDF  		ld	hl,(params)	;get filename to match.
E32F: 22E4E9  		ld	(savefcb),hl	;and save.
E332: CD09E2  		call	stfilpos	;clear initial file position (set to 0ffffh).
E335: CDACDF  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
E338: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
E33A: CD10E2  		call	nxentry		;get next filename entry in directory.
E33D: CD00E2  		call	ckfilpos	;is file position = 0ffffh?
E340: CA9FE3  		jp	z,fndnxt6	;yes, exit now then.
E343: 2AE4E9  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
E346: EB      		ex	de,hl
E347: 1A      		ld	a,(de)
E348: FEE5    		cp	0e5h		;empty directory entry?
E34A: CA55E3  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
E34D: D5      		push	de
E34E: CD8AE1  		call	morefls		;more files in directory?
E351: D1      		pop	de
E352: D29FE3  		jp	nc,fndnxt6	;no more. exit now.
E355: CD69E1  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
E358: 3AE3E9  		ld	a,(counter)	;get number of bytes (characters) to check.
E35B: 4F      		ld	c,a
E35C: 0600    		ld	b,0		;initialize byte position counter.
E35E: 79      	fndnxt2:ld	a,c		;are we done with the compare?
E35F: B7      		or	a
E360: CA8EE3  		jp	z,fndnxt5
E363: 1A      		ld	a,(de)		;no, check next byte.
E364: FE3F    		cp	'?'		;don't care about this character?
E366: CA87E3  		jp	z,fndnxt4
E369: 78      		ld	a,b		;get bytes position in fcb.
E36A: FE0D    		cp	13		;don't care about the thirteenth byte either.
E36C: CA87E3  		jp	z,fndnxt4
E36F: FE0C    		cp	12		;extent byte?
E371: 1A      		ld	a,(de)
E372: CA7EE3  		jp	z,fndnxt3
E375: 96      		sub	(hl)		;otherwise compare characters.
E376: E67F    		and	7fh
E378: C238E3  		jp	nz,findnxt	;not the same, check next entry.
E37B: C387E3  		jp	fndnxt4		;so far so good, keep checking.
E37E: C5      	fndnxt3:push	bc		;check the extent byte here.
E37F: 4E      		ld	c,(hl)
E380: CD12E3  		call	samext
E383: C1      		pop	bc
E384: C238E3  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
E387: 13      	fndnxt4:inc	de		;bump pointers.
E388: 23      		inc	hl
E389: 04      		inc	b
E38A: 0D      		dec	c		;adjust character counter.
E38B: C35EE3  		jp	fndnxt2
E38E: 3AF5E9  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
E391: E603    		and	03h
E393: 3250DF  		ld	(status),a
E396: 21DFE9  		ld	hl,fndstat
E399: 7E      		ld	a,(hl)
E39A: 17      		rla	
E39B: D0      		ret	nc
E39C: AF      		xor	a
E39D: 77      		ld	(hl),a
E39E: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
E39F: CD09E2  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
E3A2: 3EFF    		ld	a,0ffh		;say not located.
E3A4: C30CDF  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
E3A7: CD5FE1  	erafile:call	chkwprt		;is disk write protected?
E3AA: 0E0C    		ld	c,12		;only compare file names.
E3AC: CD23E3  		call	findfst		;get first file name.
E3AF: CD00E2  	erafil1:call	ckfilpos	;any found?
E3B2: C8      		ret	z		;nope, we must be done.
E3B3: CD4FE1  		call	chkrofl		;is file read only?
E3B6: CD69E1  		call	fcb2hl		;nope, get address of fcb and
E3B9: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
E3BB: 0E00    		ld	c,0		;clear the space from the bit map.
E3BD: CD76E2  		call	setfile
E3C0: CDD1E1  		call	dirwrite	;now write the directory sector back out.
E3C3: CD38E3  		call	findnxt		;find the next file name.
E3C6: C3AFE3  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
E3C9: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
E3CA: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
E3CB: 79      	fndspa1:ld	a,c		;is block 0 specified?
E3CC: B0      		or	b
E3CD: CADCE3  		jp	z,fndspa2
E3D0: 0B      		dec	bc		;nope, check previous block.
E3D1: D5      		push	de
E3D2: C5      		push	bc
E3D3: CD40E2  		call	ckbitmap
E3D6: 1F      		rra			;is this block empty?
E3D7: D2F7E3  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
E3DA: C1      		pop	bc		;nope, check some more.
E3DB: D1      		pop	de
              	;
              	;   now look after target block.
              	;
E3DC: 2AD1E9  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
E3DF: 7B      		ld	a,e
E3E0: 95      		sub	l
E3E1: 7A      		ld	a,d
E3E2: 9C      		sbc	a,h
E3E3: D2FFE3  		jp	nc,fndspa4
E3E6: 13      		inc	de		;yes, move on to next one.
E3E7: C5      		push	bc
E3E8: D5      		push	de
E3E9: 42      		ld	b,d
E3EA: 4B      		ld	c,e
E3EB: CD40E2  		call	ckbitmap	;check it.
E3EE: 1F      		rra			;empty?
E3EF: D2F7E3  		jp	nc,fndspa3
E3F2: D1      		pop	de		;nope, continue searching.
E3F3: C1      		pop	bc
E3F4: C3CBE3  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
E3F7: 17      	fndspa3:rla			;reset byte.
E3F8: 3C      		inc	a		;and set bit 0.
E3F9: CD6FE2  		call	stbmap1		;update bit map.
E3FC: E1      		pop	hl		;set return registers.
E3FD: D1      		pop	de
E3FE: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
E3FF: 79      	fndspa4:ld	a,c
E400: B0      		or	b
E401: C2CBE3  		jp	nz,fndspa1
E404: 210000  		ld	hl,0		;set 'not found' status.
E407: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
E408: 0E00    	fcbset:	ld	c,0
E40A: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
E40C: D5      	update:	push	de
E40D: 0600    		ld	b,0		;set (bc) to relative byte position.
E40F: 2A4EDF  		ld	hl,(params)	;get address of fcb.
E412: 09      		add	hl,bc		;compute starting byte.
E413: EB      		ex	de,hl
E414: CD69E1  		call	fcb2hl		;get address of fcb to update in directory.
E417: C1      		pop	bc		;set (c) to number of bytes to change.
E418: CD5ADF  		call	de2hl
E41B: CDCEDF  	update1:call	trksec		;determine the track and sector affected.
E41E: C3D1E1  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
E421: CD5FE1  	chgnames: call	chkwprt		;check for a write protected disk.
E424: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
E426: CD23E3  		call	findfst		;get first name.
E429: 2A4EDF  		ld	hl,(params)	;get address of fcb.
E42C: 7E      		ld	a,(hl)		;get user number.
E42D: 111000  		ld	de,16		;move over to desired name.
E430: 19      		add	hl,de
E431: 77      		ld	(hl),a		;keep same user number.
E432: CD00E2  	chgnam1:call	ckfilpos	;any matching file found?
E435: C8      		ret	z		;no, we must be done.
E436: CD4FE1  		call	chkrofl		;check for read only file.
E439: 0E10    		ld	c,16		;start 16 bytes into fcb.
E43B: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
E43D: CD0CE4  		call	update
E440: CD38E3  		call	findnxt		;get te next file name.
E443: C332E4  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
E446: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
E448: CD23E3  		call	findfst		;look for first filename.
E44B: CD00E2  	savatr1:call	ckfilpos	;was one found?
E44E: C8      		ret	z		;nope, we must be done.
E44F: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
E451: 1E0C    		ld	e,12
E453: CD0CE4  		call	update		;update filename and write directory.
E456: CD38E3  		call	findnxt		;and get the next file.
E459: C34BE4  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
E45C: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
E45E: CD23E3  		call	findfst		;get the first one in directory.
E461: CD00E2  		call	ckfilpos	;any at all?
E464: C8      		ret	z
E465: CDB1E0  	openit1:call	setext		;point to extent byte within users fcb.
E468: 7E      		ld	a,(hl)		;and get it.
E469: F5      		push	af		;save it and address.
E46A: E5      		push	hl
E46B: CD69E1  		call	fcb2hl		;point to fcb in directory.
E46E: EB      		ex	de,hl
E46F: 2A4EDF  		ld	hl,(params)	;this is the users copy.
E472: 0E20    		ld	c,32		;move it into users space.
E474: D5      		push	de
E475: CD5ADF  		call	de2hl
E478: CD83E1  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
E47B: D1      		pop	de		;now get the extent byte from this fcb.
E47C: 210C00  		ld	hl,12
E47F: 19      		add	hl,de
E480: 4E      		ld	c,(hl)		;into (c).
E481: 210F00  		ld	hl,15		;now get the record count byte into (b).
E484: 19      		add	hl,de
E485: 46      		ld	b,(hl)
E486: E1      		pop	hl		;keep the same extent as the user had originally.
E487: F1      		pop	af
E488: 77      		ld	(hl),a
E489: 79      		ld	a,c		;is it the same as in the directory fcb?
E48A: BE      		cp	(hl)
E48B: 78      		ld	a,b		;if yes, then use the same record count.
E48C: CA96E4  		jp	z,openit2
E48F: 3E00    		ld	a,0		;if the user specified an extent greater than
E491: DA96E4  		jp	c,openit2	;the one in the directory, then set record count to 0.
E494: 3E80    		ld	a,128		;otherwise set to maximum.
E496: 2A4EDF  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
E499: 110F00  		ld	de,15
E49C: 19      		add	hl,de		;compute relative position.
E49D: 77      		ld	(hl),a		;and set the record count.
E49E: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
E49F: 7E      	moveword: ld	a,(hl)		;check for a zero word.
E4A0: 23      		inc	hl
E4A1: B6      		or	(hl)		;both bytes zero?
E4A2: 2B      		dec	hl
E4A3: C0      		ret	nz		;nope, just return.
E4A4: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
E4A5: 77      		ld	(hl),a		;this zero space.
E4A6: 13      		inc	de
E4A7: 23      		inc	hl
E4A8: 1A      		ld	a,(de)
E4A9: 77      		ld	(hl),a
E4AA: 1B      		dec	de		;don't disturb these registers.
E4AB: 2B      		dec	hl
E4AC: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
E4AD: AF      	closeit:xor	a		;clear status and file position bytes.
E4AE: 3250DF  		ld	(status),a
E4B1: 32F5E9  		ld	(filepos),a
E4B4: 32F6E9  		ld	(filepos+1),a
E4B7: CD29E1  		call	getwprt		;get write protect bit for this drive.
E4BA: C0      		ret	nz		;just return if it is set.
E4BB: CD74E1  		call	gets2		;else get the 's2' byte.
E4BE: E680    		and	80h		;and look at bit 7 (file unmodified?).
E4C0: C0      		ret	nz		;just return if set.
E4C1: 0E0F    		ld	c,15		;else look up this file in directory.
E4C3: CD23E3  		call	findfst
E4C6: CD00E2  		call	ckfilpos	;was it found?
E4C9: C8      		ret	z		;just return if not.
E4CA: 011000  		ld	bc,16		;set (hl) pointing to records used section.
E4CD: CD69E1  		call	fcb2hl
E4D0: 09      		add	hl,bc
E4D1: EB      		ex	de,hl
E4D2: 2A4EDF  		ld	hl,(params)	;do the same for users specified fcb.
E4D5: 09      		add	hl,bc
E4D6: 0E10    		ld	c,16		;this many bytes are present in this extent.
E4D8: 3AE8E9  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
E4DB: B7      		or	a
E4DC: CAF3E4  		jp	z,closeit4
E4DF: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
E4E0: B7      		or	a
E4E1: 1A      		ld	a,(de)		;now get one from directory fcb.
E4E2: C2E6E4  		jp	nz,closeit2
E4E5: 77      		ld	(hl),a		;users byte was zero. update from directory.
E4E6: B7      	closeit2: or	a
E4E7: C2ECE4  		jp	nz,closeit3
E4EA: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
E4EB: 12      		ld	(de),a
E4EC: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
E4ED: C22AE5  		jp	nz,closeit7	;then close error if they are not the same.
E4F0: C308E5  		jp	closeit5	;ok so far, get to next byte in fcbs.
E4F3: CD9FE4  	closeit4: call	moveword	;update users fcb if it is zero.
E4F6: EB      		ex	de,hl
E4F7: CD9FE4  		call	moveword	;update directories fcb if it is zero.
E4FA: EB      		ex	de,hl
E4FB: 1A      		ld	a,(de)		;if these two values are no different,
E4FC: BE      		cp	(hl)		;then a close error occured.
E4FD: C22AE5  		jp	nz,closeit7
E500: 13      		inc	de		;check second byte.
E501: 23      		inc	hl
E502: 1A      		ld	a,(de)
E503: BE      		cp	(hl)
E504: C22AE5  		jp	nz,closeit7
E507: 0D      		dec	c		;remember 16 bit values.
E508: 13      	closeit5: inc	de		;bump to next item in table.
E509: 23      		inc	hl
E50A: 0D      		dec	c		;there are 16 entries only.
E50B: C2D8E4  		jp	nz,closeit1	;continue if more to do.
E50E: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
E511: 09      		add	hl,bc
E512: EB      		ex	de,hl
E513: 09      		add	hl,bc
E514: 1A      		ld	a,(de)
E515: BE      		cp	(hl)		;directory's extent already greater than the
E516: DA22E5  		jp	c,closeit6	;users extent?
E519: 77      		ld	(hl),a		;no, update directory extent.
E51A: 010300  		ld	bc,3		;and update the record count byte in
E51D: 09      		add	hl,bc		;directories fcb.
E51E: EB      		ex	de,hl
E51F: 09      		add	hl,bc
E520: 7E      		ld	a,(hl)		;get from user.
E521: 12      		ld	(de),a		;and put in directory.
E522: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
E524: 32DDE9  		ld	(closeflg),a
E527: C31BE4  		jp	update1		;update the directory now.
E52A: 2150DF  	closeit7: ld	hl,status	;set return status and then return.
E52D: 35      		dec	(hl)
E52E: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
E52F: CD5FE1  	getempty: call	chkwprt		;make sure disk is not write protected.
E532: 2A4EDF  		ld	hl,(params)	;save current parameters (fcb).
E535: E5      		push	hl
E536: 21B7E9  		ld	hl,emptyfcb	;use special one for empty space.
E539: 224EDF  		ld	(params),hl
E53C: 0E01    		ld	c,1		;search for first empty spot in directory.
E53E: CD23E3  		call	findfst		;(* only check first byte *)
E541: CD00E2  		call	ckfilpos	;none?
E544: E1      		pop	hl
E545: 224EDF  		ld	(params),hl	;restore original fcb address.
E548: C8      		ret	z		;return if no more space.
E549: EB      		ex	de,hl
E54A: 210F00  		ld	hl,15		;point to number of records for this file.
E54D: 19      		add	hl,de
E54E: 0E11    		ld	c,17		;and clear all of this space.
E550: AF      		xor	a
E551: 77      	getmt1:	ld	(hl),a
E552: 23      		inc	hl
E553: 0D      		dec	c
E554: C251E5  		jp	nz,getmt1
E557: 210D00  		ld	hl,13		;clear the 's1' byte also.
E55A: 19      		add	hl,de
E55B: 77      		ld	(hl),a
E55C: CD97E1  		call	chknmbr		;keep (scratch1) within bounds.
E55F: CD08E4  		call	fcbset		;write out this fcb entry to directory.
E562: C383E1  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
E565: AF      	getnext:xor	a
E566: 32DDE9  		ld	(closeflg),a	;clear close flag.
E569: CDADE4  		call	closeit		;close this extent.
E56C: CD00E2  		call	ckfilpos
E56F: C8      		ret	z		;not there???
E570: 2A4EDF  		ld	hl,(params)	;get extent byte.
E573: 010C00  		ld	bc,12
E576: 09      		add	hl,bc
E577: 7E      		ld	a,(hl)		;and increment it.
E578: 3C      		inc	a
E579: E61F    		and	1fh		;keep within range 0-31.
E57B: 77      		ld	(hl),a
E57C: CA8EE5  		jp	z,gtnext1	;overflow?
E57F: 47      		ld	b,a		;mask extent byte.
E580: 3AD0E9  		ld	a,(extmask)
E583: A0      		and	b
E584: 21DDE9  		ld	hl,closeflg	;check close flag (0ffh is ok).
E587: A6      		and	(hl)
E588: CA99E5  		jp	z,gtnext2	;if zero, we must read in next extent.
E58B: C3B7E5  		jp	gtnext3		;else, it is already in memory.
E58E: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
E591: 09      		add	hl,bc
E592: 34      		inc	(hl)		;and bump it.
E593: 7E      		ld	a,(hl)		;too many extents?
E594: E60F    		and	0fh
E596: CAC1E5  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
E599: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
E59B: CD23E3  		call	findfst		;find the first one.
E59E: CD00E2  		call	ckfilpos	;none available?
E5A1: C2B7E5  		jp	nz,gtnext3
E5A4: 3ADEE9  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
E5A7: 3C      		inc	a		;0ffh means reading (so not possible).
E5A8: CAC1E5  		jp	z,gtnext5	;or an error.
E5AB: CD2FE5  		call	getempty	;we are writing, get an empty entry.
E5AE: CD00E2  		call	ckfilpos	;none?
E5B1: CAC1E5  		jp	z,gtnext5	;error if true.
E5B4: C3BAE5  		jp	gtnext4		;else we are almost done.
E5B7: CD65E4  	gtnext3:call	openit1		;open this extent.
E5BA: CDC6E0  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
E5BD: AF      		xor	a		;clear status and return.
E5BE: C30CDF  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
E5C1: CD10DF  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
E5C4: C383E1  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
E5C7: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
E5C9: 32E0E9  		ld	(mode),a
E5CC: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
E5CE: 32DEE9  		ld	(rdwrtflg),a
E5D1: CDC6E0  		call	strdata		;put rec# and ext# into fcb.
E5D4: 3AEEE9  		ld	a,(savnrec)	;get next record to read.
E5D7: 21ECE9  		ld	hl,savnxt	;get number of records in extent.
E5DA: BE      		cp	(hl)		;within this extent?
E5DB: DAF1E5  		jp	c,rdseq2
E5DE: FE80    		cp	128		;no. is this extent fully used?
E5E0: C206E6  		jp	nz,rdseq3	;no. end-of-file.
E5E3: CD65E5  		call	getnext		;yes, open the next one.
E5E6: AF      		xor	a		;reset next record to read.
E5E7: 32EEE9  		ld	(savnrec),a
E5EA: 3A50DF  		ld	a,(status)	;check on open, successful?
E5ED: B7      		or	a
E5EE: C206E6  		jp	nz,rdseq3	;no, error.
E5F1: CD82E0  	rdseq2:	call	comblk		;ok. compute block number to read.
E5F4: CD8FE0  		call	chkblk		;check it. within bounds?
E5F7: CA06E6  		jp	z,rdseq3	;no, error.
E5FA: CD95E0  		call	logical		;convert (blknmbr) to logical sector (128 byte).
E5FD: CDDCDF  		call	trksec1		;set the track and sector for this block #.
E600: CDBDDF  		call	doread		;and read it.
E603: C3DDE0  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
E606: C310DF  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
E609: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
E60B: 32E0E9  		ld	(mode),a
E60E: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
E610: 32DEE9  		ld	(rdwrtflg),a
E613: CD5FE1  		call	chkwprt		;check write protect status.
E616: 2A4EDF  		ld	hl,(params)
E619: CD52E1  		call	ckrof1		;check for read only file, (hl) already set to fcb.
E61C: CDC6E0  		call	strdata		;put updated data into fcb.
E61F: 3AEEE9  		ld	a,(savnrec)	;get record number to write.
E622: FE80    		cp	128		;within range?
E624: D210DF  		jp	nc,ioerr1	;no, error(?).
E627: CD82E0  		call	comblk		;compute block number.
E62A: CD8FE0  		call	chkblk		;check number.
E62D: 0E00    		ld	c,0		;is there one to write to?
E62F: C279E6  		jp	nz,wtseq6	;yes, go do it.
E632: CD49E0  		call	getblock	;get next block number within fcb to use.
E635: 32E2E9  		ld	(relblock),a	;and save.
E638: 010000  		ld	bc,0		;start looking for space from the start
E63B: B7      		or	a		;if none allocated as yet.
E63C: CA46E6  		jp	z,wtseq2
E63F: 4F      		ld	c,a		;extract previous block number from fcb
E640: 0B      		dec	bc		;so we can be closest to it.
E641: CD69E0  		call	extblk
E644: 44      		ld	b,h
E645: 4D      		ld	c,l
E646: CDC9E3  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
E649: 7D      		ld	a,l		;check for a zero number.
E64A: B4      		or	h
E64B: C253E6  		jp	nz,wtseq3
E64E: 3E02    		ld	a,2		;no more space?
E650: C30CDF  		jp	setstat
E653: 22F0E9  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
E656: EB      		ex	de,hl		;put block number into (de).
E657: 2A4EDF  		ld	hl,(params)	;now we must update the fcb for this
E65A: 011000  		ld	bc,16		;newly allocated block.
E65D: 09      		add	hl,bc
E65E: 3AE8E9  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
E661: B7      		or	a
E662: 3AE2E9  		ld	a,(relblock)	;(* update this entry *)
E665: CA6FE6  		jp	z,wtseq4	;zero means 16 bit ones.
E668: CD6FE1  		call	adda2hl		;(hl)=(hl)+(a)
E66B: 73      		ld	(hl),e		;store new block number.
E66C: C377E6  		jp	wtseq5
E66F: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
E670: 0600    		ld	b,0
E672: 09      		add	hl,bc
E673: 09      		add	hl,bc
E674: 73      		ld	(hl),e		;stuff block number (de) there.
E675: 23      		inc	hl
E676: 72      		ld	(hl),d
E677: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
E679: 3A50DF  	wtseq6:	ld	a,(status)	;are we ok so far?
E67C: B7      		or	a
E67D: C0      		ret	nz
E67E: C5      		push	bc		;yes, save write flag for bios (register c).
E67F: CD95E0  		call	logical		;convert (blknmbr) over to loical sectors.
E682: 3AE0E9  		ld	a,(mode)	;get access mode flag (1=sequential,
E685: 3D      		dec	a		;0=random, 2=special?).
E686: 3D      		dec	a
E687: C2C6E6  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
E68A: C1      		pop	bc
E68B: C5      		push	bc
E68C: 79      		ld	a,c		;get write status flag (2=writing unused space).
E68D: 3D      		dec	a
E68E: 3D      		dec	a
E68F: C2C6E6  		jp	nz,wtseq9
E692: E5      		push	hl
E693: 2AC4E9  		ld	hl,(dirbuf)	;zero out the directory buffer.
E696: 57      		ld	d,a		;note that (a) is zero here.
E697: 77      	wtseq7:	ld	(hl),a
E698: 23      		inc	hl
E699: 14      		inc	d		;do 128 bytes.
E69A: F297E6  		jp	p,wtseq7
E69D: CDEBE1  		call	dirdma		;tell the bios the dma address for directory access.
E6A0: 2AF2E9  		ld	hl,(logsect)	;get sector that starts current block.
E6A3: 0E02    		ld	c,2		;set 'writing to unused space' flag.
E6A5: 22F0E9  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
E6A8: C5      		push	bc
E6A9: CDDCDF  		call	trksec1		;determine its track and sector numbers.
E6AC: C1      		pop	bc
E6AD: CDC3DF  		call	dowrite		;now write out 128 bytes of zeros.
E6B0: 2AF0E9  		ld	hl,(blknmbr)	;get sector number.
E6B3: 0E00    		ld	c,0		;set normal write flag.
E6B5: 3ACFE9  		ld	a,(blkmask)	;determine if we have written the entire
E6B8: 47      		ld	b,a		;physical block.
E6B9: A5      		and	l
E6BA: B8      		cp	b
E6BB: 23      		inc	hl		;prepare for the next one.
E6BC: C2A5E6  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
E6BF: E1      		pop	hl		;reset next sector number.
E6C0: 22F0E9  		ld	(blknmbr),hl
E6C3: CDE5E1  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
E6C6: CDDCDF  	wtseq9:	call	trksec1		;determine track and sector for this write.
E6C9: C1      		pop	bc		;get write status flag.
E6CA: C5      		push	bc
E6CB: CDC3DF  		call	dowrite		;and write this out.
E6CE: C1      		pop	bc
E6CF: 3AEEE9  		ld	a,(savnrec)	;get number of records in file.
E6D2: 21ECE9  		ld	hl,savnxt	;get last record written.
E6D5: BE      		cp	(hl)
E6D6: DADDE6  		jp	c,wtseq10
E6D9: 77      		ld	(hl),a		;we have to update record count.
E6DA: 34      		inc	(hl)
E6DB: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
E6DD: 00      	wtseq10:nop			;was 'dcr c'
E6DE: 00      		nop			;was 'dcr c'
E6DF: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
E6E2: F5      		push	af
E6E3: CD74E1  		call	gets2		;set 'extent written to' flag.
E6E6: E67F    		and	7fh		;(* clear bit 7 *)
E6E8: 77      		ld	(hl),a
E6E9: F1      		pop	af		;get record count for this extent.
E6EA: FE7F    	wtseq99:cp	127		;is it full?
E6EC: C20BE7  		jp	nz,wtseq12
E6EF: 3AE0E9  		ld	a,(mode)	;yes, are we in sequential mode?
E6F2: FE01    		cp	1
E6F4: C20BE7  		jp	nz,wtseq12
E6F7: CDDDE0  		call	setnrec		;yes, set next record number.
E6FA: CD65E5  		call	getnext		;and get next empty space in directory.
E6FD: 2150DF  		ld	hl,status	;ok?
E700: 7E      		ld	a,(hl)
E701: B7      		or	a
E702: C209E7  		jp	nz,wtseq11
E705: 3D      		dec	a		;yes, set record count to -1.
E706: 32EEE9  		ld	(savnrec),a
E709: 3600    	wtseq11:ld	(hl),0		;clear status.
E70B: C3DDE0  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
E70E: AF      	position: xor	a		;set random i/o flag.
E70F: 32E0E9  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
E712: C5      	positn1:push	bc		;save read/write flag.
E713: 2A4EDF  		ld	hl,(params)	;get address of fcb.
E716: EB      		ex	de,hl
E717: 212100  		ld	hl,33		;now get byte 'r0'.
E71A: 19      		add	hl,de
E71B: 7E      		ld	a,(hl)
E71C: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
E71E: F5      		push	af
E71F: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
E720: 17      		rla	
E721: 23      		inc	hl
E722: 7E      		ld	a,(hl)
E723: 17      		rla	
E724: E61F    		and	1fh		;and save this in bits 0-4 of (c).
E726: 4F      		ld	c,a		;this is the extent byte.
E727: 7E      		ld	a,(hl)		;now get the extra extent byte.
E728: 1F      		rra	
E729: 1F      		rra	
E72A: 1F      		rra	
E72B: 1F      		rra	
E72C: E60F    		and	0fh
E72E: 47      		ld	b,a		;and save it in (b).
E72F: F1      		pop	af		;get record number back to (a).
E730: 23      		inc	hl		;check overflow byte 'r2'.
E731: 6E      		ld	l,(hl)
E732: 2C      		inc	l
E733: 2D      		dec	l
E734: 2E06    		ld	l,6		;prepare for error.
E736: C296E7  		jp	nz,positn5	;out of disk space error.
E739: 212000  		ld	hl,32		;store record number into fcb.
E73C: 19      		add	hl,de
E73D: 77      		ld	(hl),a
E73E: 210C00  		ld	hl,12		;and now check the extent byte.
E741: 19      		add	hl,de
E742: 79      		ld	a,c
E743: 96      		sub	(hl)		;same extent as before?
E744: C252E7  		jp	nz,positn2
E747: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
E74A: 19      		add	hl,de
E74B: 78      		ld	a,b
E74C: 96      		sub	(hl)
E74D: E67F    		and	7fh
E74F: CA8AE7  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
E752: C5      	positn2:push	bc
E753: D5      		push	de
E754: CDADE4  		call	closeit		;close current extent.
E757: D1      		pop	de
E758: C1      		pop	bc
E759: 2E03    		ld	l,3		;prepare for error.
E75B: 3A50DF  		ld	a,(status)
E75E: 3C      		inc	a
E75F: CA8FE7  		jp	z,positn4	;close error.
E762: 210C00  		ld	hl,12		;put desired extent into fcb now.
E765: 19      		add	hl,de
E766: 71      		ld	(hl),c
E767: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
E76A: 19      		add	hl,de
E76B: 70      		ld	(hl),b
E76C: CD5CE4  		call	openit		;try and get this extent.
E76F: 3A50DF  		ld	a,(status)	;was it there?
E772: 3C      		inc	a
E773: C28AE7  		jp	nz,positn3
E776: C1      		pop	bc		;no. can we create a new one (writing?).
E777: C5      		push	bc
E778: 2E04    		ld	l,4		;prepare for error.
E77A: 0C      		inc	c
E77B: CA8FE7  		jp	z,positn4	;nope, reading unwritten space error.
E77E: CD2FE5  		call	getempty	;yes we can, try to find space.
E781: 2E05    		ld	l,5		;prepare for error.
E783: 3A50DF  		ld	a,(status)
E786: 3C      		inc	a
E787: CA8FE7  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
E78A: C1      	positn3:pop	bc		;restore stack.
E78B: AF      		xor	a		;and clear error code byte.
E78C: C30CDF  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
E78F: E5      	positn4:push	hl
E790: CD74E1  		call	gets2
E793: 36C0    		ld	(hl),0c0h
E795: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
E796: C1      	positn5:pop	bc
E797: 7D      		ld	a,l		;get error code.
E798: 3250DF  		ld	(status),a
E79B: C383E1  		jp	sets2b7
              	;
              	;   read a random record.
              	;
E79E: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
E7A0: CD0EE7  		call	position	;position the file to proper record.
E7A3: CCCCE5  		call	z,rdseq1	;and read it as usual (if no errors).
E7A6: C9      		ret	
              	;
              	;   write to a random record.
              	;
E7A7: 0E00    	writeran: ld	c,0		;set 'writing' flag.
E7A9: CD0EE7  		call	position	;position the file to proper record.
E7AC: CC0EE6  		call	z,wtseq1	;and write as usual (if no errors).
E7AF: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
E7B0: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
E7B1: 19      		add	hl,de		;compute relative position of record #.
E7B2: 4E      		ld	c,(hl)		;get record number into (bc).
E7B3: 0600    		ld	b,0
E7B5: 210C00  		ld	hl,12		;now get extent.
E7B8: 19      		add	hl,de
E7B9: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
E7BA: 0F      		rrca			;move lower bit into bit 7.
E7BB: E680    		and	80h		;and ignore all other bits.
E7BD: 81      		add	a,c		;add to our record number.
E7BE: 4F      		ld	c,a
E7BF: 3E00    		ld	a,0		;take care of any carry.
E7C1: 88      		adc	a,b
E7C2: 47      		ld	b,a
E7C3: 7E      		ld	a,(hl)		;now get the upper bits of extent into
E7C4: 0F      		rrca			;bit positions 0-3.
E7C5: E60F    		and	0fh		;and ignore all others.
E7C7: 80      		add	a,b		;add this in to 'r1' byte.
E7C8: 47      		ld	b,a
E7C9: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
E7CC: 19      		add	hl,de
E7CD: 7E      		ld	a,(hl)
E7CE: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
E7CF: 87      		add	a,a
E7D0: 87      		add	a,a
E7D1: 87      		add	a,a
E7D2: F5      		push	af		;save carry flag (bit 0 of flag byte).
E7D3: 80      		add	a,b		;now add extra extent into 'r1'.
E7D4: 47      		ld	b,a
E7D5: F5      		push	af		;and save carry (overflow byte 'r2').
E7D6: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
E7D7: 7D      		ld	a,l
E7D8: E1      		pop	hl		;and same for first carry flag.
E7D9: B5      		or	l		;either one of these set?
E7DA: E601    		and	01h		;only check the carry flags.
E7DC: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
E7DD: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
E7DF: CD23E3  		call	findfst		;this name.
E7E2: 2A4EDF  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
E7E5: 112100  		ld	de,33
E7E8: 19      		add	hl,de
E7E9: E5      		push	hl
E7EA: 72      		ld	(hl),d		;note that (d)=0.
E7EB: 23      		inc	hl
E7EC: 72      		ld	(hl),d
E7ED: 23      		inc	hl
E7EE: 72      		ld	(hl),d
E7EF: CD00E2  	ransiz1:call	ckfilpos	;is there an extent to process?
E7F2: CA17E8  		jp	z,ransiz3	;no, we are done.
E7F5: CD69E1  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
E7F8: 110F00  		ld	de,15		;point to last record in extent.
E7FB: CDB0E7  		call	comprand	;and compute random parameters.
E7FE: E1      		pop	hl
E7FF: E5      		push	hl		;now check these values against those
E800: 5F      		ld	e,a		;already in fcb.
E801: 79      		ld	a,c		;the carry flag will be set if those
E802: 96      		sub	(hl)		;in the fcb represent a larger size than
E803: 23      		inc	hl		;this extent does.
E804: 78      		ld	a,b
E805: 9E      		sbc	a,(hl)
E806: 23      		inc	hl
E807: 7B      		ld	a,e
E808: 9E      		sbc	a,(hl)
E809: DA11E8  		jp	c,ransiz2
E80C: 73      		ld	(hl),e		;we found a larger (in size) extent.
E80D: 2B      		dec	hl		;stuff these values into fcb.
E80E: 70      		ld	(hl),b
E80F: 2B      		dec	hl
E810: 71      		ld	(hl),c
E811: CD38E3  	ransiz2:call	findnxt		;now get the next extent.
E814: C3EFE7  		jp	ransiz1		;continue til all done.
E817: E1      	ransiz3:pop	hl		;we are done, restore the stack and
E818: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
E819: 2A4EDF  	setran:	ld	hl,(params)	;point to fcb.
E81C: 112000  		ld	de,32		;and to last used record.
E81F: CDB0E7  		call	comprand	;compute random position.
E822: 212100  		ld	hl,33		;now stuff these values into fcb.
E825: 19      		add	hl,de
E826: 71      		ld	(hl),c		;move 'r0'.
E827: 23      		inc	hl
E828: 70      		ld	(hl),b		;and 'r1'.
E829: 23      		inc	hl
E82A: 77      		ld	(hl),a		;and lastly 'r2'.
E82B: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
E82C: 2ABAE9  	logindrv: ld	hl,(login)	;get the login vector.
E82F: 3A4DDF  		ld	a,(active)	;get the default drive.
E832: 4F      		ld	c,a
E833: CDF5E0  		call	shiftr		;position active bit for this drive
E836: E5      		push	hl		;into bit 0.
E837: EB      		ex	de,hl
E838: CD64DF  		call	select		;select this drive.
E83B: E1      		pop	hl
E83C: CC52DF  		call	z,slcterr	;valid drive?
E83F: 7D      		ld	a,l		;is this a newly activated drive?
E840: 1F      		rra	
E841: D8      		ret	c
E842: 2ABAE9  		ld	hl,(login)	;yes, update the login vector.
E845: 4D      		ld	c,l
E846: 44      		ld	b,h
E847: CD16E1  		call	setbit
E84A: 22BAE9  		ld	(login),hl	;and save.
E84D: C3AEE2  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
E850: 3AE1E9  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
E853: 214DDF  		ld	hl,active	;represents a change in drives.
E856: BE      		cp	(hl)
E857: C8      		ret	z
E858: 77      		ld	(hl),a		;yes it does, log it in.
E859: C32CE8  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
E85C: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
E85E: 32E9E9  		ld	(auto),a
E861: 2A4EDF  		ld	hl,(params)	;get drive specified.
E864: 7E      		ld	a,(hl)
E865: E61F    		and	1fh		;look at lower 5 bits.
E867: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
E868: 32E1E9  		ld	(eparam),a	;and save for the select routine.
E86B: FE1E    		cp	1eh		;check for 'no change' condition.
E86D: D280E8  		jp	nc,autosl1	;yes, don't change.
E870: 3A4DDF  		ld	a,(active)	;we must change, save currently active
E873: 32EAE9  		ld	(olddrv),a	;drive.
E876: 7E      		ld	a,(hl)		;and save first byte of fcb also.
E877: 32EBE9  		ld	(autoflag),a	;this must be non-zero.
E87A: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
E87C: 77      		ld	(hl),a		;something)?
E87D: CD50E8  		call	setdsk		;select and log in this drive.
E880: 3A4CDF  	autosl1:ld	a,(userno)	;move user number into fcb.
E883: 2A4EDF  		ld	hl,(params)	;(* upper half of first byte *)
E886: B6      		or	(hl)
E887: 77      		ld	(hl),a
E888: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
E889: 3E22    	getver:	ld	a,022h		;version 2.2
E88B: C30CDF  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
E88E: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
E891: 22B8E9  		ld	(wrtprt),hl	;in vector.
E894: 22BAE9  		ld	(login),hl
E897: AF      		xor	a		;select drive 'a'.
E898: 324DDF  		ld	(active),a
E89B: 218000  		ld	hl,tbuff	;setup default dma address.
E89E: 22BCE9  		ld	(userdma),hl
E8A1: CDE5E1  		call	defdma
E8A4: C32CE8  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
E8A7: CD7DE1  	openfil:call	clears2		;clear 's2' byte.
E8AA: CD5CE8  		call	autosel		;select proper disk.
E8AD: C35CE4  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
E8B0: CD5CE8  	closefil: call	autosel		;select proper disk.
E8B3: C3ADE4  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
E8B6: 0E00    	getfst:	ld	c,0		;prepare for special search.
E8B8: EB      		ex	de,hl
E8B9: 7E      		ld	a,(hl)		;is first byte a '?'?
E8BA: FE3F    		cp	'?'
E8BC: CACDE8  		jp	z,getfst1	;yes, just get very first entry (zero length match).
E8BF: CDB1E0  		call	setext		;get the extension byte from fcb.
E8C2: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
E8C3: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
E8C5: C47DE1  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
E8C8: CD5CE8  		call	autosel		;select proper drive.
E8CB: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
E8CD: CD23E3  	getfst1:call	findfst		;find an entry and then move it into
E8D0: C3F4E1  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
E8D3: 2AE4E9  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
E8D6: 224EDF  		ld	(params),hl	;other dbos calls are allowed.
E8D9: CD5CE8  		call	autosel		;no error will be returned, but the
E8DC: CD38E3  		call	findnxt		;results will be wrong.
E8DF: C3F4E1  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
E8E2: CD5CE8  	delfile:call	autosel		;select proper drive.
E8E5: CDA7E3  		call	erafile		;erase the file.
E8E8: C30CE3  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
E8EB: CD5CE8  	readseq:call	autosel		;select proper drive then read.
E8EE: C3C7E5  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
E8F1: CD5CE8  	wrtseq:	call	autosel		;select proper drive then write.
E8F4: C309E6  		jp	wtseq
              	;
              	;   create a file function.
              	;
E8F7: CD7DE1  	fcreate:call	clears2		;clear the 's2' byte on all creates.
E8FA: CD5CE8  		call	autosel		;select proper drive and get the next
E8FD: C32FE5  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
E900: CD5CE8  	renfile:call	autosel		;select proper drive and then switch
E903: CD21E4  		call	chgnames	;file names.
E906: C30CE3  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
E909: 2ABAE9  	getlog:	ld	hl,(login)
E90C: C334E9  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
E90F: 3A4DDF  	getcrnt:ld	a,(active)
E912: C30CDF  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
E915: EB      	putdma:	ex	de,hl
E916: 22BCE9  		ld	(userdma),hl	;save in our space and then get to
E919: C3E5E1  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
E91C: 2ACAE9  	getaloc:ld	hl,(alocvect)
E91F: C334E9  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
E922: 2AB8E9  	getrov:	ld	hl,(wrtprt)
E925: C334E9  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
E928: CD5CE8  	setattr:call	autosel		;select proper drive then save attributes.
E92B: CD46E4  		call	saveattr
E92E: C30CE3  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
E931: 2AC6E9  	getparm:ld	hl,(diskpb)
E934: 2250DF  	getprm1:ld	(status),hl
E937: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
E938: 3AE1E9  	getuser:ld	a,(eparam)	;get parameter.
E93B: FEFF    		cp	0ffh		;get user number?
E93D: C246E9  		jp	nz,setuser
E940: 3A4CDF  		ld	a,(userno)	;yes, just do it.
E943: C30CDF  		jp	setstat
E946: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
E948: 324CDF  		ld	(userno),a	;bits (0-4) only.
E94B: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
E94C: CD5CE8  	rdrandom: call	autosel		;select proper drive and read.
E94F: C39EE7  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
E952: CD5CE8  	wtrandom: call	autosel		;select proper drive and write.
E955: C3A7E7  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
E958: CD5CE8  	filesize: call	autosel		;select proper drive and check file length
E95B: C3DDE7  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
E95E: 2A4EDF  	logoff:	ld	hl,(params)	;get drives to log off.
E961: 7D      		ld	a,l		;for each bit that is set, we want
E962: 2F      		cpl			;to clear that bit in (login)
E963: 5F      		ld	e,a		;and (wrtprt).
E964: 7C      		ld	a,h
E965: 2F      		cpl	
E966: 2ABAE9  		ld	hl,(login)	;reset the login vector.
E969: A4      		and	h
E96A: 57      		ld	d,a
E96B: 7D      		ld	a,l
E96C: A3      		and	e
E96D: 5F      		ld	e,a
E96E: 2AB8E9  		ld	hl,(wrtprt)
E971: EB      		ex	de,hl
E972: 22BAE9  		ld	(login),hl	;and save.
E975: 7D      		ld	a,l		;now do the write protect vector.
E976: A3      		and	e
E977: 6F      		ld	l,a
E978: 7C      		ld	a,h
E979: A2      		and	d
E97A: 67      		ld	h,a
E97B: 22B8E9  		ld	(wrtprt),hl	;and save. all done.
E97E: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
E97F: 3AE9E9  	goback:	ld	a,(auto)	;was auto select activated?
E982: B7      		or	a
E983: CA9CE9  		jp	z,goback1
E986: 2A4EDF  		ld	hl,(params)	;yes, but was a change made?
E989: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
E98B: 3AEBE9  		ld	a,(autoflag)
E98E: B7      		or	a
E98F: CA9CE9  		jp	z,goback1
E992: 77      		ld	(hl),a		;yes, reset first byte properly.
E993: 3AEAE9  		ld	a,(olddrv)	;and get the old drive and select it.
E996: 32E1E9  		ld	(eparam),a
E999: CD50E8  		call	setdsk
E99C: 2A1ADF  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
E99F: F9      		ld	sp,hl
E9A0: 2A50DF  		ld	hl,(status)	;get return status.
E9A3: 7D      		ld	a,l		;force version 1.4 compatability.
E9A4: 44      		ld	b,h
E9A5: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
E9A6: CD5CE8  	wtspecl:call	autosel		;select proper drive.
E9A9: 3E02    		ld	a,2		;use special write mode.
E9AB: 32E0E9  		ld	(mode),a
E9AE: 0E00    		ld	c,0		;set write indicator.
E9B0: CD12E7  		call	positn1		;position the file.
E9B3: CC0EE6  		call	z,wtseq1	;and write (if no errors).
E9B6: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
E9B7: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
E9B8: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
E9BA: 0000    	login:	defw	0		;drive active word (1 bit per drive).
E9BC: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
E9BE: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
E9C0: 0000    	scratch2: defw	0		;last selected track number.
E9C2: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
E9C4: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
E9C6: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
E9C8: 0000    	chkvect:defw	0		;address of check vector.
E9CA: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
E9CC: 0000    	sectors:defw	0		;sectors per track from bios.
E9CE: 00      	blkshft:defb	0		;block shift.
E9CF: 00      	blkmask:defb	0		;block mask.
E9D0: 00      	extmask:defb	0		;extent mask.
E9D1: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
E9D3: 0000    	dirsize:defw	0		;directory size.
E9D5: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
E9D7: 0000    	alloc1:	defw	0
E9D9: 0000    	offset:	defw	0		;first usable track number.
E9DB: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
E9DD: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
E9DE: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
E9DF: 00      	fndstat:defb	0		;filename found status (0=found first entry).
E9E0: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
E9E1: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
E9E2: 00      	relblock: defb	0		;relative position within fcb of block number written.
E9E3: 00      	counter:defb	0		;byte counter for directory name searches.
E9E4: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
E9E8: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
E9E9: 00      	auto:	defb	0		;if non-zero, then auto select activated.
E9EA: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
E9EB: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
E9EC: 00      	savnxt:	defb	0		;storage for next record number to access.
E9ED: 00      	savext:	defb	0		;storage for extent number of file.
E9EE: 0000    	savnrec:defw	0		;storage for number of records in file.
E9F0: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
E9F2: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
E9F4: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
E9F5: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
E9F7: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E9FB: 00...   	
              	
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "../bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS.
              	;*
              	;**************************************************************
              	;
EA07: C33AEA  		jp	boot
EA0A: C348EA  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
EA0D: C3A2EA  		jp	const
EA10: C3ADEA  		jp	conin
EA13: C3B9EA  		jp	conout
EA16: C3C5EA  		jp	list
EA19: C3C9EA  		jp	punch
EA1C: C3CDEA  		jp	reader
EA1F: C3DBEA  		jp	home
EA22: C3E0EA  		jp	seldsk
EA25: C3FEEA  		jp	settrk
EA28: C302EB  		jp	setsec
EA2B: C306EB  		jp	setdma
EA2E: C30CEB  		jp	read
EA31: C310EB  		jp	write
EA34: C314EB  		jp	prstat
EA37: C317EB  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
EA3A: 3100D4  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
EA3D: CD5FEA  		call	wbootr
              		
              		; Special conditions for a cold boot
EA40: CD5AEB  		call	cbinit
              	
              		; Jump to CP/M
EA43: 0E00    		ld	c,default
EA45: C300D4  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
EA48: 3100D4  	wboot:	ld	sp,cbase
              	
              		; Save current drive + user
EA4B: 3A0400  		ld	a,(tdrive)
EA4E: F5      		push	af
              	
              		; Save IOBYTE
EA4F: 3A0300  		ld	a,(iobyte)
EA52: F5      		push	af
              	
              		; Warm boot
EA53: CD5FEA  		call	wbootr
              		
              		; Restore IOBYTE
EA56: F1      		pop	af
EA57: 320300  		ld	(iobyte),a
              		
              		; Restore tdrive and warm boot
EA5A: F1      		pop	af
EA5B: 4F      		ld	c,a
EA5C: C300D4  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
EA5F: F3      	wbootr:	di
              		
              		; Zero out BSS
EA60: AF      		xor	a
EA61: 2130F9  		ld	hl,_TEXT_end
EA64: 77      		ld	(hl),a
EA65: 1131F9  		ld	de,_TEXT_end+1
EA68: 01D204  		ld	bc,_BSS_size
EA6B: EDB0    		ldir
              	
              		; Send init signals to all devices
EA6D: 0600    		ld	b,0
EA6F: C5      	wboot0:	push	bc
EA70: 216CEB  		ld	hl,bdevsw
EA73: 78      		ld	a,b
EA74: CD29EB  		call	swindir
EA77: AF      		xor	a
EA78: 14      		inc	d
EA79: CC46EB  		call	z,callmj
EA7C: C1      		pop	bc
EA7D: 04      		inc	b
EA7E: 3E14    		ld	a,20
EA80: B8      		cp	b
EA81: 20EC    		jr	nz,wboot0
              	
              		; Turn off batch mode
EA83: 3E00    		ld	a,0
EA85: 32B8DB  		ld	(batch),a
              	
              		; Load the CCP
EA88: CD66EB  		call	resccp
              	
              		; Call config init
EA8B: CD4BEB  		call	wbinit
              		
              		; Set up lower memory
EA8E: 219AEA  		ld	hl,cpmlow
EA91: 110000  		ld	de,0
EA94: 010800  		ld	bc,8
EA97: EDB0    		ldir
              	
              	
              		; Return
EA99: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
EA9A: C30AEA  	cpmlow:	jp	wbootin	; Call jump table version instead
EA9D: 81      		defb	0x81	; Default IOBYTE
EA9E: 00      		defb	0	; Default drive
EA9F: C302DC  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
EAA2: 0600    	const:	ld	b,0
EAA4: CD1AEB  		call	cdindir
EAA7: 14      		inc	d
EAA8: C0      		ret	nz
EAA9: 3C      		inc	a
EAAA: C346EB  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
EAAD: 0600    	conin:	ld	b,0
EAAF: CD1AEB  		call	cdindir
EAB2: 14      		inc	d
EAB3: C0      		ret	nz
EAB4: 3E02    		ld	a,2
EAB6: C346EB  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
EAB9: 0600    	conout:	ld	b,0
EABB: CD1AEB  	chrout:	call	cdindir
EABE: 14      		inc	d
EABF: C0      		ret	nz
EAC0: 3E03    		ld	a,3
EAC2: C346EB  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
EAC5: 0606    	list:	ld	b,6
EAC7: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
EAC9: 0604    	punch:	ld	b,4
EACB: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
EACD: 0602    	reader:	ld	b,2
EACF: CD1AEB  		call	cdindir
EAD2: 14      		inc	d
EAD3: 3E1A    		ld	a,0x1A
EAD5: C0      		ret	nz
EAD6: 3E02    		ld	a,2
EAD8: C346EB  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
EADB: 3E01    	home:	ld	a,1
EADD: C3F8EA  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
EAE0: 79      	seldsk:	ld	a,c
EAE1: 43      		ld	b,e
EAE2: 216CEB  		ld	hl,bdevsw
EAE5: CD29EB  		call	swindir
EAE8: 22F9EA  		ld	(callbd+1),hl
EAEB: 210000  		ld	hl,0
EAEE: 14      		inc	d
EAEF: C0      		ret	nz
EAF0: 2A47EB  		ld	hl,(callmj+1)
EAF3: 22FCEA  		ld	(callbd+4),hl
EAF6: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
EAF8: 21      	callbd:	defb	0x21
EAF9: 0000    		defw	0
EAFB: C3      		defb	0xC3
EAFC: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
EAFE: 3E03    	settrk:	ld	a,3
EB00: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
EB02: 3E04    	setsec:	ld	a,4
EB04: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
EB06: 60      	setdma:	ld	h,b
EB07: 69      		ld	l,c
EB08: 2249EB  		ld	(biodma),hl
EB0B: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
EB0C: 3E05    	read:	ld	a,5
EB0E: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
EB10: 3E06    	write:	ld	a,6
EB12: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
EB14: 3EFF    	prstat:	ld	a,0xFF
EB16: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
EB17: 60      	sectrn:	ld	h,b
EB18: 69      		ld	l,c
EB19: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
EB1A: 04      	cdindir:inc	b
EB1B: 3A0300  		ld	a,(iobyte)
EB1E: 05      	cdindi0:dec	b
EB1F: 2803    		jr	z,cdindi1
EB21: 1F      		rra
EB22: 18FA    		jr	cdindi0
EB24: E603    	cdindi1:and	0x03
EB26: 21ACEB  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
EB29: 110400  	swindir:ld	de,4
EB2C: B7      		or	a
EB2D: 2804    	swindi0:jr	z,swindi1
EB2F: 19      		add	hl,de
EB30: 3D      		dec	a
EB31: 18FA    		jr	swindi0
EB33: 7E      	swindi1:ld	a,(hl)
EB34: 3247EB  		ld	(callmj+1),a
EB37: 23      		inc	hl
EB38: B6      		or	(hl)
EB39: C8      		ret	z
EB3A: 7E      		ld	a,(hl)
EB3B: 3248EB  		ld	(callmj+2),a
EB3E: 23      		inc	hl
EB3F: 7E      		ld	a,(hl)
EB40: 23      		inc	hl
EB41: 66      		ld	h,(hl)
EB42: 6F      		ld	l,a
EB43: 16FF    		ld	d,255
EB45: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
EB46: C3      	callmj: defb	0xC3
EB47: 0000    		defw	0
              	
              	
              	
              	; Variables
EB49: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
EB4B: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
EB4D: D300    		out	(0x00),a
              		
              		; Turn on batch mode
EB4F: 3EFF    		ld	a,0xFF
EB51: 32B8DB  		ld	(batch),a
              		
              		; Also set interrupt mode 2 stuff
EB54: ED47    		ld	i,a
EB56: ED5E    		im	2		; Start interrupts
EB58: FB      		ei
              		
EB59: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
EB5A: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
EB5C: 3207D4  		ld	(inbuff+1),a
EB5F: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
EB60: FB      	cfirq:	ei
EB61: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
EB63: C3F5EF  	syshook:jp	ns_sysh
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
EB66: C3CCEF  	resccp:	jp	ns_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
EB69: C3D1EF  	resgrb:	jp	ns_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EB6C: 6CEF0000	bdevsw:	defw	nfsdev,	0	; 'A'
EB70: 6CEF0100		defw	nfsdev,	1	; 'B'
EB74: F3F60000		defw	nfddev,	0	; 'C'
EB78: F3F60100		defw	nfddev,	1	; 'D'
EB7C: 6CEF0400		defw	nfsdev,	4	; 'E'
EB80: 6CEF0500		defw	nfsdev,	5	; 'F'
EB84: 6CEF0600		defw	nfsdev,	6	; 'G'
EB88: 6CEF0700		defw	nfsdev,	7	; 'H'
EB8C: 6CEF0800		defw	nfsdev,	8	; 'I'
EB90: 6CEF0900		defw	nfsdev,	9	; 'J'
EB94: 6CEF0A00		defw	nfsdev,	10	; 'K'
EB98: 6CEF0B00		defw	nfsdev,	11	; 'L'
EB9C: 6CEF0C00		defw	nfsdev,	12	; 'M'
EBA0: 6CEF0D00		defw	nfsdev,	13	; 'N'
EBA4: 6CEF0E00		defw	nfsdev,	14	; 'O'
EBA8: 6CEF0F00		defw	nfsdev,	15	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EBAC: 36F60000	cdevsw:	defw	siodev,	0	; TTY device
EBB0: BCEB0000		defw	vdpdev,	0	; Console device
EBB4: 0CF60000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
EBB8: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "../dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F930: 00      	tm_outc:defs	1	; Output character
F931: 00      	tm_scro:defs	1	; Scroll width
F932: 00      	tm_escs:defs	1	; Escape state
F933: 00      	tm_last:defs	1	; Last character read
F934: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
F938: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
0040:         	tm_ayda	equ	0x40	; AY-3-8910 data port
0041:         	tm_atla	equ	0x41	; AY-3-8910 latch port
              	
              	; --- VRAM MAP ---
              	; 0x0000 - 0x07FF: Font
              	; 0x0800 - 0x0BFF: 40 column screen buffer
              	; 0x0C00 - 0x0FFF: Unused
              	; 0x1000 - 0x17FF: 80 column screen buffer
              	;
              	; Serial #
              	; 0x17FE: 0xE5
              	; 0x17FF: 0x81
              	
              	
              	; Driver jump table
EBBC: B7      	vdpdev:	or	a
EBBD: 2845    		jr	z,tm_init
EBBF: 3D      		dec	a
EBC0: 2819    		jr	z,tm_stat
EBC2: 3D      		dec	a
EBC3: CAA6EC  		jp	z,tm_read
EBC6: C304ED  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBC9: F5      	tm_otir:push	af
EBCA: 7E      	tm_oti0:ld	a,(hl)
EBCB: ED79    		out	(c),a
EBCD: 23      		inc	hl
EBCE: 10FA    		djnz	tm_oti0
EBD0: F1      		pop	af
EBD1: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBD2: F5      	tm_inir:push	af
EBD3: ED78    	tm_inr0:in	a,(c)
EBD5: 77      		ld	(hl),a
EBD6: 23      		inc	hl
EBD7: 10FA    		djnz	tm_inr0
EBD9: F1      		pop	af
EBDA: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
EBDB: CD29EF  	tm_stat:call	tm_dint
EBDE: CDE7EB  		call	tm_sta0
EBE1: F5      		push	af
EBE2: CD39EF  		call	tm_eint
EBE5: F1      		pop	af
EBE6: C9      		ret 
EBE7: 3A33F9  	tm_sta0:ld	a,(tm_last)
EBEA: FEE4    		cp	0xE4
EBEC: 2871    		jr	z,tm_scri
EBEE: FEE5    		cp	0xE5
EBF0: 287F    		jr	z,tm_sclf
EBF2: 3A30F9  	tm_sta1:ld	a,(tm_outc)
EBF5: 3C      		inc	a
EBF6: 3EFF    		ld	a,0xFF
EBF8: C0      		ret	nz
EBF9: CD38EE  		call	tm_getc
EBFC: 3230F9  		ld	(tm_outc),a
EBFF: 3C      		inc	a
EC00: C8      		ret	z
EC01: 3EFF    		ld	a,0xFF
EC03: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
EC04: CD69EB  	tm_init:call	resgrb
              	
              		; Set up registers
EC07: CD7BEC  		call	tm_setp
              		
              		; Set up interrupt vectors (if needed)
EC0A: 2123EF  		ld	hl,tm_virq
EC0D: 2206FF  		ld	(intvec+6),hl
EC10: 2156EE  		ld	hl,tm_kirq
EC13: 2204FF  		ld	(intvec+4),hl
              		
              		; Set TMS pattern generator block to 0
EC16: DBA1    		in	a,(tm_latc)
EC18: AF      		xor	a
EC19: D3A1    		out	(tm_latc),a
EC1B: 3E84    		ld	a,0x84
EC1D: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
EC1F: 010040  		ld	bc,0x4000
EC22: CD18EF  		call	tm_addr
EC25: 2100D4  		ld	hl,cbase
EC28: 0EA0    		ld	c,tm_data
EC2A: 3E08    		ld	a,8	; Transfer 8*256 = 2048
EC2C: 0600    	tm_ini0:ld	b,0
EC2E: CDC9EB  		call	tm_otir
EC31: 3D      		dec	a
EC32: 20F8    		jr	nz,tm_ini0
              		
              		; Cold boot?
EC34: 3A4BEF  		ld	a,(tm_cold)
EC37: B7      		or	a
EC38: 2012    		jr	nz,tm_ini1
              		
              		; Check serial #
EC3A: 01FE17  		ld	bc,0x17FE
EC3D: CD18EF  		call	tm_addr
EC40: ED78    		in	a,(c)
EC42: FEE5    		cp	0xE5
EC44: 2006    		jr	nz,tm_ini1
EC46: ED78    		in	a,(c)
EC48: FE81    		cp	0x81
EC4A: 280D    		jr	z,tm_cloc
              		
              		; Reset the terminal
EC4C: CDFBEE  	tm_ini1:call	tm_cls
EC4F: AF      		xor	a
EC50: 3249EF  		ld	(tm_curx),a
EC53: 324AEF  		ld	(tm_cury),a
EC56: 324BEF  		ld	(tm_cold),a
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
EC59: 3EFF    	tm_cloc:ld	a,0xFF
EC5B: 3230F9  		ld	(tm_outc),a
              	
EC5E: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
EC5F: 3A31F9  	tm_scri:ld	a,(tm_scro)
EC62: B7      		or	a
EC63: FE28    		cp	40
EC65: 2808    		jr	z,tm_scr1
EC67: C604    		add	a,4
EC69: 3231F9  	tm_scr0:ld	(tm_scro),a
EC6C: CDD8EE  		call	tm_usco
EC6F: 1881    	tm_scr1:jr	tm_sta1
EC71: 3A31F9  	tm_sclf:ld	a,(tm_scro)
EC74: B7      		or	a
EC75: 28F8    		jr	z,tm_scr1
EC77: D604    		sub	4
EC79: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
EC7B: 2A44EF  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
EC7E: DBA1    		in	a,(tm_latc)
EC80: 7C      		ld	a,h
EC81: D3A1    		out	(tm_latc),a
EC83: 3E80    		ld	a,0x80
EC85: D3A1    		out	(tm_latc),a
EC87: DBA1    		in	a,(tm_latc)
EC89: 3EF0    		ld	a,0xF0
EC8B: D3A1    		out	(tm_latc),a
EC8D: 3E81    		ld	a,0x81
EC8F: D3A1    		out	(tm_latc),a
              		
              		; Set TMS color
EC91: DBA1    		in	a,(tm_latc)
EC93: 3A46EF  		ld	a,(tm_colr)
EC96: D3A1    		out	(tm_latc),a
EC98: 3E87    		ld	a,0x87
EC9A: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
EC9C: DBA1    		in	a,(tm_latc)
EC9E: 7D      		ld	a,l
EC9F: D3A1    		out	(tm_latc),a
ECA1: 3E82    		ld	a,0x82
ECA3: D3A1    		out	(tm_latc),a
ECA5: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
ECA6: CD29EF  	tm_read:call	tm_dint
ECA9: CDB2EC  		call	tm_rea0
ECAC: F5      		push	af
ECAD: CD39EF  		call	tm_eint
ECB0: F1      		pop	af
ECB1: C9      		ret 
ECB2: 3A49EF  	tm_rea0:ld	a,(tm_curx)
ECB5: 4F      		ld	c,a
ECB6: 3A4AEF  		ld	a,(tm_cury)
ECB9: 57      		ld	d,a
ECBA: 210010  		ld	hl,0x1000
ECBD: 3E50    		ld	a,80
ECBF: CDB4EE  		call	tm_chat
ECC2: DBA0    		in	a,(tm_data)	; char is in A
ECC4: 57      		ld	d,a		; char key
ECC5: 5F      		ld	e,a		; blinking char
ECC6: 0601    		ld	b,1
              		
ECC8: D5      	tm_rea1:push	de
ECC9: CDE7EB  		call	tm_sta0		; No interrupts!
ECCC: D1      		pop	de
ECCD: 3C      		inc	a
ECCE: 200D    		jr	nz,tm_rea2
ECD0: 5A      		ld	e,d
ECD1: CDEDEC  		call	tm_rea3
ECD4: 3A30F9  		ld	a,(tm_outc)
ECD7: 47      		ld	b,a
ECD8: CD59EC  		call	tm_cloc
ECDB: 78      		ld	a,b
ECDC: C9      		ret
              		
ECDD: CDFBEC  	tm_rea2:call	tm_stal
ECE0: 10E6    		djnz	tm_rea1
ECE2: 3E80    		ld	a,0x80
ECE4: AB      		xor	e
ECE5: 5F      		ld	e,a
ECE6: CDEDEC  		call	tm_rea3
ECE9: 06BE    		ld	b,190
ECEB: 18DB    		jr	tm_rea1
              	
              	
ECED: D5      	tm_rea3:push	de
ECEE: 3A49EF  		ld	a,(tm_curx)
ECF1: 4F      		ld	c,a
ECF2: 3A4AEF  		ld	a,(tm_cury)
ECF5: 57      		ld	d,a
ECF6: CD90EE  		call	tm_putc
ECF9: D1      		pop	de
ECFA: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
ECFB: C5      	tm_stal:push	bc
ECFC: 06FF    		ld	b,255
ECFE: C5      	tm_sta2:push	bc
ECFF: C1      		pop	bc
ED00: 10FC    		djnz	tm_sta2
ED02: C1      		pop	bc
ED03: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
ED04: CD29EF  	tm_writ:call	tm_dint
ED07: 59      		ld	e,c
ED08: 3A49EF  		ld	a,(tm_curx)
ED0B: 4F      		ld	c,a
ED0C: 3A4AEF  		ld	a,(tm_cury)
ED0F: 57      		ld	d,a
ED10: CD1FED  		call	tm_wri0
ED13: 78      		ld	a,b
ED14: 324AEF  		ld	(tm_cury),a
ED17: 79      		ld	a,c
ED18: 3249EF  		ld	(tm_curx),a
ED1B: CD39EF  		call	tm_eint
ED1E: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
ED1F: 42      	tm_wri0:ld	b,d		; c = X, b = Y
ED20: 3A32F9  		ld	a,(tm_escs)
ED23: B7      		or	a		; Process escape code
ED24: C28CED  		jp	nz,tm_esc
ED27: 3E1F    		ld	a,0x1F
ED29: BB      		cp	e
ED2A: D25EED  		jp	nc,tm_wri1	; Process control code
ED2D: C5      		push	bc
ED2E: CD90EE  		call	tm_putc		; Write character
ED31: C1      		pop	bc
              		
              		; Increment character
ED32: 0C      	tm_ri	inc	c
ED33: 3E50    		ld	a,80
ED35: B9      		cp	c
ED36: C0      		ret	nz
ED37: AF      		xor	a
ED38: 4F      		ld	c,a
ED39: 04      	tm_lf:  inc	b	; Line feed
ED3A: 3E18    		ld	a,24
ED3C: B8      		cp	b
ED3D: C0      		ret	nz
ED3E: C5      		push	bc
ED3F: CD12EE  		call	tm_dsco
ED42: C1      		pop	bc
ED43: 05      		dec	b
ED44: C9      		ret
ED45: AF      	tm_cr:	xor	a	; Carriage return
ED46: 4F      		ld	c,a
ED47: C9      		ret
ED48: 0D      	tm_bs:	dec	c	; Backspace 
ED49: F0      		ret	p
ED4A: 0E4F    		ld	c,79
ED4C: 05      		dec	b
ED4D: F0      		ret	p
ED4E: AF      		xor	a
ED4F: 47      		ld	b,a
ED50: 4F      		ld	c,a
ED51: C9      		ret
ED52: AF      	tm_up:	xor	a	; Move up
ED53: B8      		cp	b
ED54: C8      		ret	z
ED55: 05      		dec	b
ED56: C9      		ret
ED57: CDFBEE  	tm_cshm:call	tm_cls
ED5A: AF      	tm_home:xor	a
ED5B: 47      		ld	b,a
ED5C: 4F      		ld	c,a
ED5D: C9      		ret
              	
ED5E: 7B      	tm_wri1:ld	a,e
ED5F: FE08    		cp	0x08	; '\b' (Cursor left)
ED61: 28E5    		jr	z,tm_bs
ED63: FE12    		cp	0x12	; Cursor right
ED65: 28CB    		jr	z,tm_ri
ED67: FE0A    		cp	0x0A	; '\n' (Cursor down)
ED69: 28CE    		jr	z,tm_lf
ED6B: FE0B    		cp	0x0B	; Cursor up
ED6D: 28E3    		jr	z,tm_up
ED6F: FE0D    		cp	0x0D	; '\r' 
ED71: 28D2    		jr	z,tm_cr
ED73: FE17    		cp	0x17	; Clear end of screen
ED75: 2856    		jr	z,tm_cles
ED77: FE18    		cp	0x18	; Clear end of line
ED79: 2854    		jr	z,tm_clea
ED7B: FE1A    		cp	0x1A	; Clear screen, home cursor
ED7D: 28D8    		jr	z,tm_cshm
ED7F: FE1E    		cp	0x1E	; Home cursor
ED81: 28D7    		jr	z,tm_home
ED83: FE1B    		cp	0x1B	; Escape
ED85: C0      		ret	nz
ED86: 3E01    		ld	a,1
ED88: 3232F9  		ld	(tm_escs),a
ED8B: C9      		ret
              		
              		; Handle escape sequence
ED8C: 3D      	tm_esc:	dec	a
ED8D: 280E    		jr	z,tm_esc0
ED8F: 3D      		dec	a
ED90: 2825    		jr	z,tm_esc1
ED92: 3D      		dec	a
ED93: 282D    		jr	z,tm_esc2
ED95: 3D      		dec	a
ED96: 2871    		jr	z,tm_updc
ED98: AF      	tm_escd:xor	a	; Escape done
ED99: 3232F9  	tm_escr:ld	(tm_escs),a
ED9C: C9      		ret
ED9D: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
ED9F: BB      		cp	e
EDA0: 2850    		jr	z,tm_40c
EDA2: 3EFE    		ld	a,0xFE	; Do 80-col
EDA4: BB      		cp	e
EDA5: 2858    		jr	z,tm_80c
EDA7: 3EFD    		ld	a,0xFD	; Set color
EDA9: BB      		cp	e
EDAA: 2859    		jr	z,tm_scol
EDAC: 3E3D    		ld	a,0x3D	; '='
EDAE: BB      		cp	e
EDAF: 20E7    		jr	nz,tm_escd
EDB1: 3A32F9  	tm_esci:ld	a,(tm_escs)
EDB4: 3C      		inc	a
EDB5: 18E2    		jr	tm_escr
EDB7: 7B      	tm_esc1:ld	a,e
EDB8: 1E20    		ld	e,0x20
EDBA: 93      		sub	e
EDBB: FE18    		cp	24
EDBD: 30D9    		jr	nc,tm_escd
EDBF: 47      		ld	b,a
EDC0: 18EF    		jr	tm_esci
EDC2: 7B      	tm_esc2:ld	a,e
EDC3: 1E20    		ld	e,0x20
EDC5: 93      		sub	e
EDC6: FE50    		cp	80
EDC8: 30CE    		jr	nc,tm_escd
EDCA: 4F      		ld	c,a
EDCB: 18CB    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
EDCD: 0617    	tm_cles:ld	b,23
EDCF: 04      	tm_clea:inc	b
EDD0: 1E00    		ld	e,0
EDD2: C5      		push	bc
EDD3: D5      		push	de
EDD4: 3E50    		ld	a,80
EDD6: 210050  		ld	hl,0x5000
EDD9: CDB4EE  		call	tm_chat
EDDC: D1      		pop	de
EDDD: C1      		pop	bc
EDDE: AF      	tm_cle0:xor	a
EDDF: D3A0    		out	(tm_data),a
EDE1: 0C      		inc	c
EDE2: 3E50    		ld	a,80
EDE4: B9      		cp	c
EDE5: 20F7    		jr	nz,tm_cle0
EDE7: 14      		inc	d
EDE8: AF      		xor	a
EDE9: 4F      		ld	c,a
EDEA: 7A      		ld	a,d
EDEB: B8      		cp	b
EDEC: 20F0    		jr	nz,tm_cle0
EDEE: D1      		pop	de	; Do not update character
EDEF: C3D8EE  		jp	tm_usco
              		
EDF2: E5      	tm_40c:	push	hl
EDF3: 210200  		ld	hl,0x0002
EDF6: 2244EF  	tm_cupd:ld	(tm_mode),hl
EDF9: CD7BEC  		call	tm_setp
EDFC: E1      		pop	hl
EDFD: 1899    		jr	tm_escd
              		
EDFF: E5      	tm_80c:	push	hl
EE00: 210704  		ld	hl,0x0407
EE03: 18F1    		jr	tm_cupd
              		
              		; Set color command
EE05: 3E04    	tm_scol:ld	a,4
EE07: 1890    		jr	tm_escr
              		
              		; Update color here
EE09: 7B      	tm_updc:ld	a,e
EE0A: 3246EF  		ld	(tm_colr),a
EE0D: CD7BEC  		call	tm_setp
EE10: 1886    		jr	tm_escd
              		
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
EE12: 212808  	tm_dsco:ld	hl,0x0800+40
EE15: 110048  		ld	de,0x4800
EE18: 0618    		ld	b,24
EE1A: CD25EE  		call	tm_dsc0
EE1D: 215010  		ld	hl,0x1000+80
EE20: 110050  		ld	de,0x5000
EE23: 0630    		ld	b,48
EE25: C5      	tm_dsc0:push	bc
EE26: D5      		push	de
EE27: E5      		push	hl
EE28: CDC0EE  		call	tm_vcpy
EE2B: E1      		pop	hl
EE2C: D1      		pop	de
EE2D: 012800  		ld	bc,40
EE30: 09      		add	hl,bc
EE31: EB      		ex	de,hl
EE32: 09      		add	hl,bc
EE33: EB      		ex	de,hl
EE34: C1      		pop	bc
EE35: 10EE    		djnz	tm_dsc0
EE37: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
EE38: 3A48EF  	tm_getc:ld	a,(tm_inf)
EE3B: B7      		or	a
EE3C: 3E00    		ld	a,0
EE3E: 3248EF  		ld	(tm_inf),a
EE41: 3A47EF  		ld	a,(tm_inb)
EE44: 2008    		jr	nz,tm_get0
              	
EE46: DB91    		in	a,(tm_keys)
EE48: E602    		and	2
EE4A: 3D      		dec	a
EE4B: F8      		ret	m
              		
              		; Grab the key
EE4C: DB90    		in	a,(tm_keyd)
EE4E: 3233F9  	tm_get0:ld	(tm_last),a
EE51: CD64EE  		call	tm_map
EE54: 79      		ld	a,c
EE55: C9      		ret
              		
              	; Handles a keyboard interrupt for the VDP terminal driver
              	; Keypress stored in tm_inb and tm_inf flag is set
              	; 
              	; uses: none
EE56: F5      	tm_kirq:push	af
EE57: DB90    		in	a,(tm_keyd)
EE59: 3247EF  		ld	(tm_inb),a
EE5C: 3E01    		ld	a,1
EE5E: 3248EF  		ld	(tm_inf),a
EE61: F1      		pop	af
EE62: FB      		ei
EE63: C9      		ret
              		
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
EE64: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
EE65: 217BEE  		ld	hl,tm_mapt
EE68: 7E      	tm_map0:ld	a,(hl)
EE69: B7      		or	a
EE6A: 2808    		jr	z,tm_map2
EE6C: B9      		cp	c
EE6D: 23      		inc	hl
EE6E: 7E      		ld	a,(hl)
EE6F: 23      		inc	hl
EE70: 20F6    		jr	nz,tm_map0
EE72: 4F      		ld	c,a
EE73: C9      		ret
              		
              		
              		; Filter non-ASCII
EE74: 79      	tm_map2:ld	a,c
EE75: E680    		and	0x80	
EE77: C8      		ret	z
EE78: 0EFF    		ld	c,0xFF
EE7A: C9      		ret
              		
              	; Map table
EE7B: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
EE7D: E108    		defb	0xE1,0x08	; '<-' -> BS
EE7F: EA7F    		defb	0xEA,0x7F	; TV -> DEL
EE81: E00C    		defb	0xE0,0x0C	; '->' -> Right
EE83: E20B    		defb	0xE2,0x0B	; '/\' -> Up
EE85: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
EE87: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
EE89: E860    		defb	0xE8,0x60	; SYM -> '@'
EE8B: E67C    		defb	0xE6,0x7C	; NO -> '|'
EE8D: E77E    		defb	0xE7,0x7E	; YES -> '~'
EE8F: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
EE90: 210050  	tm_putc:ld	hl,0x5000
EE93: 3E50    		ld	a,80
EE95: C5      		push	bc
EE96: D5      		push	de
EE97: CDB4EE  		call	tm_chat	; Place it in the 80 col buffer
EE9A: ED59    		out	(c),e
EE9C: D1      		pop	de
EE9D: C1      		pop	bc
EE9E: 3A31F9  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
EEA1: 47      		ld	b,a
EEA2: 79      		ld	a,c
EEA3: 90      		sub	b	; If character is less than scroll...
EEA4: 4F      		ld	c,a
EEA5: F8      		ret	m
EEA6: FE28    		cp	40	; If desired position is 40 or more
EEA8: D0      		ret	nc
EEA9: 210048  		ld	hl,0x4800
EEAC: 3E28    		ld	a,40
EEAE: CDB4EE  		call	tm_chat	; Place it in the 40 col screen buffer
EEB1: ED59    		out	(c),e
EEB3: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
EEB4: 0600    	tm_chat:ld	b,0
EEB6: 09      		add	hl,bc
EEB7: 4F      		ld	c,a
EEB8: AF      		xor	a
EEB9: BA      		cp	d
EEBA: 285A    	tm_cha0:jr	z,tm_addh
EEBC: 09      		add	hl,bc
EEBD: 15      		dec	d
EEBE: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
EEC0: CD16EF  	tm_vcpy:call	tm_addh
EEC3: 0628    		ld	b,40
EEC5: 2134F9  		ld	hl,tm_cbuf
EEC8: CDD2EB  		call	tm_inir
EECB: EB      		ex	de,hl
EECC: CD16EF  		call	tm_addh
EECF: 0628    		ld	b,40
EED1: 2134F9  		ld	hl,tm_cbuf
EED4: CDC9EB  		call	tm_otir
EED7: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
EED8: 210010  	tm_usco:ld	hl,0x1000
EEDB: 110048  		ld	de,0x4800
EEDE: 3A31F9  		ld	a,(tm_scro)
EEE1: 0600    		ld	b,0
EEE3: 4F      		ld	c,a
EEE4: 09      		add	hl,bc
EEE5: 0618    		ld	b,24
EEE7: C5      	tm_usc0:push	bc
EEE8: D5      		push	de
EEE9: E5      		push	hl
EEEA: CDC0EE  		call	tm_vcpy
EEED: E1      		pop	hl
EEEE: D1      		pop	de
EEEF: 0E50    		ld	c,80
EEF1: 09      		add	hl,bc
EEF2: EB      		ex	de,hl
EEF3: 0E28    		ld	c,40
EEF5: 09      		add	hl,bc
EEF6: EB      		ex	de,hl
EEF7: C1      		pop	bc
EEF8: 10ED    		djnz	tm_usc0
EEFA: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
EEFB: 010048  	tm_cls:	ld	bc,0x4800
EEFE: 11FE0F  		ld	de,0x1000-2
EF01: CD18EF  		call	tm_addr
EF04: ED71    	tm_cls0:out	(c),0
EF06: 1B      		dec	de
EF07: 7A      		ld	a,d
EF08: B3      		or	e
EF09: 20F9    		jr	nz,tm_cls0
              		
              		; Write super special serial #
EF0B: 3EE5    		ld	a,0xE5
EF0D: ED79    		out	(c),a
EF0F: F5      		push	af
EF10: F1      		pop	af
EF11: 3E81    		ld	a,0x81
EF13: ED79    		out	(c),a
EF15: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; Returns tm_data in c
              	; uses: af, bc
EF16: 44      	tm_addh:ld	b,h		; Does HL instead of BC
EF17: 4D      		ld	c,l
EF18: DBA1    	tm_addr:in	a,(tm_latc)
EF1A: 79      		ld	a,c
EF1B: D3A1    		out	(tm_latc),a
EF1D: 78      		ld	a,b
EF1E: D3A1    		out	(tm_latc),a
EF20: 0EA0    		ld	c,tm_data
EF22: C9      		ret
              		
              	; Handles a TMS9918 irq
EF23: F5      	tm_virq:push	af
EF24: DBA1    		in	a,(tm_latc)
EF26: F1      		pop	af
EF27: FB      		ei
EF28: C9      		ret
              		
              		
              	; Disables all interrupts while VDP operations occur
              	;
              	; uses: a
EF29: 3EC9    	tm_dint:ld	a,0xC9
EF2B: 323800  		ld	(0x38),a
EF2E: ED56    		im	1
EF30: 3E0E    		ld	a,0x0E
EF32: D341    		out	(tm_atla),a	; AY register = 14
EF34: 3E00    		ld	a,0x00
EF36: D340    		out	(tm_ayda),a	
EF38: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
EF39: 3E0E    	tm_eint:ld	a,0x0E
EF3B: D341    		out	(tm_atla),a	; AY register = 14
EF3D: 3EB0    		ld	a,0xB0
EF3F: D340    		out	(tm_ayda),a
EF41: ED5E    		im	2
EF43: C9      		ret
              		
              	; Variables
EF44: 0200    	tm_mode:defw	0x0002
EF46: E1      	tm_colr:defb	0xE1
EF47: 00      	tm_inb:	defb	0
EF48: 00      	tm_inf:	defb	0
EF49: 00      	tm_curx:defb	0
EF4A: 00      	tm_cury:defb	0
EF4B: 01      	tm_cold:defb	1
              	#include "../dev/nabu_nfs.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   F I L E   S Y S T E M
              	;*
              	;*    Unlike a standard block device, the NFS driver provides
              	;*    a CP/M filesystem by directly intercepting system calls.
              	;*    By doing this, it can access provide access to an external
              	;*    filesystem via NHACP.
              	;*
              	;*    Virtual filesystems are directories labelled "A", "B",
              	;*    "C", etc... on the host system. That are converted to
              	;*    minor numbers 0, 1, 2, etc... when the driver is being
              	;*    added to the block device switch  
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F95C: 00000000	ns_buff:defs	48	; Buffer (48b)
F960: 00...   	
F98C: 00000000	ns_ptrn:defs	11	; Pattern buffer (11b)
F990: 00...   	
F997: 00000000	ns_name:defs	11	; Name bufffer (11b)
F99B: 00...   	
F9A2: 0000    	ns_mask:defs	2	; Ownership mask (2b)
F9A4: 0000    	ns_cfcb:defs	2	; Current FCB (2b)
F9A6: 00      	ns_dore:defs	1	; Do reopen? (1b)
F9A7: 00      	ns_isls:defs	1	; Is listing dir? (1b)
F9A8: 00      	ns_tran:defs	1	; Number of bytes in transfer (1b)
              	.area	_TEXT
              	
0040:         	ns_ayda	equ	0x40		; AY-3-8910 data port
0041:         	ns_atla	equ	0x41		; AY-3-8910 latch port
0080:         	ns_hcca	equ	0x80		; Modem data port
0000:         	ns_nctl	equ	0x00		; NABU control port
              	
0080:         	ns_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D U M M Y   D I S K   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Dummy DPH
EF4C: 00000000	ns_dph:	defw	0,0,0,0
EF50: 00000000	
EF54: 10FF    		defw	dircbuf	; DIRBUF
EF56: 5CEF    		defw	ns_dpb	; DPB
EF58: 0000    		defw	0	; CSV
EF5A: 6BEF    		defw	ns_alv	; ALV 
              		
              		
              	; Dummy format
EF5C: 4000    	ns_dpb:	defw	64	; # sectors per track
EF5E: 03      		defb	3	; BSH
EF5F: 07      		defb	7	; BLM
EF60: 00      		defb	0	; EXM
EF61: 0100    		defw	1	; DSM
EF63: 0000    		defw	0	; DRM
EF65: 00      		defb	0	; AL0
EF66: 00      		defb	0	; AL1
EF67: 0000    		defw	0	; Size of directory check vector
EF69: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              		
              	; Dummy ALV
EF6B: 00      	ns_alv: defb	0
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
EF6C: B7      	nfsdev:	or	a
EF6D: 2807    		jr	z,ns_init
EF6F: 3D      		dec	a
EF70: 3D      		dec	a
EF71: 2814    		jr	z,ns_sel
EF73: 3E01    		ld	a,1
EF75: C9      		ret
              	
              	; Inits the device
              	; Figures out which devices that the NFS driver "owns"
              	; b = Logical CP/M device #
              	; hl = Call argument
              	;
              	; uses: does not matter
EF76: 78      	ns_init:ld	a,b
EF77: CD6FF3  		call	ns_domk
EF7A: 2AA2F9  		ld	hl,(ns_mask)
EF7D: 7C      		ld	a,h
EF7E: B0      		or	b
EF7F: 67      		ld	h,a
EF80: 7D      		ld	a,l
EF81: B1      		or	c
EF82: 6F      		ld	l,a
EF83: 22A2F9  		ld	(ns_mask),hl
EF86: C9      		ret
              	
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
EF87: 11C4E9  	ns_sel:	ld	de,dirbuf
EF8A: 2154EF  		ld	hl,ns_dph+8
EF8D: 010800  		ld	bc,8
EF90: EDB0    		ldir
EF92: C37FE9  		jp	goback
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a, b
EF95: 3E07    	ns_hini:ld	a,0x07
EF97: D341    		out	(ns_atla),a	; AY register = 7
EF99: 3E7F    		ld	a,0x7F
EF9B: D340    		out	(ns_ayda),a	; Configure AY port I/O
              		
              		; Claim interrupt vectors
EF9D: E5      		push	hl
EF9E: 21A4F4  		ld	hl,ns_rirq
EFA1: 2200FF  		ld	(intvec),hl
EFA4: 21EBF4  		ld	hl,ns_wirq
EFA7: 2202FF  		ld	(intvec+2),hl
EFAA: E1      		pop	hl
              		
              	; Set interrupts to their default state
              	;
              	; uses: a
EFAB: 3E0E    	ns_dflt:ld	a,0x0E
EFAD: D341    		out	(ns_atla),a	; AY register = 14
EFAF: 3EB0    		ld	a,0xB0
EFB1: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send, plus key and VDP
              		
EFB3: 3E0F    	ns_dfl0:ld	a,0x0F		
EFB5: D341    		out	(ns_atla),a	; AY register = 15
              		
EFB7: C9      		ret
              	
              	; Set receive and send interrupts
              	;
              	; uses: a
EFB8: 3E0E    	ns_esnd:ld	a,0x0E
EFBA: D341    		out	(ns_atla),a	; AY register = 14
EFBC: 3EC0    		ld	a,0xC0
EFBE: D340    		out	(ns_ayda),a	; Enable HCCA receive and send
EFC0: 18F1    		jr	ns_dfl0
              		
              	; Set receive but not send interrupt
              	;
              	; uses: a
EFC2: 3E0E    	ns_dsnd:ld	a,0x0E
EFC4: D341    		out	(ns_atla),a	; AY register = 14
EFC6: 3E80    		ld	a,0x80
EFC8: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send
EFCA: 18E7    		jr	ns_dfl0
              	
              	; Loads the CCP into the CCP space
EFCC: 2161F5  	ns_ccp:	ld	hl,ns_p0
EFCF: 1803    		jr	ns_grb0
              		
              	; Loads the GRB into the CCP space
EFD1: 216EF5  	ns_grb:	ld	hl,ns_p1
EFD4: 1184F5  	ns_grb0:ld	de,ns_m0na
EFD7: 010D00  		ld	bc,13
EFDA: EDB0    		ldir			; Copy name to file open
EFDC: CD95EF  		call	ns_hini		; Go to HCCA mode
EFDF: 210000  		ld	hl,0x0000	; O_RDONLY
EFE2: CDB0F3  		call	ns_opef		; Open the file
EFE5: 110000  		ld	de,0
EFE8: 2100D4  		ld	hl,cbase
EFEB: CDCFF3  	ns_grb1:call	ns_getb
EFEE: 1C      		inc	e
EFEF: 3E10    		ld	a,16
EFF1: BB      		cp	e
EFF2: 20F7    		jr	nz,ns_grb1
EFF4: C9      		ret
              		
              	; CP/M system hook
              	; Used to intercept certain syscalls
              	;
              	; uses: af if not hooked, all otherwise
EFF5: 79      	ns_sysh:ld	a,c
EFF6: D60F    		sub	15
EFF8: D8      		ret	c		; No syscalls lower than 15
EFF9: 2841    		jr	z,ns_fopn	; Open file
EFFB: 3D      		dec	a
EFFC: CA7CF0  		jp	z,ns_fcls	; Close file
EFFF: 3D      		dec	a
F000: CA2DF1  		jp	z,ns_sfir	; Search for first 
F003: 3D      		dec	a
F004: CA52F1  		jp	z,ns_snxt	; Search for next 
F007: 3D      		dec	a
F008: CAA2F1  		jp	z,ns_dele	; Delete file
F00B: 3D      		dec	a
F00C: CA5BF2  		jp	z,ns_frea	; File read next record
F00F: 3D      		dec	a
F010: CA87F2  		jp	z,ns_fwri	; File write next record
F013: 3D      		dec	a
F014: CADAF2  		jp	z,ns_fmak	; Create file
F017: 3D      		dec	a
F018: CA01F3  		jp	z,ns_frnm	; Rename file
F01B: D607    		sub	7
F01D: 2817    		jr	z,ns_stmp	; Set file attributes (stump)
F01F: D603    		sub	3
F021: CAA1F2  		jp	z,ns_rrea	; File read random
F024: 3D      		dec	a
F025: CAB0F2  		jp	z,ns_rwri	; File write random
F028: 3D      		dec	a
F029: CA45F3  		jp	z,ns_size	; Compute file size
F02C: 3D      		dec	a
F02D: CABFF2  		jp	z,ns_rrec	; Update random access pointer
F030: D604    		sub	4
F032: CAB0F2  		jp	z,ns_rwri	; FIle write random (we will ignore the zero part)
F035: C9      		ret
              		
              	; Stump, do nothing if FCB is owned
              	; de = Address to FCB
              	;
              	; uses: does not matter
F036: CD7BF3  	ns_stmp:call	ns_ownr
              	
F039: C37FE9  		jp	goback
              		
              	; Parses the current FCB, and searches for a file that matches
              	; the pattern.
              	; The point here is to insert the "true" name of the file into
              	; the FCB so it can be accessed later
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F03C: CD7BF3  	ns_fopn:call	ns_ownr
              	
              		; Go find the file
F03F: D5      		push	de
F040: CDD2F0  		call	ns_find
              		
              		; Update status
F043: 210000  		ld	hl,0
F046: 2250DF  		ld	(status),hl
              		
              		; Copy over false CP/M filename to the FCB
F049: D1      		pop	de
F04A: CD5DF3  		call	ns_nblk		; Get # of blocks
F04D: 79      		ld	a,c
F04E: D5      		push	de
F04F: 13      		inc	de
F050: 2197F9  		ld	hl,ns_name
F053: 010B00  		ld	bc,11
F056: EDB0    		ldir
              		
              		; Set open flag
F058: 4F      		ld	c,a
F059: 13      		inc	de
F05A: 3EE7    		ld	a,0xE7
F05C: 12      		ld	(de),a
F05D: 13      		inc	de
F05E: AF      		xor	a
F05F: 12      		ld	(de),a
F060: 13      		inc	de
F061: 79      		ld	a,c
F062: 12      		ld	(de),a
F063: 13      		inc	de
              		
              		; Copy over the real filename to the FCB
F064: 011000  		ld	bc,16
F067: 2172F9  		ld	hl,ns_buff+22
F06A: EDB0    		ldir
              		
              	
              		; Check if current
F06C: D1      		pop	de
F06D: 2AA4F9  		ld	hl,(ns_cfcb)
F070: ED52    		sbc	hl,de
F072: 2005    		jr	nz,ns_fop0
              	
              		; Set the reopen flag
F074: 3E01    		ld	a,1
F076: 32A6F9  		ld	(ns_dore),a
              		
F079: C37FE9  	ns_fop0:jp	goback
              		
              	; Close the file
              	; Main purpose is to ensure that a close on this device is deferred
              	; Also resets the open flag
              	; de = Address of DPH
              	;
              	; uses: does not matter
F07C: CD7BF3  	ns_fcls:call	ns_ownr
              	
              		; Reset open flag
F07F: 210D00  		ld	hl,13
F082: 19      		add	hl,de
F083: 3600    		ld	(hl),0x00
              		
              		; Set flag
F085: 210000  		ld	hl,0
F088: 2250DF  		ld	(status),hl
              	
F08B: C37FE9  		jp	goback
              		
              	; Function call to start a list-dir operation
              	; Must be called before a file search
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F08E: D5      	ns_slst:push	de		; Save de
F08F: 2184F5  		ld	hl,ns_m0na
F092: EB      		ex	de,hl
F093: CD34F5  		call	ns_sdir 
F096: AF      		xor	a
F097: 12      		ld	(de),a		; Zero terminate string
F098: 3E01    		ld	a,1
F09A: 32A6F9  		ld	(ns_dore),a	; The existing file will be closed unconditionally
F09D: 210800  		ld	hl,0x0008	; Set flag type to directory
F0A0: CDB0F3  		call	ns_opef		; Call ns_open, but don't set flag
F0A3: 21FF00  		ld	hl,0x00FF
F0A6: 2250DF  		ld	(status),hl	; Set status
F0A9: C27FE9  		jp	nz,goback	; Error if cannot open file
              		
              		; Send LIST-DIR
F0AC: 21B6F5  		ld	hl,ns_m4
F0AF: 0607    		ld	b,7
F0B1: CD5CF4  		call	ns_send		; Start list-dir command
F0B4: 215CF9  		ld	hl,ns_buff
F0B7: CD3EF4  		call	ns_rece
F0BA: 3A5CF9  		ld	a,(ns_buff)	; Check for errors
F0BD: FE81    		cp	0x81
F0BF: C27FE9  		jp	nz,goback
              		
              		; Copy the file pattern to the pattern buffer
F0C2: E1      		pop	hl		; Get the FCB back
F0C3: 23      		inc	hl
F0C4: 118CF9  		ld	de,ns_ptrn
F0C7: 060B    		ld	b,11
F0C9: 7E      	ns_sls0:ld	a,(hl)
F0CA: E67F    		and	0x7F		; Fix for CP/M stupidness
F0CC: 12      		ld	(de),a
F0CD: 13      		inc	de
F0CE: 23      		inc	hl
F0CF: 10F8    		djnz	ns_sls0
F0D1: C9      		ret
              	
              	; Does a complete find operation
              	; Calls ns_slst, and then falls to ns_find
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de ,hl
F0D2: CD8EF0  	ns_find:call	ns_slst		; Complete find operation
              		
              	; Put the next found file name into the name buffer
              	; If no more names are found, exit with status of 0x00FF
              	; ns_slst must have been run to set up state, no more disk operations
              	; should be been run in the meantime.
              	; enter into ns_lis0 to avoid setting status
              	;
              	; uses: af, bc, de, hl
              	
F0D5: 21FF00  	ns_list:ld	hl,0x00FF
F0D8: 2250DF  		ld	(status),hl	; Set status
              	
              		
F0DB: 215CF9  	ns_lis0:ld	hl,ns_buff	; Clear out the first 40 bytes of the buffer
F0DE: AF      		xor	a		; This is to emulate zero termination, due
F0DF: 77      		ld	(hl),a		; To the fact that NHACP does not zero-terminate
F0E0: 115DF9  		ld	de,ns_buff+1	; strings coming back from the adapter...
F0E3: 012800  		ld	bc,40		
F0E6: EDB0    		ldir			
              	
              		; Lets read a directory now
F0E8: 21BDF5  		ld	hl,ns_m5	; Entry point from ns_sfir
F0EB: 0607    		ld	b,7
F0ED: CD5CF4  		call	ns_send		; Get the next file
F0F0: 215CF9  		ld	hl,ns_buff
F0F3: CD3EF4  		call	ns_rece	
F0F6: 3A5CF9  		ld	a,(ns_buff)	; Ensure we got FILE-INFO
F0F9: FE86    		cp	0x86
F0FB: C27FE9  		jp	nz,goback
              		
              		; Ok, time to format a directory entry
F0FE: 2172F9  		ld	hl,ns_buff+22
F101: 1197F9  		ld	de,ns_name
F104: 0608    		ld	b,8
              		
              		; Format first part of file
F106: CD3EF1  		call	ns_ffmt
              		
              		; Now we must skip till we either find a '.' or a '\0'
F109: 7E      	ns_lis1:ld	a,(hl)
F10A: B7      		or	a
F10B: 2805    		jr	z,ns_lis2
F10D: 23      		inc	hl
F10E: FE2E    		cp	'.'
F110: 20F7    		jr	nz,ns_lis1
              		
              		; Now the last part
F112: 0603    	ns_lis2:ld	b,3
F114: CD3EF1  		call	ns_ffmt
              		
              		; Back dir entry against pattern
F117: 118CF9  		ld	de,ns_ptrn
F11A: 2197F9  		ld	hl,ns_name
F11D: 060B    		ld	b,11
              	
F11F: 1A      	ns_lis3:ld	a,(de)
F120: 4E      		ld	c,(hl)
F121: 23      		inc	hl
F122: 13      		inc	de
F123: FE3F    		cp	'?'
F125: 2803    		jr	z,ns_lis4
F127: B9      		cp	c
F128: 20B1    		jr	nz,ns_lis0
F12A: 10F3    	ns_lis4:djnz	ns_lis3
F12C: C9      		ret
              		
              	; Search for first file
              	; Opens up a directory, then skips to routines that read the first dir entry
              	; de = Address of FCB
              	;
              	; uses: all
F12D: AF      	ns_sfir:xor	a
F12E: 32A7F9  		ld	(ns_isls),a	; Clear "isls" flag
F131: CD7BF3  		call	ns_ownr
              		
              		; Start the list-dir function
F134: CD8EF0  		call	ns_slst
              		
              		; Set isls flag
F137: 3E01    		ld	a,1
F139: 32A7F9  		ld	(ns_isls),a
              		
              		; Move into ns_snxt
F13C: 181C    		jr	ns_snx0
              		
              	; Format incoming files into a dir entry
              	; Will copy over characters until a '.' or '\0' is reached
              	; Any remaining characters will be filled out with spaces
              	; b = Number of characters
              	; de = Destination of data
              	; hl = Source of data
              	;
              	; uses: af, b, de, hl
F13E: 7E      	ns_ffmt:ld	a,(hl)
F13F: CD47F5  		call	ns_ltou
F142: B7      		or	a
F143: 2804    		jr	z,ns_ffm0
F145: FE2E    		cp	'.'
F147: 2003    		jr	nz,ns_ffm1
F149: 2B      	ns_ffm0:dec	hl
F14A: 3E20    		ld	a,' '		; Turn it into a space
F14C: 23      	ns_ffm1:inc	hl
F14D: 12      		ld	(de),a
F14E: 13      		inc	de
F14F: 10ED    		djnz	ns_ffmt
F151: C9      		ret
              		
              	; Search for next file
              	; Takes the open directory and gets the next file
              	;
              	; uses: all
F152: 3AA7F9  	ns_snxt:ld	a,(ns_isls)
F155: B7      		or	a
F156: C8      		ret	z
              		
              		; Set up the HCCA
F157: CD95EF  		call	ns_hini	
              		
              		; Find the next entry
F15A: CDD5F0  	ns_snx0:call	ns_list
              		
              		; Copy to directory entry
F15D: ED5B49EB		ld	de,(biodma)
F161: 3A4CDF  		ld	a,(userno)
F164: 12      		ld	(de),a
F165: 13      		inc	de
F166: 2197F9  		ld	hl,ns_name
F169: 010B00  		ld	bc,11
F16C: EDB0    		ldir
              		
              		; Get file size
F16E: CD5DF3  		call	ns_nblk
              		
F171: AF      		xor	a
F172: B8      		cp	b
F173: 0610    		ld	b,16
F175: 200F    		jr	nz,ns_snx1
F177: AF      		xor	a
F178: CB39    		srl	c
F17A: 17      		rla
F17B: CB39    		srl	c
F17D: 17      		rla
F17E: CB39    		srl	c
F180: 17      		rla
F181: B7      		or	a
F182: 41      		ld	b,c
F183: 2801    		jr	z,ns_snx1
F185: 04      		inc	b
              		
              		
              		; Set the records to 0
F186: 48      	ns_snx1:ld	c,b
F187: 0604    		ld	b,4
F189: AF      		xor	a
F18A: 12      	ns_snx2:ld	(de),a
F18B: 13      		inc	de
F18C: 10FC    		djnz	ns_snx2
              		
              		; Spoof file size 1-16KB
F18E: 0610    		ld	b,16
F190: 79      		ld	a,c
F191: 12      	ns_snx3:ld	(de),a
F192: 13      		inc	de
F193: B7      		or	a
F194: 2801    		jr	z,ns_snx4
F196: 3D      		dec	a
F197: 10F8    	ns_snx4:djnz	ns_snx3
              		
              		; Set status to 0 and return
F199: 210000  		ld	hl,0
F19C: 2250DF  		ld	(status),hl
F19F: C37FE9  		jp	goback
              		
              	; Delete files based on pattern
              	; Will return error if less than 1 file is found
              	; de = Address to FCB
              	;
              	; uses: all
F1A2: CD7BF3  	ns_dele:call	ns_ownr
              	
              		; Set first part of remove message prototype
F1A5: F5      		push	af
F1A6: EB      		ex	de,hl
F1A7: 11CCF5  		ld	de,ns_m6na
F1AA: CD34F5  		call	ns_sdir
F1AD: 3E2F    		ld	a,'/'
F1AF: 12      		ld	(de),a
F1B0: EB      		ex	de,hl
F1B1: F1      		pop	af
              	
              		; Start the list-dir function
F1B2: CD8EF0  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F1B5: CDDBF0  	ns_del0:call	ns_lis0
              	
              		; Copy over file name into message
F1B8: 11CFF5  		ld	de,ns_m6na+3
F1BB: 2172F9  		ld	hl,ns_buff+22
F1BE: 011000  		ld	bc,16
F1C1: EDB0    		ldir
              		
              		; Send delete message
F1C3: 21C4F5  		ld	hl,ns_m6
F1C6: 061B    		ld	b,27
F1C8: CD5CF4  		call	ns_send
F1CB: 215CF9  		ld	hl,ns_buff
F1CE: CD3EF4  		call	ns_rece
              		
              		; Set status to 0, and get next element
F1D1: 210000  		ld	hl,0
F1D4: 2250DF  		ld	(status),hl
F1D7: 18DC    		jr	ns_del0
              	
              		
              	; Prepare to access a file
              	; Checks the magic number to ensure that the file is in fact open
              	; Also checks ns_dore and ns_cfcb to see if a reopen is required
              	; If so, copy filename from FCB and do NHACP open
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, hl
F1D9: 4F      	ns_aces:ld	c,a
F1DA: 210D00  		ld	hl,13
F1DD: 19      		add	hl,de
F1DE: 7E      		ld	a,(hl)
F1DF: FEE7    		cp	0xE7
F1E1: 2809    		jr	z,ns_ace0
              		
              		; Return invalid FCB
F1E3: 210900  		ld	hl,9
F1E6: 2250DF  		ld	(status),hl
F1E9: C37FE9  		jp	goback
              		
              		; Check to see if it is currently being accessed
F1EC: 2AA4F9  	ns_ace0:ld	hl,(ns_cfcb)
F1EF: ED52    		sbc	hl,de
F1F1: 2005    		jr	nz,ns_ace1
              		
              		; See if a reopen is needed
F1F3: 3AA6F9  		ld	a,(ns_dore)
F1F6: B7      		or	a
F1F7: C8      		ret	z
              		
              		; A reopen is needed, do it!
F1F8: 21FF00  	ns_ace1:ld	hl,0x00FF
F1FB: 2250DF  		ld	(status),hl
              		
              		; Set the current FCB to this one
F1FE: ED53A4F9		ld	(ns_cfcb),de
              		
              		; Clear ns_dore flag
F202: AF      		xor	a
F203: 32A6F9  		ld	(ns_dore),a
              		
              		; Copy over the true filename
F206: 211000  		ld	hl,16
F209: 19      		add	hl,de
F20A: D5      		push	de
F20B: 1184F5  		ld	de,ns_m0na
F20E: 79      		ld	a,c
F20F: CD34F5  		call	ns_sdir
F212: 3E2F    		ld	a,'/'
F214: 12      		ld	(de),a
F215: 13      		inc	de
F216: 011000  		ld	bc,16
F219: EDB0    		ldir
              		
              		; Now open the file
F21B: CDADF3  		call	ns_open
F21E: D1      		pop	de
F21F: C9      		ret
              		
              	; Takes in a FCB, and returns the current record to access
              	; de = Address to FCB
              	;
              	; Returns record # in bc
              	; uses: af, bc, hl
F220: 210C00  	ns_gcre:ld	hl,0x0C
F223: 19      		add	hl,de
F224: 46      		ld	b,(hl)
F225: 0E00    		ld	c,0
F227: CB38    		srl	b
F229: CB19    		rr	c
F22B: 23      		inc	hl
F22C: 23      		inc	hl
F22D: 7E      		ld	a,(hl)
F22E: 07      		rlca
F22F: 07      		rlca
F230: 07      		rlca
F231: 07      		rlca
F232: B0      		or	b
F233: 47      		ld	b,a
F234: 212000  		ld	hl,0x20
F237: 19      		add	hl,de
F238: 7E      		ld	a,(hl)
F239: B1      		or	c
F23A: 4F      		ld	c,a
F23B: C9      		ret
              		
              	; Takes in a random record, and writes it to the FCB
              	; bc = Record #
              	; de = Address to FCB
              	;
              	; uses: af, bc, hl
F23C: 212000  	ns_scre:ld	hl,0x20
F23F: 19      		add	hl,de
F240: 79      		ld	a,c
F241: E67F    		and	0x7F
F243: 77      		ld	(hl),a
F244: 210E00  		ld	hl,0x0E
F247: 19      		add	hl,de
F248: 78      		ld	a,b
F249: 0F      		rrca
F24A: 0F      		rrca
F24B: 0F      		rrca
F24C: 0F      		rrca
F24D: E60F    		and	0x0F
F24F: 77      		ld	(hl),a
F250: 2B      		dec	hl
F251: 2B      		dec	hl
F252: CB21    		sla	c
F254: CB10    		rl	b
F256: 78      		ld	a,b
F257: E60F    		and	0x0F
F259: 77      		ld	(hl),a
F25A: C9      		ret
              			
              	; Read next record
              	; Reads the next 128 bytes in a file into the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F25B: CD7BF3  	ns_frea:call	ns_ownr
              	
              		; Set file up to access
F25E: CDD9F1  		call	ns_aces
              		
              		; Get the record to read
F261: CD20F2  		call	ns_gcre
              		
              		; Set up and do read
F264: C5      		push	bc
F265: D5      		push	de
F266: 50      	ns_fre0:ld	d,b
F267: 59      		ld	e,c
F268: 2A49EB  		ld	hl,(biodma)
F26B: CDCFF3  		call	ns_getb
              		
              		; Make sure there were no issues
F26E: DA7FE9  	ns_fre1:jp	c,goback
              		
              		; Increment and writeback
F271: D1      		pop	de
F272: C1      		pop	bc
F273: 03      		inc	bc
F274: CD3CF2  		call	ns_scre
              		
              		; Set return status
F277: 210000  		ld	hl,0
F27A: 3AA8F9  		ld	a,(ns_tran)
F27D: B7      		or	a
F27E: 2001    		jr	nz,ns_fre2
F280: 23      		inc	hl
              		
F281: 2250DF  	ns_fre2:ld	(status),hl
F284: C37FE9  		jp	goback
              		
              	; Write next record
              	; Writes the next 128 bytes into a file from the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F287: CD7BF3  	ns_fwri:call	ns_ownr
              	
              		; Set file up to access
F28A: CDD9F1  		call	ns_aces
              		
              		; Get the record to write
F28D: CD20F2  		call	ns_gcre
              		
              		; Set up and do write
F290: C5      		push	bc
F291: D5      		push	de
F292: 50      	ns_fwr0:ld	d,b
F293: 59      		ld	e,c
F294: 2A49EB  		ld	hl,(biodma)
F297: CD10F4  		call	ns_putb
              		
              		; Set amount transfered to 128
F29A: 3E80    		ld	a,128
F29C: 32A8F9  		ld	(ns_tran),a
              		
              		; Continue in read
F29F: 18CD    		jr	ns_fre1
              		
              	; Read record random
              	; Takes the random address and read a sector from it
F2A1: CD7BF3  	ns_rrea:call	ns_ownr
              	
              		; Set file up to access
F2A4: CDD9F1  		call	ns_aces
              		
              		; Decode random address
F2A7: CDD2F2  		call	ns_deco
F2AA: 0B      		dec	bc
F2AB: C5      		push	bc
F2AC: D5      		push	de
F2AD: 03      		inc	bc
F2AE: 18B6    		jr	ns_fre0
              		
              	; Write record random
              	; Takes the random address and write a sector to it
              	; de = Address to FCB
              	;
              	; uses: all
F2B0: CD7BF3  	ns_rwri:call	ns_ownr
              	
              		; Set file up to access
F2B3: CDD9F1  		call	ns_aces
              		
              		; Decode random address
F2B6: CDD2F2  		call	ns_deco
F2B9: 0B      		dec	bc
F2BA: C5      		push	bc
F2BB: D5      		push	de
F2BC: 03      		inc	bc
F2BD: 18D3    		jr	ns_fwr0
              		
              	; Set random record
              	; de = Address to FCB
              	;
              	; uses: all
F2BF: CD7BF3  	ns_rrec:call	ns_ownr
              		
              		; Get current address from FCB
F2C2: CD20F2  		call	ns_gcre
              		
              		; Set FCB random record
F2C5: 212100  		ld	hl,0x21
F2C8: 19      		add	hl,de
F2C9: 71      		ld	(hl),c
F2CA: 23      		inc	hl
F2CB: 70      		ld	(hl),b
F2CC: 23      		inc	hl
F2CD: 3600    		ld	(hl),0
              		
              		; Done
F2CF: C37FE9  		jp	goback
              		
              	; Decodes random address
              	; de = Address to FCB
              	;
              	; Returns block number in bc
              	; uses: af, bc, hl
F2D2: 212100  	ns_deco:ld	hl,0x21
F2D5: 19      		add	hl,de
F2D6: 4E      		ld	c,(hl)
F2D7: 23      		inc	hl
F2D8: 46      		ld	b,(hl)
F2D9: C9      		ret
              		
              	; Make new file
              	; Reboot the system if the file already exists
              	; de = Address to FCB
              	;
              	; uses: all
F2DA: CD7BF3  	ns_fmak:call	ns_ownr
              	
              		; We either succeed or die trying
F2DD: 210000  		ld	hl,0
F2E0: 2250DF  		ld	(status),hl
              	
              		; Decode filename into open buffer
F2E3: 2184F5  		ld	hl,ns_m0na
F2E6: D5      		push	de
F2E7: EB      		ex	de,hl
F2E8: 23      		inc	hl
F2E9: CDFCF4  		call	ns_form
              		
              		; Set the flag and open
F2EC: 213000  		ld	hl,0x0030
F2EF: 2281F5  		ld	(ns_m0fl),hl
F2F2: CDB0F3  		call	ns_opef
              		
              		; Error? time to reboot!
F2F5: C20000  		jp	nz,0
              		
              		; Nope? Activate FCB
F2F8: D1      		pop	de
              		
              		; Force reopen
F2F9: 3E01    		ld	a,1
F2FB: 32A6F9  		ld	(ns_dore),a
              		
              		; Do an open
F2FE: C33CF0  		jp	ns_fopn
              		
              	; Rename file
              	; Similar to delete, wildcards are allowed
              	; de = Address to FCB
              	;
              	; uses: all
F301: CD7BF3  	ns_frnm:call	ns_ownr
              	
              		; Set first part of rename message prototype
F304: F5      		push	af
F305: EB      		ex	de,hl
F306: 11E5F5  		ld	de,ns_m7n0
F309: CD34F5  		call	ns_sdir
F30C: 3E2F    		ld	a,'/'
F30E: 12      		ld	(de),a
F30F: F1      		pop	af
F310: F5      		push	af
F311: E5      		push	hl
F312: 111100  		ld	de,17
F315: 19      		add	hl,de
F316: 11F9F5  		ld	de,ns_m7n1
F319: CDFCF4  		call	ns_form
F31C: D1      		pop	de
F31D: F1      		pop	af
              		
              	
              		; Start the list-dir function
F31E: CD8EF0  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F321: CDDBF0  	ns_frn0:call	ns_lis0
              	
              		; Copy over file name into message
F324: 11E8F5  		ld	de,ns_m7n0+3
F327: 2172F9  		ld	hl,ns_buff+22
F32A: 011000  		ld	bc,16
F32D: EDB0    		ldir
              		
              		; Send rename message
F32F: 21DFF5  		ld	hl,ns_m7
F332: 062D    		ld	b,45
F334: CD5CF4  		call	ns_send
F337: 215CF9  		ld	hl,ns_buff
F33A: CD3EF4  		call	ns_rece
              		
              		; Set status to 0, and get next element
F33D: 210000  		ld	hl,0
F340: 2250DF  		ld	(status),hl
F343: 18DC    		jr	ns_frn0
              		
              	; Place size of file into FCB
              	; de = Address to FCB
              	;
              	; uses: all
F345: CD7BF3  	ns_size:call	ns_ownr
              	
              		; Find file
F348: D5      		push	de
F349: CDD2F0  		call	ns_find
F34C: D1      		pop	de
              		
              		; Get number of blocks
F34D: CD5DF3  		call	ns_nblk
              		
              		; Set in FCB
F350: 212100  		ld	hl,0x21
F353: 19      		add	hl,de
F354: 71      		ld	(hl),c
F355: 23      		inc	hl
F356: 70      		ld	(hl),b
F357: 23      		inc	hl
F358: 3600    		ld	(hl),0
              	
F35A: C37FE9  		jp	goback	
              		
              	; Use a FILE-INFO block in ns_buff to calculate
              	; the number of blocks in a file
              	;
              	; Returns number of blocks in bc
              	; uses: af, bc, hl
F35D: 216FF9  	ns_nblk:ld	hl,ns_buff+19
F360: 46      		ld	b,(hl)
F361: 2B      		dec	hl
F362: 4E      		ld	c,(hl)
F363: 2B      		dec	hl
F364: 7E      		ld	a,(hl)
F365: CB27    		sla	a
F367: CB11    		rl	c
F369: CB10    		rl	b
F36B: B7      		or	a
F36C: C8      		ret	z
F36D: 03      		inc	bc
F36E: C9      		ret
              		
              	; Set a 16 bit mask based on a number from 0-15
              	; a = Bit to set
              	;
              	; Returns bit mask in bc
              	; uses: af, bc
F36F: 010100  	ns_domk:ld	bc,1
F372: B7      		or	a
F373: C8      	ns_dom0:ret	z
F374: CB21    		sla	c
F376: CB10    		rl	b
F378: 3D      		dec	a
F379: 18F8    		jr	ns_dom0
              		
              	; Check if driver owns device
              	; Bail if it does not
              	; If it does, get the logical NHACP device
              	; de = Address of FCB
              	;
              	; Returns logical device in a
              	; uses: af, hl
F37B: C5      	ns_ownr:push	bc
F37C: CDA6F3  		call	ns_getd		; Get FCB device
F37F: CD6FF3  		call	ns_domk		; Create bitmask
F382: 2AA2F9  		ld	hl,(ns_mask)
F385: 7C      		ld	a,h
F386: A0      		and	b
F387: 2002    		jr	nz,ns_own0
F389: 7D      		ld	a,l
F38A: A1      		and	c
F38B: 2816    	ns_own0:jr	z,ns_exit	; Exit if does not own	
F38D: 216EEB  		ld	hl,bdevsw+2
F390: CDA6F3  		call	ns_getd		; Get FCB device
F393: 010400  		ld	bc,4
F396: B7      		or	a
F397: 2804    	ns_own1:jr	z,ns_own2
F399: 09      		add	hl,bc
F39A: 3D      		dec	a
F39B: 18FA    		jr	ns_own1
F39D: CD95EF  	ns_own2:call	ns_hini		; We are commited at this point, init HCCA
F3A0: 7E      		ld	a,(hl)		; a = Logical NHACP device
F3A1: C1      		pop	bc
F3A2: C9      		ret
              	
              	; Exit, do not return to caller
F3A3: C1      	ns_exit:pop	bc
F3A4: F1      		pop	af		; Throw away caller address
F3A5: C9      		ret
              	
              	; Gets the logical device number from a FCB
              	; de = Address of FCB
              	; 
              	; Logical device returns in a
              	; uses: af
F3A6: 1A      	ns_getd:ld	a,(de)
F3A7: 3D      		dec	a
F3A8: F0      		ret	p
F3A9: 3A4DDF  		ld	a,(active)
F3AC: C9      		ret
              	
              	; Open the prepared file
              	; Closes the existing file too
              	; ns_opef can be called to set custom flag
              	;
              	; Flag z cleared on error
              	; uses: af, b, hl
F3AD: 210200  	ns_open:ld	hl,0x0002	; Read/Write Protect flag
F3B0: 2281F5  	ns_opef:ld	(ns_m0fl),hl
F3B3: 2198F5  		ld	hl,ns_m1
F3B6: 0606    		ld	b,6
F3B8: CD5CF4  		call	ns_send
F3BB: 217BF5  		ld	hl,ns_m0
F3BE: 061C    		ld	b,28
F3C0: CD5CF4  		call	ns_send
F3C3: 215CF9  		ld	hl,ns_buff
F3C6: CD3EF4  		call	ns_rece
F3C9: 3A5CF9  		ld	a,(ns_buff)
F3CC: FE83    		cp	0x83
F3CE: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F3CF: CDD5F3  	ns_getb:call	ns_get0
F3D2: C3ABEF  		jp	ns_dflt
F3D5: EB      	ns_get0:ex	de,hl
F3D6: 22A4F5  		ld	(ns_m2bn),hl
F3D9: EB      		ex	de,hl
F3DA: E5      		push	hl
F3DB: 219EF5  		ld	hl,ns_m2
F3DE: 060C    		ld	b,12
F3E0: CD5CF4  		call	ns_send
F3E3: E1      		pop	hl
F3E4: D8      		ret	c
F3E5: CD65F4  		call	ns_hcrd
F3E8: CD68F4  		call	ns_hcre
F3EB: D8      		ret	c
F3EC: FE84    		cp	0x84
F3EE: 37      		scf
F3EF: 2017    		jr	nz,ns_get2
F3F1: CD68F4  		call	ns_hcre
F3F4: 32A8F9  		ld	(ns_tran),a
F3F7: 47      		ld	b,a
F3F8: CD68F4  		call	ns_hcre
F3FB: 78      		ld	a,b
F3FC: B7      		or	a
F3FD: C8      		ret	z
F3FE: CD68F4  	ns_get1:call	ns_hcre
F401: D8      		ret	c
F402: 77      		ld	(hl),a
F403: 23      		inc	hl
F404: 10F8    		djnz	ns_get1
F406: B7      		or	a
F407: C9      		ret
F408: CD65F4  	ns_get2:call	ns_hcrd	; Read the error message and exit
F40B: CD68F4  		call	ns_hcre
F40E: 37      		scf
F40F: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F410: CD16F4  	ns_putb:call	ns_put0
F413: C3ABEF  		jp	ns_dflt
F416: EB      	ns_put0:ex	de,hl
F417: 22B0F5  		ld	(ns_m3bn),hl
F41A: EB      		ex	de,hl
F41B: E5      		push	hl
F41C: 21AAF5  		ld	hl,ns_m3
F41F: 060C    		ld	b,12
F421: CD5CF4  		call	ns_send		; Send message precursor
F424: E1      		pop	hl
F425: D8      		ret	c
F426: 0680    		ld	b,128
F428: 7E      	ns_put1:ld	a,(hl)		; Send the block
F429: CDB2F4  		call	ns_hcwr
F42C: D8      		ret	c
F42D: 23      		inc	hl
F42E: 10F8    		djnz	ns_put1
F430: 215CF9  		ld	hl,ns_buff
F433: CD3EF4  		call	ns_rece
F436: 3A5CF9  		ld	a,(ns_buff)
F439: FE81    		cp	0x81
F43B: C8      		ret	z
F43C: 37      		scf
F43D: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F43E: CDC2EF  	ns_rece:call	ns_dsnd
F441: CD47F4  		call	ns_rec0
F444: C3ABEF  		jp	ns_dflt
F447: CD68F4  	ns_rec0:call	ns_hcre
F44A: D8      		ret	c		; Existing error
F44B: 47      		ld	b,a
F44C: CD68F4  		call	ns_hcre
F44F: D8      		ret	c		; Existing error
F450: 37      		scf
F451: C0      		ret	nz		; Message too big!
F452: CD68F4  	ns_rec1:call	ns_hcre
F455: D8      		ret	c		; Error!
F456: 77      		ld	(hl),a
F457: 23      		inc	hl
F458: 10F8    		djnz	ns_rec1
F45A: B7      		or	a
F45B: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F45C: 7E      	ns_send:ld	a,(hl)
F45D: 23      		inc	hl
F45E: CDB2F4  		call	ns_hcwr
F461: D8      		ret	c		; Error!
F462: 10F8    		djnz	ns_send
F464: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns result in a
              	; Carry flag set on error
              	; Uses: af
F465: CD68F4  	ns_hcrd:call	ns_hcre
F468: AF      	ns_hcre:xor	a
F469: 3260F5  		ld	(ns_inf),a
F46C: D5      		push	de
F46D: 3E09    		ld	a,0x09
F46F: D300    		out	(ns_nctl),a	; Turn on recv light
F471: 11FFFF  		ld	de,0xFFFF
F474: 3A60F5  	ns_hcr0:ld	a,(ns_inf)
F477: B7      		or	a
F478: 201D    		jr	nz,ns_hcr2
F47A: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcr0	; Await an interrupt
              		;bit	1,a
              		;jr	z,ns_hcr1
F47C: E60F    		and	0x0F
F47E: EE01    		xor	0b00000001
F480: 280C    		jr	z,ns_hcr1
F482: 1B      		dec	de
F483: 7B      		ld	a,e
F484: B2      		or	d
F485: 20ED    		jr	nz,ns_hcr0
F487: 3E01    	ns_hcer:ld	a,0x01
F489: D300    		out	(ns_nctl),a	; Turn off recv light
F48B: 37      		scf
F48C: D1      		pop	de
F48D: C9      		ret			; Timed out waiting
F48E: 3E01    	ns_hcr1:ld	a,0x01
F490: D300    		out	(ns_nctl),a	; Turn off recv light
F492: DB80    		in	a,(ns_hcca)
F494: D1      		pop	de
F495: B7      		or	a
F496: C9      		ret
F497: 3E01    	ns_hcr2:ld	a,0x01
F499: D300    		out	(ns_nctl),a	; Turn off recv light
F49B: AF      		xor	a
F49C: 3260F5  		ld	(ns_inf),a
F49F: 3A5FF5  		ld	a,(ns_inb)
F4A2: D1      		pop	de
F4A3: C9      		ret
              		
              	; HCCA read interrupt
              	; Reads from the HCCA, buffers it, and then sets the flag
              	;
              	; uses: none
F4A4: F5      	ns_rirq:push	af
F4A5: DB80    		in	a,(ns_hcca)
F4A7: 325FF5  		ld	(ns_inb),a
F4AA: 3E01    		ld	a,1
F4AC: 3260F5  		ld	(ns_inf),a
F4AF: F1      		pop	af
F4B0: FB      		ei
F4B1: C9      		ret
              		
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F4B2: D5      	ns_hcwr:push	de
F4B3: 325DF5  		ld	(ns_outb),a
F4B6: AF      		xor	a
F4B7: 325EF5  		ld	(ns_outf),a
F4BA: CDB8EF  		call	ns_esnd
F4BD: 11FFFF  		ld	de,0xFFFF
F4C0: 3E21    		ld	a,0x21
F4C2: D300    		out	(ns_nctl),a	; Turn on send light
F4C4: 3A5EF5  	ns_hcw0:ld	a,(ns_outf)
F4C7: B7      		or	a
F4C8: 2017    		jr	nz,ns_hcw2
F4CA: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcw0	; Await an interrupt
              		;bit	1,a
              		;jr	nz,ns_hcw1
F4CC: E60F    		and	0x0F
F4CE: EE03    		xor	0b00000011
F4D0: 280A    		jr	z,ns_hcw1
F4D2: 1B      		dec	de
F4D3: 7B      		ld	a,e
F4D4: B2      		or	d
F4D5: 20ED    		jr	nz,ns_hcw0
F4D7: CDC2EF  		call	ns_dsnd
F4DA: 18AB    		jr	ns_hcer		; Timed out waiting
F4DC: 3A5DF5  	ns_hcw1:ld	a,(ns_outb)
F4DF: D380    		out	(ns_hcca),a
F4E1: D1      	ns_hcw2:pop	de
F4E2: 3E01    		ld	a,0x01
F4E4: D300    		out	(ns_nctl),a	; Turn off send light
F4E6: CDC2EF  		call	ns_dsnd
F4E9: B7      		or	a
F4EA: C9      		ret
              		
              	; HCCA write interrupt
              	; Writes to the HCCA from the buffer, and 
F4EB: F5      	ns_wirq:push	af
F4EC: 3A5DF5  		ld	a,(ns_outb)
F4EF: D380    		out	(ns_hcca),a
F4F1: 3E01    		ld	a,1
F4F3: 325EF5  		ld	(ns_outf),a
F4F6: CDC2EF  		call	ns_dsnd		; Y'all can't behave, turning off
F4F9: F1      		pop	af
F4FA: FB      		ei
F4FB: C9      		ret
              		
              		
              	; Takes a FCB-style name and formats it to standard notation
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	; hl = Source FCB file name
              	;
              	; uses: all
F4FC: CD34F5  	ns_form:call	ns_sdir
F4FF: 3E2F    		ld	a,'/'
F501: CD44F5  		call	ns_wchd
F504: 0608    		ld	b,8		; Look at all 8 possible name chars
F506: 7E      	ns_for1:ld	a,(hl)
F507: E67F    		and	0x7F
F509: CD52F5  		call	ns_utol
F50C: FE21    		cp	0x21
F50E: 3806    		jr	c,ns_for2
F510: CD44F5  		call	ns_wchd
F513: 23      		inc	hl
F514: 10F0    		djnz	ns_for1
F516: 3E2E    	ns_for2:ld	a,0x2E		; '.'
F518: CD44F5  		call	ns_wchd
F51B: 48      		ld	c,b
F51C: 0600    		ld	b,0
F51E: 09      		add	hl,bc		; Fast forward to extenstion
F51F: 0603    		ld	b,3		; Copy over extension
F521: 7E      	ns_for3:ld	a,(hl)
F522: E67F    		and	0x7F
F524: CD52F5  		call	ns_utol
F527: FE21    		cp	0x21
F529: 3806    		jr	c,ns_for4
F52B: CD44F5  		call	ns_wchd
F52E: 23      		inc	hl
F52F: 10F0    		djnz	ns_for3
F531: AF      	ns_for4:xor	a		; Zero terminate
F532: 12      		ld	(de),a
F533: C9      		ret
              		
              	; Part of ns_form, but sometimes is called independently
              	; Sets the directory to access files from
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	;
              	; uses: af, de
F534: C641    	ns_sdir:add	a,'A'
F536: CD44F5  		call	ns_wchd
F539: 3A4CDF  		ld	a,(userno)
F53C: C630    		add	a,'0'
F53E: FE3A    		cp	':'
F540: 3802    		jr	c,ns_wchd
F542: C607    		add	a,7
              		
              		; Fall to ns_wchd
              		
              	; Writes a byte to (de), then increments de
              	; a = Character to write
              	; de = Destination for character
              	;
              	; Returns de=de+1
              	; uses: af, de
F544: 12      	ns_wchd:ld	(de),a
F545: 13      		inc	de
F546: C9      		ret
              	
              	; Converts lowercase to uppercase
              	; a = Character to convert
              	;
              	; Returns uppercase in A
              	; uses: af
F547: E67F    	ns_ltou:and	0x7F
F549: FE61    		cp	0x61		; 'a'
F54B: D8      		ret	c
F54C: FE7B    		cp	0x7B		; '{'
F54E: D0      		ret	nc
F54F: D620    		sub	0x20
F551: C9      		ret
              		
              	; Converts uppercase to lowercase
              	; a = Character to convert
              	;
              	; Returns lowercase in A
              	; uses: af
F552: E67F    	ns_utol:and	0x7F
F554: FE41    		cp	0x41		; 'A'
F556: D8      		ret	c
F557: FE5B    		cp	0x5B		; '['
F559: D0      		ret	nc
F55A: C620    		add	0x20
F55C: C9      		ret
              		
              	; Byte to send out of HCCA
F55D: 00      	ns_outb:defb	0
              	
              	; HCCA output flag
F55E: 00      	ns_outf:defb	0
              	
              	; Byte received from HCCA
F55F: 00      	ns_inb:	defb	0
              	
              	; HCCA input flag
F560: 00      	ns_inf: defb	0
              		
              	; Path to CP/M image
              	; Total length: 13 bytes
F561: 41302F43	ns_p0:	defb	'A0/CPM22.SYS',0
F565: 504D3232	
F569: 2E535953	
F56D: 00      	
              	
              	; Path to GRB image
              	; Total length: 13 bytes
F56E: 41302F46	ns_p1:	defb	'A0/FONT.GRB',0,0
F572: 4F4E542E	
F576: 47524200	
F57A: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 28 bytes
F57B: 8F00    	ns_m0:	defb	0x8F,0x00
F57D: 1800    		defw	24		; Message length
F57F: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F580: 80      		defb	ns_fild		; Default file descriptor
F581: 0000    	ns_m0fl:defw	0x0000		; Read/Write flags
F583: 13      		defb	19		; File name length
F584: 58585858	ns_m0na:defs	19,'X'		; File name field
F588: 58...   	
F597: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F598: 8F00    	ns_m1:	defb	0x8F,0x00
F59A: 0200    		defw	2		; Message length
F59C: 05      		defb	0x05		; Cmd: FILE-CLOSE
F59D: 80      		defb	ns_fild		; Default file descriptor
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F59E: 8F00    	ns_m2:	defb	0x8F,0x00
F5A0: 0800    		defw	8		; Message length
F5A2: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F5A3: 80      		defb	ns_fild		; Default file descritor
F5A4: 00000000	ns_m2bn:defw	0x00,0x00	; Block number
F5A8: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F5AA: 8F00    	ns_m3:	defb	0x8F,0x00
F5AC: 8800    		defw	136		; Message length
F5AE: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F5AF: 80      		defb	ns_fild		; Default file descritor
F5B0: 00000000	ns_m3bn:defw	0x00,0x00	; Block number
F5B4: 8000    		defw	128		; Block length
              		
              	; Message prototype to start a list-dir
              	; Total length: 7 bytes
F5B6: 8F00    	ns_m4:	defb	0x8F,0x00
F5B8: 0300    		defw	3		; Message length
F5BA: 0E      		defb	0x0E		; Cmd: LIST-DIR
F5BB: 80      		defb	ns_fild		; Default file descriptor
F5BC: 00      		defb	0x00		; Null string
              		
              	; Message prototype to get the next dir entry
              	; Total length: 7 bytes
F5BD: 8F00    	ns_m5:	defb	0x8F,0x00
F5BF: 0300    		defw	3		; Message length
F5C1: 0F      		defb	0x0F		; Cmd: GET-DIR-ENTRY
F5C2: 80      		defb	ns_fild		; Default file descriptor
F5C3: 10      		defb	16		; Max length of file
              		
              	; Message prototype to remove a file
              	; Total length: 27 bytes
F5C4: 8F00    	ns_m6:	defb	0x8F,0x00
F5C6: 1700    		defw	23		; Message length
F5C8: 10      		defb	0x10		; Cmd: REMOVE
F5C9: 0000    		defw	0x0000		; Remove regular file
F5CB: 13      		defb	19		; File name length
F5CC: 58585858	ns_m6na:defs	19,'X'		; File name field
F5D0: 58...   	
              	
              	; Message prototype to rename a file
              	; Total length: 45 bytes
F5DF: 8F00    	ns_m7:	defb	0x8F,0x00
F5E1: 2900    		defw	41		; Message length
F5E3: 11      		defb	0x11		; Cmd: RENAME
F5E4: 13      		defb	19		; File name #1 length
F5E5: 58585858	ns_m7n0:defs	19,'X'		; File name #1 field
F5E9: 58...   	
F5F8: 13      		defb	19		; File name #2 length
F5F9: 58585858	ns_m7n1:defs	19,'X'		; File name #2 field
F5FD: 58...   	
              	#include "../dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F60C: B7      	prtdev:	or	a
F60D: 2808    		jr	z,pr_init
F60F: 3D      		dec	a
F610: 2806    		jr	z,pr_stat
F612: 3D      		dec	a
F613: 2805    		jr	z,pr_read
F615: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F617: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F618: AF      	pr_stat:xor	a
F619: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F61A: AF      	pr_read:xor	a
F61B: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F61C: 3E0F    	pr_writ:ld	a,0x0F
F61E: D341    		out	(pr_atla),a	; AY register = 15
              		
F620: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F622: E610    		and	0x10
F624: 20FA    		jr	nz,pr_wri0
              		
F626: 79      		ld	a,c
F627: D3B0    		out	(pr_prnt),a	; Write data
              		
F629: 3E05    		ld	a,0x05		; Strobe
F62B: D300    		out	(pr_ctrl),a
              		
F62D: 0620    		ld	b,32		
F62F: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
F631: 3E01    		ld	a,0x01		; Strobe off
F633: D300    		out	(pr_ctrl),a
              		
F635: C9      		ret
              		
              	#include "../dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
F636: B7      	siodev:	or	a
F637: 2808    		jr	z,so_init
F639: 3D      		dec	a
F63A: 2833    		jr	z,so_stat
F63C: 3D      		dec	a
F63D: 2841    		jr	z,so_read
F63F: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
F641: 11A6F6  	so_init:ld	de,so_atab
F644: 45      		ld	b,l
F645: 04      		inc	b		; Slot 1,2,3,...
F646: 19      		add	hl,de 		; Get address table entry
F647: 0ECF    		ld	c,0xCF		; First slot
              		
F649: ED78    	so_ini0:in	a,(c)
F64B: FE08    		cp	0x08
F64D: 2807    		jr	z,so_ini2
              		
F64F: 3E10    	so_ini1:ld	a,0x10
F651: 81      		add	c
F652: F0      		ret	p		; Can't find, failure
F653: 4F      		ld	c,a
F654: 18F3    		jr	so_ini0
              		
F656: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
F658: 79      		ld	a,c
F659: D60F    		sub	0x0F
F65B: 4F      		ld	c,a
F65C: 71      		ld	(hl),c
F65D: 11AAF6  		ld	de,so_conf
F660: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
F662: 1A      	so_ini3:ld	a,(de)
F663: 13      		inc	de
F664: 86      		add	a,(hl)
F665: 4F      		ld	c,a
F666: 1A      		ld	a,(de)
F667: 13      		inc	de
F668: ED79    		out	(c),a
F66A: E5      		push	hl
F66B: E1      		pop	hl	; Small delay
F66C: 10F4    		djnz	so_ini3
F66E: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F66F: 11A6F6  	so_stat:ld	de,so_atab
F672: 19      		add	hl,de
F673: AF      		xor	a
F674: BE      		cp	(hl)
F675: C8      		ret	z	; No device, return 0
F676: 4E      		ld	c,(hl)
F677: 0C      		inc	c
F678: ED78    	so_sta0:in	a,(c)	; Check status register
F67A: E602    		and	0x02
F67C: C8      		ret	z
F67D: 3EFF    		ld	a,0xFF
F67F: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
F680: 11A6F6  	so_read:ld	de,so_atab
F683: 19      		add	hl,de
F684: AF      		xor	a
F685: BE      		cp	(hl)
F686: C8      		ret	z	; No device, return 0
F687: 4E      		ld	c,(hl)
F688: 0C      		inc	c
F689: CD78F6  	so_rea0:call	so_sta0	; Wait for a character
F68C: 28FB    		jr	z,so_rea0
F68E: 0D      		dec	c
F68F: ED78    		in	a,(c)
F691: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
F692: 41      	so_writ:ld	b,c
F693: 11A6F6  		ld	de,so_atab
F696: 19      		add	hl,de
F697: AF      		xor	a
F698: BE      		cp	(hl)
F699: C8      		ret	z	; No device, return 0
F69A: 4E      		ld	c,(hl)
F69B: 0C      		inc	c
F69C: ED78    	so_wri0:in	a,(c)
F69E: E601    		and	0x01
F6A0: 28FA    		jr	z,so_wri0
F6A2: 0D      		dec	c
F6A3: ED41    		out	(c),b
F6A5: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
F6A6: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
F6AA: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
F6AC: 0412    		defb	0x04,0x12
F6AE: 0400    		defb	0x04,0x00
F6B0: 0777    		defb	0x07,0x77	; Counter 2 setup
F6B2: 0512    		defb	0x05,0x12
F6B4: 0500    		defb	0x05,0x00
              		
F6B6: 0100    		defb	0x01,0x00	; 8251 setup
F6B8: 0100    		defb	0x01,0x00
F6BA: 0100    		defb	0x01,0x00
F6BC: 0100    		defb	0x01,0x00
F6BE: 0140    		defb	0x01,0x40
F6C0: 014E    		defb	0x01,0x4E
F6C2: 0137    		defb	0x01,0x37
              	#include "../dev/nabu_fdc.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F9A9: 00      	nf_io:	defs	1	; FDC address
F9AA: 00      	nf_r2ks:defs	1	; Temp storaged used in nf_r2k
              	
F9AB: 00      	nf_curd:defs	1	; Currently selected disk
F9AC: 00      	nf_subs:defs	1	; Current subsector
F9AD: 00      	nf_sync:defs	1	; Set if disk needs to be rehomed
F9AE: 00      	nf_inco:defs	1	; Set if sector is in core already
F9AF: 00      	nf_dirt:defs	1	; Set if cache is dirty
              	
F9B0: 00000000	nf_asva:defs	26	; Misc CP/M buffer
F9B4: 00...   	
F9CA: 00000000	nf_asvb:defs	26
F9CE: 00...   	
F9E4: 00000000	nf_csva:defs	15
F9E8: 00...   	
F9F3: 00000000	nf_csvb:defs	15
F9F7: 00...   	
              	
FA02: 00000000	nf_cach:defs	1024	; Sector cache
FA06: 00...   	
              	.area	_TEXT
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              				
0040:         	nf_ayda	equ	0x40	; AY-3-8910 data port
0041:         	nf_atla	equ	0x41	; AY-3-8910 latch port
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F6C4:         	nf_dpha:
F6C4: 00000000		defw	0,0,0,0
F6C8: 00000000	
F6CC: 10FF    		defw	dircbuf	; DIRBUF
F6CE: E4F6    		defw	nf_dpb	; DPB
F6D0: E4F9    		defw	nf_csva	; CSV
F6D2: B0F9    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F6D4:         	nf_dphb:
F6D4: 00000000		defw	0,0,0,0
F6D8: 00000000	
F6DC: 10FF    		defw	dircbuf	; DIRBUF
F6DE: E4F6    		defw	nf_dpb	; DPB
F6E0: F3F9    		defw	nf_csvb	; CSV
F6E2: CAF9    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F6E4:         	nf_dpb:
F6E4: 2800    		defw	40	; # sectors per track
F6E6: 03      		defb	3	; BSH
F6E7: 07      		defb	7	; BLM
F6E8: 00      		defb	0	; EXM
F6E9: B800    		defw	184	; DSM
F6EB: 3F00    		defw	63	; DRM
F6ED: C0      		defb	0xC0	; AL0
F6EE: 00      		defb	0	; AL1
F6EF: 1000    		defw	16	; Size of directory check vector
F6F1: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F6F3: B7      	nfddev:	or	a
F6F4: 2815    		jr	z,nf_init
F6F6: 3D      		dec	a
F6F7: 283D    		jr	z,nf_home
F6F9: 3D      		dec	a
F6FA: 2852    		jr	z,nf_sel
F6FC: 3D      		dec	a
F6FD: CAA2F7  		jp	z,nf_strk
F700: 3D      		dec	a
F701: CAD8F7  		jp	z,nf_ssec
F704: 3D      		dec	a
F705: CA29F8  		jp	z,nf_read
F708: C331F8  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F70B: AF      	nf_init:xor	a
F70C: 32A9F9  		ld	(nf_io),a
              	
              		; Look for the FDC
F70F: 0ECF    		ld	c,0xCF
F711: ED78    	nf_ini1:in	a,(c)
F713: FE10    		cp	0x10
F715: 2808    		jr	z,nf_ini2
F717: 0C      		inc	c
F718: C8      		ret	z	; Should not be possible!
F719: 3E0F    		ld	a,0x0F
F71B: 81      		add	a,c
F71C: 4F      		ld	c,a
F71D: 18F2    		jr	nf_ini1
              		
              		; Get command register
F71F: 79      	nf_ini2:ld	a,c
F720: D60F    		sub	15
F722: 4F      		ld	c,a
F723: 32A9F9  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F726: CB25    		sla	l
F728: 3E02    		ld	a,2
F72A: 85      		add	l
F72B: 32ABF9  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F72E: 3ED0    		ld	a,0xD0
F730: ED79    		out	(c),a
              		
              		; Re-home drive
F732: CD36F7  		call	nf_home
              		
              		; De-select drive
              		
F735: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F736: CD49F8  	nf_home:call	nf_wdef
F739: CDFCF8  		call	nf_dvsc
              	
F73C: 3AA9F9  		ld	a,(nf_io)
F73F: 4F      		ld	c,a
              		
              		; Restore to track 0
F740: 3E09    		ld	a,0x09
F742: ED79    		out	(c),a 
F744: CD13F9  		call	nf_busy
              		
              		; Reset sync flag
F747: AF      		xor	a
F748: 32ADF9  		ld	(nf_sync),a
              		
              		; De-select drive
F74B: C301F9  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F74E: 3AA9F9  	nf_sel:	ld	a,(nf_io)
F751: B7      		or	a
F752: FA59F7  		jp	m,nf_seld
              		
              		; no FDC card
F755: 210000  		ld	hl,0
F758: C9      		ret
              	
F759: 7D      	nf_seld:ld	a,l		; Select a disk
F75A: 0602    		ld	b,2
F75C: B7      		or	a
F75D: 2809    		jr	z,nf_sel0
F75F: 3D      		dec	a
F760: 0604    		ld	b,4
F762: 2804    		jr	z,nf_sel0
F764: 210000  		ld	hl,0
F767: C9      		ret
              	
              		; Move control of drive buffers
F768: CD49F8  	nf_sel0:call	nf_wdef		; Write back if needed
F76B: 3EFF    		ld	a,0xFF
F76D: 32ADF9  		ld	(nf_sync),a	; Set sync flag
F770: 78      		ld	a,b
F771: 32ABF9  		ld	(nf_curd),a	; Set current drive
F774: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F775: 16FF    	nf_selc	ld	d,255
F777: CDFCF8  		call	nf_dvsc
F77A: 3AA9F9  		ld	a,(nf_io)
F77D: 4F      		ld	c,a
F77E: 3ED0    		ld	a,0xD0
F780: ED79    		out	(c),a		; Force FDC interrupt
F782: CD19F9  	nf_sel1:call	nf_stal
F785: ED78    		in	a,(c)
F787: E602    		and	0x02
F789: 2009    		jr	nz,nf_sel2
F78B: 15      		dec	d
F78C: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F78E: 210000  		ld	hl,0
F791: C301F9  		jp	nf_udsl
              		
              		
              		; Output DPH
F794: CD01F9  	nf_sel2:call	nf_udsl
F797: 21C4F6  		ld	hl,nf_dpha
F79A: 3E02    		ld	a,2
F79C: BB      		cp	e
F79D: C8      		ret	z
F79E: 21D4F6  		ld	hl,nf_dphb
F7A1: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F7A2: 51      	nf_strk:ld	d,c		; Track = d
F7A3: 3AA9F9  		ld	a,(nf_io)
F7A6: 4F      		ld	c,a
F7A7: 3AADF9  		ld	a,(nf_sync)
F7AA: B7      		or	a
F7AB: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F7AD: CDFCF8  		call	nf_dvsc
              		
              		; Restore to track 0
F7B0: 3E09    		ld	a,0x09
F7B2: ED79    		out	(c),a 
F7B4: CD13F9  		call	nf_busy
              		
              		; Reset sync flag
F7B7: AF      		xor	a
F7B8: 32ADF9  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F7BB: 59      	nf_str0:ld	e,c
F7BC: 0C      		inc	c
F7BD: ED78    		in	a,(c)
F7BF: BA      		cp	d
F7C0: CA01F9  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F7C3: CD49F8  		call	nf_wdef
              	
              		; Seek to track
F7C6: CDFCF8  		call	nf_dvsc
F7C9: 0C      		inc	c
F7CA: 0C      		inc	c
F7CB: ED51    		out	(c),d
F7CD: 3E19    		ld	a,0x19
F7CF: 4B      		ld	c,e
F7D0: ED79    		out	(c),a 
F7D2: CD13F9  		call	nf_busy	
              		
F7D5: C301F9  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F7D8: 79      	nf_ssec:ld	a,c
F7D9: E607    		and	0x07
F7DB: 32ACF9  		ld	(nf_subs),a
F7DE: 79      		ld	a,c
              		
              		; Compute physical sector
F7DF: CB3F    		srl	a
F7E1: CB3F    		srl	a
F7E3: CB3F    		srl	a
F7E5: 3C      		inc	a
F7E6: 47      		ld	b,a	; b = Physical sector
F7E7: 3AA9F9  		ld	a,(nf_io)
F7EA: 3C      		inc	a
F7EB: 3C      		inc	a
F7EC: 4F      		ld	c,a
F7ED: ED78    		in	a,(c)
F7EF: B8      		cp	b
F7F0: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F7F1: CD49F8  		call	nf_wdef
F7F4: ED41    		out	(c),b
F7F6: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F7F7: 3AAEF9  	nf_rdwr:ld	a,(nf_inco)
F7FA: B7      		or	a
F7FB: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F7FD: CDFCF8  		call	nf_dvsc
F800: 3AA9F9  		ld	a,(nf_io)
F803: 4F      		ld	c,a
F804: 2102FA  		ld	hl,nf_cach
F807: CDDAF8  		call	nf_rphy
F80A: 47      		ld	b,a
F80B: CD01F9  		call	nf_udsl
F80E: 78      		ld	a,b
              		
              		; Error checking
F80F: B7      		or	a
F810: 3E01    		ld	a,1
F812: C0      		ret	nz
F813: 32AEF9  		ld	(nf_inco),a
              		
              		; DMA subsector
F816: 2A49EB  	nf_rdw0:ld	hl,(biodma)
F819: EB      		ex	de,hl
              	
F81A: 3AACF9  		ld	a,(nf_subs)
F81D: 2182F9  		ld	hl,nf_cach-128
F820: 018000  		ld	bc,128
F823: 3C      		inc	a
F824: 09      	nf_rdw1:add	hl,bc
F825: 3D      		dec	a
F826: 20FC    		jr	nz,nf_rdw1
F828: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F829: CDF7F7  	nf_read:call	nf_rdwr
F82C: B7      		or	a
F82D: C0      		ret	nz
F82E: EDB0    		ldir
F830: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F831: C5      	nf_writ:push	bc
F832: CDF7F7  		call	nf_rdwr
F835: B7      		or	a
F836: C1      		pop	bc
F837: C0      		ret	nz
F838: 3E01    		ld	a,1
F83A: 32AFF9  		ld	(nf_dirt),a
F83D: 79      		ld	a,c
F83E: 018000  		ld	bc,128
F841: EB      		ex	de,hl
F842: EDB0    		ldir
F844: FE01    		cp	1
F846: 3E00    		ld	a,0
F848: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F849: 3AAFF9  	nf_wdef:ld	a,(nf_dirt)
F84C: B7      		or	a
F84D: 283D    		jr	z,nf_wde4
              	
F84F: C5      		push	bc
F850: D5      		push	de
F851: E5      		push	hl
              		
              		
              		; Write physical sector
F852: CD1EF9  		call	nf_dint
F855: CDFCF8  		call	nf_dvsc
F858: 3AA9F9  		ld	a,(nf_io)
F85B: 4F      		ld	c,a
F85C: C603    		add	a,3
F85E: 57      		ld	d,a
F85F: 59      		ld	e,c
F860: 3EA8    		ld	a,0xA8		; Write command
F862: ED79    		out	(c),a
F864: 2102FA  		ld	hl,nf_cach
F867: ED78    	nf_wde1:in	a,(c)
F869: 1F      		rra	
F86A: 3009    		jr	nc,nf_wde2
F86C: 1F      		rra
F86D: 30F8    		jr	nc,nf_wde1
F86F: 4A      		ld	c,d
F870: EDA3    		outi 
F872: 4B      		ld	c,e
F873: 18F2    		jr	nf_wde1
F875: CD27F9  	nf_wde2:call	nf_eint
F878: ED78    		in	a,(c)
              		
              		; Deselect drive
F87A: 47      		ld	b,a
F87B: CD01F9  		call	nf_udsl
F87E: 78      		ld	a,b
              		
F87F: E1      		pop	hl
F880: D1      		pop	de
F881: C1      		pop	bc
              		
              		; Error checking
F882: E6FC    		and	0xFC
F884: 2803    		jr	z,nf_wde3
              		
F886: 3E01    		ld	a,1
F888: C9      		ret
              		
              		; Cache is no longer dirty
F889: 32AFF9  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F88C: AF      	nf_wde4:xor	a
F88D: 32AEF9  		ld	(nf_inco),a
              		
F890: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F891: 3E02    	nf_grb:	ld	a,2
F893: 32AAF9  		ld	(nf_r2ks),a
F896: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F898: 3E04    	nf_ccp:	ld	a,4
F89A: 32AAF9  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F89D: 3E02    	nf_r2k: ld	a,nf_rdsk
F89F: CD02F9  		call	nf_dvsl
              		
              		; Restore to track 0
F8A2: 3AA9F9  		ld	a,(nf_io)
F8A5: 4F      		ld	c,a
F8A6: 3E09    		ld	a,0x09
F8A8: ED79    		out	(c),a 
F8AA: CD13F9  		call	nf_busy
              		
              		; Set sector # to 4
F8AD: 3AAAF9  		ld	a,(nf_r2ks)
F8B0: 0C      		inc	c
F8B1: 0C      		inc	c
F8B2: ED79    		out	(c),a
F8B4: C5      		push	bc
F8B5: 0D      		dec	c
F8B6: 0D      		dec	c
              		
              		; Read into memory
F8B7: 2100D4  		ld	hl,cbase
F8BA: CDDAF8  		call	nf_rphy
F8BD: C1      		pop	bc
F8BE: B7      		or	a
F8BF: 2805    		jr	z,nf_r2k0
F8C1: CD0BF7  		call	nf_init		; Error!
F8C4: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F8C6: ED78    	nf_r2k0:in	a,(c)
F8C8: 3C      		inc	a
F8C9: ED79    		out	(c),a
F8CB: 0D      		dec	c
F8CC: 0D      		dec	c
              		
              		; Read into memory again
F8CD: CDDAF8  		call	nf_rphy
F8D0: B7      		or	a
F8D1: C8      		ret	z
F8D2: CD0BF7  		call	nf_init		; Error!
F8D5: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F8D7: C301F9  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F8DA: CD1EF9  	nf_rphy:call	nf_dint
F8DD: 51      		ld	d,c
F8DE: 59      		ld	e,c
F8DF: 14      		inc	d
F8E0: 14      		inc	d
F8E1: 14      		inc	d
              		
              		; Read command
F8E2: 3E88    		ld	a,0x88
F8E4: ED79    		out	(c),a
F8E6: ED78    	nf_rph1:in	a,(c)
F8E8: 1F      		rra	
F8E9: 3009    		jr	nc,nf_rph2
F8EB: 1F      		rra
F8EC: 30F8    		jr	nc,nf_rph1
F8EE: 4A      		ld	c,d
F8EF: EDA2    		ini
F8F1: 4B      		ld	c,e
F8F2: 18F2    		jr	nf_rph1
F8F4: CD27F9  	nf_rph2:call	nf_eint
F8F7: ED78    		in	a,(c)
F8F9: E6FC    		and	0xFC
F8FB: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F8FC: 3AABF9  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F8FF: 1801    		jr	nf_dvsl
F901: AF      	nf_udsl:xor	a		; Unselects a drive
F902: C5      	nf_dvsl:push	bc
F903: 47      		ld	b,a
F904: 3AA9F9  		ld	a,(nf_io)
F907: C60F    		add	a,0x0F
F909: 4F      		ld	c,a
F90A: ED41    		out	(c),b
F90C: 06FF    		ld	b,0xFF
F90E: CD19F9  		call	nf_stal
F911: C1      		pop	bc
F912: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F913: ED78    	nf_busy:in	a,(c)
F915: 1F      		rra
F916: 38FB    		jr	c,nf_busy
F918: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F919: C5      	nf_stal:push	bc
F91A: C1      		pop	bc
F91B: 10FC    		djnz	nf_stal
F91D: C9      		ret
              		
              	; Disables all interrupts while FDC operations occur
              	;
              	; uses: a
F91E: 3E0E    	nf_dint:ld	a,0x0E
F920: D341    		out	(nf_atla),a	; AY register = 14
F922: 3E00    		ld	a,0x00
F924: D340    		out	(nf_ayda),a	
F926: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
F927: 3E0E    	nf_eint:ld	a,0x0E
F929: D341    		out	(nf_atla),a	; AY register = 14
F92B: 3EB0    		ld	a,0xB0
F92D: D340    		out	(nf_ayda),a
F92F: C9      		ret


; +++ segments +++

#CODE _TEXT        = $D400 = 54272,  size = $2530 =  9520
#DATA _BSS         = $F930 = 63792,  size = $04D2 =  1234
#DATA _JUMP_TABLE  = $FF00 = 65280,  size = $0090 =   144

; +++ global symbols +++

_BSS             = $F930 = 63792  _BSS        config_nfs_hybrid.asm:44 (unused)
_BSS_end         = $FE02 = 65026  _BSS        config_nfs_hybrid.asm:44 (unused)
_BSS_size        = $04D2 =  1234  _BSS        config_nfs_hybrid.asm:44
_JUMP_TABLE      = $FF00 = 65280  _JUMP_TABLE config_nfs_hybrid.asm:45 (unused)
_JUMP_TABLE_end  = $FF90 = 65424  _JUMP_TABLE config_nfs_hybrid.asm:45 (unused)
_JUMP_TABLE_size = $0090 =   144  _JUMP_TABLE config_nfs_hybrid.asm:45 (unused)
_TEXT            = $D400 = 54272  _TEXT       config_nfs_hybrid.asm:43 (unused)
_TEXT_end        = $F930 = 63792  _TEXT       config_nfs_hybrid.asm:43
_TEXT_size       = $2530 =  9520  _TEXT       config_nfs_hybrid.asm:43 (unused)
active           = $DF4D = 57165  _TEXT       CPM22.asm:1726
adda2hl          = $E16F = 57711  _TEXT       CPM22.asm:2155
addhl            = $D661 = 54881  _TEXT       CPM22.asm:442
alloc0           = $E9D5 = 59861  _TEXT       CPM22.asm:3703
alloc1           = $E9D7 = 59863  _TEXT       CPM22.asm:3704
alocvect         = $E9CA = 59850  _TEXT       CPM22.asm:3693
auto             = $E9E9 = 59881  _TEXT       CPM22.asm:3718
autoflag         = $E9EB = 59883  _TEXT       CPM22.asm:3720
autosel          = $E85C = 59484  _TEXT       CPM22.asm:3433
autosl1          = $E880 = 59520  _TEXT       CPM22.asm:3449
backup           = $DDAF = 56751  _TEXT       CPM22.asm:1486
backup1          = $DDB7 = 56759  _TEXT       CPM22.asm:1489
badload          = $DB77 = 56183  _TEXT       CPM22.asm:1206
badsctr          = $DC0C = 56332  _TEXT       CPM22.asm:1267
badsec           = $DCD5 = 56533  _TEXT       CPM22.asm:1341
badsel           = $DCE0 = 56544  _TEXT       CPM22.asm:1342
badslct          = $DC0E = 56334  _TEXT       CPM22.asm:1268
batch            = $DBB8 = 56248  _TEXT       CPM22.asm:1239
batchfcb         = $DBB9 = 56249  _TEXT       CPM22.asm:1240
bdevsw           = $EB6C = 60268  _TEXT       config_nfs_hybrid.asm:160
bdosdrv          = $DCD1 = 56529  _TEXT       CPM22.asm:1340
bdoserr          = $DCC5 = 56517  _TEXT       CPM22.asm:1339
bigdisk          = $E9E8 = 59880  _TEXT       CPM22.asm:3717
biodma           = $EB49 = 60233  _TEXT       bios.asm:326
bitmap           = $E2AE = 58030  _TEXT       CPM22.asm:2448
bitmap1          = $E2BC = 58044  _TEXT       CPM22.asm:2463
bitmap2          = $E2DD = 58077  _TEXT       CPM22.asm:2484
bitmap3          = $E301 = 58113  _TEXT       CPM22.asm:2501
blkmask          = $E9CF = 59855  _TEXT       CPM22.asm:3699
blknmbr          = $E9F0 = 59888  _TEXT       CPM22.asm:3724
blkshft          = $E9CE = 59854  _TEXT       CPM22.asm:3698
boot             = $EA3A = 59962  _TEXT       bios.asm:42
bs               = $0008 =     8  _TEXT       CPM22.asm:31
callbd           = $EAF8 = 60152  _TEXT       bios.asm:225
callmj           = $EB46 = 60230  _TEXT       bios.asm:320
cbase            = $D400 = 54272  _TEXT       CPM22.asm:44
cbinit           = $EB5A = 60250  _TEXT       config_nfs_hybrid.asm:91
ccpstack         = $DBB8 = 56248  _TEXT       CPM22.asm:1235
cdevsw           = $EBAC = 60332  _TEXT       config_nfs_hybrid.asm:199
cdindi0          = $EB1E = 60190  _TEXT       bios.asm:285
cdindi1          = $EB24 = 60196  _TEXT       bios.asm:289
cdindir          = $EB1A = 60186  _TEXT       bios.asm:283
cdrive           = $DBFC = 56316  _TEXT       CPM22.asm:1246
cfirq            = $EB60 = 60256  _TEXT       config_nfs_hybrid.asm:107 (unused)
charbuf          = $DF19 = 57113  _TEXT       CPM22.asm:1715
check            = $D638 = 54840  _TEXT       CPM22.asm:408
checkdir         = $E1A9 = 57769  _TEXT       CPM22.asm:2228
checksum         = $E102 = 57602  _TEXT       CPM22.asm:2067
chgdrv           = $DBFD = 56317  _TEXT       CPM22.asm:1247
chgnam1          = $E432 = 58418  _TEXT       CPM22.asm:2740
chgnames         = $E421 = 58401  _TEXT       CPM22.asm:2732
chkblk           = $E08F = 57487  _TEXT       CPM22.asm:1974
chkchar          = $DD1F = 56607  _TEXT       CPM22.asm:1383
chkcon           = $D5CA = 54730  _TEXT       CPM22.asm:333
chkdir1          = $E1CF = 57807  _TEXT       CPM22.asm:2248
chknmbr          = $E197 = 57751  _TEXT       CPM22.asm:2201
chkrofl          = $E14F = 57679  _TEXT       CPM22.asm:2131
chksum1          = $E108 = 57608  _TEXT       CPM22.asm:2070
chkvect          = $E9C8 = 59848  _TEXT       CPM22.asm:3692
chkwprt          = $E15F = 57695  _TEXT       CPM22.asm:2142
chrout           = $EABB = 60091  _TEXT       bios.asm:166
ckbitmap         = $E240 = 57920  _TEXT       CPM22.asm:2342
ckbmap1          = $E261 = 57953  _TEXT       CPM22.asm:2377
ckcon1           = $DD4D = 56653  _TEXT       CPM22.asm:1413
ckcon2           = $DD50 = 56656  _TEXT       CPM22.asm:1414
ckconsol         = $DD2E = 56622  _TEXT       CPM22.asm:1399
ckfilpos         = $E200 = 57856  _TEXT       CPM22.asm:2291
ckrof1           = $E152 = 57682  _TEXT       CPM22.asm:2132
cksumtbl         = $E9F7 = 59895  _TEXT       CPM22.asm:3732
clearbuf         = $D760 = 55136  _TEXT       CPM22.asm:608
clears2          = $E17D = 57725  _TEXT       CPM22.asm:2172
close            = $D4D9 = 54489  _TEXT       CPM22.asm:138
closefil         = $E8B0 = 59568  _TEXT       CPM22.asm:3480
closeflg         = $E9DD = 59869  _TEXT       CPM22.asm:3709
closeit          = $E4AD = 58541  _TEXT       CPM22.asm:2826
closeit1         = $E4D8 = 58584  _TEXT       CPM22.asm:2846
closeit2         = $E4E6 = 58598  _TEXT       CPM22.asm:2854
closeit3         = $E4EC = 58604  _TEXT       CPM22.asm:2858
closeit4         = $E4F3 = 58611  _TEXT       CPM22.asm:2861
closeit5         = $E508 = 58632  _TEXT       CPM22.asm:2874
closeit6         = $E522 = 58658  _TEXT       CPM22.asm:2892
closeit7         = $E52A = 58666  _TEXT       CPM22.asm:2895
cmdadr           = $D7CE = 55246  _TEXT       CPM22.asm:685
cmdtbl           = $D718 = 55064  _TEXT       CPM22.asm:562
cmmnd1           = $D787 = 55175  _TEXT       CPM22.asm:643
cmmnd2           = $D7A5 = 55205  _TEXT       CPM22.asm:657
cntrlc           = $0003 =     3  _TEXT       CPM22.asm:29
cntrle           = $0005 =     5  _TEXT       CPM22.asm:30
cntrlp           = $0010 =    16  _TEXT       CPM22.asm:36
cntrlr           = $0012 =    18  _TEXT       CPM22.asm:37
cntrls           = $0013 =    19  _TEXT       CPM22.asm:38
cntrlu           = $0015 =    21  _TEXT       CPM22.asm:39
cntrlx           = $0018 =    24  _TEXT       CPM22.asm:40
cntrlz           = $001A =    26  _TEXT       CPM22.asm:41
comblk           = $E082 = 57474  _TEXT       CPM22.asm:1965
comfile          = $DB80 = 56192  _TEXT       CPM22.asm:1207
command          = $D764 = 55140  _TEXT       CPM22.asm:618
comprand         = $E7B0 = 59312  _TEXT       CPM22.asm:3299
conin            = $EAAD = 60077  _TEXT       bios.asm:153
conout           = $EAB9 = 60089  _TEXT       bios.asm:165
const            = $EAA2 = 60066  _TEXT       bios.asm:141
convert          = $D668 = 54888  _TEXT       CPM22.asm:456
convfst          = $D666 = 54886  _TEXT       CPM22.asm:450
convrt1          = $D691 = 54929  _TEXT       CPM22.asm:479
convrt2          = $D698 = 54936  _TEXT       CPM22.asm:482
convrt3          = $D69E = 54942  _TEXT       CPM22.asm:489
convrt4          = $D6A0 = 54944  _TEXT       CPM22.asm:490
convrt5          = $D6B1 = 54961  _TEXT       CPM22.asm:497
convrt6          = $D6B3 = 54963  _TEXT       CPM22.asm:499
convrt7          = $D6B7 = 54967  _TEXT       CPM22.asm:501
convrt8          = $D6C1 = 54977  _TEXT       CPM22.asm:505
counter          = $E9E3 = 59875  _TEXT       CPM22.asm:3715
cpmlow           = $EA9A = 60058  _TEXT       bios.asm:130
cr               = $000D =    13  _TEXT       CPM22.asm:35
create           = $D508 = 54536  _TEXT       CPM22.asm:188
crlf             = $D498 = 54424  _TEXT       CPM22.asm:80
curpos           = $DF17 = 57111  _TEXT       CPM22.asm:1713
de2hl            = $DF5A = 57178  _TEXT       CPM22.asm:1744
de2hl1           = $DF5B = 57179  _TEXT       CPM22.asm:1745
decode           = $D805 = 55301  _TEXT       CPM22.asm:712
decode1          = $D815 = 55317  _TEXT       CPM22.asm:718
decode2          = $D837 = 55351  _TEXT       CPM22.asm:738 (unused)
decode3          = $D840 = 55360  _TEXT       CPM22.asm:743
decode4          = $D847 = 55367  _TEXT       CPM22.asm:747 (unused)
default          = $0000 =     0              config_nfs_hybrid.asm:19
defdma           = $E1E5 = 57829  _TEXT       CPM22.asm:2266
del              = $007F =   127  _TEXT       CPM22.asm:42
delbatch         = $D5E5 = 54757  _TEXT       CPM22.asm:358
delete           = $D4EE = 54510  _TEXT       CPM22.asm:159
delfile          = $E8E2 = 59618  _TEXT       CPM22.asm:3511
dirbuf           = $E9C4 = 59844  _TEXT       CPM22.asm:3690
dirc1            = $DEEB = 57067  _TEXT       CPM22.asm:1671
dircbuf          = $FF10 = 65296  _JUMP_TABLE config_nfs_hybrid.asm:47
dircio           = $DEDF = 57055  _TEXT       CPM22.asm:1665
dirdma           = $E1EB = 57835  _TEXT       CPM22.asm:2271
dirdma1          = $E1EE = 57838  _TEXT       CPM22.asm:2276
direct           = $D884 = 55428  _TEXT       CPM22.asm:809
direct1          = $D895 = 55445  _TEXT       CPM22.asm:816
direct2          = $D89C = 55452  _TEXT       CPM22.asm:820
direct3          = $D8A5 = 55461  _TEXT       CPM22.asm:824
direct4          = $D8D9 = 55513  _TEXT       CPM22.asm:851
direct5          = $D8E1 = 55521  _TEXT       CPM22.asm:854
direct6          = $D8E6 = 55526  _TEXT       CPM22.asm:856
direct7          = $D91B = 55579  _TEXT       CPM22.asm:880
direct8          = $D91C = 55580  _TEXT       CPM22.asm:881
direct9          = $D928 = 55592  _TEXT       CPM22.asm:885
dirread          = $E1DF = 57823  _TEXT       CPM22.asm:2261
dirsize          = $E9D3 = 59859  _TEXT       CPM22.asm:3702
dirwrite         = $E1D1 = 57809  _TEXT       CPM22.asm:2253
diskpb           = $E9C6 = 59846  _TEXT       CPM22.asm:3691
diskro           = $DCEC = 56556  _TEXT       CPM22.asm:1344
dmaset           = $D5E0 = 54752  _TEXT       CPM22.asm:353
doread           = $DFBD = 57277  _TEXT       CPM22.asm:1815
dowrite          = $DFC3 = 57283  _TEXT       CPM22.asm:1820
drect63          = $D904 = 55556  _TEXT       CPM22.asm:870
drect65          = $D906 = 55558  _TEXT       CPM22.asm:871
dselect          = $D861 = 55393  _TEXT       CPM22.asm:779
dsksel           = $D4BC = 54460  _TEXT       CPM22.asm:112
dsksize          = $E9D1 = 59857  _TEXT       CPM22.asm:3701
emptyfcb         = $E9B7 = 59831  _TEXT       CPM22.asm:3677
entry            = $0005 =     5  _TEXT       CPM22.asm:22
entry1           = $D4C2 = 54466  _TEXT       CPM22.asm:119
entry2           = $D4F3 = 54515  _TEXT       CPM22.asm:165
eparam           = $E9E1 = 59873  _TEXT       CPM22.asm:3713
erafil1          = $E3AF = 58287  _TEXT       CPM22.asm:2618
erafile          = $E3A7 = 58279  _TEXT       CPM22.asm:2615
erase            = $D92C = 55596  _TEXT       CPM22.asm:894
erase1           = $D94F = 55631  _TEXT       CPM22.asm:909
error1           = $DC9F = 56479  _TEXT       CPM22.asm:1320
error2           = $DCAB = 56491  _TEXT       CPM22.asm:1326
error3           = $DCB1 = 56497  _TEXT       CPM22.asm:1329
error4           = $DCB7 = 56503  _TEXT       CPM22.asm:1332
error5           = $DCBA = 56506  _TEXT       CPM22.asm:1334
exists           = $DA8D = 55949  _TEXT       CPM22.asm:1071
extblk           = $E069 = 57449  _TEXT       CPM22.asm:1946
extblk1          = $E07C = 57468  _TEXT       CPM22.asm:1956
extmask          = $E9D0 = 59856  _TEXT       CPM22.asm:3700
extract          = $D858 = 55384  _TEXT       CPM22.asm:769
fbase            = $DC06 = 56326  _TEXT       CPM22.asm:1262
fbase1           = $DC14 = 56340  _TEXT       CPM22.asm:1275
fcb              = $DBDA = 56282  _TEXT       CPM22.asm:1244
fcb2hl           = $E169 = 57705  _TEXT       CPM22.asm:2150
fcbpos           = $E9F4 = 59892  _TEXT       CPM22.asm:3726
fcbset           = $E408 = 58376  _TEXT       CPM22.asm:2710
fcreate          = $E8F7 = 59639  _TEXT       CPM22.asm:3528
ff               = $000C =    12  _TEXT       CPM22.asm:34 (unused)
filepos          = $E9F5 = 59893  _TEXT       CPM22.asm:3727
filero           = $DCE7 = 56551  _TEXT       CPM22.asm:1343
filesize         = $E958 = 59736  _TEXT       CPM22.asm:3602
findfst          = $E323 = 58147  _TEXT       CPM22.asm:2535
findnxt          = $E338 = 58168  _TEXT       CPM22.asm:2548
fndnxt1          = $E355 = 58197  _TEXT       CPM22.asm:2561
fndnxt2          = $E35E = 58206  _TEXT       CPM22.asm:2565
fndnxt3          = $E37E = 58238  _TEXT       CPM22.asm:2581
fndnxt4          = $E387 = 58247  _TEXT       CPM22.asm:2590
fndnxt5          = $E38E = 58254  _TEXT       CPM22.asm:2595
fndnxt6          = $E39F = 58271  _TEXT       CPM22.asm:2608
fndspa1          = $E3CB = 58315  _TEXT       CPM22.asm:2648
fndspa2          = $E3DC = 58332  _TEXT       CPM22.asm:2671
fndspa3          = $E3F7 = 58359  _TEXT       CPM22.asm:2692
fndspa4          = $E3FF = 58367  _TEXT       CPM22.asm:2702
fndspace         = $E3C9 = 58313  _TEXT       CPM22.asm:2642
fndstat          = $E9DF = 59871  _TEXT       CPM22.asm:3711
functns          = $DC4D = 56397  _TEXT       CPM22.asm:1311
getaloc          = $E91C = 59676  _TEXT       CPM22.asm:3556
getback          = $DB83 = 56195  _TEXT       CPM22.asm:1213
getback1         = $DB86 = 56198  _TEXT       CPM22.asm:1214
getblk1          = $E050 = 57424  _TEXT       CPM22.asm:1924
getblk2          = $E05E = 57438  _TEXT       CPM22.asm:1933
getblk3          = $E067 = 57447  _TEXT       CPM22.asm:1938
getblock         = $E049 = 57417  _TEXT       CPM22.asm:1921
getchar          = $DD06 = 56582  _TEXT       CPM22.asm:1361
getcon           = $DED3 = 57043  _TEXT       CPM22.asm:1653
getcrnt          = $E90F = 59663  _TEXT       CPM22.asm:3545
getcsts          = $DF09 = 57097  _TEXT       CPM22.asm:1698
getdsk           = $D5D8 = 54744  _TEXT       CPM22.asm:344
getecho          = $DD11 = 56593  _TEXT       CPM22.asm:1370
getempty         = $E52F = 58671  _TEXT       CPM22.asm:2902
getext           = $D6C8 = 54984  _TEXT       CPM22.asm:512
getext1          = $D6D0 = 54992  _TEXT       CPM22.asm:516
getext2          = $D6E1 = 55009  _TEXT       CPM22.asm:523
getext3          = $D6E3 = 55011  _TEXT       CPM22.asm:525
getext4          = $D6E7 = 55015  _TEXT       CPM22.asm:527
getext5          = $D6F1 = 55025  _TEXT       CPM22.asm:531
getext6          = $D6F8 = 55032  _TEXT       CPM22.asm:535
getext7          = $D6FA = 55034  _TEXT       CPM22.asm:536
getext8          = $D709 = 55049  _TEXT       CPM22.asm:548
getext9          = $D711 = 55057  _TEXT       CPM22.asm:553
getfst           = $E8B6 = 59574  _TEXT       CPM22.asm:3487
getfst1          = $E8CD = 59597  _TEXT       CPM22.asm:3498
getinp           = $D538 = 54584  _TEXT       CPM22.asm:239
getinp0          = $D554 = 54612  _TEXT       CPM22.asm:255
getinp1          = $D5A0 = 54688  _TEXT       CPM22.asm:305
getinp2          = $D5B1 = 54705  _TEXT       CPM22.asm:314
getinp3          = $D5B5 = 54709  _TEXT       CPM22.asm:316
getinp4          = $D5C2 = 54722  _TEXT       CPM22.asm:325
getiob           = $DEF8 = 57080  _TEXT       CPM22.asm:1679
getlog           = $E909 = 59657  _TEXT       CPM22.asm:3540
getmt1           = $E551 = 58705  _TEXT       CPM22.asm:2918
getnext          = $E565 = 58725  _TEXT       CPM22.asm:2932
getnxt           = $E8D3 = 59603  _TEXT       CPM22.asm:3503
getparm          = $E931 = 59697  _TEXT       CPM22.asm:3573
getprm1          = $E934 = 59700  _TEXT       CPM22.asm:3574
getrdr           = $DED9 = 57049  _TEXT       CPM22.asm:1658
getrov           = $E922 = 59682  _TEXT       CPM22.asm:3561
gets2            = $E174 = 57716  _TEXT       CPM22.asm:2164
getsetuc         = $D514 = 54548  _TEXT       CPM22.asm:204
getuser          = $E938 = 59704  _TEXT       CPM22.asm:3581
getusr           = $D512 = 54546  _TEXT       CPM22.asm:199
getver           = $E889 = 59529  _TEXT       CPM22.asm:3457
getwprt          = $E129 = 57641  _TEXT       CPM22.asm:2104
goback           = $E97F = 59775  _TEXT       CPM22.asm:3637
goback1          = $E99C = 59804  _TEXT       CPM22.asm:3649
gtnext1          = $E58E = 58766  _TEXT       CPM22.asm:2952
gtnext2          = $E599 = 58777  _TEXT       CPM22.asm:2961
gtnext3          = $E5B7 = 58807  _TEXT       CPM22.asm:2972
gtnext4          = $E5BA = 58810  _TEXT       CPM22.asm:2973
gtnext5          = $E5C1 = 58817  _TEXT       CPM22.asm:2980
halt             = $D7DC = 55260  _TEXT       CPM22.asm:690
hl2de            = $D84F = 55375  _TEXT       CPM22.asm:759
home             = $EADB = 60123  _TEXT       bios.asm:199
homedrv          = $DFAC = 57260  _TEXT       CPM22.asm:1801
inbuff           = $D406 = 54278  _TEXT       CPM22.asm:51
inpoint          = $D488 = 54408  _TEXT       CPM22.asm:60
intvec           = $FF00 = 65280  _JUMP_TABLE config_nfs_hybrid.asm:46
iobyte           = $0003 =     3  _TEXT       CPM22.asm:20
ioerr1           = $DF10 = 57104  _TEXT       CPM22.asm:1708
ioret            = $DFC6 = 57286  _TEXT       CPM22.asm:1821
jumphl           = $DF55 = 57173  _TEXT       CPM22.asm:1736
lf               = $000A =    10  _TEXT       CPM22.asm:33
list             = $EAC5 = 60101  _TEXT       bios.asm:176
logical          = $E095 = 57493  _TEXT       CPM22.asm:1985
logicl1          = $E09B = 57499  _TEXT       CPM22.asm:1987
login            = $E9BA = 59834  _TEXT       CPM22.asm:3679
logindrv         = $E82C = 59436  _TEXT       CPM22.asm:3401
logoff           = $E95E = 59742  _TEXT       CPM22.asm:3611
logsect          = $E9F2 = 59890  _TEXT       CPM22.asm:3725
mem              = $0035 =    53              config_nfs_hybrid.asm:38
mode             = $E9E0 = 59872  _TEXT       CPM22.asm:3712
morefls          = $E18A = 57738  _TEXT       CPM22.asm:2188
move3            = $D84D = 55373  _TEXT       CPM22.asm:755
movecd           = $D528 = 54568  _TEXT       CPM22.asm:221
movedir          = $E1F4 = 57844  _TEXT       CPM22.asm:2283
moveword         = $E49F = 58527  _TEXT       CPM22.asm:2809
namepnt          = $D48A = 54410  _TEXT       CPM22.asm:61
nbytes           = $DBFE = 56318  _TEXT       CPM22.asm:1248
newline          = $DDBC = 56764  _TEXT       CPM22.asm:1495
newln1           = $DDC4 = 56772  _TEXT       CPM22.asm:1498
nf_asva          = $F9B0 = 63920  _BSS        nabu_fdc.asm:34
nf_asvb          = $F9CA = 63946  _BSS        nabu_fdc.asm:35
nf_atla          = $0041 =    65  _TEXT       nabu_fdc.asm:46
nf_ayda          = $0040 =    64  _TEXT       nabu_fdc.asm:45
nf_busy          = $F913 = 63763  _TEXT       nabu_fdc.asm:532
nf_cach          = $FA02 = 64002  _BSS        nabu_fdc.asm:39
nf_ccp           = $F898 = 63640  _TEXT       nabu_fdc.asm:428 (unused)
nf_csva          = $F9E4 = 63972  _BSS        nabu_fdc.asm:36
nf_csvb          = $F9F3 = 63987  _BSS        nabu_fdc.asm:37
nf_curd          = $F9AB = 63915  _BSS        nabu_fdc.asm:28
nf_dint          = $F91E = 63774  _TEXT       nabu_fdc.asm:548
nf_dirt          = $F9AF = 63919  _BSS        nabu_fdc.asm:32
nf_dpb           = $F6E4 = 63204  _TEXT       nabu_fdc.asm:73
nf_dpha          = $F6C4 = 63172  _TEXT       nabu_fdc.asm:57
nf_dphb          = $F6D4 = 63188  _TEXT       nabu_fdc.asm:65
nf_dvsc          = $F8FC = 63740  _TEXT       nabu_fdc.asm:513
nf_dvsl          = $F902 = 63746  _TEXT       nabu_fdc.asm:516
nf_eint          = $F927 = 63783  _TEXT       nabu_fdc.asm:557
nf_grb           = $F891 = 63633  _TEXT       nabu_fdc.asm:423 (unused)
nf_home          = $F736 = 63286  _TEXT       nabu_fdc.asm:147
nf_inco          = $F9AE = 63918  _BSS        nabu_fdc.asm:31
nf_ini1          = $F711 = 63249  _TEXT       nabu_fdc.asm:111
nf_ini2          = $F71F = 63263  _TEXT       nabu_fdc.asm:122
nf_init          = $F70B = 63243  _TEXT       nabu_fdc.asm:106
nf_io            = $F9A9 = 63913  _BSS        nabu_fdc.asm:25
nf_r2k           = $F89D = 63645  _TEXT       nabu_fdc.asm:433
nf_r2k0          = $F8C6 = 63686  _TEXT       nabu_fdc.asm:462
nf_r2ks          = $F9AA = 63914  _BSS        nabu_fdc.asm:26
nf_rdsk          = $0002 =     2  _TEXT       nabu_fdc.asm:42
nf_rdw0          = $F816 = 63510  _TEXT       nabu_fdc.asm:322
nf_rdw1          = $F824 = 63524  _TEXT       nabu_fdc.asm:329
nf_rdwr          = $F7F7 = 63479  _TEXT       nabu_fdc.asm:301
nf_read          = $F829 = 63529  _TEXT       nabu_fdc.asm:335
nf_rph1          = $F8E6 = 63718  _TEXT       nabu_fdc.asm:495
nf_rph2          = $F8F4 = 63732  _TEXT       nabu_fdc.asm:504
nf_rphy          = $F8DA = 63706  _TEXT       nabu_fdc.asm:485
nf_sel           = $F74E = 63310  _TEXT       nabu_fdc.asm:170
nf_sel0          = $F768 = 63336  _TEXT       nabu_fdc.asm:189
nf_sel1          = $F782 = 63362  _TEXT       nabu_fdc.asm:203
nf_sel2          = $F794 = 63380  _TEXT       nabu_fdc.asm:216
nf_selc          = $F775 = 63349  _TEXT       nabu_fdc.asm:197 (unused)
nf_seld          = $F759 = 63321  _TEXT       nabu_fdc.asm:178
nf_ssec          = $F7D8 = 63448  _TEXT       nabu_fdc.asm:274
nf_stal          = $F919 = 63769  _TEXT       nabu_fdc.asm:540
nf_str0          = $F7BB = 63419  _TEXT       nabu_fdc.asm:248
nf_strk          = $F7A2 = 63394  _TEXT       nabu_fdc.asm:229
nf_subs          = $F9AC = 63916  _BSS        nabu_fdc.asm:29
nf_sync          = $F9AD = 63917  _BSS        nabu_fdc.asm:30
nf_udsl          = $F901 = 63745  _TEXT       nabu_fdc.asm:515
nf_wde1          = $F867 = 63591  _TEXT       nabu_fdc.asm:385
nf_wde2          = $F875 = 63605  _TEXT       nabu_fdc.asm:394
nf_wde3          = $F889 = 63625  _TEXT       nabu_fdc.asm:414
nf_wde4          = $F88C = 63628  _TEXT       nabu_fdc.asm:417
nf_wdef          = $F849 = 63561  _TEXT       nabu_fdc.asm:365
nf_writ          = $F831 = 63537  _TEXT       nabu_fdc.asm:343
nfddev           = $F6F3 = 63219  _TEXT       nabu_fdc.asm:90
nfsdev           = $EF6C = 61292  _TEXT       nabu_nfs.asm:73
nfuncts          = $0029 =    41  _TEXT       CPM22.asm:1309
nofile           = $D7FD = 55293  _TEXT       CPM22.asm:705
nonblank         = $D657 = 54871  _TEXT       CPM22.asm:432
none             = $D7F7 = 55287  _TEXT       CPM22.asm:703
nospace          = $DA14 = 55828  _TEXT       CPM22.asm:1013
ns_ace0          = $F1EC = 61932  _TEXT       nabu_nfs.asm:592
ns_ace1          = $F1F8 = 61944  _TEXT       nabu_nfs.asm:602
ns_aces          = $F1D9 = 61913  _TEXT       nabu_nfs.asm:579
ns_alv           = $EF6B = 61291  _TEXT       nabu_nfs.asm:67
ns_atla          = $0041 =    65  _TEXT       nabu_nfs.asm:31
ns_ayda          = $0040 =    64  _TEXT       nabu_nfs.asm:30
ns_buff          = $F95C = 63836  _BSS        nabu_nfs.asm:20
ns_ccp           = $EFCC = 61388  _TEXT       nabu_nfs.asm:163
ns_cfcb          = $F9A4 = 63908  _BSS        nabu_nfs.asm:24
ns_deco          = $F2D2 = 62162  _TEXT       nabu_nfs.asm:814
ns_del0          = $F1B5 = 61877  _TEXT       nabu_nfs.asm:550
ns_dele          = $F1A2 = 61858  _TEXT       nabu_nfs.asm:534
ns_dfl0          = $EFB3 = 61363  _TEXT       nabu_nfs.asm:139
ns_dflt          = $EFAB = 61355  _TEXT       nabu_nfs.asm:134
ns_dom0          = $F373 = 62323  _TEXT       nabu_nfs.asm:957
ns_domk          = $F36F = 62319  _TEXT       nabu_nfs.asm:955
ns_dore          = $F9A6 = 63910  _BSS        nabu_nfs.asm:25
ns_dpb           = $EF5C = 61276  _TEXT       nabu_nfs.asm:55
ns_dph           = $EF4C = 61260  _TEXT       nabu_nfs.asm:47
ns_dsnd          = $EFC2 = 61378  _TEXT       nabu_nfs.asm:156
ns_esnd          = $EFB8 = 61368  _TEXT       nabu_nfs.asm:147
ns_exit          = $F3A3 = 62371  _TEXT       nabu_nfs.asm:994
ns_fcls          = $F07C = 61564  _TEXT       nabu_nfs.asm:293
ns_ffm0          = $F149 = 61769  _TEXT       nabu_nfs.asm:455
ns_ffm1          = $F14C = 61772  _TEXT       nabu_nfs.asm:457
ns_ffmt          = $F13E = 61758  _TEXT       nabu_nfs.asm:449
ns_fild          = $0080 =   128  _TEXT       nabu_nfs.asm:35
ns_find          = $F0D2 = 61650  _TEXT       nabu_nfs.asm:355
ns_fmak          = $F2DA = 62170  _TEXT       nabu_nfs.asm:826
ns_fop0          = $F079 = 61561  _TEXT       nabu_nfs.asm:285
ns_fopn          = $F03C = 61500  _TEXT       nabu_nfs.asm:236
ns_for1          = $F506 = 62726  _TEXT       nabu_nfs.asm:1267
ns_for2          = $F516 = 62742  _TEXT       nabu_nfs.asm:1275
ns_for3          = $F521 = 62753  _TEXT       nabu_nfs.asm:1281
ns_for4          = $F531 = 62769  _TEXT       nabu_nfs.asm:1289
ns_form          = $F4FC = 62716  _TEXT       nabu_nfs.asm:1263
ns_fre0          = $F266 = 62054  _TEXT       nabu_nfs.asm:702
ns_fre1          = $F26E = 62062  _TEXT       nabu_nfs.asm:708
ns_fre2          = $F281 = 62081  _TEXT       nabu_nfs.asm:723
ns_frea          = $F25B = 62043  _TEXT       nabu_nfs.asm:691
ns_frn0          = $F321 = 62241  _TEXT       nabu_nfs.asm:886
ns_frnm          = $F301 = 62209  _TEXT       nabu_nfs.asm:862
ns_fwr0          = $F292 = 62098  _TEXT       nabu_nfs.asm:743
ns_fwri          = $F287 = 62087  _TEXT       nabu_nfs.asm:732
ns_gcre          = $F220 = 61984  _TEXT       nabu_nfs.asm:635
ns_get0          = $F3D5 = 62421  _TEXT       nabu_nfs.asm:1039
ns_get1          = $F3FE = 62462  _TEXT       nabu_nfs.asm:1061
ns_get2          = $F408 = 62472  _TEXT       nabu_nfs.asm:1068
ns_getb          = $F3CF = 62415  _TEXT       nabu_nfs.asm:1037
ns_getd          = $F3A6 = 62374  _TEXT       nabu_nfs.asm:1003
ns_grb           = $EFD1 = 61393  _TEXT       nabu_nfs.asm:167
ns_grb0          = $EFD4 = 61396  _TEXT       nabu_nfs.asm:168
ns_grb1          = $EFEB = 61419  _TEXT       nabu_nfs.asm:176
ns_hcca          = $0080 =   128  _TEXT       nabu_nfs.asm:32
ns_hcer          = $F487 = 62599  _TEXT       nabu_nfs.asm:1170
ns_hcr0          = $F474 = 62580  _TEXT       nabu_nfs.asm:1155
ns_hcr1          = $F48E = 62606  _TEXT       nabu_nfs.asm:1175
ns_hcr2          = $F497 = 62615  _TEXT       nabu_nfs.asm:1181
ns_hcrd          = $F465 = 62565  _TEXT       nabu_nfs.asm:1148
ns_hcre          = $F468 = 62568  _TEXT       nabu_nfs.asm:1149
ns_hcw0          = $F4C4 = 62660  _TEXT       nabu_nfs.asm:1218
ns_hcw1          = $F4DC = 62684  _TEXT       nabu_nfs.asm:1235
ns_hcw2          = $F4E1 = 62689  _TEXT       nabu_nfs.asm:1237
ns_hcwr          = $F4B2 = 62642  _TEXT       nabu_nfs.asm:1210
ns_hini          = $EF95 = 61333  _TEXT       nabu_nfs.asm:118
ns_inb           = $F55F = 62815  _TEXT       nabu_nfs.asm:1352
ns_inf           = $F560 = 62816  _TEXT       nabu_nfs.asm:1355
ns_init          = $EF76 = 61302  _TEXT       nabu_nfs.asm:87
ns_isls          = $F9A7 = 63911  _BSS        nabu_nfs.asm:26
ns_lis0          = $F0DB = 61659  _TEXT       nabu_nfs.asm:369
ns_lis1          = $F109 = 61705  _TEXT       nabu_nfs.asm:395
ns_lis2          = $F112 = 61714  _TEXT       nabu_nfs.asm:403
ns_lis3          = $F11F = 61727  _TEXT       nabu_nfs.asm:411
ns_lis4          = $F12A = 61738  _TEXT       nabu_nfs.asm:419
ns_list          = $F0D5 = 61653  _TEXT       nabu_nfs.asm:365
ns_ltou          = $F547 = 62791  _TEXT       nabu_nfs.asm:1324
ns_m0            = $F57B = 62843  _TEXT       nabu_nfs.asm:1367
ns_m0fl          = $F581 = 62849  _TEXT       nabu_nfs.asm:1371
ns_m0na          = $F584 = 62852  _TEXT       nabu_nfs.asm:1373
ns_m1            = $F598 = 62872  _TEXT       nabu_nfs.asm:1378
ns_m2            = $F59E = 62878  _TEXT       nabu_nfs.asm:1385
ns_m2bn          = $F5A4 = 62884  _TEXT       nabu_nfs.asm:1389
ns_m3            = $F5AA = 62890  _TEXT       nabu_nfs.asm:1394
ns_m3bn          = $F5B0 = 62896  _TEXT       nabu_nfs.asm:1398
ns_m4            = $F5B6 = 62902  _TEXT       nabu_nfs.asm:1403
ns_m5            = $F5BD = 62909  _TEXT       nabu_nfs.asm:1411
ns_m6            = $F5C4 = 62916  _TEXT       nabu_nfs.asm:1419
ns_m6na          = $F5CC = 62924  _TEXT       nabu_nfs.asm:1424
ns_m7            = $F5DF = 62943  _TEXT       nabu_nfs.asm:1428
ns_m7n0          = $F5E5 = 62949  _TEXT       nabu_nfs.asm:1432
ns_m7n1          = $F5F9 = 62969  _TEXT       nabu_nfs.asm:1434
ns_mask          = $F9A2 = 63906  _BSS        nabu_nfs.asm:23
ns_name          = $F997 = 63895  _BSS        nabu_nfs.asm:22
ns_nblk          = $F35D = 62301  _TEXT       nabu_nfs.asm:936
ns_nctl          = $0000 =     0  _TEXT       nabu_nfs.asm:33
ns_opef          = $F3B0 = 62384  _TEXT       nabu_nfs.asm:1016
ns_open          = $F3AD = 62381  _TEXT       nabu_nfs.asm:1015
ns_outb          = $F55D = 62813  _TEXT       nabu_nfs.asm:1346
ns_outf          = $F55E = 62814  _TEXT       nabu_nfs.asm:1349
ns_own0          = $F38B = 62347  _TEXT       nabu_nfs.asm:979
ns_own1          = $F397 = 62359  _TEXT       nabu_nfs.asm:984
ns_own2          = $F39D = 62365  _TEXT       nabu_nfs.asm:988
ns_ownr          = $F37B = 62331  _TEXT       nabu_nfs.asm:970
ns_p0            = $F561 = 62817  _TEXT       nabu_nfs.asm:1359
ns_p1            = $F56E = 62830  _TEXT       nabu_nfs.asm:1363
ns_ptrn          = $F98C = 63884  _BSS        nabu_nfs.asm:21
ns_put0          = $F416 = 62486  _TEXT       nabu_nfs.asm:1082
ns_put1          = $F428 = 62504  _TEXT       nabu_nfs.asm:1092
ns_putb          = $F410 = 62480  _TEXT       nabu_nfs.asm:1080
ns_rec0          = $F447 = 62535  _TEXT       nabu_nfs.asm:1113
ns_rec1          = $F452 = 62546  _TEXT       nabu_nfs.asm:1120
ns_rece          = $F43E = 62526  _TEXT       nabu_nfs.asm:1110
ns_rirq          = $F4A4 = 62628  _TEXT       nabu_nfs.asm:1193
ns_rrea          = $F2A1 = 62113  _TEXT       nabu_nfs.asm:757
ns_rrec          = $F2BF = 62143  _TEXT       nabu_nfs.asm:792
ns_rwri          = $F2B0 = 62128  _TEXT       nabu_nfs.asm:775
ns_scre          = $F23C = 62012  _TEXT       nabu_nfs.asm:662
ns_sdir          = $F534 = 62772  _TEXT       nabu_nfs.asm:1299
ns_sel           = $EF87 = 61319  _TEXT       nabu_nfs.asm:105
ns_send          = $F45C = 62556  _TEXT       nabu_nfs.asm:1134
ns_sfir          = $F12D = 61741  _TEXT       nabu_nfs.asm:427
ns_size          = $F345 = 62277  _TEXT       nabu_nfs.asm:910
ns_sls0          = $F0C9 = 61641  _TEXT       nabu_nfs.asm:341
ns_slst          = $F08E = 61582  _TEXT       nabu_nfs.asm:312
ns_snx0          = $F15A = 61786  _TEXT       nabu_nfs.asm:475
ns_snx1          = $F186 = 61830  _TEXT       nabu_nfs.asm:507
ns_snx2          = $F18A = 61834  _TEXT       nabu_nfs.asm:510
ns_snx3          = $F191 = 61841  _TEXT       nabu_nfs.asm:517
ns_snx4          = $F197 = 61847  _TEXT       nabu_nfs.asm:522
ns_snxt          = $F152 = 61778  _TEXT       nabu_nfs.asm:467
ns_stmp          = $F036 = 61494  _TEXT       nabu_nfs.asm:225
ns_sysh          = $EFF5 = 61429  _TEXT       nabu_nfs.asm:187
ns_tran          = $F9A8 = 63912  _BSS        nabu_nfs.asm:27
ns_utol          = $F552 = 62802  _TEXT       nabu_nfs.asm:1337
ns_wchd          = $F544 = 62788  _TEXT       nabu_nfs.asm:1315
ns_wirq          = $F4EB = 62699  _TEXT       nabu_nfs.asm:1246
nulldev          = $EB45 = 60229  _TEXT       bios.asm:317 (unused)
numcmds          = $0006 =     6  _TEXT       CPM22.asm:561
nxent1           = $E224 = 57892  _TEXT       CPM22.asm:2321
nxent2           = $E22B = 57899  _TEXT       CPM22.asm:2324
nxentry          = $E210 = 57872  _TEXT       CPM22.asm:2313
offset           = $E9D9 = 59865  _TEXT       CPM22.asm:3705
olddrv           = $E9EA = 59882  _TEXT       CPM22.asm:3719
open             = $D4CA = 54474  _TEXT       CPM22.asm:126
openfcb          = $D4CF = 54479  _TEXT       CPM22.asm:131
openfil          = $E8A7 = 59559  _TEXT       CPM22.asm:3474
openit           = $E45C = 58460  _TEXT       CPM22.asm:2766
openit1          = $E465 = 58469  _TEXT       CPM22.asm:2770
openit2          = $E496 = 58518  _TEXT       CPM22.asm:2798
outchar          = $DD53 = 56659  _TEXT       CPM22.asm:1421
outchr1          = $DD6D = 56685  _TEXT       CPM22.asm:1435
outchr2          = $DD84 = 56708  _TEXT       CPM22.asm:1451
outcon           = $DD9B = 56731  _TEXT       CPM22.asm:1472
outcon1          = $DDA1 = 56737  _TEXT       CPM22.asm:1475
outcrlf          = $DDD4 = 56788  _TEXT       CPM22.asm:1508
outflag          = $DF15 = 57109  _TEXT       CPM22.asm:1711
params           = $DF4E = 57166  _TEXT       CPM22.asm:1727
pattrn1          = $D730 = 55088  _TEXT       CPM22.asm:572
pattrn2          = $DC00 = 56320  _TEXT       CPM22.asm:1254
pline            = $D4A6 = 54438  _TEXT       CPM22.asm:93
pline2           = $D4AB = 54443  _TEXT       CPM22.asm:96
position         = $E70E = 59150  _TEXT       CPM22.asm:3176
positn1          = $E712 = 59154  _TEXT       CPM22.asm:3181
positn2          = $E752 = 59218  _TEXT       CPM22.asm:3227
positn3          = $E78A = 59274  _TEXT       CPM22.asm:3259
positn4          = $E78F = 59279  _TEXT       CPM22.asm:3265
positn5          = $E796 = 59286  _TEXT       CPM22.asm:3272
pr_atla          = $0041 =    65  _TEXT       nabu_prt.asm:14
pr_ayda          = $0040 =    64  _TEXT       nabu_prt.asm:13
pr_ctrl          = $0000 =     0  _TEXT       nabu_prt.asm:16
pr_init          = $F617 = 62999  _TEXT       nabu_prt.asm:31
pr_prnt          = $00B0 =   176  _TEXT       nabu_prt.asm:15
pr_read          = $F61A = 63002  _TEXT       nabu_prt.asm:46
pr_stat          = $F618 = 63000  _TEXT       nabu_prt.asm:38
pr_wri0          = $F620 = 63008  _TEXT       nabu_prt.asm:56
pr_wri1          = $F62F = 63023  _TEXT       nabu_prt.asm:67
pr_writ          = $F61C = 63004  _TEXT       nabu_prt.asm:53
print            = $D48C = 54412  _TEXT       CPM22.asm:66
printb           = $D492 = 54418  _TEXT       CPM22.asm:72
printdc          = $DB98 = 56216  _TEXT       CPM22.asm:1223
prstat           = $EB14 = 60180  _TEXT       bios.asm:271
prtdev           = $F60C = 62988  _TEXT       nabu_prt.asm:19
prterr           = $DCF0 = 56560  _TEXT       CPM22.asm:1348
prtflag          = $DF18 = 57112  _TEXT       CPM22.asm:1714
prtmesg          = $DDDE = 56798  _TEXT       CPM22.asm:1515
prtstr           = $DF03 = 57091  _TEXT       CPM22.asm:1691
punch            = $EAC9 = 60105  _TEXT       bios.asm:182
putdma           = $E915 = 59669  _TEXT       CPM22.asm:3550
ransiz1          = $E7EF = 59375  _TEXT       CPM22.asm:3355
ransiz2          = $E811 = 59409  _TEXT       CPM22.asm:3377
ransiz3          = $E817 = 59415  _TEXT       CPM22.asm:3379
ransize          = $E7DD = 59357  _TEXT       CPM22.asm:3344
rdbuf1           = $DDFA = 56826  _TEXT       CPM22.asm:1534
rdbuf10          = $DE7B = 56955  _TEXT       CPM22.asm:1596
rdbuf11          = $DE83 = 56963  _TEXT       CPM22.asm:1602
rdbuf12          = $DE95 = 56981  _TEXT       CPM22.asm:1614
rdbuf13          = $DEA4 = 56996  _TEXT       CPM22.asm:1621
rdbuf14          = $DEB1 = 57009  _TEXT       CPM22.asm:1629
rdbuf15          = $DEB4 = 57012  _TEXT       CPM22.asm:1632
rdbuf16          = $DEC8 = 57032  _TEXT       CPM22.asm:1644
rdbuf17          = $DECC = 57036  _TEXT       CPM22.asm:1646
rdbuf2           = $DDFC = 56828  _TEXT       CPM22.asm:1536
rdbuf3           = $DE21 = 56865  _TEXT       CPM22.asm:1553
rdbuf4           = $DE31 = 56881  _TEXT       CPM22.asm:1562
rdbuf5           = $DE42 = 56898  _TEXT       CPM22.asm:1570
rdbuf6           = $DE53 = 56915  _TEXT       CPM22.asm:1579
rdbuf7           = $DE59 = 56921  _TEXT       CPM22.asm:1582
rdbuf8           = $DE6A = 56938  _TEXT       CPM22.asm:1589
rdbuf9           = $DE76 = 56950  _TEXT       CPM22.asm:1594
rdbuff           = $DDEC = 56812  _TEXT       CPM22.asm:1527
rderr            = $D7EC = 55276  _TEXT       CPM22.asm:699
rderror          = $D7E6 = 55270  _TEXT       CPM22.asm:697
rdrandom         = $E94C = 59724  _TEXT       CPM22.asm:3592
rdrec            = $D4F8 = 54520  _TEXT       CPM22.asm:172
rdseq            = $E5C7 = 58823  _TEXT       CPM22.asm:2985
rdseq1           = $E5CC = 58828  _TEXT       CPM22.asm:2987
rdseq2           = $E5F1 = 58865  _TEXT       CPM22.asm:3002
rdseq3           = $E606 = 58886  _TEXT       CPM22.asm:3012
rdwrtflg         = $E9DE = 59870  _TEXT       CPM22.asm:3710
read             = $EB0C = 60172  _TEXT       bios.asm:256
reader           = $EACD = 60109  _TEXT       bios.asm:188
readfcb          = $D4FD = 54525  _TEXT       CPM22.asm:177
readran          = $E79E = 59294  _TEXT       CPM22.asm:3279
readseq          = $E8EB = 59627  _TEXT       CPM22.asm:3518
relblock         = $E9E2 = 59874  _TEXT       CPM22.asm:3714
renam            = $D50D = 54541  _TEXT       CPM22.asm:194
rename           = $DA1D = 55837  _TEXT       CPM22.asm:1021
rename1          = $DA4C = 55884  _TEXT       CPM22.asm:1039
rename2          = $DA65 = 55909  _TEXT       CPM22.asm:1053
rename3          = $DA6A = 55914  _TEXT       CPM22.asm:1056 (unused)
rename4          = $DA78 = 55928  _TEXT       CPM22.asm:1064
rename5          = $DA7E = 55934  _TEXT       CPM22.asm:1066
rename6          = $DA84 = 55940  _TEXT       CPM22.asm:1068
renfile          = $E900 = 59648  _TEXT       CPM22.asm:3534
resccp           = $EB66 = 60262  _TEXT       config_nfs_hybrid.asm:149
resdsk           = $D4B7 = 54455  _TEXT       CPM22.asm:107
resetdr          = $D873 = 55411  _TEXT       CPM22.asm:793
resgrb           = $EB69 = 60265  _TEXT       config_nfs_hybrid.asm:155
rodisk           = $DC10 = 56336  _TEXT       CPM22.asm:1269
rofile           = $DC12 = 56338  _TEXT       CPM22.asm:1270
rstdsk           = $E88E = 59534  _TEXT       CPM22.asm:3462
rtn              = $DF0F = 57103  _TEXT       CPM22.asm:1704
rtncode          = $DBFB = 56315  _TEXT       CPM22.asm:1245
samext           = $E312 = 58130  _TEXT       CPM22.asm:2516
savatr1          = $E44B = 58443  _TEXT       CPM22.asm:2756
save             = $D9BA = 55738  _TEXT       CPM22.asm:966
save1            = $D9E1 = 55777  _TEXT       CPM22.asm:984
save2            = $D9FE = 55806  _TEXT       CPM22.asm:1002
save3            = $DA08 = 55816  _TEXT       CPM22.asm:1009
save4            = $DA0E = 55822  _TEXT       CPM22.asm:1011
saveattr         = $E446 = 58438  _TEXT       CPM22.asm:2754
savefcb          = $E9E4 = 59876  _TEXT       CPM22.asm:3716
savext           = $E9ED = 59885  _TEXT       CPM22.asm:3722
savnrec          = $E9EE = 59886  _TEXT       CPM22.asm:3723
savnxt           = $E9EC = 59884  _TEXT       CPM22.asm:3721
scratch1         = $E9BE = 59838  _TEXT       CPM22.asm:3684
scratch2         = $E9C0 = 59840  _TEXT       CPM22.asm:3685
scratch3         = $E9C2 = 59842  _TEXT       CPM22.asm:3686
search           = $D736 = 55094  _TEXT       CPM22.asm:580
search1          = $D73B = 55099  _TEXT       CPM22.asm:582
search2          = $D744 = 55108  _TEXT       CPM22.asm:587
search3          = $D757 = 55127  _TEXT       CPM22.asm:599
search4          = $D75C = 55132  _TEXT       CPM22.asm:602
sectors          = $E9CC = 59852  _TEXT       CPM22.asm:3697
sectrn           = $EB17 = 60183  _TEXT       bios.asm:276
seldsk           = $EAE0 = 60128  _TEXT       bios.asm:208
select           = $DF64 = 57188  _TEXT       CPM22.asm:1755
select1          = $DFA8 = 57256  _TEXT       CPM22.asm:1795
setattr          = $E928 = 59688  _TEXT       CPM22.asm:3566
setbit           = $E116 = 57622  _TEXT       CPM22.asm:2087
setcdrv          = $D519 = 54553  _TEXT       CPM22.asm:209
setdir           = $E1A7 = 57767  _TEXT       CPM22.asm:2221
setdma           = $EB06 = 60166  _TEXT       bios.asm:248
setdsk           = $E850 = 59472  _TEXT       CPM22.asm:3422
setext           = $E0B1 = 57521  _TEXT       CPM22.asm:2002
setfile          = $E276 = 57974  _TEXT       CPM22.asm:2406
setfl1           = $E280 = 57984  _TEXT       CPM22.asm:2411
setfl2           = $E293 = 58003  _TEXT       CPM22.asm:2423
setfl3           = $E299 = 58009  _TEXT       CPM22.asm:2429
setfl4           = $E2A8 = 58024  _TEXT       CPM22.asm:2438
sethlde          = $E0B9 = 57529  _TEXT       CPM22.asm:2010
setiob           = $DEFE = 57086  _TEXT       CPM22.asm:1684
setnrec          = $E0DD = 57565  _TEXT       CPM22.asm:2036
setran           = $E819 = 59417  _TEXT       CPM22.asm:3385
sets2b7          = $E183 = 57731  _TEXT       CPM22.asm:2178
setsec           = $EB02 = 60162  _TEXT       bios.asm:241
setstat          = $DF0C = 57100  _TEXT       CPM22.asm:1703
settrk           = $EAFE = 60158  _TEXT       bios.asm:234
setuser          = $E946 = 59718  _TEXT       CPM22.asm:3586
shiftl           = $E10F = 57615  _TEXT       CPM22.asm:2078
shiftl1          = $E110 = 57616  _TEXT       CPM22.asm:2079
shiftr           = $E0F5 = 57589  _TEXT       CPM22.asm:2052
shiftr1          = $E0F6 = 57590  _TEXT       CPM22.asm:2053
showit           = $DD8A = 56714  _TEXT       CPM22.asm:1459
siodev           = $F636 = 63030  _TEXT       nabu_sio.asm:20
slcterr          = $DF52 = 57170  _TEXT       CPM22.asm:1732
so_atab          = $F6A6 = 63142  _TEXT       nabu_sio.asm:131
so_conf          = $F6AA = 63146  _TEXT       nabu_sio.asm:135
so_ini0          = $F649 = 63049  _TEXT       nabu_sio.asm:39
so_ini1          = $F64F = 63055  _TEXT       nabu_sio.asm:43
so_ini2          = $F656 = 63062  _TEXT       nabu_sio.asm:49
so_ini3          = $F662 = 63074  _TEXT       nabu_sio.asm:59
so_init          = $F641 = 63041  _TEXT       nabu_sio.asm:33
so_rea0          = $F689 = 63113  _TEXT       nabu_sio.asm:102
so_read          = $F680 = 63104  _TEXT       nabu_sio.asm:95
so_sta0          = $F678 = 63096  _TEXT       nabu_sio.asm:83
so_stat          = $F66F = 63087  _TEXT       nabu_sio.asm:76
so_wri0          = $F69C = 63132  _TEXT       nabu_sio.asm:121
so_writ          = $F692 = 63122  _TEXT       nabu_sio.asm:113
space            = $D4A1 = 54433  _TEXT       CPM22.asm:87
srchfcb          = $D4E8 = 54504  _TEXT       CPM22.asm:154
srchfst          = $D4DE = 54494  _TEXT       CPM22.asm:144
srchnxt          = $D4E3 = 54499  _TEXT       CPM22.asm:149
starting         = $DF16 = 57110  _TEXT       CPM22.asm:1712
status           = $DF50 = 57168  _TEXT       CPM22.asm:1728
stbitmap         = $E267 = 57959  _TEXT       CPM22.asm:2386
stbmap1          = $E26F = 57967  _TEXT       CPM22.asm:2397
stddma           = $D5DD = 54749  _TEXT       CPM22.asm:349
stfilpos         = $E209 = 57865  _TEXT       CPM22.asm:2301
stkarea          = $DF4C = 57164  _TEXT       CPM22.asm:1723
stnrec1          = $E0E9 = 57577  _TEXT       CPM22.asm:2041
strdata          = $E0C6 = 57542  _TEXT       CPM22.asm:2020
ststatus         = $E30C = 58124  _TEXT       CPM22.asm:2508
subhl            = $E1A0 = 57760  _TEXT       CPM22.asm:2211
swindi0          = $EB2D = 60205  _TEXT       bios.asm:300
swindi1          = $EB33 = 60211  _TEXT       bios.asm:304
swindir          = $EB29 = 60201  _TEXT       bios.asm:298
synerr           = $D611 = 54801  _TEXT       CPM22.asm:387
synerr1          = $D617 = 54807  _TEXT       CPM22.asm:389
synerr2          = $D62A = 54826  _TEXT       CPM22.asm:399
synerrt          = $DA81 = 55937  _TEXT       CPM22.asm:1067
syshook          = $EB63 = 60259  _TEXT       config_nfs_hybrid.asm:127
tab              = $0009 =     9  _TEXT       CPM22.asm:32
tbase            = $0100 =   256  _TEXT       CPM22.asm:25
tbuff            = $0080 =   128  _TEXT       CPM22.asm:24
tdrive           = $0004 =     4  _TEXT       CPM22.asm:21
tfcb             = $005C =    92  _TEXT       CPM22.asm:23
tm_40c           = $EDF2 = 60914  _TEXT       nabu_vdp.asm:462
tm_80c           = $EDFF = 60927  _TEXT       nabu_vdp.asm:469
tm_addh          = $EF16 = 61206  _TEXT       nabu_vdp.asm:707
tm_addr          = $EF18 = 61208  _TEXT       nabu_vdp.asm:709
tm_atla          = $0041 =    65  _TEXT       nabu_vdp.asm:37
tm_ayda          = $0040 =    64  _TEXT       nabu_vdp.asm:36
tm_bs            = $ED48 = 60744  _TEXT       nabu_vdp.asm:348
tm_cbuf          = $F934 = 63796  _BSS        nabu_vdp.asm:26
tm_cha0          = $EEBA = 61114  _TEXT       nabu_vdp.asm:630
tm_chat          = $EEB4 = 61108  _TEXT       nabu_vdp.asm:625
tm_cle0          = $EDDE = 60894  _TEXT       nabu_vdp.asm:447
tm_clea          = $EDCF = 60879  _TEXT       nabu_vdp.asm:438
tm_cles          = $EDCD = 60877  _TEXT       nabu_vdp.asm:437
tm_cloc          = $EC59 = 60505  _TEXT       nabu_vdp.asm:172
tm_cls           = $EEFB = 61179  _TEXT       nabu_vdp.asm:684
tm_cls0          = $EF04 = 61188  _TEXT       nabu_vdp.asm:687
tm_cold          = $EF4B = 61259  _TEXT       nabu_vdp.asm:754
tm_colr          = $EF46 = 61254  _TEXT       nabu_vdp.asm:749
tm_cr            = $ED45 = 60741  _TEXT       nabu_vdp.asm:345
tm_cshm          = $ED57 = 60759  _TEXT       nabu_vdp.asm:362
tm_cupd          = $EDF6 = 60918  _TEXT       nabu_vdp.asm:464
tm_curx          = $EF49 = 61257  _TEXT       nabu_vdp.asm:752
tm_cury          = $EF4A = 61258  _TEXT       nabu_vdp.asm:753
tm_data          = $00A0 =   160  _TEXT       nabu_vdp.asm:30
tm_dint          = $EF29 = 61225  _TEXT       nabu_vdp.asm:728
tm_dsc0          = $EE25 = 60965  _TEXT       nabu_vdp.asm:495
tm_dsco          = $EE12 = 60946  _TEXT       nabu_vdp.asm:488
tm_eint          = $EF39 = 61241  _TEXT       nabu_vdp.asm:740
tm_esc           = $ED8C = 60812  _TEXT       nabu_vdp.asm:394
tm_esc0          = $ED9D = 60829  _TEXT       nabu_vdp.asm:405
tm_esc1          = $EDB7 = 60855  _TEXT       nabu_vdp.asm:420
tm_esc2          = $EDC2 = 60866  _TEXT       nabu_vdp.asm:427
tm_escd          = $ED98 = 60824  _TEXT       nabu_vdp.asm:402
tm_esci          = $EDB1 = 60849  _TEXT       nabu_vdp.asm:417
tm_escr          = $ED99 = 60825  _TEXT       nabu_vdp.asm:403
tm_escs          = $F932 = 63794  _BSS        nabu_vdp.asm:24
tm_get0          = $EE4E = 61006  _TEXT       nabu_vdp.asm:530
tm_getc          = $EE38 = 60984  _TEXT       nabu_vdp.asm:516
tm_home          = $ED5A = 60762  _TEXT       nabu_vdp.asm:363
tm_inb           = $EF47 = 61255  _TEXT       nabu_vdp.asm:750
tm_inf           = $EF48 = 61256  _TEXT       nabu_vdp.asm:751
tm_ini0          = $EC2C = 60460  _TEXT       nabu_vdp.asm:140
tm_ini1          = $EC4C = 60492  _TEXT       nabu_vdp.asm:161
tm_inir          = $EBD2 = 60370  _TEXT       nabu_vdp.asm:79
tm_init          = $EC04 = 60420  _TEXT       nabu_vdp.asm:116
tm_inr0          = $EBD3 = 60371  _TEXT       nabu_vdp.asm:80
tm_keyd          = $0090 =   144  _TEXT       nabu_vdp.asm:33
tm_keys          = $0091 =   145  _TEXT       nabu_vdp.asm:34
tm_kirq          = $EE56 = 61014  _TEXT       nabu_vdp.asm:539
tm_last          = $F933 = 63795  _BSS        nabu_vdp.asm:25
tm_latc          = $00A1 =   161  _TEXT       nabu_vdp.asm:31
tm_lf            = $ED39 = 60729  _TEXT       nabu_vdp.asm:336
tm_map           = $EE64 = 61028  _TEXT       nabu_vdp.asm:554
tm_map0          = $EE68 = 61032  _TEXT       nabu_vdp.asm:558
tm_map2          = $EE74 = 61044  _TEXT       nabu_vdp.asm:571
tm_mapt          = $EE7B = 61051  _TEXT       nabu_vdp.asm:578
tm_mode          = $EF44 = 61252  _TEXT       nabu_vdp.asm:748
tm_oti0          = $EBCA = 60362  _TEXT       nabu_vdp.asm:66
tm_otir          = $EBC9 = 60361  _TEXT       nabu_vdp.asm:65
tm_outc          = $F930 = 63792  _BSS        nabu_vdp.asm:22
tm_putc          = $EE90 = 61072  _TEXT       nabu_vdp.asm:596
tm_putf          = $EE9E = 61086  _TEXT       nabu_vdp.asm:604 (unused)
tm_rea0          = $ECB2 = 60594  _TEXT       nabu_vdp.asm:237
tm_rea1          = $ECC8 = 60616  _TEXT       nabu_vdp.asm:249
tm_rea2          = $ECDD = 60637  _TEXT       nabu_vdp.asm:262
tm_rea3          = $ECED = 60653  _TEXT       nabu_vdp.asm:272
tm_read          = $ECA6 = 60582  _TEXT       nabu_vdp.asm:231
tm_ri            = $ED32 = 60722  _TEXT       nabu_vdp.asm:330
tm_sclf          = $EC71 = 60529  _TEXT       nabu_vdp.asm:188
tm_scol          = $EE05 = 60933  _TEXT       nabu_vdp.asm:474
tm_scr0          = $EC69 = 60521  _TEXT       nabu_vdp.asm:185
tm_scr1          = $EC6F = 60527  _TEXT       nabu_vdp.asm:187
tm_scri          = $EC5F = 60511  _TEXT       nabu_vdp.asm:180
tm_scro          = $F931 = 63793  _BSS        nabu_vdp.asm:23
tm_setp          = $EC7B = 60539  _TEXT       nabu_vdp.asm:198
tm_sta0          = $EBE7 = 60391  _TEXT       nabu_vdp.asm:98
tm_sta1          = $EBF2 = 60402  _TEXT       nabu_vdp.asm:103
tm_sta2          = $ECFE = 60670  _TEXT       nabu_vdp.asm:286
tm_stal          = $ECFB = 60667  _TEXT       nabu_vdp.asm:284
tm_stat          = $EBDB = 60379  _TEXT       nabu_vdp.asm:92
tm_up            = $ED52 = 60754  _TEXT       nabu_vdp.asm:357
tm_updc          = $EE09 = 60937  _TEXT       nabu_vdp.asm:478
tm_usc0          = $EEE7 = 61159  _TEXT       nabu_vdp.asm:663
tm_usco          = $EED8 = 61144  _TEXT       nabu_vdp.asm:656
tm_vcpy          = $EEC0 = 61120  _TEXT       nabu_vdp.asm:642
tm_virq          = $EF23 = 61219  _TEXT       nabu_vdp.asm:718
tm_wri0          = $ED1F = 60703  _TEXT       nabu_vdp.asm:318
tm_wri1          = $ED5E = 60766  _TEXT       nabu_vdp.asm:368
tm_writ          = $ED04 = 60676  _TEXT       nabu_vdp.asm:298
trksec           = $DFCE = 57294  _TEXT       CPM22.asm:1829
trksec1          = $DFDC = 57308  _TEXT       CPM22.asm:1838
trksec2          = $DFEF = 57327  _TEXT       CPM22.asm:1851
trksec3          = $E005 = 57349  _TEXT       CPM22.asm:1867
trksec4          = $E01A = 57370  _TEXT       CPM22.asm:1884
type             = $D96A = 55658  _TEXT       CPM22.asm:923
type1            = $D981 = 55681  _TEXT       CPM22.asm:931
type2            = $D984 = 55684  _TEXT       CPM22.asm:932 (unused)
type3            = $D994 = 55700  _TEXT       CPM22.asm:941
type4            = $D9AD = 55725  _TEXT       CPM22.asm:954
type5            = $D9B4 = 55732  _TEXT       CPM22.asm:957
unknown          = $DAAE = 55982  _TEXT       CPM22.asm:1095
unkwn0           = $DB6F = 56175  _TEXT       CPM22.asm:1203
unkwn1           = $DACC = 56012  _TEXT       CPM22.asm:1110
unkwn2           = $DAD4 = 56020  _TEXT       CPM22.asm:1114 (unused)
unkwn3           = $DAE8 = 56040  _TEXT       CPM22.asm:1125
unkwn4           = $DB05 = 56069  _TEXT       CPM22.asm:1144
unkwn5           = $DB33 = 56115  _TEXT       CPM22.asm:1165
unkwn6           = $DB3E = 56126  _TEXT       CPM22.asm:1175
unkwn7           = $DB43 = 56131  _TEXT       CPM22.asm:1177
unkwn8           = $DB4D = 56141  _TEXT       CPM22.asm:1185
unkwn9           = $DB69 = 56169  _TEXT       CPM22.asm:1201
update           = $E40C = 58380  _TEXT       CPM22.asm:2717
update1          = $E41B = 58395  _TEXT       CPM22.asm:2725
upper            = $D52F = 54575  _TEXT       CPM22.asm:228
user             = $DA99 = 55961  _TEXT       CPM22.asm:1079
userdma          = $E9BC = 59836  _TEXT       CPM22.asm:3680
userno           = $DF4C = 57164  _TEXT       CPM22.asm:1725
usrstack         = $DF1A = 57114  _TEXT       CPM22.asm:1719
vdpdev           = $EBBC = 60348  _TEXT       nabu_vdp.asm:51
verify           = $D5FD = 54781  _TEXT       CPM22.asm:373
verify1          = $D605 = 54789  _TEXT       CPM22.asm:376
wbinit           = $EB4B = 60235  _TEXT       config_nfs_hybrid.asm:65
wboot            = $EA48 = 59976  _TEXT       bios.asm:57
wboot0           = $EA6F = 60015  _TEXT       bios.asm:94
wbootin          = $EA0A = 59914  _TEXT       bios.asm:22
wbootr           = $EA5F = 59999  _TEXT       bios.asm:82
write            = $EB10 = 60176  _TEXT       bios.asm:263
writeran         = $E7A7 = 59303  _TEXT       CPM22.asm:3286
wrtprt           = $E9B8 = 59832  _TEXT       CPM22.asm:3678
wrtprtd          = $E137 = 57655  _TEXT       CPM22.asm:2114
wrtrec           = $D503 = 54531  _TEXT       CPM22.asm:183
wrtseq           = $E8F1 = 59633  _TEXT       CPM22.asm:3523
wtrandom         = $E952 = 59730  _TEXT       CPM22.asm:3597
wtseq            = $E609 = 58889  _TEXT       CPM22.asm:3016
wtseq1           = $E60E = 58894  _TEXT       CPM22.asm:3018
wtseq10          = $E6DD = 59101  _TEXT       CPM22.asm:3133
wtseq11          = $E709 = 59145  _TEXT       CPM22.asm:3157
wtseq12          = $E70B = 59147  _TEXT       CPM22.asm:3158
wtseq2           = $E646 = 58950  _TEXT       CPM22.asm:3041
wtseq3           = $E653 = 58963  _TEXT       CPM22.asm:3047
wtseq4           = $E66F = 58991  _TEXT       CPM22.asm:3059
wtseq5           = $E677 = 58999  _TEXT       CPM22.asm:3066
wtseq6           = $E679 = 59001  _TEXT       CPM22.asm:3067
wtseq7           = $E697 = 59031  _TEXT       CPM22.asm:3090
wtseq8           = $E6A5 = 59045  _TEXT       CPM22.asm:3097
wtseq9           = $E6C6 = 59078  _TEXT       CPM22.asm:3117
wtseq99          = $E6EA = 59114  _TEXT       CPM22.asm:3144 (unused)
wtspecl          = $E9A6 = 59814  _TEXT       CPM22.asm:3663
xlate            = $E9DB = 59867  _TEXT       CPM22.asm:3706
yesno            = $D95F = 55647  _TEXT       CPM22.asm:915


total time: 0.0745 sec.
no errors
