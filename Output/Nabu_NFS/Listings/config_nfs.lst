              	; --------------------------------------
              	; zasm: assemble "config_nfs.asm"
              	; date: 2023-06-10 14:05:43
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0036:         	mem	equ	54		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
D800:         	#code	_TEXT,(mem)*1024
FAA7:         	#data	_BSS,_TEXT_end
FF00:         	#data	_JUMP_TABLE,0xFF00
FF00: 00000000	intvec:	defs	16
FF04: 00...   	
FF10: 00000000	dircbuf:defs	128
FF14: 00...   	
              	.area	_TEXT
              	; Include CP/M and BIOS
              	#include "../CPM22.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	;
              	;   set origin for cp/m
              	;
              	;	org	(mem)*1024
              	;
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
D800: C364DB  	cbase:	jp	command		;execute command processor (ccp).
D803: C360DB  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
D806: 7F      	inbuff:	defb	127		;length of input buffer.
D807: 00      		defb	0		;current length of contents.
D808: 494E4954		defb	'INIT '
D80C: 20      	
D80D: FF000000		defb	255,0,0,0
D811: 20313937		defb	' 1979 (c) by Digital Research      '
D815: 39202863	
D819: 29206279	
D81D: 20446967	
D821: 6974616C	
D825: 20526573	
D829: 65617263	
D82D: 68202020	
D831: 202020  	
D834: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D838: 00...   	
D84B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D84F: 00...   	
D862: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D866: 00...   	
D879: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D87D: 00...   	
D888: 08D8    	inpoint:defw	inbuff+2	;input line pointer
D88A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
D88C: 5F      	print:	ld	e,a		;setup bdos call.
D88D: 0E02    		ld	c,2
D88F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
D892: C5      	printb:	push	bc
D893: CD8CD8  		call	print
D896: C1      		pop	bc
D897: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
D898: 3E0D    	crlf:	ld	a,cr
D89A: CD92D8  		call	printb
D89D: 3E0A    		ld	a,lf
D89F: 18F1    		jr	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
D8A1: 3E20    	space:	ld	a,' '
D8A3: C392D8  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
D8A6: C5      	pline:	push	bc
D8A7: CD98D8  		call	crlf
D8AA: E1      		pop	hl
D8AB: 7E      	pline2:	ld	a,(hl)
D8AC: B7      		or	a
D8AD: C8      		ret	z
D8AE: 23      		inc	hl
D8AF: E5      		push	hl
D8B0: CD8CD8  		call	print
D8B3: E1      		pop	hl
D8B4: C3ABD8  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
D8B7: 0E0D    	resdsk:	ld	c,13
D8B9: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
D8BC: 5F      	dsksel:	ld	e,a
D8BD: 0E0E    		ld	c,14
D8BF: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
D8C2: CD0500  	entry1:	call	entry
D8C5: 32FBDF  		ld	(rtncode),a	;save return code.
D8C8: 3C      		inc	a		;set zero if 0ffh returned.
D8C9: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
D8CA: 0E0F    	open:	ld	c,15
D8CC: C3C2D8  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
D8CF: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
D8D0: 32FADF  		ld	(fcb+32),a
D8D3: 11DADF  		ld	de,fcb
D8D6: C3CAD8  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
D8D9: 0E10    	close:	ld	c,16
D8DB: C3C2D8  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
D8DE: 0E11    	srchfst:ld	c,17
D8E0: C3C2D8  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
D8E3: 0E12    	srchnxt:ld	c,18
D8E5: C3C2D8  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
D8E8: 11DADF  	srchfcb:ld	de,fcb
D8EB: C3DED8  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
D8EE: 0E13    	delete:	ld	c,19
D8F0: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
D8F3: CD0500  	entry2:	call	entry
D8F6: B7      		or	a		;set zero flag if appropriate.
D8F7: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
D8F8: 0E14    	rdrec:	ld	c,20
D8FA: C3F3D8  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
D8FD: 11DADF  	readfcb:ld	de,fcb
D900: C3F8D8  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
D903: 0E15    	wrtrec:	ld	c,21
D905: C3F3D8  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
D908: 0E16    	create:	ld	c,22
D90A: C3C2D8  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
D90D: 0E17    	renam:	ld	c,23
D90F: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
D912: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
D914: 0E20    	getsetuc: ld	c,32
D916: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
D919: CD12D9  	setcdrv:call	getusr		;get user number
D91C: 87      		add	a,a		;and shift into the upper 4 bits.
D91D: 87      		add	a,a
D91E: 87      		add	a,a
D91F: 87      		add	a,a
D920: 21FCDF  		ld	hl,cdrive	;now add in the current drive number.
D923: B6      		or	(hl)
D924: 320400  		ld	(tdrive),a	;and save.
D927: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
D928: 3AFCDF  	movecd:	ld	a,(cdrive)
D92B: 320400  		ld	(tdrive),a
D92E: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
D92F: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
D931: D8      		ret	c
D932: FE7B    		cp	'{'
D934: D0      		ret	nc
D935: E65F    		and	5fh		;convert it if found.
D937: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
D938: 3AB8DF  	getinp:	ld	a,(batch)	;if =0, then use console input.
D93B: B7      		or	a
D93C: CAA0D9  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
D93F: 3AFCDF  		ld	a,(cdrive)	;select drive 0 if need be.
D942: B7      		or	a
D943: 3E00    		ld	a,0		;always use drive a for submit.
D945: C4BCD8  		call	nz,dsksel	;select it if required.
D948: 11B9DF  		ld	de,batchfcb
D94B: CDCAD8  		call	open		;look for it.
D94E: CAA0D9  		jp	z,getinp1	;if not there, use normal input.
D951: 3AC8DF  		ld	a,(batchfcb+15)	;get last record number+1.
D954: 3D      	getinp0:dec	a
D955: 32D9DF  		ld	(batchfcb+32),a
D958: 11B9DF  		ld	de,batchfcb
D95B: F5      		push	af
D95C: CDF8D8  		call	rdrec		;read last record.
D95F: D1      		pop	de
D960: C2A0D9  		jp	nz,getinp1	;quit on end of file.
D963: 218000  		ld	hl,tbuff	;data was read into buffer here.
D966: AF      		xor	a		;skip if entry has nothing in it
D967: BE      		cp	(hl)
D968: 7A      		ld	a,d
D969: 28E9    		jr	z,getinp0
              	
              	;   move this record into input buffer.
              	;
D96B: 1107D8  		ld	de,inbuff+1
D96E: 0680    		ld	b,128		;all 128 characters may be used.
D970: E5      		push	hl		;save tbuff
D971: CD4FDC  		call	hl2de		;(hl) to (de), (b) bytes.
D974: E1      		pop	hl		;zero out first in tbuff
D975: 3600    		ld	(hl),0
D977: 21D9DF  		ld	hl,batchfcb+32
D97A: 35      		dec	(hl)		;decrement the record count.
D97B: 11B9DF  		ld	de,batchfcb	;close the batch file now.
D97E: D5      		push	de
D97F: CD03D9  		call	wrtrec		;write out record
D982: D1      		pop	de
D983: CDD9D8  		call	close
D986: 2818    		jr	z,getinp1	;quit on an error.
D988: 3AFCDF  		ld	a,(cdrive)	;re-select previous drive if need be.
D98B: B7      		or	a
D98C: C4BCD8  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
D98F: 2108D8  		ld	hl,inbuff+2
D992: CDABD8  		call	pline2
D995: CDCAD9  		call	chkcon		;check console, quit on a key.
D998: 2817    		jr	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
D99A: CDE5D9  		call	delbatch	;delete the batch file.
D99D: C387DB  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
D9A0: CDE5D9  	getinp1:call	delbatch	;delete file ($$$.sub).
D9A3: CD19D9  		call	setcdrv		;reset active disk.
D9A6: 0E0A    		ld	c,10		;get line from console device.
D9A8: 1106D8  		ld	de,inbuff
D9AB: CD0500  		call	entry
D9AE: CD28D9  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
D9B1: 2107D8  	getinp2:ld	hl,inbuff+1
D9B4: 46      		ld	b,(hl)		;(b)=character counter.
D9B5: 23      	getinp3:inc	hl
D9B6: 78      		ld	a,b		;end of the line?
D9B7: B7      		or	a
D9B8: 2808    		jr	z,getinp4
D9BA: 7E      		ld	a,(hl)		;convert to upper case.
D9BB: CD2FD9  		call	upper
D9BE: 77      		ld	(hl),a
D9BF: 05      		dec	b		;adjust character count.
D9C0: 18F3    		jr	getinp3
D9C2: 77      	getinp4:ld	(hl),a		;add trailing null.
D9C3: 2108D8  		ld	hl,inbuff+2
D9C6: 2288D8  		ld	(inpoint),hl	;reset input line pointer.
D9C9: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
D9CA: 0E0B    	chkcon:	ld	c,11		;check console.
D9CC: CD0500  		call	entry
D9CF: B7      		or	a
D9D0: C8      		ret	z		;return if nothing.
D9D1: 0E01    		ld	c,1		;else get character.
D9D3: CD0500  		call	entry
D9D6: B7      		or	a		;clear zero flag and return.
D9D7: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
D9D8: 0E19    	getdsk:	ld	c,25
D9DA: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
D9DD: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
D9E0: 0E1A    	dmaset:	ld	c,26
D9E2: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
D9E5: 21B8DF  	delbatch: ld	hl,batch	;is batch active?
D9E8: 7E      		ld	a,(hl)
D9E9: B7      		or	a
D9EA: C8      		ret	z
D9EB: 3600    		ld	(hl),0		;yes, de-activate it.
D9ED: AF      		xor	a
D9EE: CDBCD8  		call	dsksel		;select drive 0 for sure.
D9F1: 11B9DF  		ld	de,batchfcb	;and delete this file.
D9F4: CDEED8  		call	delete
D9F7: 3AFCDF  		ld	a,(cdrive)	;reset current drive.
D9FA: C3BCD8  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
D9FD: 1132DB  	verify:	ld	de,pattrn1+2	;these are the serial number bytes.
DA00: 2102E0  		ld	hl,pattrn2+2	;ditto, but how could they be different?
DA03: 0604    		ld	b,4		;6 bytes each.
DA05: 1A      	verify1:ld	a,(de)
DA06: BE      		cp	(hl)
DA07: C2DCDB  		jp	nz,halt		;jump to halt routine.
DA0A: 13      		inc	de
DA0B: 23      		inc	hl
DA0C: 05      		dec	b
DA0D: C205DA  		jp	nz,verify1
DA10: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
DA11: CD98D8  	synerr:	call	crlf		;end current line.
DA14: 2A8AD8  		ld	hl,(namepnt)	;this points to name in error.
DA17: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
DA18: FE20    		cp	' '
DA1A: CA2ADA  		jp	z,synerr2
DA1D: B7      		or	a
DA1E: CA2ADA  		jp	z,synerr2
DA21: E5      		push	hl
DA22: CD8CD8  		call	print
DA25: E1      		pop	hl
DA26: 23      		inc	hl
DA27: C317DA  		jp	synerr1
DA2A: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
DA2C: CD8CD8  		call	print
DA2F: CD98D8  		call	crlf
DA32: CDE5D9  		call	delbatch	;delete any batch file.
DA35: C387DB  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
DA38: 1A      	check:	ld	a,(de)
DA39: B7      		or	a
DA3A: C8      		ret	z
DA3B: FE20    		cp	' '		;control characters are not legal here.
DA3D: DA11DA  		jp	c,synerr
DA40: C8      		ret	z		;check for valid delimiter.
DA41: FE3D    		cp	'='
DA43: C8      		ret	z
DA44: FE5F    		cp	'_'
DA46: C8      		ret	z
DA47: FE2E    		cp	'.'
DA49: C8      		ret	z
DA4A: FE3A    		cp	':'
DA4C: C8      		ret	z
DA4D: FE3B    		cp	';'
DA4F: C8      		ret	z
DA50: FE3C    		cp	'<'
DA52: C8      		ret	z
DA53: FE3E    		cp	'>'
DA55: C8      		ret	z
DA56: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
DA57: 1A      	nonblank: ld	a,(de)
DA58: B7      		or	a		;string ends with a null.
DA59: C8      		ret	z
DA5A: FE20    		cp	' '
DA5C: C0      		ret	nz
DA5D: 13      		inc	de
DA5E: C357DA  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
DA61: 85      	addhl:	add	a,l
DA62: 6F      		ld	l,a
DA63: D0      		ret	nc		;take care of any carry.
DA64: 24      		inc	h
DA65: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
DA66: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
DA68: 21DADF  	convert:ld	hl,fcb
DA6B: CD61DA  		call	addhl
DA6E: E5      		push	hl
DA6F: E5      		push	hl
DA70: AF      		xor	a
DA71: 32FDDF  		ld	(chgdrv),a	;initialize drive change flag.
DA74: 2A88D8  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
DA77: EB      		ex	de,hl
DA78: CD57DA  		call	nonblank	;get next non-blank character.
DA7B: EB      		ex	de,hl
DA7C: 228AD8  		ld	(namepnt),hl	;save pointer here for any error message.
DA7F: EB      		ex	de,hl
DA80: E1      		pop	hl
DA81: 1A      		ld	a,(de)		;get first character.
DA82: B7      		or	a
DA83: CA91DA  		jp	z,convrt1
DA86: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
DA88: 47      		ld	b,a		;and save.
DA89: 13      		inc	de		;check next character for a ':'.
DA8A: 1A      		ld	a,(de)
DA8B: FE3A    		cp	':'
DA8D: CA98DA  		jp	z,convrt2
DA90: 1B      		dec	de		;nope, move pointer back to the start of the line.
DA91: 3AFCDF  	convrt1:ld	a,(cdrive)
DA94: 77      		ld	(hl),a
DA95: C39EDA  		jp	convrt3
DA98: 78      	convrt2:ld	a,b
DA99: 32FDDF  		ld	(chgdrv),a	;set change in drives flag.
DA9C: 70      		ld	(hl),b
DA9D: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
DA9E: 0608    	convrt3:ld	b,08h
DAA0: CD38DA  	convrt4:call	check
DAA3: CAC1DA  		jp	z,convrt8
DAA6: 23      		inc	hl
DAA7: FE2A    		cp	'*'		;note that an '*' will fill the remaining
DAA9: C2B1DA  		jp	nz,convrt5	;field with '?'.
DAAC: 363F    		ld	(hl),'?'
DAAE: C3B3DA  		jp	convrt6
DAB1: 77      	convrt5:ld	(hl),a
DAB2: 13      		inc	de
DAB3: 05      	convrt6:dec	b
DAB4: C2A0DA  		jp	nz,convrt4
DAB7: CD38DA  	convrt7:call	check		;get next delimiter.
DABA: CAC8DA  		jp	z,getext
DABD: 13      		inc	de
DABE: C3B7DA  		jp	convrt7
DAC1: 23      	convrt8:inc	hl		;blank fill the file name.
DAC2: 3620    		ld	(hl),' '
DAC4: 05      		dec	b
DAC5: C2C1DA  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
DAC8: 0603    	getext:	ld	b,03h
DACA: FE2E    		cp	'.'
DACC: C2F1DA  		jp	nz,getext5
DACF: 13      		inc	de
DAD0: CD38DA  	getext1:call	check
DAD3: CAF1DA  		jp	z,getext5
DAD6: 23      		inc	hl
DAD7: FE2A    		cp	'*'
DAD9: C2E1DA  		jp	nz,getext2
DADC: 363F    		ld	(hl),'?'
DADE: C3E3DA  		jp	getext3
DAE1: 77      	getext2:ld	(hl),a
DAE2: 13      		inc	de
DAE3: 05      	getext3:dec	b
DAE4: C2D0DA  		jp	nz,getext1
DAE7: CD38DA  	getext4:call	check
DAEA: CAF8DA  		jp	z,getext6
DAED: 13      		inc	de
DAEE: C3E7DA  		jp	getext4
DAF1: 23      	getext5:inc	hl
DAF2: 3620    		ld	(hl),' '
DAF4: 05      		dec	b
DAF5: C2F1DA  		jp	nz,getext5
DAF8: 0603    	getext6:ld	b,3
DAFA: 23      	getext7:inc	hl
DAFB: 3600    		ld	(hl),0
DAFD: 05      		dec	b
DAFE: C2FADA  		jp	nz,getext7
DB01: EB      		ex	de,hl
DB02: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DB05: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
DB06: 010B00  		ld	bc,11		;set name length.
DB09: 23      	getext8:inc	hl
DB0A: 7E      		ld	a,(hl)
DB0B: FE3F    		cp	'?'		;any question marks?
DB0D: C211DB  		jp	nz,getext9
DB10: 04      		inc	b		;count them.
DB11: 0D      	getext9:dec	c
DB12: C209DB  		jp	nz,getext8
DB15: 78      		ld	a,b
DB16: B7      		or	a
DB17: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
DB18: 44495220	cmdtbl:	defb	'DIR '
DB1C: 45524120		defb	'ERA '
DB20: 54595045		defb	'TYPE'
DB24: 53415645		defb	'SAVE'
DB28: 52454E20		defb	'REN '
DB2C: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
DB30: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
DB34: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
DB36: 2118DB  	search:	ld	hl,cmdtbl
DB39: 0E00    		ld	c,0
DB3B: 79      	search1:ld	a,c
DB3C: FE06    		cp	numcmds		;this commands exists.
DB3E: D0      		ret	nc
DB3F: 11DBDF  		ld	de,fcb+1	;check this one.
DB42: 0604    		ld	b,4		;max command length.
DB44: 1A      	search2:ld	a,(de)
DB45: BE      		cp	(hl)
DB46: C257DB  		jp	nz,search3	;not a match.
DB49: 13      		inc	de
DB4A: 23      		inc	hl
DB4B: 05      		dec	b
DB4C: C244DB  		jp	nz,search2
DB4F: 1A      		ld	a,(de)		;allow a 3 character command to match.
DB50: FE20    		cp	' '
DB52: C25CDB  		jp	nz,search4
DB55: 79      		ld	a,c		;set return register for this command.
DB56: C9      		ret	
DB57: 23      	search3:inc	hl
DB58: 05      		dec	b
DB59: C257DB  		jp	nz,search3
DB5C: 0C      	search4:inc	c
DB5D: C33BDB  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
DB60: AF      	clearbuf: xor	a
DB61: 3207D8  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
DB64: 31B8DF  	command:ld	sp,ccpstack	;setup stack area.
DB67: C5      		push	bc		;note that (c) should be equal to:
DB68: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
DB69: 1F      		rra			;and 'dddd' is the drive number.
DB6A: 1F      		rra	
DB6B: 1F      		rra	
DB6C: 1F      		rra	
DB6D: E60F    		and	0fh		;isolate the user number.
DB6F: 5F      		ld	e,a
DB70: CD14D9  		call	getsetuc	;and set it.
DB73: CDB7D8  		call	resdsk		;reset the disk system.
              		;ld	(batch),a	;clear batch mode flag.
DB76: C1      		pop	bc
DB77: 79      		ld	a,c
DB78: E60F    		and	0fh		;isolate the drive number.
DB7A: 32FCDF  		ld	(cdrive),a	;and save.
DB7D: CDBCD8  		call	dsksel		;...and select.
DB80: 3A07D8  		ld	a,(inbuff+1)
DB83: B7      		or	a		;anything in input buffer already?
DB84: C2A5DB  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
DB87: 31B8DF  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
DB8A: CD98D8  		call	crlf		;start a new line on the screen.
DB8D: CDD8D9  		call	getdsk		;get current drive.
DB90: C641    		add	a,'A'
DB92: CD8CD8  		call	print		;print current drive.
DB95: CD12D9  		call	getusr		;get current user.
DB98: C630    		add	a,'0'
DB9A: CD98DF  		call	printdc		;print current user.
DB9D: 3E3E    		ld	a,'>'
DB9F: CD8CD8  		call	print		;and add prompt.
DBA2: CD38D9  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
DBA5: 118000  	cmmnd2:	ld	de,tbuff
DBA8: CDE0D9  		call	dmaset		;set standard dma address.
DBAB: CDD8D9  		call	getdsk
DBAE: 32FCDF  		ld	(cdrive),a	;set current drive.
DBB1: CD66DA  		call	convfst		;convert name typed in.
DBB4: C411DA  		call	nz,synerr	;wild cards are not allowed.
DBB7: 3AFDDF  		ld	a,(chgdrv)	;if a change in drives was indicated,
DBBA: B7      		or	a		;then treat this as an unknown command
DBBB: C2AEDE  		jp	nz,unknown	;which gets executed.
DBBE: CD36DB  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
DBC1: 21CEDB  		ld	hl,cmdadr	;now, look thru our address table for command (a).
DBC4: 5F      		ld	e,a		;set (de) to command number.
DBC5: 1600    		ld	d,0
DBC7: 19      		add	hl,de
DBC8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
DBC9: 7E      		ld	a,(hl)		;now pick out this address.
DBCA: 23      		inc	hl
DBCB: 66      		ld	h,(hl)
DBCC: 6F      		ld	l,a
DBCD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
DBCE: 84DC2CDD	cmdadr:	defw	direct,erase,type,save
DBD2: 6ADDBADD	
DBD6: 1DDE99DE		defw	rename,user,unknown
DBDA: AEDE    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
DBDC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
DBDF: 2200D8  		ld	(cbase),hl
DBE2: 2100D8  		ld	hl,cbase
DBE5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
DBE6: 01ECDB  	rderror:ld	bc,rderr
DBE9: C3A6D8  		jp	pline
DBEC: 72656164	rderr:	defb	'read error',0
DBF0: 20657272	
DBF4: 6F7200  	
              	;
              	;   required file was not located.
              	;
DBF7: 01FDDB  	none:	ld	bc,nofile
DBFA: C3A6D8  		jp	pline
DBFD: 6E6F2066	nofile:	defb	'no file',0
DC01: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
DC05: CD66DA  	decode:	call	convfst		;convert filename.
DC08: 3AFDDF  		ld	a,(chgdrv)	;do not allow a drive to be specified.
DC0B: B7      		or	a
DC0C: C211DA  		jp	nz,synerr
DC0F: 21DBDF  		ld	hl,fcb+1	;convert number now.
DC12: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
DC15: 7E      	decode1:ld	a,(hl)
DC16: FE20    		cp	' '		;a space terminates the numeral.
DC18: CA40DC  		jp	z,decode3
DC1B: 23      		inc	hl
DC1C: D630    		sub	'0'		;make binary from ascii.
DC1E: FE0A    		cp	10		;legal digit?
DC20: D211DA  		jp	nc,synerr
DC23: 57      		ld	d,a		;yes, save it in (d).
DC24: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
DC25: E6E0    		and	0e0h
DC27: C211DA  		jp	nz,synerr
DC2A: 78      		ld	a,b
DC2B: 07      		rlca	
DC2C: 07      		rlca	
DC2D: 07      		rlca			;(a)=(b)*8
DC2E: 80      		add	a,b		;.......*9
DC2F: DA11DA  		jp	c,synerr
DC32: 80      		add	a,b		;.......*10
DC33: DA11DA  		jp	c,synerr
DC36: 82      		add	a,d		;add in new digit now.
DC37: DA11DA  	decode2:jp	c,synerr
DC3A: 47      		ld	b,a		;and save result.
DC3B: 0D      		dec	c		;only look at 11 digits.
DC3C: C215DC  		jp	nz,decode1
DC3F: C9      		ret	
DC40: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
DC41: FE20    		cp	' '
DC43: C211DA  		jp	nz,synerr
DC46: 23      		inc	hl
DC47: 0D      	decode4:dec	c
DC48: C240DC  		jp	nz,decode3
DC4B: 78      		ld	a,b		;set (a)=the numeric value entered.
DC4C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
DC4D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
DC4F: 7E      	hl2de:	ld	a,(hl)
DC50: 12      		ld	(de),a
DC51: 23      		inc	hl
DC52: 13      		inc	de
DC53: 05      		dec	b
DC54: C24FDC  		jp	nz,hl2de
DC57: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
DC58: 218000  	extract:ld	hl,tbuff
DC5B: 81      		add	a,c
DC5C: CD61DA  		call	addhl
DC5F: 7E      		ld	a,(hl)
DC60: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
DC61: AF      	dselect:xor	a		;null out first byte of fcb.
DC62: 32DADF  		ld	(fcb),a
DC65: 3AFDDF  		ld	a,(chgdrv)	;a drive change indicated?
DC68: B7      		or	a
DC69: C8      		ret	z
DC6A: 3D      		dec	a		;yes, is it the same as the current drive?
DC6B: 21FCDF  		ld	hl,cdrive
DC6E: BE      		cp	(hl)
DC6F: C8      		ret	z
DC70: C3BCD8  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
DC73: 3AFDDF  	resetdr:ld	a,(chgdrv)	;drive change indicated?
DC76: B7      		or	a
DC77: C8      		ret	z
DC78: 3D      		dec	a		;yes, was it a different drive?
DC79: 21FCDF  		ld	hl,cdrive
DC7C: BE      		cp	(hl)
DC7D: C8      		ret	z
DC7E: 3AFCDF  		ld	a,(cdrive)	;yes, re-select our old drive.
DC81: C3BCD8  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
DC84: CD66DA  	direct:	call	convfst		;convert file name.
DC87: CD61DC  		call	dselect		;select indicated drive.
DC8A: 21DBDF  		ld	hl,fcb+1	;was any file indicated?
DC8D: 7E      		ld	a,(hl)
DC8E: FE20    		cp	' '
DC90: C29CDC  		jp	nz,direct2
DC93: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
DC95: 363F    	direct1:ld	(hl),'?'
DC97: 23      		inc	hl
DC98: 05      		dec	b
DC99: C295DC  		jp	nz,direct1
DC9C: 1E00    	direct2:ld	e,0		;set initial cursor position.
DC9E: D5      		push	de
DC9F: CDE8D8  		call	srchfcb		;get first file name.
DCA2: CCF7DB  		call	z,none		;none found at all?
DCA5: CA28DD  	direct3:jp	z,direct9	;terminate if no more names.
DCA8: 3AFBDF  		ld	a,(rtncode)	;get file's position in segment (0-3).
DCAB: 0F      		rrca	
DCAC: 0F      		rrca	
DCAD: 0F      		rrca	
DCAE: E660    		and	60h		;(a)=position*32
DCB0: 4F      		ld	c,a
DCB1: 3E0A    		ld	a,10
DCB3: CD58DC  		call	extract		;extract the tenth entry in fcb.
DCB6: 17      		rla			;check system file status bit.
DCB7: DA1CDD  		jp	c,direct8	;we don't list them.
DCBA: D1      		pop	de
DCBB: 7B      		ld	a,e		;bump name count.
DCBC: 1C      		inc	e
DCBD: D5      		push	de
DCBE: E603    		and	03h		;at end of line?
DCC0: F5      		push	af
DCC1: C2D9DC  		jp	nz,direct4
DCC4: CD98D8  		call	crlf		;yes, end this line and start another.
DCC7: C5      		push	bc
DCC8: CDD8D9  		call	getdsk		;start line with ('a:').
DCCB: C1      		pop	bc
DCCC: C641    		add	a,'A'
DCCE: CD92D8  		call	printb
DCD1: 3E3A    		ld	a,':'
DCD3: CD92D8  		call	printb
DCD6: C3E1DC  		jp	direct5
DCD9: CDA1D8  	direct4:call	space		;add seperator between file names.
DCDC: 3E3A    		ld	a,':'
DCDE: CD92D8  		call	printb
DCE1: CDA1D8  	direct5:call	space
DCE4: 0601    		ld	b,1		;'extract' each file name character at a time.
DCE6: 78      	direct6:ld	a,b
DCE7: CD58DC  		call	extract
DCEA: E67F    		and	7fh		;strip bit 7 (status bit).
DCEC: FE20    		cp	' '		;are we at the end of the name?
DCEE: C206DD  		jp	nz,drect65
DCF1: F1      		pop	af		;yes, don't print spaces at the end of a line.
DCF2: F5      		push	af
DCF3: FE03    		cp	3
DCF5: C204DD  		jp	nz,drect63
DCF8: 3E09    		ld	a,9		;first check for no extension.
DCFA: CD58DC  		call	extract
DCFD: E67F    		and	7fh
DCFF: FE20    		cp	' '
DD01: CA1BDD  		jp	z,direct7	;don't print spaces.
DD04: 3E20    	drect63:ld	a,' '		;else print them.
DD06: CD92D8  	drect65:call	printb
DD09: 04      		inc	b		;bump to next character psoition.
DD0A: 78      		ld	a,b
DD0B: FE0C    		cp	12		;end of the name?
DD0D: D21BDD  		jp	nc,direct7
DD10: FE09    		cp	9		;nope, starting extension?
DD12: C2E6DC  		jp	nz,direct6
DD15: CDA1D8  		call	space		;yes, add seperating space.
DD18: C3E6DC  		jp	direct6
DD1B: F1      	direct7:pop	af		;get the next file name.
DD1C: CDCAD9  	direct8:call	chkcon		;first check console, quit on anything.
DD1F: C228DD  		jp	nz,direct9
DD22: CDE3D8  		call	srchnxt		;get next name.
DD25: C3A5DC  		jp	direct3		;and continue with our list.
DD28: D1      	direct9:pop	de		;restore the stack and return to command level.
DD29: C383DF  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DD2C: CD66DA  	erase:	call	convfst		;convert file name.
DD2F: FE0B    		cp	11		;was '*.*' entered?
DD31: C24FDD  		jp	nz,erase1
DD34: 015FDD  		ld	bc,yesno	;yes, ask for confirmation.
DD37: CDA6D8  		call	pline
DD3A: CD38D9  		call	getinp
DD3D: 2107D8  		ld	hl,inbuff+1
DD40: 35      		dec	(hl)		;must be exactly 'y'.
DD41: C287DB  		jp	nz,cmmnd1
DD44: 23      		inc	hl
DD45: 7E      		ld	a,(hl)
DD46: FE79    		cp	'y'
DD48: C287DB  		jp	nz,cmmnd1
DD4B: 23      		inc	hl
DD4C: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DD4F: CD61DC  	erase1:	call	dselect		;select desired disk.
DD52: 11DADF  		ld	de,fcb
DD55: CDEED8  		call	delete		;delete the file.
DD58: 3C      		inc	a
DD59: CCF7DB  		call	z,none		;not there?
DD5C: C383DF  		jp	getback		;return to command level now.
DD5F: 616C6C20	yesno:	defb	'all (y/n)?',0
DD63: 28792F6E	
DD67: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DD6A: CD66DA  	type:	call	convfst		;convert file name.
DD6D: C211DA  		jp	nz,synerr	;wild cards not allowed.
DD70: CD61DC  		call	dselect		;select indicated drive.
DD73: CDCFD8  		call	openfcb		;open the file.
DD76: CAB4DD  		jp	z,type5		;not there?
DD79: CD98D8  		call	crlf		;ok, start a new line on the screen.
DD7C: 21FEDF  		ld	hl,nbytes	;initialize byte counter.
DD7F: 36FF    		ld	(hl),0ffh	;set to read first sector.
DD81: 21FEDF  	type1:	ld	hl,nbytes
DD84: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
DD85: FE80    		cp	128
DD87: DA94DD  		jp	c,type3
DD8A: E5      		push	hl		;yes, read in the next one.
DD8B: CDFDD8  		call	readfcb
DD8E: E1      		pop	hl
DD8F: C2ADDD  		jp	nz,type4	;end or error?
DD92: AF      		xor	a		;ok, clear byte counter.
DD93: 77      		ld	(hl),a
DD94: 34      	type3:	inc	(hl)		;count this byte.
DD95: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
DD98: CD61DA  		call	addhl
DD9B: 7E      		ld	a,(hl)
DD9C: FE1A    		cp	cntrlz		;end of file mark?
DD9E: CA83DF  		jp	z,getback
DDA1: CD8CD8  		call	print		;no, print it.
DDA4: CDCAD9  		call	chkcon		;check console, quit if anything ready.
DDA7: C283DF  		jp	nz,getback
DDAA: C381DD  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
DDAD: 3D      	type4:	dec	a		;read error?
DDAE: CA83DF  		jp	z,getback
DDB1: CDE6DB  		call	rderror		;yes, print message.
DDB4: CD73DC  	type5:	call	resetdr		;and reset proper drive
DDB7: C311DA  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DDBA: CD05DC  	save:	call	decode		;get numeric number that follows save.
DDBD: F5      		push	af		;save number of pages to write.
DDBE: CD66DA  		call	convfst		;convert file name.
DDC1: C211DA  		jp	nz,synerr	;wild cards not allowed.
DDC4: CD61DC  		call	dselect		;select specified drive.
DDC7: 11DADF  		ld	de,fcb		;now delete this file.
DDCA: D5      		push	de
DDCB: CDEED8  		call	delete
DDCE: D1      		pop	de
DDCF: CD08D9  		call	create		;and create it again.
DDD2: CA08DE  		jp	z,save3		;can't create?
DDD5: AF      		xor	a		;clear record number byte.
DDD6: 32FADF  		ld	(fcb+32),a
DDD9: F1      		pop	af		;convert pages to sectors.
DDDA: 6F      		ld	l,a
DDDB: 2600    		ld	h,0
DDDD: 29      		add	hl,hl		;(hl)=number of sectors to write.
DDDE: 110001  		ld	de,tbase	;and we start from here.
DDE1: 7C      	save1:	ld	a,h		;done yet?
DDE2: B5      		or	l
DDE3: CAFEDD  		jp	z,save2
DDE6: 2B      		dec	hl		;nope, count this and compute the start
DDE7: E5      		push	hl		;of the next 128 byte sector.
DDE8: 218000  		ld	hl,128
DDEB: 19      		add	hl,de
DDEC: E5      		push	hl		;save it and set the transfer address.
DDED: CDE0D9  		call	dmaset
DDF0: 11DADF  		ld	de,fcb		;write out this sector now.
DDF3: CD03D9  		call	wrtrec
DDF6: D1      		pop	de		;reset (de) to the start of the last sector.
DDF7: E1      		pop	hl		;restore sector count.
DDF8: C208DE  		jp	nz,save3	;write error?
DDFB: C3E1DD  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
DDFE: 11DADF  	save2:	ld	de,fcb		;now close the file.
DE01: CDD9D8  		call	close
DE04: 3C      		inc	a		;did it close ok?
DE05: C20EDE  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
DE08: 0114DE  	save3:	ld	bc,nospace
DE0B: CDA6D8  		call	pline
DE0E: CDDDD9  	save4:	call	stddma		;reset the standard dma address.
DE11: C383DF  		jp	getback
DE14: 6E6F2073	nospace:defb	'no space',0
DE18: 70616365	
DE1C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DE1D: CD66DA  	rename:	call	convfst		;convert first file name.
DE20: C211DA  		jp	nz,synerr	;wild cards not allowed.
DE23: 3AFDDF  		ld	a,(chgdrv)	;remember any change in drives specified.
DE26: F5      		push	af
DE27: CD61DC  		call	dselect		;and select this drive.
DE2A: CDE8D8  		call	srchfcb		;is this file present?
DE2D: C284DE  		jp	nz,rename6	;yes, print error message.
DE30: 21DADF  		ld	hl,fcb		;yes, move this name into second slot.
DE33: 11EADF  		ld	de,fcb+16
DE36: 0610    		ld	b,16
DE38: CD4FDC  		call	hl2de
DE3B: 2A88D8  		ld	hl,(inpoint)	;get input pointer.
DE3E: EB      		ex	de,hl
DE3F: CD57DA  		call	nonblank	;get next non blank character.
DE42: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
DE44: CA4CDE  		jp	z,rename1
DE47: FE5F    		cp	'_'
DE49: C27EDE  		jp	nz,rename5
DE4C: EB      	rename1:ex	de,hl
DE4D: 23      		inc	hl		;ok, skip seperator.
DE4E: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DE51: CD66DA  		call	convfst		;convert this second file name now.
DE54: C27EDE  		jp	nz,rename5	;again, no wild cards.
DE57: F1      		pop	af		;if a drive was specified, then it
DE58: 47      		ld	b,a		;must be the same as before.
DE59: 21FDDF  		ld	hl,chgdrv
DE5C: 7E      		ld	a,(hl)
DE5D: B7      		or	a
DE5E: CA65DE  		jp	z,rename2
DE61: B8      		cp	b
DE62: 70      		ld	(hl),b
DE63: 2019    		jr	nz,rename5	;they were different, error.
DE65: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
DE66: AF      		xor	a
DE67: 32DADF  		ld	(fcb),a		;clear the drive byte of the fcb.
DE6A: CDE8D8  	rename3:call	srchfcb		;and go look for second file.
DE6D: 2809    		jr	z,rename4	;doesn't exist?
DE6F: 11DADF  		ld	de,fcb
DE72: CD0DD9  		call	renam		;ok, rename the file.
DE75: C383DF  		jp	getback
              	;
              	;   process rename errors here.
              	;
DE78: CDF7DB  	rename4:call	none		;file not there.
DE7B: C383DF  		jp	getback
DE7E: CD73DC  	rename5:call	resetdr		;bad command format.
DE81: C311DA  	synerrt:jp	synerr
DE84: 018DDE  	rename6:ld	bc,exists	;destination file already exists.
DE87: CDA6D8  		call	pline
DE8A: C383DF  		jp	getback
DE8D: 66696C65	exists:	defb	'file exists',0
DE91: 20657869	
DE95: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
DE99: CD05DC  	user:	call	decode		;get numeric value following command.
DE9C: FE10    		cp	16		;legal user number?
DE9E: 30E1    		jr	nc,synerrt
DEA0: 5F      		ld	e,a		;yes but is there anything else?
DEA1: 3ADBDF  		ld	a,(fcb+1)
DEA4: FE20    		cp	' '
DEA6: 28D9    		jr	z,synerrt	;yes, that is not allowed.
DEA8: CD14D9  		call	getsetuc	;ok, set user code.
DEAB: C386DF  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
DEAE: CDFDD9  	unknown:call	verify		;check for valid system (why?).
DEB1: 3ADBDF  		ld	a,(fcb+1)	;anything to execute?
DEB4: FE20    		cp	' '
DEB6: 2014    		jr	nz,unkwn1
DEB8: 3AFDDF  		ld	a,(chgdrv)	;nope, only a drive change?
DEBB: B7      		or	a
DEBC: CA86DF  		jp	z,getback1	;neither???
DEBF: 3D      		dec	a
DEC0: 32FCDF  		ld	(cdrive),a	;ok, store new drive.
DEC3: CD28D9  		call	movecd		;set (tdrive) also.
DEC6: CDBCD8  		call	dsksel		;and select this drive.
DEC9: C386DF  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
DECC: 11E3DF  	unkwn1:	ld	de,fcb+9	;an extension specified?
DECF: 1A      		ld	a,(de)
DED0: FE20    		cp	' '
DED2: 20AD    		jr	nz,synerrt	;yes, not allowed.
DED4: D5      	unkwn2:	push	de
DED5: CD61DC  		call	dselect		;select specified drive.
DED8: D1      		pop	de
DED9: 2180DF  		ld	hl,comfile	;set the extension to 'com'.
DEDC: CD4DDC  		call	move3
DEDF: CDCFD8  		call	openfcb		;and open this file.
DEE2: CA69DF  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
DEE5: 210001  		ld	hl,tbase	;store the program starting here.
DEE8: E5      	unkwn3:	push	hl
DEE9: EB      		ex	de,hl
DEEA: CDE0D9  		call	dmaset		;set transfer address.
DEED: 11DADF  		ld	de,fcb		;and read the next record.
DEF0: CDF8D8  		call	rdrec
DEF3: 2010    		jr	nz,unkwn4	;end of file or read error?
DEF5: E1      		pop	hl		;nope, bump pointer for next sector.
DEF6: 118000  		ld	de,128
DEF9: 19      		add	hl,de
DEFA: 1100D8  		ld	de,cbase	;enough room for the whole file?
DEFD: 7D      		ld	a,l
DEFE: 93      		sub	e
DEFF: 7C      		ld	a,h
DF00: 9A      		sbc	a,d
DF01: 306C    		jr	nc,unkwn0	;no, it can't fit.
DF03: 18E3    		jr	unkwn3
              	;
              	;   get here after finished reading.
              	;
DF05: E1      	unkwn4:	pop	hl
DF06: 3D      		dec	a		;normal end of file?
DF07: 2066    		jr	nz,unkwn0
DF09: CD73DC  		call	resetdr		;yes, reset previous drive.
DF0C: CD66DA  		call	convfst		;convert the first file name that follows
DF0F: 21FDDF  		ld	hl,chgdrv	;command name.
DF12: E5      		push	hl
DF13: 7E      		ld	a,(hl)		;set drive code in default fcb.
DF14: 32DADF  		ld	(fcb),a
DF17: 3E10    		ld	a,16		;put second name 16 bytes later.
DF19: CD68DA  		call	convert		;convert second file name.
DF1C: E1      		pop	hl
DF1D: 7E      		ld	a,(hl)		;and set the drive for this second file.
DF1E: 32EADF  		ld	(fcb+16),a
DF21: AF      		xor	a		;clear record byte in fcb.
DF22: 32FADF  		ld	(fcb+32),a
DF25: 115C00  		ld	de,tfcb		;move it into place at(005ch).
DF28: 21DADF  		ld	hl,fcb
DF2B: 0621    		ld	b,33
DF2D: CD4FDC  		call	hl2de
DF30: 2108D8  		ld	hl,inbuff+2	;now move the remainder of the input
DF33: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
DF34: B7      		or	a		;or a null.
DF35: 2807    		jr	z,unkwn6
DF37: FE20    		cp	' '
DF39: 2803    		jr	z,unkwn6
DF3B: 23      		inc	hl
DF3C: 18F5    		jr	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
DF3E: 0600    	unkwn6:	ld	b,0		;keep a character count.
DF40: 118100  		ld	de,tbuff+1	;data gets put here.
DF43: 7E      	unkwn7:	ld	a,(hl)		;move it now.
DF44: 12      		ld	(de),a
DF45: B7      		or	a
DF46: 2805    		jr	z,unkwn8
DF48: 04      		inc	b
DF49: 23      		inc	hl
DF4A: 13      		inc	de
DF4B: 18F6    		jr	unkwn7
DF4D: 78      	unkwn8:	ld	a,b		;now store the character count.
DF4E: 328000  		ld	(tbuff),a
DF51: CD98D8  		call	crlf		;clean up the screen.
DF54: CDDDD9  		call	stddma		;set standard transfer address.
DF57: CD19D9  		call	setcdrv		;reset current drive.
DF5A: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
DF5D: 31B8DF  		ld	sp,batch	;set stack first off.
DF60: CD28D9  		call	movecd		;move current drive into place (tdrive).
DF63: CDBCD8  		call	dsksel		;and reselect it.
DF66: C387DB  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
DF69: CD73DC  	unkwn9:	call	resetdr		;inproper format.
DF6C: C311DA  		jp	synerr
DF6F: 0177DF  	unkwn0:	ld	bc,badload	;read error or won't fit.
DF72: CDA6D8  		call	pline
DF75: 180C    		jr	getback
DF77: 42616420	badload:defb	'Bad load',0
DF7B: 6C6F6164	
DF7F: 00      	
DF80: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
DF83: CD73DC  	getback:call	resetdr		;reset previous drive.
DF86: CD66DA  	getback1: call	convfst		;convert first name in (fcb).
DF89: 3ADBDF  		ld	a,(fcb+1)	;if this was just a drive change request,
DF8C: D620    		sub	' '		;make sure it was valid.
DF8E: 21FDDF  		ld	hl,chgdrv
DF91: B6      		or	(hl)
DF92: C211DA  		jp	nz,synerr
DF95: C387DB  		jp	cmmnd1		;ok, return to command level.
              		
              	; Small routine to print a decimal 0-19
DF98: FE3A    	printdc:cp	':'
DF9A: DA8CD8  		jp	c,print
DF9D: D60A    		sub	10
DF9F: F5      		push	af
DFA0: 3E31    		ld	a,'1'
DFA2: CD8CD8  		call	print
DFA5: F1      		pop	af
DFA6: 18F0    		jr	printdc
              	;
              	;   ccp stack area.
              	;
DFA8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DFAC: 00...   	
DFB8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
DFB8: 00      	batch:	defb	0		;batch mode flag (0=not active).
DFB9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DFBD: 20202020	
DFC1: 20535542	
DFC5: 00000000	
DFC9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
DFDA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
DFDE: 20202020	
DFE2: 20202020	
DFE6: 00000000	
DFEA: 00202020	
DFEE: 20202020	
DFF2: 20202020	
DFF6: 00000000	
DFFA: 00      	
DFFB: 00      	rtncode:defb	0		;status returned from bdos call.
DFFC: 00      	cdrive:	defb	0		;currently active drive.
DFFD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
DFFE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E000: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E004: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E006: C314E0  	fbase:	jp	fbase1
E009: C33AEE  		jp	boot
              	;
              	;   bdos error table.
              	;
E00C: 9FE0    	badsctr:defw	error1		;bad sector on read or write.
E00E: ABE0    	badslct:defw	error2		;bad disk select.
E010: B1E0    	rodisk:	defw	error3		;disk is read only.
E012: B7E0    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E014: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E015: 224EE3  		ld	(params),hl
E018: EB      		ex	de,hl
E019: 7B      		ld	a,e		;and save register (e) in particular.
E01A: 32E1ED  		ld	(eparam),a
E01D: 210000  		ld	hl,0
E020: 2250E3  		ld	(status),hl	;clear return status.
E023: 39      		add	hl,sp
E024: 221AE3  		ld	(usrstack),hl	;save users stack pointer.
E027: 314CE3  		ld	sp,stkarea	;and set our own.
E02A: AF      		xor	a		;clear auto select storage space.
E02B: 32EBED  		ld	(autoflag),a
E02E: 32E9ED  		ld	(auto),a
E031: 217FED  		ld	hl,goback	;set return address.
E034: E5      		push	hl
E035: CD6EEF  		call	syshook		; see if anyone wants to intercept the call
E038: 79      		ld	a,c		;get function number.
E039: FE29    		cp	nfuncts		;valid function number?
E03B: D0      		ret	nc
E03C: 4B      		ld	c,e		;keep single register function here.
E03D: 214DE0  		ld	hl,functns	;now look thru the function table.
E040: 5F      		ld	e,a
E041: 1600    		ld	d,0		;(de)=function number.
E043: 19      		add	hl,de
E044: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E045: 5E      		ld	e,(hl)
E046: 23      		inc	hl
E047: 56      		ld	d,(hl)		;now (de)=address for this function.
E048: 2A4EE3  		ld	hl,(params)	;retrieve parameters.
E04B: EB      		ex	de,hl		;now (de) has the original parameters.
E04C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E04D: 48EED3E2	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E051: 9BE1D9E2	
E055: C9EEC5EE	
E059: DFE2F8E2	
E05D: FEE203E3		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E061: ECE109E3	
E065: 89EC8EEC	
E069: 50ECA7EC	
E06D: B0ECB6EC		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E071: D3ECE2EC	
E075: EBECF1EC	
E079: F7EC    	
E07B: 00ED09ED		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E07F: 0FED15ED	
E083: 1CED37E5	
E087: 22ED28ED	
E08B: 31ED38ED		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E08F: 4CED52ED	
E093: 58ED19EC	
E097: 5EED0FE3	
E09B: 0FE3A6ED		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E09F: 21D5E0  	error1:	ld	hl,badsec	;bad sector message.
E0A2: CDF0E0  		call	prterr		;print it and get a 1 char responce.
E0A5: FE03    		cp	cntrlc		;re-boot request (control-c)?
E0A7: CA0000  		jp	z,0		;yes.
E0AA: C9      		ret			;no, return to retry i/o function.
              	;
E0AB: 21E0E0  	error2:	ld	hl,badsel	;bad drive selected.
E0AE: C3BAE0  		jp	error5
              	;
E0B1: 21ECE0  	error3:	ld	hl,diskro	;disk is read only.
E0B4: C3BAE0  		jp	error5
              	;
E0B7: 21E7E0  	error4:	ld	hl,filero	;file is read only.
              	;
E0BA: 3E00    	error5:	ld	a,default
E0BC: 320400  		ld	(tdrive),a
E0BF: CDF0E0  		call	prterr
E0C2: C30000  		jp	0		;always reboot on these errors.
              	;
E0C5: 42646F73	bdoserr:defb	'Bdos Err on '
E0C9: 20457272	
E0CD: 206F6E20	
E0D1: 203A2024	bdosdrv:defb	' : $'
E0D5: 42616420	badsec:	defb	'Bad Sector$'
E0D9: 53656374	
E0DD: 6F7224  	
E0E0: 53656C65	badsel:	defb	'Select$'
E0E4: 637424  	
E0E7: 46696C65	filero:	defb	'File '
E0EB: 20      	
E0EC: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E0F0: E5      	prterr:	push	hl		;save second message pointer.
E0F1: CDD4E1  		call	outcrlf		;send (cr)(lf).
E0F4: 3A4DE3  		ld	a,(active)	;get active drive.
E0F7: C641    		add	a,'A'		;make ascii.
E0F9: 32D1E0  		ld	(bdosdrv),a	;and put in message.
E0FC: 01C5E0  		ld	bc,bdoserr	;and print it.
E0FF: CDDEE1  		call	prtmesg
E102: C1      		pop	bc		;print second message line now.
E103: CDDEE1  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E106: 2119E3  	getchar:ld	hl,charbuf	;check character buffer.
E109: 7E      		ld	a,(hl)		;anything present already?
E10A: 3600    		ld	(hl),0		;...either case clear it.
E10C: B7      		or	a
E10D: C0      		ret	nz		;yes, use it.
E10E: C3ADEE  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E111: CD06E1  	getecho:call	getchar		;input a character.
E114: CD1FE1  		call	chkchar		;carriage control?
E117: D8      		ret	c		;no, a regular control char so don't echo.
E118: F5      		push	af		;ok, save character now.
E119: 4F      		ld	c,a
E11A: CD9BE1  		call	outcon		;and echo it.
E11D: F1      		pop	af		;get character and return.
E11E: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E11F: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E121: C8      		ret	z		;or a tab.
E122: FE0A    		cp	lf
E124: C8      		ret	z
E125: FE09    		cp	tab
E127: C8      		ret	z
E128: FE08    		cp	bs
E12A: C8      		ret	z
E12B: FE20    		cp	' '		;other control char? set carry flag.
E12D: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E12E: 3A19E3  	ckconsol: ld	a,(charbuf)	;check buffer.
E131: B7      		or	a		;if anything, just return without checking.
E132: C250E1  		jp	nz,ckcon2
E135: CDA2EE  		call	const		;nothing in buffer. check console.
E138: E601    		and	01h		;look at bit 0.
E13A: C8      		ret	z		;return if nothing.
E13B: CDADEE  		call	conin		;ok, get it.
E13E: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E140: C24DE1  		jp	nz,ckcon1
E143: CDADEE  		call	conin		;halt processing until another char
E146: FE03    		cp	cntrlc		;is typed. control-c?
E148: CA0000  		jp	z,0		;yes, reboot now.
E14B: AF      		xor	a		;no, just pretend nothing was ever ready.
E14C: C9      		ret	
E14D: 3219E3  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E150: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E152: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E153: 3A15E3  	outchar:ld	a,(outflag)	;check output flag.
E156: B7      		or	a		;anything and we won't generate output.
E157: C26DE1  		jp	nz,outchr1
E15A: C5      		push	bc
E15B: CD2EE1  		call	ckconsol	;check console (we don't care whats there).
E15E: C1      		pop	bc
E15F: C5      		push	bc
E160: CDB9EE  		call	conout		;output (c) to the screen.
E163: C1      		pop	bc
E164: C5      		push	bc
E165: 3A18E3  		ld	a,(prtflag)	;check printer flip-flop flag.
E168: B7      		or	a
E169: C4C5EE  		call	nz,list		;print it also if non-zero.
E16C: C1      		pop	bc
E16D: 79      	outchr1:ld	a,c		;update cursors position.
E16E: 2117E3  		ld	hl,curpos
E171: FE7F    		cp	del		;rubouts don't do anything here.
E173: C8      		ret	z
E174: 34      		inc	(hl)		;bump line pointer.
E175: FE20    		cp	' '		;and return if a normal character.
E177: D0      		ret	nc
E178: 35      		dec	(hl)		;restore and check for the start of the line.
E179: 7E      		ld	a,(hl)
E17A: B7      		or	a
E17B: C8      		ret	z		;ingnore control characters at the start of the line.
E17C: 79      		ld	a,c
E17D: FE08    		cp	bs		;is it a backspace?
E17F: C284E1  		jp	nz,outchr2
E182: 35      		dec	(hl)		;yes, backup pointer.
E183: C9      		ret	
E184: FE0A    	outchr2:cp	lf		;is it a line feed?
E186: C0      		ret	nz		;ignore anything else.
E187: 3600    		ld	(hl),0		;reset pointer to start of line.
E189: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E18A: 79      	showit:	ld	a,c
E18B: CD1FE1  		call	chkchar		;check character.
E18E: D29BE1  		jp	nc,outcon	;not a control, use normal output.
E191: F5      		push	af
E192: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E194: CD53E1  		call	outchar
E197: F1      		pop	af
E198: F640    		or	'@'		;and then use the letter equivelant.
E19A: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E19B: 79      	outcon:	ld	a,c
E19C: FE09    		cp	tab		;is it a tab?
E19E: C253E1  		jp	nz,outchar	;use regular output.
E1A1: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E1A3: CD53E1  		call	outchar
E1A6: 3A17E3  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E1A9: E607    		and	07h		;position.
E1AB: C2A1E1  		jp	nz,outcon1
E1AE: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E1AF: CDB7E1  	backup:	call	backup1		;backup the screen 1 place.
E1B2: 0E20    		ld	c,' '		;then blank that character.
E1B4: CDB9EE  		call	conout
E1B7: 0E08    	backup1:ld	c,bs		;then back space once more.
E1B9: C3B9EE  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E1BC: 0E23    	newline:ld	c,'#'
E1BE: CD53E1  		call	outchar		;print this.
E1C1: CDD4E1  		call	outcrlf		;start new line.
E1C4: 3A17E3  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E1C7: 2116E3  		ld	hl,starting
E1CA: BE      		cp	(hl)
E1CB: D0      		ret	nc		;there yet?
E1CC: 0E20    		ld	c,' '
E1CE: CD53E1  		call	outchar		;nope, keep going.
E1D1: C3C4E1  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E1D4: 0E0D    	outcrlf:ld	c,cr
E1D6: CD53E1  		call	outchar
E1D9: 0E0A    		ld	c,lf
E1DB: C353E1  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E1DE: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E1DF: FE24    		cp	'$'
E1E1: C8      		ret	z
E1E2: 03      		inc	bc
E1E3: C5      		push	bc		;otherwise, bump pointer and print it.
E1E4: 4F      		ld	c,a
E1E5: CD9BE1  		call	outcon
E1E8: C1      		pop	bc
E1E9: C3DEE1  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E1EC: 3A17E3  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E1EF: 3216E3  		ld	(starting),a
E1F2: 2A4EE3  		ld	hl,(params)	;get the maximum buffer space.
E1F5: 4E      		ld	c,(hl)
E1F6: 23      		inc	hl		;point to first available space.
E1F7: E5      		push	hl		;and save.
E1F8: 0600    		ld	b,0		;keep a character count.
E1FA: C5      	rdbuf1:	push	bc
E1FB: E5      		push	hl
E1FC: CD06E1  	rdbuf2:	call	getchar		;get the next input character.
E1FF: E67F    		and	7fh		;strip bit 7.
E201: E1      		pop	hl		;reset registers.
E202: C1      		pop	bc
E203: FE0D    		cp	cr		;en of the line?
E205: CACCE2  		jp	z,rdbuf17
E208: FE0A    		cp	lf
E20A: CACCE2  		jp	z,rdbuf17
E20D: FE08    		cp	bs		;how about a backspace?
E20F: C221E2  		jp	nz,rdbuf3
E212: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E213: B7      		or	a
E214: CAFAE1  		jp	z,rdbuf1
E217: 05      		dec	b		;ok, update counter.
E218: 3A17E3  		ld	a,(curpos)	;if we backspace to the start of the line,
E21B: 3215E3  		ld	(outflag),a	;treat as a cancel (control-x).
E21E: C37BE2  		jp	rdbuf10
E221: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E223: C231E2  		jp	nz,rdbuf4
E226: 78      		ld	a,b		;ignore at the start of the line.
E227: B7      		or	a
E228: CAFAE1  		jp	z,rdbuf1
E22B: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E22C: 05      		dec	b		;and reset pointers (counters).
E22D: 2B      		dec	hl
E22E: C3B4E2  		jp	rdbuf15
E231: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E233: C242E2  		jp	nz,rdbuf5
E236: C5      		push	bc		;yes, do it.
E237: E5      		push	hl
E238: CDD4E1  		call	outcrlf
E23B: AF      		xor	a		;and update starting position.
E23C: 3216E3  		ld	(starting),a
E23F: C3FCE1  		jp	rdbuf2
E242: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E244: C253E2  		jp	nz,rdbuf6
E247: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E248: 2118E3  		ld	hl,prtflag
E24B: 3E01    		ld	a,1		;prtflag=1-prtflag
E24D: 96      		sub	(hl)
E24E: 77      		ld	(hl),a
E24F: E1      		pop	hl
E250: C3FAE1  		jp	rdbuf1
E253: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E255: C26AE2  		jp	nz,rdbuf8
E258: E1      		pop	hl
E259: 3A16E3  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E25C: 2117E3  		ld	hl,curpos
E25F: BE      		cp	(hl)
E260: D2ECE1  		jp	nc,rdbuff	;done yet?
E263: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E264: CDAFE1  		call	backup
E267: C359E2  		jp	rdbuf7
E26A: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E26C: C276E2  		jp	nz,rdbuf9
E26F: CDBCE1  		call	newline		;start a new line.
E272: E1      		pop	hl
E273: C3ECE1  		jp	rdbuff
E276: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E278: C2B1E2  		jp	nz,rdbuf14
E27B: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E27C: CDBCE1  		call	newline
E27F: C1      		pop	bc
E280: E1      		pop	hl
E281: E5      		push	hl
E282: C5      		push	bc
E283: 78      	rdbuf11:ld	a,b		;done whole line yet?
E284: B7      		or	a
E285: CA95E2  		jp	z,rdbuf12
E288: 23      		inc	hl		;nope, get next character.
E289: 4E      		ld	c,(hl)
E28A: 05      		dec	b		;count it.
E28B: C5      		push	bc
E28C: E5      		push	hl
E28D: CD8AE1  		call	showit		;and display it.
E290: E1      		pop	hl
E291: C1      		pop	bc
E292: C383E2  		jp	rdbuf11
E295: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E296: 3A15E3  		ld	a,(outflag)	;then update cursor position.
E299: B7      		or	a
E29A: CAFCE1  		jp	z,rdbuf2
E29D: 2117E3  		ld	hl,curpos	;because this line is shorter, we must
E2A0: 96      		sub	(hl)		;back up the cursor (not the screen however)
E2A1: 3215E3  		ld	(outflag),a	;some number of positions.
E2A4: CDAFE1  	rdbuf13:call	backup		;note that as long as (outflag) is non
E2A7: 2115E3  		ld	hl,outflag	;zero, the screen will not be changed.
E2AA: 35      		dec	(hl)
E2AB: C2A4E2  		jp	nz,rdbuf13
E2AE: C3FCE1  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E2B1: 23      	rdbuf14:inc	hl
E2B2: 77      		ld	(hl),a		;store character.
E2B3: 04      		inc	b		;and count it.
E2B4: C5      	rdbuf15:push	bc
E2B5: E5      		push	hl
E2B6: 4F      		ld	c,a		;echo it now.
E2B7: CD8AE1  		call	showit
E2BA: E1      		pop	hl
E2BB: C1      		pop	bc
E2BC: 7E      		ld	a,(hl)		;was it an abort request?
E2BD: FE03    		cp	cntrlc		;control-c abort?
E2BF: 78      		ld	a,b
E2C0: C2C8E2  		jp	nz,rdbuf16
E2C3: FE01    		cp	1		;only if at start of line.
E2C5: CA0000  		jp	z,0
E2C8: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E2C9: DAFAE1  		jp	c,rdbuf1
E2CC: E1      	rdbuf17:pop	hl		;yes end the line and return.
E2CD: 70      		ld	(hl),b
E2CE: 0E0D    		ld	c,cr
E2D0: C353E1  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E2D3: CD11E1  	getcon:	call	getecho		;get and echo.
E2D6: C30CE3  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E2D9: CDCDEE  	getrdr:	call	reader		;get a character from reader, set status and return.
E2DC: C30CE3  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E2DF: 79      	dircio:	ld	a,c		;test for (ff).
E2E0: 3C      		inc	a
E2E1: CAEBE2  		jp	z,dirc1
E2E4: 3C      		inc	a		;test for (fe).
E2E5: CAA2EE  		jp	z,const
E2E8: C3B9EE  		jp	conout		;just output (c).
E2EB: CDA2EE  	dirc1:	call	const		;this is an input request.
E2EE: B7      		or	a
E2EF: CA9CED  		jp	z,goback1	;not ready? just return (directly).
E2F2: CDADEE  		call	conin		;yes, get character.
E2F5: C30CE3  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E2F8: 3A0300  	getiob:	ld	a,(iobyte)
E2FB: C30CE3  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E2FE: 210300  	setiob:	ld	hl,iobyte
E301: 71      		ld	(hl),c
E302: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E303: EB      	prtstr:	ex	de,hl
E304: 4D      		ld	c,l
E305: 44      		ld	b,h		;now (bc) points to it.
E306: C3DEE1  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E309: CD2EE1  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E30C: 3250E3  	setstat:ld	(status),a
E30F: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E310: 3E01    	ioerr1:	ld	a,1
E312: C30CE3  		jp	setstat
              	;
E315: 00      	outflag:defb	0		;output flag (non zero means no output).
E316: 02      	starting: defb	2		;starting position for cursor.
E317: 00      	curpos:	defb	0		;cursor position (0=start of line).
E318: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E319: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E31A: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E31C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E320: 00...   	
E334: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E338: 00...   	
E34C:         	stkarea equ	$		;end of stack area.
              	;
E34C: 00      	userno:	defb	0		;current user number.
E34D: 00      	active:	defb	0		;currently active drive.
E34E: 0000    	params:	defw	0		;save (de) parameters here on entry.
E350: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E352: 210EE0  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E355: 5E      	jumphl:	ld	e,(hl)
E356: 23      		inc	hl
E357: 56      		ld	d,(hl)		;now (de) contain the desired address.
E358: EB      		ex	de,hl
E359: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E35A: 0C      	de2hl:	inc	c		;is count down to zero?
E35B: 0D      	de2hl1:	dec	c
E35C: C8      		ret	z		;yes, we are done.
E35D: 1A      		ld	a,(de)		;no, move one more byte.
E35E: 77      		ld	(hl),a
E35F: 13      		inc	de
E360: 23      		inc	hl
E361: C35BE3  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E364: 3A4DE3  	select:	ld	a,(active)	;get active disk.
E367: 4F      		ld	c,a
E368: CDE0EE  		call	seldsk		;select it.
E36B: 7C      		ld	a,h		;valid drive?
E36C: B5      		or	l		;valid drive?
E36D: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E36E: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E36F: 23      		inc	hl
E370: 56      		ld	d,(hl)
E371: 23      		inc	hl
E372: 22BEED  		ld	(scratch1),hl	;save pointers to scratch areas.
E375: 23      		inc	hl
E376: 23      		inc	hl
E377: 22C0ED  		ld	(scratch2),hl	;ditto.
E37A: 23      		inc	hl
E37B: 23      		inc	hl
E37C: 22C2ED  		ld	(scratch3),hl	;ditto.
E37F: 23      		inc	hl
E380: 23      		inc	hl
E381: EB      		ex	de,hl		;now save the translation table address.
E382: 22DBED  		ld	(xlate),hl
E385: 21C4ED  		ld	hl,dirbuf	;put the next 8 bytes here.
E388: 0E08    		ld	c,8		;they consist of the directory buffer
E38A: CD5AE3  		call	de2hl		;pointer, parameter block pointer,
E38D: 2AC6ED  		ld	hl,(diskpb)	;check and allocation vectors.
E390: EB      		ex	de,hl
E391: 21CCED  		ld	hl,sectors	;move parameter block into our ram.
E394: 0E0F    		ld	c,15		;it is 15 bytes long.
E396: CD5AE3  		call	de2hl
E399: 2AD1ED  		ld	hl,(dsksize)	;check disk size.
E39C: 7C      		ld	a,h		;more than 256 blocks on this?
E39D: 21E8ED  		ld	hl,bigdisk
E3A0: 36FF    		ld	(hl),0ffh	;set to samll.
E3A2: B7      		or	a
E3A3: CAA8E3  		jp	z,select1
E3A6: 3600    		ld	(hl),0		;wrong, set to large.
E3A8: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E3AA: B7      		or	a
E3AB: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E3AC: CDDBEE  	homedrv:call	home		;home the head.
E3AF: AF      		xor	a
E3B0: 2AC0ED  		ld	hl,(scratch2)	;set our track pointer also.
E3B3: 77      		ld	(hl),a
E3B4: 23      		inc	hl
E3B5: 77      		ld	(hl),a
E3B6: 2AC2ED  		ld	hl,(scratch3)	;and our sector pointer.
E3B9: 77      		ld	(hl),a
E3BA: 23      		inc	hl
E3BB: 77      		ld	(hl),a
E3BC: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E3BD: CD0CEF  	doread:	call	read
E3C0: C3C6E3  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E3C3: CD10EF  	dowrite:call	write
E3C6: B7      	ioret:	or	a
E3C7: C8      		ret	z		;return unless an error occured.
E3C8: 210CE0  		ld	hl,badsctr	;bad read/write on this sector.
E3CB: C355E3  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E3CE: 2AF5ED  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E3D1: 0E02    		ld	c,2		;in directory and compute sector #.
E3D3: CDF5E4  		call	shiftr		;sector #=file-position/4.
E3D6: 22F0ED  		ld	(blknmbr),hl	;save this as the block number of interest.
E3D9: 22F7ED  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E3DC: 21F0ED  	trksec1:ld	hl,blknmbr
E3DF: 4E      		ld	c,(hl)		;move sector number into (bc).
E3E0: 23      		inc	hl
E3E1: 46      		ld	b,(hl)
E3E2: 2AC2ED  		ld	hl,(scratch3)	;get current sector number and
E3E5: 5E      		ld	e,(hl)		;move this into (de).
E3E6: 23      		inc	hl
E3E7: 56      		ld	d,(hl)
E3E8: 2AC0ED  		ld	hl,(scratch2)	;get current track number.
E3EB: 7E      		ld	a,(hl)		;and this into (hl).
E3EC: 23      		inc	hl
E3ED: 66      		ld	h,(hl)
E3EE: 6F      		ld	l,a
E3EF: 79      	trksec2:ld	a,c		;is desired sector before current one?
E3F0: 93      		sub	e
E3F1: 78      		ld	a,b
E3F2: 9A      		sbc	a,d
E3F3: D205E4  		jp	nc,trksec3
E3F6: E5      		push	hl		;yes, decrement sectors by one track.
E3F7: 2ACCED  		ld	hl,(sectors)	;get sectors per track.
E3FA: 7B      		ld	a,e
E3FB: 95      		sub	l
E3FC: 5F      		ld	e,a
E3FD: 7A      		ld	a,d
E3FE: 9C      		sbc	a,h
E3FF: 57      		ld	d,a		;now we have backed up one full track.
E400: E1      		pop	hl
E401: 2B      		dec	hl		;adjust track counter.
E402: C3EFE3  		jp	trksec2
E405: E5      	trksec3:push	hl		;desired sector is after current one.
E406: 2ACCED  		ld	hl,(sectors)	;get sectors per track.
E409: 19      		add	hl,de		;bump sector pointer to next track.
E40A: DA1AE4  		jp	c,trksec4
E40D: 79      		ld	a,c		;is desired sector now before current one?
E40E: 95      		sub	l
E40F: 78      		ld	a,b
E410: 9C      		sbc	a,h
E411: DA1AE4  		jp	c,trksec4
E414: EB      		ex	de,hl		;not yes, increment track counter
E415: E1      		pop	hl		;and continue until it is.
E416: 23      		inc	hl
E417: C305E4  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E41A: E1      	trksec4:pop	hl		;get track number (hl).
E41B: C5      		push	bc
E41C: D5      		push	de
E41D: E5      		push	hl
E41E: EB      		ex	de,hl
E41F: 2AD9ED  		ld	hl,(offset)	;adjust for first track offset.
E422: 19      		add	hl,de
E423: 44      		ld	b,h
E424: 4D      		ld	c,l
E425: CDFEEE  		call	settrk		;select this track.
E428: D1      		pop	de		;reset current track pointer.
E429: 2AC0ED  		ld	hl,(scratch2)
E42C: 73      		ld	(hl),e
E42D: 23      		inc	hl
E42E: 72      		ld	(hl),d
E42F: D1      		pop	de
E430: 2AC2ED  		ld	hl,(scratch3)	;reset the first sector on this track.
E433: 73      		ld	(hl),e
E434: 23      		inc	hl
E435: 72      		ld	(hl),d
E436: C1      		pop	bc
E437: 79      		ld	a,c		;now subtract the desired one.
E438: 93      		sub	e		;to make it relative (1-# sectors/track).
E439: 4F      		ld	c,a
E43A: 78      		ld	a,b
E43B: 9A      		sbc	a,d
E43C: 47      		ld	b,a
E43D: 2ADBED  		ld	hl,(xlate)	;translate this sector according to this table.
E440: EB      		ex	de,hl
E441: CD17EF  		call	sectrn		;let the bios translate it.
E444: 4D      		ld	c,l
E445: 44      		ld	b,h
E446: C302EF  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E449: 21CEED  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E44C: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E44D: 3AEEED  		ld	a,(savnrec)	;get record number.
E450: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E451: 1F      		rra	
E452: 0D      		dec	c
E453: C250E4  		jp	nz,getblk1
E456: 47      		ld	b,a		;save result in (b).
E457: 3E08    		ld	a,8
E459: 96      		sub	(hl)
E45A: 4F      		ld	c,a		;compute (c)=8-blkshft.
E45B: 3AEDED  		ld	a,(savext)
E45E: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E45F: CA67E4  		jp	z,getblk3
E462: B7      		or	a
E463: 17      		rla	
E464: C35EE4  		jp	getblk2
E467: 80      	getblk3:add	a,b
E468: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E469: 2A4EE3  	extblk:	ld	hl,(params)	;get fcb address.
E46C: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E46F: 19      		add	hl,de
E470: 09      		add	hl,bc
E471: 3AE8ED  		ld	a,(bigdisk)	;are we using a big-disk?
E474: B7      		or	a
E475: CA7CE4  		jp	z,extblk1
E478: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E479: 2600    		ld	h,0
E47B: C9      		ret	
E47C: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E47D: 5E      		ld	e,(hl)
E47E: 23      		inc	hl
E47F: 56      		ld	d,(hl)
E480: EB      		ex	de,hl		;return in (hl).
E481: C9      		ret	
              	;
              	;   compute block number.
              	;
E482: CD49E4  	comblk:	call	getblock
E485: 4F      		ld	c,a
E486: 0600    		ld	b,0
E488: CD69E4  		call	extblk
E48B: 22F0ED  		ld	(blknmbr),hl
E48E: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E48F: 2AF0ED  	chkblk:	ld	hl,(blknmbr)
E492: 7D      		ld	a,l		;is it zero?
E493: B4      		or	h
E494: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E495: 3ACEED  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E498: 2AF0ED  		ld	hl,(blknmbr)	;get physical sector desired.
E49B: 29      	logicl1:add	hl,hl		;compute logical sector number.
E49C: 3D      		dec	a		;note logical sectors are 128 bytes long.
E49D: C29BE4  		jp	nz,logicl1
E4A0: 22F2ED  		ld	(logsect),hl	;save logical sector.
E4A3: 3ACFED  		ld	a,(blkmask)	;get block mask.
E4A6: 4F      		ld	c,a
E4A7: 3AEEED  		ld	a,(savnrec)	;get next sector to access.
E4AA: A1      		and	c		;extract the relative position within physical block.
E4AB: B5      		or	l		;and add it too logical sector.
E4AC: 6F      		ld	l,a
E4AD: 22F0ED  		ld	(blknmbr),hl	;and store.
E4B0: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E4B1: 2A4EE3  	setext:	ld	hl,(params)
E4B4: 110C00  		ld	de,12		;it is the twelth byte.
E4B7: 19      		add	hl,de
E4B8: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E4B9: 2A4EE3  	sethlde:ld	hl,(params)
E4BC: 110F00  		ld	de,15		;record count byte (#15).
E4BF: 19      		add	hl,de
E4C0: EB      		ex	de,hl
E4C1: 211100  		ld	hl,17		;next record number (#32).
E4C4: 19      		add	hl,de
E4C5: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E4C6: CDB9E4  	strdata:call	sethlde
E4C9: 7E      		ld	a,(hl)		;get and store record count byte.
E4CA: 32EEED  		ld	(savnrec),a
E4CD: EB      		ex	de,hl
E4CE: 7E      		ld	a,(hl)		;get and store next record number byte.
E4CF: 32ECED  		ld	(savnxt),a
E4D2: CDB1E4  		call	setext		;point to extent byte.
E4D5: 3AD0ED  		ld	a,(extmask)	;get extent mask.
E4D8: A6      		and	(hl)
E4D9: 32EDED  		ld	(savext),a	;and save extent here.
E4DC: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E4DD: CDB9E4  	setnrec:call	sethlde
E4E0: 3AE0ED  		ld	a,(mode)	;get sequential flag (=1).
E4E3: FE02    		cp	2		;a 2 indicates that no adder is needed.
E4E5: C2E9E4  		jp	nz,stnrec1
E4E8: AF      		xor	a		;clear adder (random access?).
E4E9: 4F      	stnrec1:ld	c,a
E4EA: 3AEEED  		ld	a,(savnrec)	;get last record number.
E4ED: 81      		add	a,c		;increment record count.
E4EE: 77      		ld	(hl),a		;and set fcb's next record byte.
E4EF: EB      		ex	de,hl
E4F0: 3AECED  		ld	a,(savnxt)	;get next record byte from storage.
E4F3: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E4F4: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E4F5: 0C      	shiftr:	inc	c
E4F6: 0D      	shiftr1:dec	c
E4F7: C8      		ret	z
E4F8: 7C      		ld	a,h
E4F9: B7      		or	a
E4FA: 1F      		rra	
E4FB: 67      		ld	h,a
E4FC: 7D      		ld	a,l
E4FD: 1F      		rra	
E4FE: 6F      		ld	l,a
E4FF: C3F6E4  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E502: 0E80    	checksum: ld	c,128		;length of buffer.
E504: 2AC4ED  		ld	hl,(dirbuf)	;get its location.
E507: AF      		xor	a		;clear summation byte.
E508: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E509: 23      		inc	hl
E50A: 0D      		dec	c
E50B: C208E5  		jp	nz,chksum1
E50E: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E50F: 0C      	shiftl:	inc	c
E510: 0D      	shiftl1:dec	c
E511: C8      		ret	z
E512: 29      		add	hl,hl		;shift left 1 bit.
E513: C310E5  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E516: C5      	setbit:	push	bc		;save 16 bit word.
E517: 3A4DE3  		ld	a,(active)	;get active drive.
E51A: 4F      		ld	c,a
E51B: 210100  		ld	hl,1
E51E: CD0FE5  		call	shiftl		;shift bit 0 into place.
E521: C1      		pop	bc		;now 'or' this with the original word.
E522: 79      		ld	a,c
E523: B5      		or	l
E524: 6F      		ld	l,a		;low byte done, do high byte.
E525: 78      		ld	a,b
E526: B4      		or	h
E527: 67      		ld	h,a
E528: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E529: 2AB8ED  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E52C: 3A4DE3  		ld	a,(active)	;which drive is current?
E52F: 4F      		ld	c,a
E530: CDF5E4  		call	shiftr		;shift status such that bit 0 is the
E533: 7D      		ld	a,l		;one of interest for this drive.
E534: E601    		and	01h		;and isolate it.
E536: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E537: 21B8ED  	wrtprtd:ld	hl,wrtprt	;point to status word.
E53A: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E53B: 23      		inc	hl
E53C: 46      		ld	b,(hl)
E53D: CD16E5  		call	setbit		;and set this bit according to current drive.
E540: 22B8ED  		ld	(wrtprt),hl	;then save.
E543: 2AD3ED  		ld	hl,(dirsize)	;now save directory size limit.
E546: 23      		inc	hl		;remember the last one.
E547: EB      		ex	de,hl
E548: 2ABEED  		ld	hl,(scratch1)	;and store it here.
E54B: 73      		ld	(hl),e		;put low byte.
E54C: 23      		inc	hl
E54D: 72      		ld	(hl),d		;then high byte.
E54E: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E54F: CD69E5  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E552: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E555: 19      		add	hl,de
E556: 7E      		ld	a,(hl)
E557: 17      		rla	
E558: D0      		ret	nc		;return if ok.
E559: 2112E0  		ld	hl,rofile	;else, print error message and terminate.
E55C: C355E3  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E55F: CD29E5  	chkwprt:call	getwprt
E562: C8      		ret	z		;return if ok.
E563: 2110E0  		ld	hl,rodisk	;else print message and terminate.
E566: C355E3  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E569: 2AC4ED  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E56C: 3AF4ED  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E56F: 85      	adda2hl:add	a,l
E570: 6F      		ld	l,a
E571: D0      		ret	nc
E572: 24      		inc	h		;take care of any carry.
E573: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E574: 2A4EE3  	gets2:	ld	hl,(params)	;get address of fcb.
E577: 110E00  		ld	de,14		;relative position of 's2'.
E57A: 19      		add	hl,de
E57B: 7E      		ld	a,(hl)		;extract this byte.
E57C: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E57D: CD74E5  	clears2:call	gets2		;this sets (hl) pointing to it.
E580: 3600    		ld	(hl),0		;now clear it.
E582: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E583: CD74E5  	sets2b7:call	gets2		;get the byte.
E586: F680    		or	80h		;and set bit 7.
E588: 77      		ld	(hl),a		;then store.
E589: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E58A: 2AF5ED  	morefls:ld	hl,(filepos)	;we are here.
E58D: EB      		ex	de,hl
E58E: 2ABEED  		ld	hl,(scratch1)	;and don't go past here.
E591: 7B      		ld	a,e		;compute difference but don't keep.
E592: 96      		sub	(hl)
E593: 23      		inc	hl
E594: 7A      		ld	a,d
E595: 9E      		sbc	a,(hl)		;set carry if no more names.
E596: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E597: CD8AE5  	chknmbr:call	morefls		;scratch1 too big?
E59A: D8      		ret	c
E59B: 13      		inc	de		;yes, reset it to (filepos).
E59C: 72      		ld	(hl),d
E59D: 2B      		dec	hl
E59E: 73      		ld	(hl),e
E59F: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E5A0: 7B      	subhl:	ld	a,e		;compute difference.
E5A1: 95      		sub	l
E5A2: 6F      		ld	l,a		;store low byte.
E5A3: 7A      		ld	a,d
E5A4: 9C      		sbc	a,h
E5A5: 67      		ld	h,a		;and then high byte.
E5A6: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E5A7: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E5A9: 2AF7ED  	checkdir: ld	hl,(cksumtbl)
E5AC: EB      		ex	de,hl
E5AD: 2AD7ED  		ld	hl,(alloc1)
E5B0: CDA0E5  		call	subhl
E5B3: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E5B4: C5      		push	bc
E5B5: CD02E5  		call	checksum	;else compute checksum.
E5B8: 2AC8ED  		ld	hl,(chkvect)	;get address of checksum table.
E5BB: EB      		ex	de,hl
E5BC: 2AF7ED  		ld	hl,(cksumtbl)
E5BF: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E5C0: C1      		pop	bc
E5C1: 0C      		inc	c		;set or check ?
E5C2: CACFE5  		jp	z,chkdir1
E5C5: BE      		cp	(hl)		;check them.
E5C6: C8      		ret	z		;return if they are the same.
E5C7: CD8AE5  		call	morefls		;not the same, do we care?
E5CA: D0      		ret	nc
E5CB: CD37E5  		call	wrtprtd		;yes, mark this as write protected.
E5CE: C9      		ret	
E5CF: 77      	chkdir1:ld	(hl),a		;just set the byte.
E5D0: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E5D1: CDA7E5  	dirwrite: call	setdir		;set checksum byte.
E5D4: CDEBE5  		call	dirdma		;set directory dma address.
E5D7: 0E01    		ld	c,1		;tell the bios to actually write.
E5D9: CDC3E3  		call	dowrite		;then do the write.
E5DC: C3E5E5  		jp	defdma
              	;
              	;   read from the directory.
              	;
E5DF: CDEBE5  	dirread:call	dirdma		;set the directory dma address.
E5E2: CDBDE3  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E5E5: 21BCED  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E5E8: C3EEE5  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E5EB: 21C4ED  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E5EE: 4E      	dirdma1:ld	c,(hl)
E5EF: 23      		inc	hl
E5F0: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E5F1: C306EF  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E5F4: 2AC4ED  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E5F7: EB      		ex	de,hl
E5F8: 2ABCED  		ld	hl,(userdma)	; put it here.
E5FB: 0E80    		ld	c,128		;this is its length.
E5FD: C35AE3  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E600: 21F5ED  	ckfilpos: ld	hl,filepos
E603: 7E      		ld	a,(hl)
E604: 23      		inc	hl
E605: BE      		cp	(hl)		;are both bytes the same?
E606: C0      		ret	nz
E607: 3C      		inc	a		;yes, but are they each 0ffh?
E608: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E609: 21FFFF  	stfilpos: ld	hl,0ffffh
E60C: 22F5ED  		ld	(filepos),hl
E60F: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
E610: 2AD3ED  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
E613: EB      		ex	de,hl
E614: 2AF5ED  		ld	hl,(filepos)	;get current count.
E617: 23      		inc	hl		;go on to the next one.
E618: 22F5ED  		ld	(filepos),hl
E61B: CDA0E5  		call	subhl		;(hl)=(dirsize)-(filepos)
E61E: D224E6  		jp	nc,nxent1	;is there more room left?
E621: C309E6  		jp	stfilpos	;no. set this flag and return.
E624: 3AF5ED  	nxent1:	ld	a,(filepos)	;get file position within directory.
E627: E603    		and	03h		;only look within this sector (only 4 entries fit).
E629: 0605    		ld	b,5		;convert to relative position (32 bytes each).
E62B: 87      	nxent2:	add	a,a		;note that this is not efficient code.
E62C: 05      		dec	b		;5 'add a's would be better.
E62D: C22BE6  		jp	nz,nxent2
E630: 32F4ED  		ld	(fcbpos),a	;save it as position of fcb.
E633: B7      		or	a
E634: C0      		ret	nz		;return if we are within buffer.
E635: C5      		push	bc
E636: CDCEE3  		call	trksec		;we need the next directory sector.
E639: CDDFE5  		call	dirread
E63C: C1      		pop	bc
E63D: C3A9E5  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
E640: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
E641: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
E643: 3C      		inc	a
E644: 5F      		ld	e,a		;save particular bit number.
E645: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
E646: 79      		ld	a,c
E647: 0F      		rrca			;now shift right 3 bits.
E648: 0F      		rrca	
E649: 0F      		rrca	
E64A: E61F    		and	1fh		;and clear bits 7,6,5.
E64C: 4F      		ld	c,a
E64D: 78      		ld	a,b
E64E: 87      		add	a,a		;now shift (b) into bits 7,6,5.
E64F: 87      		add	a,a
E650: 87      		add	a,a
E651: 87      		add	a,a
E652: 87      		add	a,a
E653: B1      		or	c		;and add in (c).
E654: 4F      		ld	c,a		;ok, (c) ha been completed.
E655: 78      		ld	a,b		;is there a better way of doing this?
E656: 0F      		rrca	
E657: 0F      		rrca	
E658: 0F      		rrca	
E659: E61F    		and	1fh
E65B: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
E65C: 2ACAED  		ld	hl,(alocvect)
E65F: 09      		add	hl,bc
E660: 7E      		ld	a,(hl)		;now get correct byte.
E661: 07      	ckbmap1:rlca			;get correct bit into position 0.
E662: 1D      		dec	e
E663: C261E6  		jp	nz,ckbmap1
E666: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
E667: D5      	stbitmap: push	de
E668: CD40E6  		call	ckbitmap	;get the byte of interest.
E66B: E6FE    		and	0feh		;clear the affected bit.
E66D: C1      		pop	bc
E66E: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
E66F: 0F      	stbmap1:rrca			;restore original bit position.
E670: 15      		dec	d
E671: C26FE6  		jp	nz,stbmap1
E674: 77      		ld	(hl),a		;and stor byte in table.
E675: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
E676: CD69E5  	setfile:call	fcb2hl		;get address of fcb
E679: 111000  		ld	de,16
E67C: 19      		add	hl,de		;get to block number bytes.
E67D: C5      		push	bc
E67E: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
E680: D1      	setfl1:	pop	de
E681: 0D      		dec	c		;done all bytes yet?
E682: C8      		ret	z
E683: D5      		push	de
E684: 3AE8ED  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
E687: B7      		or	a
E688: CA93E6  		jp	z,setfl2
E68B: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
E68C: E5      		push	hl
E68D: 4E      		ld	c,(hl)		;get low byte from table, always
E68E: 0600    		ld	b,0		;set high byte to zero.
E690: C399E6  		jp	setfl3
E693: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
E694: C5      		push	bc
E695: 4E      		ld	c,(hl)		;now get both the low and high bytes.
E696: 23      		inc	hl
E697: 46      		ld	b,(hl)
E698: E5      		push	hl
E699: 79      	setfl3:	ld	a,c		;block used?
E69A: B0      		or	b
E69B: CAA8E6  		jp	z,setfl4
E69E: 2AD1ED  		ld	hl,(dsksize)	;is this block number within the
E6A1: 7D      		ld	a,l		;space on the disk?
E6A2: 91      		sub	c
E6A3: 7C      		ld	a,h
E6A4: 98      		sbc	a,b
E6A5: D467E6  		call	nc,stbitmap	;yes, set the proper bit.
E6A8: E1      	setfl4:	pop	hl		;point to next block number in fcb.
E6A9: 23      		inc	hl
E6AA: C1      		pop	bc
E6AB: C380E6  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
E6AE: 2AD1ED  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
E6B1: 0E03    		ld	c,3
E6B3: CDF5E4  		call	shiftr		;(hl)=(hl)/8.
E6B6: 23      		inc	hl		;at lease 1 byte.
E6B7: 44      		ld	b,h
E6B8: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
E6B9: 2ACAED  		ld	hl,(alocvect)	;now zero out the table now.
E6BC: 3600    	bitmap1:ld	(hl),0
E6BE: 23      		inc	hl
E6BF: 0B      		dec	bc
E6C0: 78      		ld	a,b
E6C1: B1      		or	c
E6C2: C2BCE6  		jp	nz,bitmap1
E6C5: 2AD5ED  		ld	hl,(alloc0)	;get initial space used by directory.
E6C8: EB      		ex	de,hl
E6C9: 2ACAED  		ld	hl,(alocvect)	;and put this into map.
E6CC: 73      		ld	(hl),e
E6CD: 23      		inc	hl
E6CE: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
E6CF: CDACE3  		call	homedrv		;now home the drive.
E6D2: 2ABEED  		ld	hl,(scratch1)
E6D5: 3603    		ld	(hl),3		;force next directory request to read
E6D7: 23      		inc	hl		;in a sector.
E6D8: 3600    		ld	(hl),0
E6DA: CD09E6  		call	stfilpos	;clear initial file position also.
E6DD: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
E6DF: CD10E6  		call	nxentry		;and set checksum byte.
E6E2: CD00E6  		call	ckfilpos	;is there another file?
E6E5: C8      		ret	z
E6E6: CD69E5  		call	fcb2hl		;yes, get its address.
E6E9: 3EE5    		ld	a,0e5h
E6EB: BE      		cp	(hl)		;empty file entry?
E6EC: CADDE6  		jp	z,bitmap2
E6EF: 3A4CE3  		ld	a,(userno)	;no, correct user number?
E6F2: BE      		cp	(hl)
E6F3: C201E7  		jp	nz,bitmap3
E6F6: 23      		inc	hl
E6F7: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
E6F8: D624    		sub	'$'
E6FA: C201E7  		jp	nz,bitmap3
E6FD: 3D      		dec	a		;yes, set atatus to minus one.
E6FE: 3250E3  		ld	(status),a
E701: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
E703: CD76E6  		call	setfile
E706: CD97E5  		call	chknmbr		;keep (scratch1) in bounds.
E709: C3DDE6  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
E70C: 3ADFED  	ststatus: ld	a,(fndstat)
E70F: C30CE3  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
E712: C5      	samext:	push	bc
E713: F5      		push	af
E714: 3AD0ED  		ld	a,(extmask)	;get extent mask and use it to
E717: 2F      		cpl			;to compare both extent numbers.
E718: 47      		ld	b,a		;save resulting mask here.
E719: 79      		ld	a,c		;mask first extent and save in (c).
E71A: A0      		and	b
E71B: 4F      		ld	c,a
E71C: F1      		pop	af		;now mask second extent and compare
E71D: A0      		and	b		;with the first one.
E71E: 91      		sub	c
E71F: E61F    		and	1fh		;(* only check buts 0-4 *)
E721: C1      		pop	bc		;the zero flag is set if they are the same.
E722: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
E723: 3EFF    	findfst:ld	a,0ffh
E725: 32DFED  		ld	(fndstat),a
E728: 21E3ED  		ld	hl,counter	;save character count.
E72B: 71      		ld	(hl),c
E72C: 2A4EE3  		ld	hl,(params)	;get filename to match.
E72F: 22E4ED  		ld	(savefcb),hl	;and save.
E732: CD09E6  		call	stfilpos	;clear initial file position (set to 0ffffh).
E735: CDACE3  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
E738: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
E73A: CD10E6  		call	nxentry		;get next filename entry in directory.
E73D: CD00E6  		call	ckfilpos	;is file position = 0ffffh?
E740: CA9FE7  		jp	z,fndnxt6	;yes, exit now then.
E743: 2AE4ED  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
E746: EB      		ex	de,hl
E747: 1A      		ld	a,(de)
E748: FEE5    		cp	0e5h		;empty directory entry?
E74A: CA55E7  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
E74D: D5      		push	de
E74E: CD8AE5  		call	morefls		;more files in directory?
E751: D1      		pop	de
E752: D29FE7  		jp	nc,fndnxt6	;no more. exit now.
E755: CD69E5  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
E758: 3AE3ED  		ld	a,(counter)	;get number of bytes (characters) to check.
E75B: 4F      		ld	c,a
E75C: 0600    		ld	b,0		;initialize byte position counter.
E75E: 79      	fndnxt2:ld	a,c		;are we done with the compare?
E75F: B7      		or	a
E760: CA8EE7  		jp	z,fndnxt5
E763: 1A      		ld	a,(de)		;no, check next byte.
E764: FE3F    		cp	'?'		;don't care about this character?
E766: CA87E7  		jp	z,fndnxt4
E769: 78      		ld	a,b		;get bytes position in fcb.
E76A: FE0D    		cp	13		;don't care about the thirteenth byte either.
E76C: CA87E7  		jp	z,fndnxt4
E76F: FE0C    		cp	12		;extent byte?
E771: 1A      		ld	a,(de)
E772: CA7EE7  		jp	z,fndnxt3
E775: 96      		sub	(hl)		;otherwise compare characters.
E776: E67F    		and	7fh
E778: C238E7  		jp	nz,findnxt	;not the same, check next entry.
E77B: C387E7  		jp	fndnxt4		;so far so good, keep checking.
E77E: C5      	fndnxt3:push	bc		;check the extent byte here.
E77F: 4E      		ld	c,(hl)
E780: CD12E7  		call	samext
E783: C1      		pop	bc
E784: C238E7  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
E787: 13      	fndnxt4:inc	de		;bump pointers.
E788: 23      		inc	hl
E789: 04      		inc	b
E78A: 0D      		dec	c		;adjust character counter.
E78B: C35EE7  		jp	fndnxt2
E78E: 3AF5ED  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
E791: E603    		and	03h
E793: 3250E3  		ld	(status),a
E796: 21DFED  		ld	hl,fndstat
E799: 7E      		ld	a,(hl)
E79A: 17      		rla	
E79B: D0      		ret	nc
E79C: AF      		xor	a
E79D: 77      		ld	(hl),a
E79E: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
E79F: CD09E6  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
E7A2: 3EFF    		ld	a,0ffh		;say not located.
E7A4: C30CE3  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
E7A7: CD5FE5  	erafile:call	chkwprt		;is disk write protected?
E7AA: 0E0C    		ld	c,12		;only compare file names.
E7AC: CD23E7  		call	findfst		;get first file name.
E7AF: CD00E6  	erafil1:call	ckfilpos	;any found?
E7B2: C8      		ret	z		;nope, we must be done.
E7B3: CD4FE5  		call	chkrofl		;is file read only?
E7B6: CD69E5  		call	fcb2hl		;nope, get address of fcb and
E7B9: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
E7BB: 0E00    		ld	c,0		;clear the space from the bit map.
E7BD: CD76E6  		call	setfile
E7C0: CDD1E5  		call	dirwrite	;now write the directory sector back out.
E7C3: CD38E7  		call	findnxt		;find the next file name.
E7C6: C3AFE7  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
E7C9: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
E7CA: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
E7CB: 79      	fndspa1:ld	a,c		;is block 0 specified?
E7CC: B0      		or	b
E7CD: CADCE7  		jp	z,fndspa2
E7D0: 0B      		dec	bc		;nope, check previous block.
E7D1: D5      		push	de
E7D2: C5      		push	bc
E7D3: CD40E6  		call	ckbitmap
E7D6: 1F      		rra			;is this block empty?
E7D7: D2F7E7  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
E7DA: C1      		pop	bc		;nope, check some more.
E7DB: D1      		pop	de
              	;
              	;   now look after target block.
              	;
E7DC: 2AD1ED  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
E7DF: 7B      		ld	a,e
E7E0: 95      		sub	l
E7E1: 7A      		ld	a,d
E7E2: 9C      		sbc	a,h
E7E3: D2FFE7  		jp	nc,fndspa4
E7E6: 13      		inc	de		;yes, move on to next one.
E7E7: C5      		push	bc
E7E8: D5      		push	de
E7E9: 42      		ld	b,d
E7EA: 4B      		ld	c,e
E7EB: CD40E6  		call	ckbitmap	;check it.
E7EE: 1F      		rra			;empty?
E7EF: D2F7E7  		jp	nc,fndspa3
E7F2: D1      		pop	de		;nope, continue searching.
E7F3: C1      		pop	bc
E7F4: C3CBE7  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
E7F7: 17      	fndspa3:rla			;reset byte.
E7F8: 3C      		inc	a		;and set bit 0.
E7F9: CD6FE6  		call	stbmap1		;update bit map.
E7FC: E1      		pop	hl		;set return registers.
E7FD: D1      		pop	de
E7FE: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
E7FF: 79      	fndspa4:ld	a,c
E800: B0      		or	b
E801: C2CBE7  		jp	nz,fndspa1
E804: 210000  		ld	hl,0		;set 'not found' status.
E807: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
E808: 0E00    	fcbset:	ld	c,0
E80A: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
E80C: D5      	update:	push	de
E80D: 0600    		ld	b,0		;set (bc) to relative byte position.
E80F: 2A4EE3  		ld	hl,(params)	;get address of fcb.
E812: 09      		add	hl,bc		;compute starting byte.
E813: EB      		ex	de,hl
E814: CD69E5  		call	fcb2hl		;get address of fcb to update in directory.
E817: C1      		pop	bc		;set (c) to number of bytes to change.
E818: CD5AE3  		call	de2hl
E81B: CDCEE3  	update1:call	trksec		;determine the track and sector affected.
E81E: C3D1E5  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
E821: CD5FE5  	chgnames: call	chkwprt		;check for a write protected disk.
E824: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
E826: CD23E7  		call	findfst		;get first name.
E829: 2A4EE3  		ld	hl,(params)	;get address of fcb.
E82C: 7E      		ld	a,(hl)		;get user number.
E82D: 111000  		ld	de,16		;move over to desired name.
E830: 19      		add	hl,de
E831: 77      		ld	(hl),a		;keep same user number.
E832: CD00E6  	chgnam1:call	ckfilpos	;any matching file found?
E835: C8      		ret	z		;no, we must be done.
E836: CD4FE5  		call	chkrofl		;check for read only file.
E839: 0E10    		ld	c,16		;start 16 bytes into fcb.
E83B: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
E83D: CD0CE8  		call	update
E840: CD38E7  		call	findnxt		;get te next file name.
E843: C332E8  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
E846: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
E848: CD23E7  		call	findfst		;look for first filename.
E84B: CD00E6  	savatr1:call	ckfilpos	;was one found?
E84E: C8      		ret	z		;nope, we must be done.
E84F: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
E851: 1E0C    		ld	e,12
E853: CD0CE8  		call	update		;update filename and write directory.
E856: CD38E7  		call	findnxt		;and get the next file.
E859: C34BE8  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
E85C: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
E85E: CD23E7  		call	findfst		;get the first one in directory.
E861: CD00E6  		call	ckfilpos	;any at all?
E864: C8      		ret	z
E865: CDB1E4  	openit1:call	setext		;point to extent byte within users fcb.
E868: 7E      		ld	a,(hl)		;and get it.
E869: F5      		push	af		;save it and address.
E86A: E5      		push	hl
E86B: CD69E5  		call	fcb2hl		;point to fcb in directory.
E86E: EB      		ex	de,hl
E86F: 2A4EE3  		ld	hl,(params)	;this is the users copy.
E872: 0E20    		ld	c,32		;move it into users space.
E874: D5      		push	de
E875: CD5AE3  		call	de2hl
E878: CD83E5  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
E87B: D1      		pop	de		;now get the extent byte from this fcb.
E87C: 210C00  		ld	hl,12
E87F: 19      		add	hl,de
E880: 4E      		ld	c,(hl)		;into (c).
E881: 210F00  		ld	hl,15		;now get the record count byte into (b).
E884: 19      		add	hl,de
E885: 46      		ld	b,(hl)
E886: E1      		pop	hl		;keep the same extent as the user had originally.
E887: F1      		pop	af
E888: 77      		ld	(hl),a
E889: 79      		ld	a,c		;is it the same as in the directory fcb?
E88A: BE      		cp	(hl)
E88B: 78      		ld	a,b		;if yes, then use the same record count.
E88C: CA96E8  		jp	z,openit2
E88F: 3E00    		ld	a,0		;if the user specified an extent greater than
E891: DA96E8  		jp	c,openit2	;the one in the directory, then set record count to 0.
E894: 3E80    		ld	a,128		;otherwise set to maximum.
E896: 2A4EE3  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
E899: 110F00  		ld	de,15
E89C: 19      		add	hl,de		;compute relative position.
E89D: 77      		ld	(hl),a		;and set the record count.
E89E: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
E89F: 7E      	moveword: ld	a,(hl)		;check for a zero word.
E8A0: 23      		inc	hl
E8A1: B6      		or	(hl)		;both bytes zero?
E8A2: 2B      		dec	hl
E8A3: C0      		ret	nz		;nope, just return.
E8A4: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
E8A5: 77      		ld	(hl),a		;this zero space.
E8A6: 13      		inc	de
E8A7: 23      		inc	hl
E8A8: 1A      		ld	a,(de)
E8A9: 77      		ld	(hl),a
E8AA: 1B      		dec	de		;don't disturb these registers.
E8AB: 2B      		dec	hl
E8AC: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
E8AD: AF      	closeit:xor	a		;clear status and file position bytes.
E8AE: 3250E3  		ld	(status),a
E8B1: 32F5ED  		ld	(filepos),a
E8B4: 32F6ED  		ld	(filepos+1),a
E8B7: CD29E5  		call	getwprt		;get write protect bit for this drive.
E8BA: C0      		ret	nz		;just return if it is set.
E8BB: CD74E5  		call	gets2		;else get the 's2' byte.
E8BE: E680    		and	80h		;and look at bit 7 (file unmodified?).
E8C0: C0      		ret	nz		;just return if set.
E8C1: 0E0F    		ld	c,15		;else look up this file in directory.
E8C3: CD23E7  		call	findfst
E8C6: CD00E6  		call	ckfilpos	;was it found?
E8C9: C8      		ret	z		;just return if not.
E8CA: 011000  		ld	bc,16		;set (hl) pointing to records used section.
E8CD: CD69E5  		call	fcb2hl
E8D0: 09      		add	hl,bc
E8D1: EB      		ex	de,hl
E8D2: 2A4EE3  		ld	hl,(params)	;do the same for users specified fcb.
E8D5: 09      		add	hl,bc
E8D6: 0E10    		ld	c,16		;this many bytes are present in this extent.
E8D8: 3AE8ED  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
E8DB: B7      		or	a
E8DC: CAF3E8  		jp	z,closeit4
E8DF: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
E8E0: B7      		or	a
E8E1: 1A      		ld	a,(de)		;now get one from directory fcb.
E8E2: C2E6E8  		jp	nz,closeit2
E8E5: 77      		ld	(hl),a		;users byte was zero. update from directory.
E8E6: B7      	closeit2: or	a
E8E7: C2ECE8  		jp	nz,closeit3
E8EA: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
E8EB: 12      		ld	(de),a
E8EC: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
E8ED: C22AE9  		jp	nz,closeit7	;then close error if they are not the same.
E8F0: C308E9  		jp	closeit5	;ok so far, get to next byte in fcbs.
E8F3: CD9FE8  	closeit4: call	moveword	;update users fcb if it is zero.
E8F6: EB      		ex	de,hl
E8F7: CD9FE8  		call	moveword	;update directories fcb if it is zero.
E8FA: EB      		ex	de,hl
E8FB: 1A      		ld	a,(de)		;if these two values are no different,
E8FC: BE      		cp	(hl)		;then a close error occured.
E8FD: C22AE9  		jp	nz,closeit7
E900: 13      		inc	de		;check second byte.
E901: 23      		inc	hl
E902: 1A      		ld	a,(de)
E903: BE      		cp	(hl)
E904: C22AE9  		jp	nz,closeit7
E907: 0D      		dec	c		;remember 16 bit values.
E908: 13      	closeit5: inc	de		;bump to next item in table.
E909: 23      		inc	hl
E90A: 0D      		dec	c		;there are 16 entries only.
E90B: C2D8E8  		jp	nz,closeit1	;continue if more to do.
E90E: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
E911: 09      		add	hl,bc
E912: EB      		ex	de,hl
E913: 09      		add	hl,bc
E914: 1A      		ld	a,(de)
E915: BE      		cp	(hl)		;directory's extent already greater than the
E916: DA22E9  		jp	c,closeit6	;users extent?
E919: 77      		ld	(hl),a		;no, update directory extent.
E91A: 010300  		ld	bc,3		;and update the record count byte in
E91D: 09      		add	hl,bc		;directories fcb.
E91E: EB      		ex	de,hl
E91F: 09      		add	hl,bc
E920: 7E      		ld	a,(hl)		;get from user.
E921: 12      		ld	(de),a		;and put in directory.
E922: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
E924: 32DDED  		ld	(closeflg),a
E927: C31BE8  		jp	update1		;update the directory now.
E92A: 2150E3  	closeit7: ld	hl,status	;set return status and then return.
E92D: 35      		dec	(hl)
E92E: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
E92F: CD5FE5  	getempty: call	chkwprt		;make sure disk is not write protected.
E932: 2A4EE3  		ld	hl,(params)	;save current parameters (fcb).
E935: E5      		push	hl
E936: 21B7ED  		ld	hl,emptyfcb	;use special one for empty space.
E939: 224EE3  		ld	(params),hl
E93C: 0E01    		ld	c,1		;search for first empty spot in directory.
E93E: CD23E7  		call	findfst		;(* only check first byte *)
E941: CD00E6  		call	ckfilpos	;none?
E944: E1      		pop	hl
E945: 224EE3  		ld	(params),hl	;restore original fcb address.
E948: C8      		ret	z		;return if no more space.
E949: EB      		ex	de,hl
E94A: 210F00  		ld	hl,15		;point to number of records for this file.
E94D: 19      		add	hl,de
E94E: 0E11    		ld	c,17		;and clear all of this space.
E950: AF      		xor	a
E951: 77      	getmt1:	ld	(hl),a
E952: 23      		inc	hl
E953: 0D      		dec	c
E954: C251E9  		jp	nz,getmt1
E957: 210D00  		ld	hl,13		;clear the 's1' byte also.
E95A: 19      		add	hl,de
E95B: 77      		ld	(hl),a
E95C: CD97E5  		call	chknmbr		;keep (scratch1) within bounds.
E95F: CD08E8  		call	fcbset		;write out this fcb entry to directory.
E962: C383E5  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
E965: AF      	getnext:xor	a
E966: 32DDED  		ld	(closeflg),a	;clear close flag.
E969: CDADE8  		call	closeit		;close this extent.
E96C: CD00E6  		call	ckfilpos
E96F: C8      		ret	z		;not there???
E970: 2A4EE3  		ld	hl,(params)	;get extent byte.
E973: 010C00  		ld	bc,12
E976: 09      		add	hl,bc
E977: 7E      		ld	a,(hl)		;and increment it.
E978: 3C      		inc	a
E979: E61F    		and	1fh		;keep within range 0-31.
E97B: 77      		ld	(hl),a
E97C: CA8EE9  		jp	z,gtnext1	;overflow?
E97F: 47      		ld	b,a		;mask extent byte.
E980: 3AD0ED  		ld	a,(extmask)
E983: A0      		and	b
E984: 21DDED  		ld	hl,closeflg	;check close flag (0ffh is ok).
E987: A6      		and	(hl)
E988: CA99E9  		jp	z,gtnext2	;if zero, we must read in next extent.
E98B: C3B7E9  		jp	gtnext3		;else, it is already in memory.
E98E: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
E991: 09      		add	hl,bc
E992: 34      		inc	(hl)		;and bump it.
E993: 7E      		ld	a,(hl)		;too many extents?
E994: E60F    		and	0fh
E996: CAC1E9  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
E999: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
E99B: CD23E7  		call	findfst		;find the first one.
E99E: CD00E6  		call	ckfilpos	;none available?
E9A1: C2B7E9  		jp	nz,gtnext3
E9A4: 3ADEED  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
E9A7: 3C      		inc	a		;0ffh means reading (so not possible).
E9A8: CAC1E9  		jp	z,gtnext5	;or an error.
E9AB: CD2FE9  		call	getempty	;we are writing, get an empty entry.
E9AE: CD00E6  		call	ckfilpos	;none?
E9B1: CAC1E9  		jp	z,gtnext5	;error if true.
E9B4: C3BAE9  		jp	gtnext4		;else we are almost done.
E9B7: CD65E8  	gtnext3:call	openit1		;open this extent.
E9BA: CDC6E4  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
E9BD: AF      		xor	a		;clear status and return.
E9BE: C30CE3  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
E9C1: CD10E3  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
E9C4: C383E5  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
E9C7: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
E9C9: 32E0ED  		ld	(mode),a
E9CC: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
E9CE: 32DEED  		ld	(rdwrtflg),a
E9D1: CDC6E4  		call	strdata		;put rec# and ext# into fcb.
E9D4: 3AEEED  		ld	a,(savnrec)	;get next record to read.
E9D7: 21ECED  		ld	hl,savnxt	;get number of records in extent.
E9DA: BE      		cp	(hl)		;within this extent?
E9DB: DAF1E9  		jp	c,rdseq2
E9DE: FE80    		cp	128		;no. is this extent fully used?
E9E0: C206EA  		jp	nz,rdseq3	;no. end-of-file.
E9E3: CD65E9  		call	getnext		;yes, open the next one.
E9E6: AF      		xor	a		;reset next record to read.
E9E7: 32EEED  		ld	(savnrec),a
E9EA: 3A50E3  		ld	a,(status)	;check on open, successful?
E9ED: B7      		or	a
E9EE: C206EA  		jp	nz,rdseq3	;no, error.
E9F1: CD82E4  	rdseq2:	call	comblk		;ok. compute block number to read.
E9F4: CD8FE4  		call	chkblk		;check it. within bounds?
E9F7: CA06EA  		jp	z,rdseq3	;no, error.
E9FA: CD95E4  		call	logical		;convert (blknmbr) to logical sector (128 byte).
E9FD: CDDCE3  		call	trksec1		;set the track and sector for this block #.
EA00: CDBDE3  		call	doread		;and read it.
EA03: C3DDE4  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EA06: C310E3  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EA09: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EA0B: 32E0ED  		ld	(mode),a
EA0E: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EA10: 32DEED  		ld	(rdwrtflg),a
EA13: CD5FE5  		call	chkwprt		;check write protect status.
EA16: 2A4EE3  		ld	hl,(params)
EA19: CD52E5  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EA1C: CDC6E4  		call	strdata		;put updated data into fcb.
EA1F: 3AEEED  		ld	a,(savnrec)	;get record number to write.
EA22: FE80    		cp	128		;within range?
EA24: D210E3  		jp	nc,ioerr1	;no, error(?).
EA27: CD82E4  		call	comblk		;compute block number.
EA2A: CD8FE4  		call	chkblk		;check number.
EA2D: 0E00    		ld	c,0		;is there one to write to?
EA2F: C279EA  		jp	nz,wtseq6	;yes, go do it.
EA32: CD49E4  		call	getblock	;get next block number within fcb to use.
EA35: 32E2ED  		ld	(relblock),a	;and save.
EA38: 010000  		ld	bc,0		;start looking for space from the start
EA3B: B7      		or	a		;if none allocated as yet.
EA3C: CA46EA  		jp	z,wtseq2
EA3F: 4F      		ld	c,a		;extract previous block number from fcb
EA40: 0B      		dec	bc		;so we can be closest to it.
EA41: CD69E4  		call	extblk
EA44: 44      		ld	b,h
EA45: 4D      		ld	c,l
EA46: CDC9E7  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EA49: 7D      		ld	a,l		;check for a zero number.
EA4A: B4      		or	h
EA4B: C253EA  		jp	nz,wtseq3
EA4E: 3E02    		ld	a,2		;no more space?
EA50: C30CE3  		jp	setstat
EA53: 22F0ED  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EA56: EB      		ex	de,hl		;put block number into (de).
EA57: 2A4EE3  		ld	hl,(params)	;now we must update the fcb for this
EA5A: 011000  		ld	bc,16		;newly allocated block.
EA5D: 09      		add	hl,bc
EA5E: 3AE8ED  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EA61: B7      		or	a
EA62: 3AE2ED  		ld	a,(relblock)	;(* update this entry *)
EA65: CA6FEA  		jp	z,wtseq4	;zero means 16 bit ones.
EA68: CD6FE5  		call	adda2hl		;(hl)=(hl)+(a)
EA6B: 73      		ld	(hl),e		;store new block number.
EA6C: C377EA  		jp	wtseq5
EA6F: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EA70: 0600    		ld	b,0
EA72: 09      		add	hl,bc
EA73: 09      		add	hl,bc
EA74: 73      		ld	(hl),e		;stuff block number (de) there.
EA75: 23      		inc	hl
EA76: 72      		ld	(hl),d
EA77: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EA79: 3A50E3  	wtseq6:	ld	a,(status)	;are we ok so far?
EA7C: B7      		or	a
EA7D: C0      		ret	nz
EA7E: C5      		push	bc		;yes, save write flag for bios (register c).
EA7F: CD95E4  		call	logical		;convert (blknmbr) over to loical sectors.
EA82: 3AE0ED  		ld	a,(mode)	;get access mode flag (1=sequential,
EA85: 3D      		dec	a		;0=random, 2=special?).
EA86: 3D      		dec	a
EA87: C2C6EA  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EA8A: C1      		pop	bc
EA8B: C5      		push	bc
EA8C: 79      		ld	a,c		;get write status flag (2=writing unused space).
EA8D: 3D      		dec	a
EA8E: 3D      		dec	a
EA8F: C2C6EA  		jp	nz,wtseq9
EA92: E5      		push	hl
EA93: 2AC4ED  		ld	hl,(dirbuf)	;zero out the directory buffer.
EA96: 57      		ld	d,a		;note that (a) is zero here.
EA97: 77      	wtseq7:	ld	(hl),a
EA98: 23      		inc	hl
EA99: 14      		inc	d		;do 128 bytes.
EA9A: F297EA  		jp	p,wtseq7
EA9D: CDEBE5  		call	dirdma		;tell the bios the dma address for directory access.
EAA0: 2AF2ED  		ld	hl,(logsect)	;get sector that starts current block.
EAA3: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EAA5: 22F0ED  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EAA8: C5      		push	bc
EAA9: CDDCE3  		call	trksec1		;determine its track and sector numbers.
EAAC: C1      		pop	bc
EAAD: CDC3E3  		call	dowrite		;now write out 128 bytes of zeros.
EAB0: 2AF0ED  		ld	hl,(blknmbr)	;get sector number.
EAB3: 0E00    		ld	c,0		;set normal write flag.
EAB5: 3ACFED  		ld	a,(blkmask)	;determine if we have written the entire
EAB8: 47      		ld	b,a		;physical block.
EAB9: A5      		and	l
EABA: B8      		cp	b
EABB: 23      		inc	hl		;prepare for the next one.
EABC: C2A5EA  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EABF: E1      		pop	hl		;reset next sector number.
EAC0: 22F0ED  		ld	(blknmbr),hl
EAC3: CDE5E5  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EAC6: CDDCE3  	wtseq9:	call	trksec1		;determine track and sector for this write.
EAC9: C1      		pop	bc		;get write status flag.
EACA: C5      		push	bc
EACB: CDC3E3  		call	dowrite		;and write this out.
EACE: C1      		pop	bc
EACF: 3AEEED  		ld	a,(savnrec)	;get number of records in file.
EAD2: 21ECED  		ld	hl,savnxt	;get last record written.
EAD5: BE      		cp	(hl)
EAD6: DADDEA  		jp	c,wtseq10
EAD9: 77      		ld	(hl),a		;we have to update record count.
EADA: 34      		inc	(hl)
EADB: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EADD: 00      	wtseq10:nop			;was 'dcr c'
EADE: 00      		nop			;was 'dcr c'
EADF: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EAE2: F5      		push	af
EAE3: CD74E5  		call	gets2		;set 'extent written to' flag.
EAE6: E67F    		and	7fh		;(* clear bit 7 *)
EAE8: 77      		ld	(hl),a
EAE9: F1      		pop	af		;get record count for this extent.
EAEA: FE7F    	wtseq99:cp	127		;is it full?
EAEC: C20BEB  		jp	nz,wtseq12
EAEF: 3AE0ED  		ld	a,(mode)	;yes, are we in sequential mode?
EAF2: FE01    		cp	1
EAF4: C20BEB  		jp	nz,wtseq12
EAF7: CDDDE4  		call	setnrec		;yes, set next record number.
EAFA: CD65E9  		call	getnext		;and get next empty space in directory.
EAFD: 2150E3  		ld	hl,status	;ok?
EB00: 7E      		ld	a,(hl)
EB01: B7      		or	a
EB02: C209EB  		jp	nz,wtseq11
EB05: 3D      		dec	a		;yes, set record count to -1.
EB06: 32EEED  		ld	(savnrec),a
EB09: 3600    	wtseq11:ld	(hl),0		;clear status.
EB0B: C3DDE4  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EB0E: AF      	position: xor	a		;set random i/o flag.
EB0F: 32E0ED  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EB12: C5      	positn1:push	bc		;save read/write flag.
EB13: 2A4EE3  		ld	hl,(params)	;get address of fcb.
EB16: EB      		ex	de,hl
EB17: 212100  		ld	hl,33		;now get byte 'r0'.
EB1A: 19      		add	hl,de
EB1B: 7E      		ld	a,(hl)
EB1C: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EB1E: F5      		push	af
EB1F: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EB20: 17      		rla	
EB21: 23      		inc	hl
EB22: 7E      		ld	a,(hl)
EB23: 17      		rla	
EB24: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EB26: 4F      		ld	c,a		;this is the extent byte.
EB27: 7E      		ld	a,(hl)		;now get the extra extent byte.
EB28: 1F      		rra	
EB29: 1F      		rra	
EB2A: 1F      		rra	
EB2B: 1F      		rra	
EB2C: E60F    		and	0fh
EB2E: 47      		ld	b,a		;and save it in (b).
EB2F: F1      		pop	af		;get record number back to (a).
EB30: 23      		inc	hl		;check overflow byte 'r2'.
EB31: 6E      		ld	l,(hl)
EB32: 2C      		inc	l
EB33: 2D      		dec	l
EB34: 2E06    		ld	l,6		;prepare for error.
EB36: C296EB  		jp	nz,positn5	;out of disk space error.
EB39: 212000  		ld	hl,32		;store record number into fcb.
EB3C: 19      		add	hl,de
EB3D: 77      		ld	(hl),a
EB3E: 210C00  		ld	hl,12		;and now check the extent byte.
EB41: 19      		add	hl,de
EB42: 79      		ld	a,c
EB43: 96      		sub	(hl)		;same extent as before?
EB44: C252EB  		jp	nz,positn2
EB47: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EB4A: 19      		add	hl,de
EB4B: 78      		ld	a,b
EB4C: 96      		sub	(hl)
EB4D: E67F    		and	7fh
EB4F: CA8AEB  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EB52: C5      	positn2:push	bc
EB53: D5      		push	de
EB54: CDADE8  		call	closeit		;close current extent.
EB57: D1      		pop	de
EB58: C1      		pop	bc
EB59: 2E03    		ld	l,3		;prepare for error.
EB5B: 3A50E3  		ld	a,(status)
EB5E: 3C      		inc	a
EB5F: CA8FEB  		jp	z,positn4	;close error.
EB62: 210C00  		ld	hl,12		;put desired extent into fcb now.
EB65: 19      		add	hl,de
EB66: 71      		ld	(hl),c
EB67: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EB6A: 19      		add	hl,de
EB6B: 70      		ld	(hl),b
EB6C: CD5CE8  		call	openit		;try and get this extent.
EB6F: 3A50E3  		ld	a,(status)	;was it there?
EB72: 3C      		inc	a
EB73: C28AEB  		jp	nz,positn3
EB76: C1      		pop	bc		;no. can we create a new one (writing?).
EB77: C5      		push	bc
EB78: 2E04    		ld	l,4		;prepare for error.
EB7A: 0C      		inc	c
EB7B: CA8FEB  		jp	z,positn4	;nope, reading unwritten space error.
EB7E: CD2FE9  		call	getempty	;yes we can, try to find space.
EB81: 2E05    		ld	l,5		;prepare for error.
EB83: 3A50E3  		ld	a,(status)
EB86: 3C      		inc	a
EB87: CA8FEB  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EB8A: C1      	positn3:pop	bc		;restore stack.
EB8B: AF      		xor	a		;and clear error code byte.
EB8C: C30CE3  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EB8F: E5      	positn4:push	hl
EB90: CD74E5  		call	gets2
EB93: 36C0    		ld	(hl),0c0h
EB95: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EB96: C1      	positn5:pop	bc
EB97: 7D      		ld	a,l		;get error code.
EB98: 3250E3  		ld	(status),a
EB9B: C383E5  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EB9E: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EBA0: CD0EEB  		call	position	;position the file to proper record.
EBA3: CCCCE9  		call	z,rdseq1	;and read it as usual (if no errors).
EBA6: C9      		ret	
              	;
              	;   write to a random record.
              	;
EBA7: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EBA9: CD0EEB  		call	position	;position the file to proper record.
EBAC: CC0EEA  		call	z,wtseq1	;and write as usual (if no errors).
EBAF: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EBB0: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EBB1: 19      		add	hl,de		;compute relative position of record #.
EBB2: 4E      		ld	c,(hl)		;get record number into (bc).
EBB3: 0600    		ld	b,0
EBB5: 210C00  		ld	hl,12		;now get extent.
EBB8: 19      		add	hl,de
EBB9: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EBBA: 0F      		rrca			;move lower bit into bit 7.
EBBB: E680    		and	80h		;and ignore all other bits.
EBBD: 81      		add	a,c		;add to our record number.
EBBE: 4F      		ld	c,a
EBBF: 3E00    		ld	a,0		;take care of any carry.
EBC1: 88      		adc	a,b
EBC2: 47      		ld	b,a
EBC3: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EBC4: 0F      		rrca			;bit positions 0-3.
EBC5: E60F    		and	0fh		;and ignore all others.
EBC7: 80      		add	a,b		;add this in to 'r1' byte.
EBC8: 47      		ld	b,a
EBC9: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EBCC: 19      		add	hl,de
EBCD: 7E      		ld	a,(hl)
EBCE: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EBCF: 87      		add	a,a
EBD0: 87      		add	a,a
EBD1: 87      		add	a,a
EBD2: F5      		push	af		;save carry flag (bit 0 of flag byte).
EBD3: 80      		add	a,b		;now add extra extent into 'r1'.
EBD4: 47      		ld	b,a
EBD5: F5      		push	af		;and save carry (overflow byte 'r2').
EBD6: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EBD7: 7D      		ld	a,l
EBD8: E1      		pop	hl		;and same for first carry flag.
EBD9: B5      		or	l		;either one of these set?
EBDA: E601    		and	01h		;only check the carry flags.
EBDC: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EBDD: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EBDF: CD23E7  		call	findfst		;this name.
EBE2: 2A4EE3  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EBE5: 112100  		ld	de,33
EBE8: 19      		add	hl,de
EBE9: E5      		push	hl
EBEA: 72      		ld	(hl),d		;note that (d)=0.
EBEB: 23      		inc	hl
EBEC: 72      		ld	(hl),d
EBED: 23      		inc	hl
EBEE: 72      		ld	(hl),d
EBEF: CD00E6  	ransiz1:call	ckfilpos	;is there an extent to process?
EBF2: CA17EC  		jp	z,ransiz3	;no, we are done.
EBF5: CD69E5  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EBF8: 110F00  		ld	de,15		;point to last record in extent.
EBFB: CDB0EB  		call	comprand	;and compute random parameters.
EBFE: E1      		pop	hl
EBFF: E5      		push	hl		;now check these values against those
EC00: 5F      		ld	e,a		;already in fcb.
EC01: 79      		ld	a,c		;the carry flag will be set if those
EC02: 96      		sub	(hl)		;in the fcb represent a larger size than
EC03: 23      		inc	hl		;this extent does.
EC04: 78      		ld	a,b
EC05: 9E      		sbc	a,(hl)
EC06: 23      		inc	hl
EC07: 7B      		ld	a,e
EC08: 9E      		sbc	a,(hl)
EC09: DA11EC  		jp	c,ransiz2
EC0C: 73      		ld	(hl),e		;we found a larger (in size) extent.
EC0D: 2B      		dec	hl		;stuff these values into fcb.
EC0E: 70      		ld	(hl),b
EC0F: 2B      		dec	hl
EC10: 71      		ld	(hl),c
EC11: CD38E7  	ransiz2:call	findnxt		;now get the next extent.
EC14: C3EFEB  		jp	ransiz1		;continue til all done.
EC17: E1      	ransiz3:pop	hl		;we are done, restore the stack and
EC18: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
EC19: 2A4EE3  	setran:	ld	hl,(params)	;point to fcb.
EC1C: 112000  		ld	de,32		;and to last used record.
EC1F: CDB0EB  		call	comprand	;compute random position.
EC22: 212100  		ld	hl,33		;now stuff these values into fcb.
EC25: 19      		add	hl,de
EC26: 71      		ld	(hl),c		;move 'r0'.
EC27: 23      		inc	hl
EC28: 70      		ld	(hl),b		;and 'r1'.
EC29: 23      		inc	hl
EC2A: 77      		ld	(hl),a		;and lastly 'r2'.
EC2B: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
EC2C: 2ABAED  	logindrv: ld	hl,(login)	;get the login vector.
EC2F: 3A4DE3  		ld	a,(active)	;get the default drive.
EC32: 4F      		ld	c,a
EC33: CDF5E4  		call	shiftr		;position active bit for this drive
EC36: E5      		push	hl		;into bit 0.
EC37: EB      		ex	de,hl
EC38: CD64E3  		call	select		;select this drive.
EC3B: E1      		pop	hl
EC3C: CC52E3  		call	z,slcterr	;valid drive?
EC3F: 7D      		ld	a,l		;is this a newly activated drive?
EC40: 1F      		rra	
EC41: D8      		ret	c
EC42: 2ABAED  		ld	hl,(login)	;yes, update the login vector.
EC45: 4D      		ld	c,l
EC46: 44      		ld	b,h
EC47: CD16E5  		call	setbit
EC4A: 22BAED  		ld	(login),hl	;and save.
EC4D: C3AEE6  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
EC50: 3AE1ED  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
EC53: 214DE3  		ld	hl,active	;represents a change in drives.
EC56: BE      		cp	(hl)
EC57: C8      		ret	z
EC58: 77      		ld	(hl),a		;yes it does, log it in.
EC59: C32CEC  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
EC5C: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
EC5E: 32E9ED  		ld	(auto),a
EC61: 2A4EE3  		ld	hl,(params)	;get drive specified.
EC64: 7E      		ld	a,(hl)
EC65: E61F    		and	1fh		;look at lower 5 bits.
EC67: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
EC68: 32E1ED  		ld	(eparam),a	;and save for the select routine.
EC6B: FE1E    		cp	1eh		;check for 'no change' condition.
EC6D: D280EC  		jp	nc,autosl1	;yes, don't change.
EC70: 3A4DE3  		ld	a,(active)	;we must change, save currently active
EC73: 32EAED  		ld	(olddrv),a	;drive.
EC76: 7E      		ld	a,(hl)		;and save first byte of fcb also.
EC77: 32EBED  		ld	(autoflag),a	;this must be non-zero.
EC7A: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
EC7C: 77      		ld	(hl),a		;something)?
EC7D: CD50EC  		call	setdsk		;select and log in this drive.
EC80: 3A4CE3  	autosl1:ld	a,(userno)	;move user number into fcb.
EC83: 2A4EE3  		ld	hl,(params)	;(* upper half of first byte *)
EC86: B6      		or	(hl)
EC87: 77      		ld	(hl),a
EC88: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
EC89: 3E22    	getver:	ld	a,022h		;version 2.2
EC8B: C30CE3  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
EC8E: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
EC91: 22B8ED  		ld	(wrtprt),hl	;in vector.
EC94: 22BAED  		ld	(login),hl
EC97: AF      		xor	a		;select drive 'a'.
EC98: 324DE3  		ld	(active),a
EC9B: 218000  		ld	hl,tbuff	;setup default dma address.
EC9E: 22BCED  		ld	(userdma),hl
ECA1: CDE5E5  		call	defdma
ECA4: C32CEC  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
ECA7: CD7DE5  	openfil:call	clears2		;clear 's2' byte.
ECAA: CD5CEC  		call	autosel		;select proper disk.
ECAD: C35CE8  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
ECB0: CD5CEC  	closefil: call	autosel		;select proper disk.
ECB3: C3ADE8  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
ECB6: 0E00    	getfst:	ld	c,0		;prepare for special search.
ECB8: EB      		ex	de,hl
ECB9: 7E      		ld	a,(hl)		;is first byte a '?'?
ECBA: FE3F    		cp	'?'
ECBC: CACDEC  		jp	z,getfst1	;yes, just get very first entry (zero length match).
ECBF: CDB1E4  		call	setext		;get the extension byte from fcb.
ECC2: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
ECC3: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
ECC5: C47DE5  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
ECC8: CD5CEC  		call	autosel		;select proper drive.
ECCB: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
ECCD: CD23E7  	getfst1:call	findfst		;find an entry and then move it into
ECD0: C3F4E5  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
ECD3: 2AE4ED  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
ECD6: 224EE3  		ld	(params),hl	;other dbos calls are allowed.
ECD9: CD5CEC  		call	autosel		;no error will be returned, but the
ECDC: CD38E7  		call	findnxt		;results will be wrong.
ECDF: C3F4E5  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
ECE2: CD5CEC  	delfile:call	autosel		;select proper drive.
ECE5: CDA7E7  		call	erafile		;erase the file.
ECE8: C30CE7  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
ECEB: CD5CEC  	readseq:call	autosel		;select proper drive then read.
ECEE: C3C7E9  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
ECF1: CD5CEC  	wrtseq:	call	autosel		;select proper drive then write.
ECF4: C309EA  		jp	wtseq
              	;
              	;   create a file function.
              	;
ECF7: CD7DE5  	fcreate:call	clears2		;clear the 's2' byte on all creates.
ECFA: CD5CEC  		call	autosel		;select proper drive and get the next
ECFD: C32FE9  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
ED00: CD5CEC  	renfile:call	autosel		;select proper drive and then switch
ED03: CD21E8  		call	chgnames	;file names.
ED06: C30CE7  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
ED09: 2ABAED  	getlog:	ld	hl,(login)
ED0C: C334ED  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
ED0F: 3A4DE3  	getcrnt:ld	a,(active)
ED12: C30CE3  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
ED15: EB      	putdma:	ex	de,hl
ED16: 22BCED  		ld	(userdma),hl	;save in our space and then get to
ED19: C3E5E5  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
ED1C: 2ACAED  	getaloc:ld	hl,(alocvect)
ED1F: C334ED  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
ED22: 2AB8ED  	getrov:	ld	hl,(wrtprt)
ED25: C334ED  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
ED28: CD5CEC  	setattr:call	autosel		;select proper drive then save attributes.
ED2B: CD46E8  		call	saveattr
ED2E: C30CE7  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
ED31: 2AC6ED  	getparm:ld	hl,(diskpb)
ED34: 2250E3  	getprm1:ld	(status),hl
ED37: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
ED38: 3AE1ED  	getuser:ld	a,(eparam)	;get parameter.
ED3B: FEFF    		cp	0ffh		;get user number?
ED3D: C246ED  		jp	nz,setuser
ED40: 3A4CE3  		ld	a,(userno)	;yes, just do it.
ED43: C30CE3  		jp	setstat
ED46: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
ED48: 324CE3  		ld	(userno),a	;bits (0-4) only.
ED4B: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
ED4C: CD5CEC  	rdrandom: call	autosel		;select proper drive and read.
ED4F: C39EEB  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
ED52: CD5CEC  	wtrandom: call	autosel		;select proper drive and write.
ED55: C3A7EB  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
ED58: CD5CEC  	filesize: call	autosel		;select proper drive and check file length
ED5B: C3DDEB  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
ED5E: 2A4EE3  	logoff:	ld	hl,(params)	;get drives to log off.
ED61: 7D      		ld	a,l		;for each bit that is set, we want
ED62: 2F      		cpl			;to clear that bit in (login)
ED63: 5F      		ld	e,a		;and (wrtprt).
ED64: 7C      		ld	a,h
ED65: 2F      		cpl	
ED66: 2ABAED  		ld	hl,(login)	;reset the login vector.
ED69: A4      		and	h
ED6A: 57      		ld	d,a
ED6B: 7D      		ld	a,l
ED6C: A3      		and	e
ED6D: 5F      		ld	e,a
ED6E: 2AB8ED  		ld	hl,(wrtprt)
ED71: EB      		ex	de,hl
ED72: 22BAED  		ld	(login),hl	;and save.
ED75: 7D      		ld	a,l		;now do the write protect vector.
ED76: A3      		and	e
ED77: 6F      		ld	l,a
ED78: 7C      		ld	a,h
ED79: A2      		and	d
ED7A: 67      		ld	h,a
ED7B: 22B8ED  		ld	(wrtprt),hl	;and save. all done.
ED7E: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
ED7F: 3AE9ED  	goback:	ld	a,(auto)	;was auto select activated?
ED82: B7      		or	a
ED83: CA9CED  		jp	z,goback1
ED86: 2A4EE3  		ld	hl,(params)	;yes, but was a change made?
ED89: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
ED8B: 3AEBED  		ld	a,(autoflag)
ED8E: B7      		or	a
ED8F: CA9CED  		jp	z,goback1
ED92: 77      		ld	(hl),a		;yes, reset first byte properly.
ED93: 3AEAED  		ld	a,(olddrv)	;and get the old drive and select it.
ED96: 32E1ED  		ld	(eparam),a
ED99: CD50EC  		call	setdsk
ED9C: 2A1AE3  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
ED9F: F9      		ld	sp,hl
EDA0: 2A50E3  		ld	hl,(status)	;get return status.
EDA3: 7D      		ld	a,l		;force version 1.4 compatability.
EDA4: 44      		ld	b,h
EDA5: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
EDA6: CD5CEC  	wtspecl:call	autosel		;select proper drive.
EDA9: 3E02    		ld	a,2		;use special write mode.
EDAB: 32E0ED  		ld	(mode),a
EDAE: 0E00    		ld	c,0		;set write indicator.
EDB0: CD12EB  		call	positn1		;position the file.
EDB3: CC0EEA  		call	z,wtseq1	;and write (if no errors).
EDB6: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
EDB7: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
EDB8: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
EDBA: 0000    	login:	defw	0		;drive active word (1 bit per drive).
EDBC: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
EDBE: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
EDC0: 0000    	scratch2: defw	0		;last selected track number.
EDC2: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
EDC4: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
EDC6: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
EDC8: 0000    	chkvect:defw	0		;address of check vector.
EDCA: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
EDCC: 0000    	sectors:defw	0		;sectors per track from bios.
EDCE: 00      	blkshft:defb	0		;block shift.
EDCF: 00      	blkmask:defb	0		;block mask.
EDD0: 00      	extmask:defb	0		;extent mask.
EDD1: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
EDD3: 0000    	dirsize:defw	0		;directory size.
EDD5: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
EDD7: 0000    	alloc1:	defw	0
EDD9: 0000    	offset:	defw	0		;first usable track number.
EDDB: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
EDDD: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
EDDE: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
EDDF: 00      	fndstat:defb	0		;filename found status (0=found first entry).
EDE0: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
EDE1: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
EDE2: 00      	relblock: defb	0		;relative position within fcb of block number written.
EDE3: 00      	counter:defb	0		;byte counter for directory name searches.
EDE4: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
EDE8: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
EDE9: 00      	auto:	defb	0		;if non-zero, then auto select activated.
EDEA: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
EDEB: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
EDEC: 00      	savnxt:	defb	0		;storage for next record number to access.
EDED: 00      	savext:	defb	0		;storage for extent number of file.
EDEE: 0000    	savnrec:defw	0		;storage for number of records in file.
EDF0: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
EDF2: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
EDF4: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
EDF5: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
EDF7: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EDFB: 00...   	
              	
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "../bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS.
              	;*
              	;**************************************************************
              	;
EE07: C33AEE  		jp	boot
EE0A: C348EE  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
EE0D: C3A2EE  		jp	const
EE10: C3ADEE  		jp	conin
EE13: C3B9EE  		jp	conout
EE16: C3C5EE  		jp	list
EE19: C3C9EE  		jp	punch
EE1C: C3CDEE  		jp	reader
EE1F: C3DBEE  		jp	home
EE22: C3E0EE  		jp	seldsk
EE25: C3FEEE  		jp	settrk
EE28: C302EF  		jp	setsec
EE2B: C306EF  		jp	setdma
EE2E: C30CEF  		jp	read
EE31: C310EF  		jp	write
EE34: C314EF  		jp	prstat
EE37: C317EF  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
EE3A: 3100D8  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
EE3D: CD5FEE  		call	wbootr
              		
              		; Special conditions for a cold boot
EE40: CD65EF  		call	cbinit
              	
              		; Jump to CP/M
EE43: 0E00    		ld	c,default
EE45: C300D8  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
EE48: 3100D8  	wboot:	ld	sp,cbase
              	
              		; Save current drive + user
EE4B: 3A0400  		ld	a,(tdrive)
EE4E: F5      		push	af
              	
              		; Save IOBYTE
EE4F: 3A0300  		ld	a,(iobyte)
EE52: F5      		push	af
              	
              		; Warm boot
EE53: CD5FEE  		call	wbootr
              		
              		; Restore IOBYTE
EE56: F1      		pop	af
EE57: 320300  		ld	(iobyte),a
              		
              		; Restore tdrive and warm boot
EE5A: F1      		pop	af
EE5B: 4F      		ld	c,a
EE5C: C300D8  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
EE5F: F3      	wbootr:	di
              		
              		; Zero out BSS
EE60: AF      		xor	a
EE61: 21A7FA  		ld	hl,_TEXT_end
EE64: 77      		ld	(hl),a
EE65: 11A8FA  		ld	de,_TEXT_end+1
EE68: 017900  		ld	bc,_BSS_size
EE6B: EDB0    		ldir
              	
              		; Send init signals to all devices
EE6D: 0600    		ld	b,0
EE6F: C5      	wboot0:	push	bc
EE70: 2177EF  		ld	hl,bdevsw
EE73: 78      		ld	a,b
EE74: CD29EF  		call	swindir
EE77: AF      		xor	a
EE78: 14      		inc	d
EE79: CC46EF  		call	z,callmj
EE7C: C1      		pop	bc
EE7D: 04      		inc	b
EE7E: 3E14    		ld	a,20
EE80: B8      		cp	b
EE81: 20EC    		jr	nz,wboot0
              	
              		; Turn off batch mode
EE83: 3E00    		ld	a,0
EE85: 32B8DF  		ld	(batch),a
              	
              		; Load the CCP
EE88: CD71EF  		call	resccp
              	
              		; Call config init
EE8B: CD4BEF  		call	wbinit
              		
              		; Set up lower memory
EE8E: 219AEE  		ld	hl,cpmlow
EE91: 110000  		ld	de,0
EE94: 010800  		ld	bc,8
EE97: EDB0    		ldir
              	
              	
              		; Return
EE99: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
EE9A: C30AEE  	cpmlow:	jp	wbootin	; Call jump table version instead
EE9D: 81      		defb	0x81	; Default IOBYTE
EE9E: 00      		defb	0	; Default drive
EE9F: C302E0  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
EEA2: 0600    	const:	ld	b,0
EEA4: CD1AEF  		call	cdindir
EEA7: 14      		inc	d
EEA8: C0      		ret	nz
EEA9: 3C      		inc	a
EEAA: C346EF  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
EEAD: 0600    	conin:	ld	b,0
EEAF: CD1AEF  		call	cdindir
EEB2: 14      		inc	d
EEB3: C0      		ret	nz
EEB4: 3E02    		ld	a,2
EEB6: C346EF  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
EEB9: 0600    	conout:	ld	b,0
EEBB: CD1AEF  	chrout:	call	cdindir
EEBE: 14      		inc	d
EEBF: C0      		ret	nz
EEC0: 3E03    		ld	a,3
EEC2: C346EF  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
EEC5: 0606    	list:	ld	b,6
EEC7: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
EEC9: 0604    	punch:	ld	b,4
EECB: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
EECD: 0602    	reader:	ld	b,2
EECF: CD1AEF  		call	cdindir
EED2: 14      		inc	d
EED3: 3E1A    		ld	a,0x1A
EED5: C0      		ret	nz
EED6: 3E02    		ld	a,2
EED8: C346EF  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
EEDB: 3E01    	home:	ld	a,1
EEDD: C3F8EE  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
EEE0: 79      	seldsk:	ld	a,c
EEE1: 43      		ld	b,e
EEE2: 2177EF  		ld	hl,bdevsw
EEE5: CD29EF  		call	swindir
EEE8: 22F9EE  		ld	(callbd+1),hl
EEEB: 210000  		ld	hl,0
EEEE: 14      		inc	d
EEEF: C0      		ret	nz
EEF0: 2A47EF  		ld	hl,(callmj+1)
EEF3: 22FCEE  		ld	(callbd+4),hl
EEF6: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
EEF8: 21      	callbd:	defb	0x21
EEF9: 0000    		defw	0
EEFB: C3      		defb	0xC3
EEFC: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
EEFE: 3E03    	settrk:	ld	a,3
EF00: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
EF02: 3E04    	setsec:	ld	a,4
EF04: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
EF06: 60      	setdma:	ld	h,b
EF07: 69      		ld	l,c
EF08: 2249EF  		ld	(biodma),hl
EF0B: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
EF0C: 3E05    	read:	ld	a,5
EF0E: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
EF10: 3E06    	write:	ld	a,6
EF12: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
EF14: 3EFF    	prstat:	ld	a,0xFF
EF16: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
EF17: 60      	sectrn:	ld	h,b
EF18: 69      		ld	l,c
EF19: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
EF1A: 04      	cdindir:inc	b
EF1B: 3A0300  		ld	a,(iobyte)
EF1E: 05      	cdindi0:dec	b
EF1F: 2803    		jr	z,cdindi1
EF21: 1F      		rra
EF22: 18FA    		jr	cdindi0
EF24: E603    	cdindi1:and	0x03
EF26: 21B7EF  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
EF29: 110400  	swindir:ld	de,4
EF2C: B7      		or	a
EF2D: 2804    	swindi0:jr	z,swindi1
EF2F: 19      		add	hl,de
EF30: 3D      		dec	a
EF31: 18FA    		jr	swindi0
EF33: 7E      	swindi1:ld	a,(hl)
EF34: 3247EF  		ld	(callmj+1),a
EF37: 23      		inc	hl
EF38: B6      		or	(hl)
EF39: C8      		ret	z
EF3A: 7E      		ld	a,(hl)
EF3B: 3248EF  		ld	(callmj+2),a
EF3E: 23      		inc	hl
EF3F: 7E      		ld	a,(hl)
EF40: 23      		inc	hl
EF41: 66      		ld	h,(hl)
EF42: 6F      		ld	l,a
EF43: 16FF    		ld	d,255
EF45: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
EF46: C3      	callmj: defb	0xC3
EF47: 0000    		defw	0
              	
              	
              	
              	; Variables
EF49: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
EF4B: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
EF4D: D300    		out	(0x00),a
              		
EF4F: 3EC3    		ld	a,0xC3		; Set up IRQ handler
EF51: 323800  		ld	(0x38),a	
EF54: 216BEF  		ld	hl,cfirq
EF57: 223900  		ld	(0x39),hl
              		
              		; Turn on batch mode
EF5A: 3EFF    		ld	a,0xFF
EF5C: 32B8DF  		ld	(batch),a
              		
              		; Also set interrupt mode 2 stuff
EF5F: ED47    		ld	i,a
EF61: ED5E    		im	2		; Start interrupts
EF63: FB      		ei
              		
EF64: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
EF65: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
EF67: 3207D8  		ld	(inbuff+1),a
EF6A: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
EF6B: FB      	cfirq:	ei
EF6C: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
EF6E: C3DFF3  	syshook:jp	ns_sysh
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
EF71: C3B6F3  	resccp:	jp	ns_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
EF74: C3BBF3  	resgrb:	jp	ns_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EF77: 56F30000	bdevsw:	defw	nfsdev,	0	; 'A'
EF7B: 56F30100		defw	nfsdev,	1	; 'B'
EF7F: 56F30200		defw	nfsdev,	2	; 'C'
EF83: 56F30300		defw	nfsdev,	3	; 'D'
EF87: 56F30400		defw	nfsdev,	4	; 'E'
EF8B: 56F30500		defw	nfsdev,	5	; 'F'
EF8F: 56F30600		defw	nfsdev,	6	; 'G'
EF93: 56F30700		defw	nfsdev,	7	; 'H'
EF97: 56F30800		defw	nfsdev,	8	; 'I'
EF9B: 56F30900		defw	nfsdev,	9	; 'J'
EF9F: 56F30A00		defw	nfsdev,	10	; 'K'
EFA3: 56F30B00		defw	nfsdev,	11	; 'L'
EFA7: 56F30C00		defw	nfsdev,	12	; 'M'
EFAB: 56F30D00		defw	nfsdev,	13	; 'N'
EFAF: 56F30E00		defw	nfsdev,	14	; 'O'
EFB3: 56F30F00		defw	nfsdev,	15	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EFB7: 19FA0000	cdevsw:	defw	siodev,	0	; TTY device
EFBB: C7EF0000		defw	vdpdev,	0	; Console device
EFBF: EFF90000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
EFC3: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "../dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FAA7: 00      	tm_outc:defs	1	; Output character
FAA8: 00      	tm_scro:defs	1	; Scroll width
FAA9: 00      	tm_escs:defs	1	; Escape state
FAAA: 00      	tm_last:defs	1	; Last character read
FAAB: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
FAAF: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
0040:         	tm_ayda	equ	0x40	; AY-3-8910 data port
0041:         	tm_atla	equ	0x41	; AY-3-8910 latch port
              	
              	; --- VRAM MAP ---
              	; 0x0000 - 0x07FF: Font
              	; 0x0800 - 0x0BFF: 40 column screen buffer
              	; 0x0C00 - 0x0FFF: Unused
              	; 0x1000 - 0x17FF: 80 column screen buffer
              	;
              	; Serial #
              	; 0x17FE: 0xE5
              	; 0x17FF: 0x81
              	
              	
              	; Driver jump table
EFC7: B7      	vdpdev:	or	a
EFC8: 2839    		jr	z,tm_init
EFCA: 3D      		dec	a
EFCB: 2819    		jr	z,tm_stat
EFCD: 3D      		dec	a
EFCE: CAA5F0  		jp	z,tm_read
EFD1: C3F7F0  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EFD4: F5      	tm_otir:push	af
EFD5: 7E      	tm_oti0:ld	a,(hl)
EFD6: ED79    		out	(c),a
EFD8: 23      		inc	hl
EFD9: 10FA    		djnz	tm_oti0
EFDB: F1      		pop	af
EFDC: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EFDD: F5      	tm_inir:push	af
EFDE: ED78    	tm_inr0:in	a,(c)
EFE0: 77      		ld	(hl),a
EFE1: 23      		inc	hl
EFE2: 10FA    		djnz	tm_inr0
EFE4: F1      		pop	af
EFE5: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
EFE6: 3AAAFA  	tm_stat:ld	a,(tm_last)
EFE9: FEE4    		cp	0xE4
EFEB: 2871    		jr	z,tm_scri
EFED: FEE5    		cp	0xE5
EFEF: 287F    		jr	z,tm_sclf
EFF1: 3AA7FA  	tm_sta0:ld	a,(tm_outc)
EFF4: 3C      		inc	a
EFF5: 3EFF    		ld	a,0xFF
EFF7: C0      		ret	nz
EFF8: CD2BF2  		call	tm_getc
EFFB: 32A7FA  		ld	(tm_outc),a
EFFE: 3C      		inc	a
EFFF: C8      		ret	z
F000: 3EFF    		ld	a,0xFF
F002: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
F003: CD74EF  	tm_init:call	resgrb
              	
              		; Set up registers
F006: CD7AF0  		call	tm_setp
              		
              		; Set up interrupt vectors (if needed)
F009: 2116F3  		ld	hl,tm_virq
F00C: 2206FF  		ld	(intvec+6),hl
F00F: 2149F2  		ld	hl,tm_kirq
F012: 2204FF  		ld	(intvec+4),hl
              		
              		; Set TMS pattern generator block to 0
F015: DBA1    		in	a,(tm_latc)
F017: AF      		xor	a
F018: D3A1    		out	(tm_latc),a
F01A: 3E84    		ld	a,0x84
F01C: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F01E: 010040  		ld	bc,0x4000
F021: CD0BF3  		call	tm_addr
F024: 2100D8  		ld	hl,cbase
F027: 0EA0    		ld	c,tm_data
F029: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F02B: 0600    	tm_ini0:ld	b,0
F02D: CDD4EF  		call	tm_otir
F030: 3D      		dec	a
F031: 20F8    		jr	nz,tm_ini0
              		
              		; Cold boot?
F033: 3A35F3  		ld	a,(tm_cold)
F036: B7      		or	a
F037: 2012    		jr	nz,tm_ini1
              		
              		; Check serial #
F039: 01FE17  		ld	bc,0x17FE
F03C: CD0BF3  		call	tm_addr
F03F: ED78    		in	a,(c)
F041: FEE5    		cp	0xE5
F043: 2006    		jr	nz,tm_ini1
F045: ED78    		in	a,(c)
F047: FE81    		cp	0x81
F049: 280D    		jr	z,tm_cloc
              		
              		; Reset the terminal
F04B: CDEEF2  	tm_ini1:call	tm_cls
F04E: AF      		xor	a
F04F: 3233F3  		ld	(tm_curx),a
F052: 3234F3  		ld	(tm_cury),a
F055: 3235F3  		ld	(tm_cold),a
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F058: 3EFF    	tm_cloc:ld	a,0xFF
F05A: 32A7FA  		ld	(tm_outc),a
              	
F05D: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F05E: 3AA8FA  	tm_scri:ld	a,(tm_scro)
F061: B7      		or	a
F062: FE28    		cp	40
F064: 2808    		jr	z,tm_scr1
F066: C604    		add	a,4
F068: 32A8FA  	tm_scr0:ld	(tm_scro),a
F06B: CDCBF2  		call	tm_usco
F06E: 1881    	tm_scr1:jr	tm_sta0
F070: 3AA8FA  	tm_sclf:ld	a,(tm_scro)
F073: B7      		or	a
F074: 28F8    		jr	z,tm_scr1
F076: D604    		sub	4
F078: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
F07A: 2A2EF3  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
F07D: DBA1    		in	a,(tm_latc)
F07F: 7C      		ld	a,h
F080: D3A1    		out	(tm_latc),a
F082: 3E80    		ld	a,0x80
F084: D3A1    		out	(tm_latc),a
F086: DBA1    		in	a,(tm_latc)
F088: 3EF0    		ld	a,0xF0
F08A: D3A1    		out	(tm_latc),a
F08C: 3E81    		ld	a,0x81
F08E: D3A1    		out	(tm_latc),a
              		
              		; Set TMS color
F090: DBA1    		in	a,(tm_latc)
F092: 3A30F3  		ld	a,(tm_colr)
F095: D3A1    		out	(tm_latc),a
F097: 3E87    		ld	a,0x87
F099: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F09B: DBA1    		in	a,(tm_latc)
F09D: 7D      		ld	a,l
F09E: D3A1    		out	(tm_latc),a
F0A0: 3E82    		ld	a,0x82
F0A2: D3A1    		out	(tm_latc),a
F0A4: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F0A5: 3A33F3  	tm_read:ld	a,(tm_curx)
F0A8: 4F      		ld	c,a
F0A9: 3A34F3  		ld	a,(tm_cury)
F0AC: 57      		ld	d,a
F0AD: 210010  		ld	hl,0x1000
F0B0: 3E50    		ld	a,80
F0B2: CDA7F2  		call	tm_chat
F0B5: DBA0    		in	a,(tm_data)	; char is in A
F0B7: 57      		ld	d,a		; char key
F0B8: 5F      		ld	e,a		; blinking char
F0B9: 0601    		ld	b,1
              		
F0BB: D5      	tm_rea0:push	de
F0BC: CDE6EF  		call	tm_stat
F0BF: D1      		pop	de
F0C0: 3C      		inc	a
F0C1: 200D    		jr	nz,tm_rea1
F0C3: 5A      		ld	e,d
F0C4: CDE0F0  		call	tm_rea2
F0C7: 3AA7FA  		ld	a,(tm_outc)
F0CA: 47      		ld	b,a
F0CB: CD58F0  		call	tm_cloc
F0CE: 78      		ld	a,b
F0CF: C9      		ret
              		
F0D0: CDEEF0  	tm_rea1:call	tm_stal
F0D3: 10E6    		djnz	tm_rea0
F0D5: 3E80    		ld	a,0x80
F0D7: AB      		xor	e
F0D8: 5F      		ld	e,a
F0D9: CDE0F0  		call	tm_rea2
F0DC: 06BE    		ld	b,190
F0DE: 18DB    		jr	tm_rea0
              	
              	
F0E0: D5      	tm_rea2:push	de
F0E1: 3A33F3  		ld	a,(tm_curx)
F0E4: 4F      		ld	c,a
F0E5: 3A34F3  		ld	a,(tm_cury)
F0E8: 57      		ld	d,a
F0E9: CD83F2  		call	tm_putc
F0EC: D1      		pop	de
F0ED: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F0EE: C5      	tm_stal:push	bc
F0EF: 06FF    		ld	b,255
F0F1: C5      	tm_sta1:push	bc
F0F2: C1      		pop	bc
F0F3: 10FC    		djnz	tm_sta1
F0F5: C1      		pop	bc
F0F6: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F0F7: CD1CF3  	tm_writ:call	tm_dint
F0FA: 59      		ld	e,c
F0FB: 3A33F3  		ld	a,(tm_curx)
F0FE: 4F      		ld	c,a
F0FF: 3A34F3  		ld	a,(tm_cury)
F102: 57      		ld	d,a
F103: CD12F1  		call	tm_wri0
F106: 78      		ld	a,b
F107: 3234F3  		ld	(tm_cury),a
F10A: 79      		ld	a,c
F10B: 3233F3  		ld	(tm_curx),a
F10E: CD25F3  		call	tm_eint
F111: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F112: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F113: 3AA9FA  		ld	a,(tm_escs)
F116: B7      		or	a		; Process escape code
F117: C27FF1  		jp	nz,tm_esc
F11A: 3E1F    		ld	a,0x1F
F11C: BB      		cp	e
F11D: D251F1  		jp	nc,tm_wri1	; Process control code
F120: C5      		push	bc
F121: CD83F2  		call	tm_putc		; Write character
F124: C1      		pop	bc
              		
              		; Increment character
F125: 0C      	tm_ri	inc	c
F126: 3E50    		ld	a,80
F128: B9      		cp	c
F129: C0      		ret	nz
F12A: AF      		xor	a
F12B: 4F      		ld	c,a
F12C: 04      	tm_lf:  inc	b	; Line feed
F12D: 3E18    		ld	a,24
F12F: B8      		cp	b
F130: C0      		ret	nz
F131: C5      		push	bc
F132: CD05F2  		call	tm_dsco
F135: C1      		pop	bc
F136: 05      		dec	b
F137: C9      		ret
F138: AF      	tm_cr:	xor	a	; Carriage return
F139: 4F      		ld	c,a
F13A: C9      		ret
F13B: 0D      	tm_bs:	dec	c	; Backspace 
F13C: F0      		ret	p
F13D: 0E4F    		ld	c,79
F13F: 05      		dec	b
F140: F0      		ret	p
F141: AF      		xor	a
F142: 47      		ld	b,a
F143: 4F      		ld	c,a
F144: C9      		ret
F145: AF      	tm_up:	xor	a	; Move up
F146: B8      		cp	b
F147: C8      		ret	z
F148: 05      		dec	b
F149: C9      		ret
F14A: CDEEF2  	tm_cshm:call	tm_cls
F14D: AF      	tm_home:xor	a
F14E: 47      		ld	b,a
F14F: 4F      		ld	c,a
F150: C9      		ret
              	
F151: 7B      	tm_wri1:ld	a,e
F152: FE08    		cp	0x08	; '\b' (Cursor left)
F154: 28E5    		jr	z,tm_bs
F156: FE12    		cp	0x12	; Cursor right
F158: 28CB    		jr	z,tm_ri
F15A: FE0A    		cp	0x0A	; '\n' (Cursor down)
F15C: 28CE    		jr	z,tm_lf
F15E: FE0B    		cp	0x0B	; Cursor up
F160: 28E3    		jr	z,tm_up
F162: FE0D    		cp	0x0D	; '\r' 
F164: 28D2    		jr	z,tm_cr
F166: FE17    		cp	0x17	; Clear end of screen
F168: 2856    		jr	z,tm_cles
F16A: FE18    		cp	0x18	; Clear end of line
F16C: 2854    		jr	z,tm_clea
F16E: FE1A    		cp	0x1A	; Clear screen, home cursor
F170: 28D8    		jr	z,tm_cshm
F172: FE1E    		cp	0x1E	; Home cursor
F174: 28D7    		jr	z,tm_home
F176: FE1B    		cp	0x1B	; Escape
F178: C0      		ret	nz
F179: 3E01    		ld	a,1
F17B: 32A9FA  		ld	(tm_escs),a
F17E: C9      		ret
              		
              		; Handle escape sequence
F17F: 3D      	tm_esc:	dec	a
F180: 280E    		jr	z,tm_esc0
F182: 3D      		dec	a
F183: 2825    		jr	z,tm_esc1
F185: 3D      		dec	a
F186: 282D    		jr	z,tm_esc2
F188: 3D      		dec	a
F189: 2871    		jr	z,tm_updc
F18B: AF      	tm_escd:xor	a	; Escape done
F18C: 32A9FA  	tm_escr:ld	(tm_escs),a
F18F: C9      		ret
F190: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
F192: BB      		cp	e
F193: 2850    		jr	z,tm_40c
F195: 3EFE    		ld	a,0xFE	; Do 80-col
F197: BB      		cp	e
F198: 2858    		jr	z,tm_80c
F19A: 3EFD    		ld	a,0xFD	; Set color
F19C: BB      		cp	e
F19D: 2859    		jr	z,tm_scol
F19F: 3E3D    		ld	a,0x3D	; '='
F1A1: BB      		cp	e
F1A2: 20E7    		jr	nz,tm_escd
F1A4: 3AA9FA  	tm_esci:ld	a,(tm_escs)
F1A7: 3C      		inc	a
F1A8: 18E2    		jr	tm_escr
F1AA: 7B      	tm_esc1:ld	a,e
F1AB: 1E20    		ld	e,0x20
F1AD: 93      		sub	e
F1AE: FE18    		cp	24
F1B0: 30D9    		jr	nc,tm_escd
F1B2: 47      		ld	b,a
F1B3: 18EF    		jr	tm_esci
F1B5: 7B      	tm_esc2:ld	a,e
F1B6: 1E20    		ld	e,0x20
F1B8: 93      		sub	e
F1B9: FE50    		cp	80
F1BB: 30CE    		jr	nc,tm_escd
F1BD: 4F      		ld	c,a
F1BE: 18CB    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F1C0: 0617    	tm_cles:ld	b,23
F1C2: 04      	tm_clea:inc	b
F1C3: 1E00    		ld	e,0
F1C5: C5      		push	bc
F1C6: D5      		push	de
F1C7: 3E50    		ld	a,80
F1C9: 210050  		ld	hl,0x5000
F1CC: CDA7F2  		call	tm_chat
F1CF: D1      		pop	de
F1D0: C1      		pop	bc
F1D1: AF      	tm_cle0:xor	a
F1D2: D3A0    		out	(tm_data),a
F1D4: 0C      		inc	c
F1D5: 3E50    		ld	a,80
F1D7: B9      		cp	c
F1D8: 20F7    		jr	nz,tm_cle0
F1DA: 14      		inc	d
F1DB: AF      		xor	a
F1DC: 4F      		ld	c,a
F1DD: 7A      		ld	a,d
F1DE: B8      		cp	b
F1DF: 20F0    		jr	nz,tm_cle0
F1E1: D1      		pop	de	; Do not update character
F1E2: C3CBF2  		jp	tm_usco
              		
F1E5: E5      	tm_40c:	push	hl
F1E6: 210200  		ld	hl,0x0002
F1E9: 222EF3  	tm_cupd:ld	(tm_mode),hl
F1EC: CD7AF0  		call	tm_setp
F1EF: E1      		pop	hl
F1F0: 1899    		jr	tm_escd
              		
F1F2: E5      	tm_80c:	push	hl
F1F3: 210704  		ld	hl,0x0407
F1F6: 18F1    		jr	tm_cupd
              		
              		; Set color command
F1F8: 3E04    	tm_scol:ld	a,4
F1FA: 1890    		jr	tm_escr
              		
              		; Update color here
F1FC: 7B      	tm_updc:ld	a,e
F1FD: 3230F3  		ld	(tm_colr),a
F200: CD7AF0  		call	tm_setp
F203: 1886    		jr	tm_escd
              		
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F205: 212808  	tm_dsco:ld	hl,0x0800+40
F208: 110048  		ld	de,0x4800
F20B: 0618    		ld	b,24
F20D: CD18F2  		call	tm_dsc0
F210: 215010  		ld	hl,0x1000+80
F213: 110050  		ld	de,0x5000
F216: 0630    		ld	b,48
F218: C5      	tm_dsc0:push	bc
F219: D5      		push	de
F21A: E5      		push	hl
F21B: CDB3F2  		call	tm_vcpy
F21E: E1      		pop	hl
F21F: D1      		pop	de
F220: 012800  		ld	bc,40
F223: 09      		add	hl,bc
F224: EB      		ex	de,hl
F225: 09      		add	hl,bc
F226: EB      		ex	de,hl
F227: C1      		pop	bc
F228: 10EE    		djnz	tm_dsc0
F22A: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F22B: 3A32F3  	tm_getc:ld	a,(tm_inf)
F22E: B7      		or	a
F22F: 3E00    		ld	a,0
F231: 3232F3  		ld	(tm_inf),a
F234: 3A31F3  		ld	a,(tm_inb)
F237: 2008    		jr	nz,tm_get0
              	
F239: DB91    		in	a,(tm_keys)
F23B: E602    		and	2
F23D: 3D      		dec	a
F23E: F8      		ret	m
              		
              		; Grab the key
F23F: DB90    		in	a,(tm_keyd)
F241: 32AAFA  	tm_get0:ld	(tm_last),a
F244: CD57F2  		call	tm_map
F247: 79      		ld	a,c
F248: C9      		ret
              		
              	; Handles a keyboard interrupt for the VDP terminal driver
              	; Keypress stored in tm_inb and tm_inf flag is set
              	; 
              	; uses: none
F249: F5      	tm_kirq:push	af
F24A: DB90    		in	a,(tm_keyd)
F24C: 3231F3  		ld	(tm_inb),a
F24F: 3E01    		ld	a,1
F251: 3232F3  		ld	(tm_inf),a
F254: F1      		pop	af
F255: FB      		ei
F256: C9      		ret
              		
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F257: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
F258: 216EF2  		ld	hl,tm_mapt
F25B: 7E      	tm_map0:ld	a,(hl)
F25C: B7      		or	a
F25D: 2808    		jr	z,tm_map2
F25F: B9      		cp	c
F260: 23      		inc	hl
F261: 7E      		ld	a,(hl)
F262: 23      		inc	hl
F263: 20F6    		jr	nz,tm_map0
F265: 4F      		ld	c,a
F266: C9      		ret
              		
              		
              		; Filter non-ASCII
F267: 79      	tm_map2:ld	a,c
F268: E680    		and	0x80	
F26A: C8      		ret	z
F26B: 0EFF    		ld	c,0xFF
F26D: C9      		ret
              		
              	; Map table
F26E: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
F270: E108    		defb	0xE1,0x08	; '<-' -> BS
F272: EA7F    		defb	0xEA,0x7F	; TV -> DEL
F274: E00C    		defb	0xE0,0x0C	; '->' -> Right
F276: E20B    		defb	0xE2,0x0B	; '/\' -> Up
F278: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
F27A: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
F27C: E860    		defb	0xE8,0x60	; SYM -> '@'
F27E: E67C    		defb	0xE6,0x7C	; NO -> '|'
F280: E77E    		defb	0xE7,0x7E	; YES -> '~'
F282: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F283: 210050  	tm_putc:ld	hl,0x5000
F286: 3E50    		ld	a,80
F288: C5      		push	bc
F289: D5      		push	de
F28A: CDA7F2  		call	tm_chat	; Place it in the 80 col buffer
F28D: ED59    		out	(c),e
F28F: D1      		pop	de
F290: C1      		pop	bc
F291: 3AA8FA  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F294: 47      		ld	b,a
F295: 79      		ld	a,c
F296: 90      		sub	b	; If character is less than scroll...
F297: 4F      		ld	c,a
F298: F8      		ret	m
F299: FE28    		cp	40	; If desired position is 40 or more
F29B: D0      		ret	nc
F29C: 210048  		ld	hl,0x4800
F29F: 3E28    		ld	a,40
F2A1: CDA7F2  		call	tm_chat	; Place it in the 40 col screen buffer
F2A4: ED59    		out	(c),e
F2A6: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
F2A7: 0600    	tm_chat:ld	b,0
F2A9: 09      		add	hl,bc
F2AA: 4F      		ld	c,a
F2AB: AF      		xor	a
F2AC: BA      		cp	d
F2AD: 285A    	tm_cha0:jr	z,tm_addh
F2AF: 09      		add	hl,bc
F2B0: 15      		dec	d
F2B1: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F2B3: CD09F3  	tm_vcpy:call	tm_addh
F2B6: 0628    		ld	b,40
F2B8: 21ABFA  		ld	hl,tm_cbuf
F2BB: CDDDEF  		call	tm_inir
F2BE: EB      		ex	de,hl
F2BF: CD09F3  		call	tm_addh
F2C2: 0628    		ld	b,40
F2C4: 21ABFA  		ld	hl,tm_cbuf
F2C7: CDD4EF  		call	tm_otir
F2CA: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F2CB: 210010  	tm_usco:ld	hl,0x1000
F2CE: 110048  		ld	de,0x4800
F2D1: 3AA8FA  		ld	a,(tm_scro)
F2D4: 0600    		ld	b,0
F2D6: 4F      		ld	c,a
F2D7: 09      		add	hl,bc
F2D8: 0618    		ld	b,24
F2DA: C5      	tm_usc0:push	bc
F2DB: D5      		push	de
F2DC: E5      		push	hl
F2DD: CDB3F2  		call	tm_vcpy
F2E0: E1      		pop	hl
F2E1: D1      		pop	de
F2E2: 0E50    		ld	c,80
F2E4: 09      		add	hl,bc
F2E5: EB      		ex	de,hl
F2E6: 0E28    		ld	c,40
F2E8: 09      		add	hl,bc
F2E9: EB      		ex	de,hl
F2EA: C1      		pop	bc
F2EB: 10ED    		djnz	tm_usc0
F2ED: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F2EE: 010048  	tm_cls:	ld	bc,0x4800
F2F1: 11FE0F  		ld	de,0x1000-2
F2F4: CD0BF3  		call	tm_addr
F2F7: ED71    	tm_cls0:out	(c),0
F2F9: 1B      		dec	de
F2FA: 7A      		ld	a,d
F2FB: B3      		or	e
F2FC: 20F9    		jr	nz,tm_cls0
              		
              		; Write super special serial #
F2FE: 3EE5    		ld	a,0xE5
F300: ED79    		out	(c),a
F302: F5      		push	af
F303: F1      		pop	af
F304: 3E81    		ld	a,0x81
F306: ED79    		out	(c),a
F308: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; Returns tm_data in c
              	; uses: af, bc
F309: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F30A: 4D      		ld	c,l
F30B: DBA1    	tm_addr:in	a,(tm_latc)
F30D: 79      		ld	a,c
F30E: D3A1    		out	(tm_latc),a
F310: 78      		ld	a,b
F311: D3A1    		out	(tm_latc),a
F313: 0EA0    		ld	c,tm_data
F315: C9      		ret
              		
              	; Handles a TMS9918 irq
F316: F5      	tm_virq:push	af
F317: DBA1    		in	a,(tm_latc)
F319: F1      		pop	af
F31A: FB      		ei
F31B: C9      		ret
              		
              		
              	; Disables all interrupts while VDP operations occur
              	;
              	; uses: a
F31C: 3E0E    	tm_dint:ld	a,0x0E
F31E: D341    		out	(tm_atla),a	; AY register = 14
F320: 3E00    		ld	a,0x00
F322: D340    		out	(tm_ayda),a	
F324: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
F325: 3E0E    	tm_eint:ld	a,0x0E
F327: D341    		out	(tm_atla),a	; AY register = 14
F329: 3EB0    		ld	a,0xB0
F32B: D340    		out	(tm_ayda),a
F32D: C9      		ret
              		
              	; Variables
F32E: 0200    	tm_mode:defw	0x0002
F330: E1      	tm_colr:defb	0xE1
F331: 00      	tm_inb:	defb	0
F332: 00      	tm_inf:	defb	0
F333: 00      	tm_curx:defb	0
F334: 00      	tm_cury:defb	0
F335: 01      	tm_cold:defb	1
              	#include "../dev/nabu_nfs.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   F I L E   S Y S T E M
              	;*
              	;*    Unlike a standard block device, the NFS driver provides
              	;*    a CP/M filesystem by directly intercepting system calls.
              	;*    By doing this, it can access provide access to an external
              	;*    filesystem via NHACP.
              	;*
              	;*    Virtual filesystems are directories labelled "A", "B",
              	;*    "C", etc... on the host system. That are converted to
              	;*    minor numbers 0, 1, 2, etc... when the driver is being
              	;*    added to the block device switch  
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FAD3: 00000000	ns_buff:defs	48	; Buffer (48b)
FAD7: 00...   	
FB03: 00000000	ns_ptrn:defs	11	; Pattern buffer (11b)
FB07: 00...   	
FB0E: 00000000	ns_name:defs	11	; Name bufffer (11b)
FB12: 00...   	
FB19: 0000    	ns_mask:defs	2	; Ownership mask (2b)
FB1B: 0000    	ns_cfcb:defs	2	; Current FCB (2b)
FB1D: 00      	ns_dore:defs	1	; Do reopen? (1b)
FB1E: 00      	ns_isls:defs	1	; Is listing dir? (1b)
FB1F: 00      	ns_tran:defs	1	; Number of bytes in transfer (1b)
              	.area	_TEXT
              	
0040:         	ns_ayda	equ	0x40		; AY-3-8910 data port
0041:         	ns_atla	equ	0x41		; AY-3-8910 latch port
0080:         	ns_hcca	equ	0x80		; Modem data port
0000:         	ns_nctl	equ	0x00		; NABU control port
              	
0080:         	ns_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D U M M Y   D I S K   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Dummy DPH
F336: 00000000	ns_dph:	defw	0,0,0,0
F33A: 00000000	
F33E: 10FF    		defw	dircbuf	; DIRBUF
F340: 46F3    		defw	ns_dpb	; DPB
F342: 0000    		defw	0	; CSV
F344: 55F3    		defw	ns_alv	; ALV 
              		
              		
              	; Dummy format
F346: 4000    	ns_dpb:	defw	64	; # sectors per track
F348: 03      		defb	3	; BSH
F349: 07      		defb	7	; BLM
F34A: 00      		defb	0	; EXM
F34B: 0100    		defw	1	; DSM
F34D: 0000    		defw	0	; DRM
F34F: 00      		defb	0	; AL0
F350: 00      		defb	0	; AL1
F351: 0000    		defw	0	; Size of directory check vector
F353: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              		
              	; Dummy ALV
F355: 00      	ns_alv: defb	0
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F356: B7      	nfsdev:	or	a
F357: 2807    		jr	z,ns_init
F359: 3D      		dec	a
F35A: 3D      		dec	a
F35B: 2814    		jr	z,ns_sel
F35D: 3E01    		ld	a,1
F35F: C9      		ret
              	
              	; Inits the device
              	; Figures out which devices that the NFS driver "owns"
              	; b = Logical CP/M device #
              	; hl = Call argument
              	;
              	; uses: does not matter
F360: 78      	ns_init:ld	a,b
F361: CD59F7  		call	ns_domk
F364: 2A19FB  		ld	hl,(ns_mask)
F367: 7C      		ld	a,h
F368: B0      		or	b
F369: 67      		ld	h,a
F36A: 7D      		ld	a,l
F36B: B1      		or	c
F36C: 6F      		ld	l,a
F36D: 2219FB  		ld	(ns_mask),hl
F370: C9      		ret
              	
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
F371: 11C4ED  	ns_sel:	ld	de,dirbuf
F374: 213EF3  		ld	hl,ns_dph+8
F377: 010800  		ld	bc,8
F37A: EDB0    		ldir
F37C: C37FED  		jp	goback
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a, b
F37F: 3E07    	ns_hini:ld	a,0x07
F381: D341    		out	(ns_atla),a	; AY register = 7
F383: 3E7F    		ld	a,0x7F
F385: D340    		out	(ns_ayda),a	; Configure AY port I/O
              		
              		; Claim interrupt vectors
F387: E5      		push	hl
F388: 2187F8  		ld	hl,ns_rirq
F38B: 2200FF  		ld	(intvec),hl
F38E: 21CEF8  		ld	hl,ns_wirq
F391: 2202FF  		ld	(intvec+2),hl
F394: E1      		pop	hl
              		
              	; Set interrupts to their default state
              	;
              	; uses: a
F395: 3E0E    	ns_dflt:ld	a,0x0E
F397: D341    		out	(ns_atla),a	; AY register = 14
F399: 3EB0    		ld	a,0xB0
F39B: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send, plus key and VDP
              		
F39D: 3E0F    	ns_dfl0:ld	a,0x0F		
F39F: D341    		out	(ns_atla),a	; AY register = 15
              		
F3A1: C9      		ret
              	
              	; Set receive and send interrupts
              	;
              	; uses: a
F3A2: 3E0E    	ns_esnd:ld	a,0x0E
F3A4: D341    		out	(ns_atla),a	; AY register = 14
F3A6: 3EC0    		ld	a,0xC0
F3A8: D340    		out	(ns_ayda),a	; Enable HCCA receive and send
F3AA: 18F1    		jr	ns_dfl0
              		
              	; Set receive but not send interrupt
              	;
              	; uses: a
F3AC: 3E0E    	ns_dsnd:ld	a,0x0E
F3AE: D341    		out	(ns_atla),a	; AY register = 14
F3B0: 3E80    		ld	a,0x80
F3B2: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send
F3B4: 18E7    		jr	ns_dfl0
              	
              	; Loads the CCP into the CCP space
F3B6: 2144F9  	ns_ccp:	ld	hl,ns_p0
F3B9: 1803    		jr	ns_grb0
              		
              	; Loads the GRB into the CCP space
F3BB: 2151F9  	ns_grb:	ld	hl,ns_p1
F3BE: 1167F9  	ns_grb0:ld	de,ns_m0na
F3C1: 010D00  		ld	bc,13
F3C4: EDB0    		ldir			; Copy name to file open
F3C6: CD7FF3  		call	ns_hini		; Go to HCCA mode
F3C9: 210000  		ld	hl,0x0000	; O_RDONLY
F3CC: CD9AF7  		call	ns_opef		; Open the file
F3CF: 110000  		ld	de,0
F3D2: 2100D8  		ld	hl,cbase
F3D5: CDB9F7  	ns_grb1:call	ns_getb
F3D8: 1C      		inc	e
F3D9: 3E10    		ld	a,16
F3DB: BB      		cp	e
F3DC: 20F7    		jr	nz,ns_grb1
F3DE: C9      		ret
              		
              	; CP/M system hook
              	; Used to intercept certain syscalls
              	;
              	; uses: af if not hooked, all otherwise
F3DF: 79      	ns_sysh:ld	a,c
F3E0: D60F    		sub	15
F3E2: D8      		ret	c		; No syscalls lower than 15
F3E3: 2841    		jr	z,ns_fopn	; Open file
F3E5: 3D      		dec	a
F3E6: CA66F4  		jp	z,ns_fcls	; Close file
F3E9: 3D      		dec	a
F3EA: CA17F5  		jp	z,ns_sfir	; Search for first 
F3ED: 3D      		dec	a
F3EE: CA3CF5  		jp	z,ns_snxt	; Search for next 
F3F1: 3D      		dec	a
F3F2: CA8CF5  		jp	z,ns_dele	; Delete file
F3F5: 3D      		dec	a
F3F6: CA45F6  		jp	z,ns_frea	; File read next record
F3F9: 3D      		dec	a
F3FA: CA71F6  		jp	z,ns_fwri	; File write next record
F3FD: 3D      		dec	a
F3FE: CAC4F6  		jp	z,ns_fmak	; Create file
F401: 3D      		dec	a
F402: CAEBF6  		jp	z,ns_frnm	; Rename file
F405: D607    		sub	7
F407: 2817    		jr	z,ns_stmp	; Set file attributes (stump)
F409: D603    		sub	3
F40B: CA8BF6  		jp	z,ns_rrea	; File read random
F40E: 3D      		dec	a
F40F: CA9AF6  		jp	z,ns_rwri	; File write random
F412: 3D      		dec	a
F413: CA2FF7  		jp	z,ns_size	; Compute file size
F416: 3D      		dec	a
F417: CAA9F6  		jp	z,ns_rrec	; Update random access pointer
F41A: D604    		sub	4
F41C: CA9AF6  		jp	z,ns_rwri	; FIle write random (we will ignore the zero part)
F41F: C9      		ret
              		
              	; Stump, do nothing if FCB is owned
              	; de = Address to FCB
              	;
              	; uses: does not matter
F420: CD65F7  	ns_stmp:call	ns_ownr
              	
F423: C37FED  		jp	goback
              		
              	; Parses the current FCB, and searches for a file that matches
              	; the pattern.
              	; The point here is to insert the "true" name of the file into
              	; the FCB so it can be accessed later
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F426: CD65F7  	ns_fopn:call	ns_ownr
              	
              		; Go find the file
F429: D5      		push	de
F42A: CDBCF4  		call	ns_find
              		
              		; Update status
F42D: 210000  		ld	hl,0
F430: 2250E3  		ld	(status),hl
              		
              		; Copy over false CP/M filename to the FCB
F433: D1      		pop	de
F434: CD47F7  		call	ns_nblk		; Get # of blocks
F437: 79      		ld	a,c
F438: D5      		push	de
F439: 13      		inc	de
F43A: 210EFB  		ld	hl,ns_name
F43D: 010B00  		ld	bc,11
F440: EDB0    		ldir
              		
              		; Set open flag
F442: 4F      		ld	c,a
F443: 13      		inc	de
F444: 3EE7    		ld	a,0xE7
F446: 12      		ld	(de),a
F447: 13      		inc	de
F448: AF      		xor	a
F449: 12      		ld	(de),a
F44A: 13      		inc	de
F44B: 79      		ld	a,c
F44C: 12      		ld	(de),a
F44D: 13      		inc	de
              		
              		; Copy over the real filename to the FCB
F44E: 011000  		ld	bc,16
F451: 21E9FA  		ld	hl,ns_buff+22
F454: EDB0    		ldir
              		
              	
              		; Check if current
F456: D1      		pop	de
F457: 2A1BFB  		ld	hl,(ns_cfcb)
F45A: ED52    		sbc	hl,de
F45C: 2005    		jr	nz,ns_fop0
              	
              		; Set the reopen flag
F45E: 3E01    		ld	a,1
F460: 321DFB  		ld	(ns_dore),a
              		
F463: C37FED  	ns_fop0:jp	goback
              		
              	; Close the file
              	; Main purpose is to ensure that a close on this device is deferred
              	; Also resets the open flag
              	; de = Address of DPH
              	;
              	; uses: does not matter
F466: CD65F7  	ns_fcls:call	ns_ownr
              	
              		; Reset open flag
F469: 210D00  		ld	hl,13
F46C: 19      		add	hl,de
F46D: 3600    		ld	(hl),0x00
              		
              		; Set flag
F46F: 210000  		ld	hl,0
F472: 2250E3  		ld	(status),hl
              	
F475: C37FED  		jp	goback
              		
              	; Function call to start a list-dir operation
              	; Must be called before a file search
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F478: D5      	ns_slst:push	de		; Save de
F479: 2167F9  		ld	hl,ns_m0na
F47C: EB      		ex	de,hl
F47D: CD17F9  		call	ns_sdir 
F480: AF      		xor	a
F481: 12      		ld	(de),a		; Zero terminate string
F482: 3E01    		ld	a,1
F484: 321DFB  		ld	(ns_dore),a	; The existing file will be closed unconditionally
F487: 210800  		ld	hl,0x0008	; Set flag type to directory
F48A: CD9AF7  		call	ns_opef		; Call ns_open, but don't set flag
F48D: 21FF00  		ld	hl,0x00FF
F490: 2250E3  		ld	(status),hl	; Set status
F493: C27FED  		jp	nz,goback	; Error if cannot open file
              		
              		; Send LIST-DIR
F496: 2199F9  		ld	hl,ns_m4
F499: 0607    		ld	b,7
F49B: CD43F8  		call	ns_send		; Start list-dir command
F49E: 21D3FA  		ld	hl,ns_buff
F4A1: CD28F8  		call	ns_rece
F4A4: 3AD3FA  		ld	a,(ns_buff)	; Check for errors
F4A7: FE81    		cp	0x81
F4A9: C27FED  		jp	nz,goback
              		
              		; Copy the file pattern to the pattern buffer
F4AC: E1      		pop	hl		; Get the FCB back
F4AD: 23      		inc	hl
F4AE: 1103FB  		ld	de,ns_ptrn
F4B1: 060B    		ld	b,11
F4B3: 7E      	ns_sls0:ld	a,(hl)
F4B4: E67F    		and	0x7F		; Fix for CP/M stupidness
F4B6: 12      		ld	(de),a
F4B7: 13      		inc	de
F4B8: 23      		inc	hl
F4B9: 10F8    		djnz	ns_sls0
F4BB: C9      		ret
              	
              	; Does a complete find operation
              	; Calls ns_slst, and then falls to ns_find
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de ,hl
F4BC: CD78F4  	ns_find:call	ns_slst		; Complete find operation
              		
              	; Put the next found file name into the name buffer
              	; If no more names are found, exit with status of 0x00FF
              	; ns_slst must have been run to set up state, no more disk operations
              	; should be been run in the meantime.
              	; enter into ns_lis0 to avoid setting status
              	;
              	; uses: af, bc, de, hl
              	
F4BF: 21FF00  	ns_list:ld	hl,0x00FF
F4C2: 2250E3  		ld	(status),hl	; Set status
              	
              		
F4C5: 21D3FA  	ns_lis0:ld	hl,ns_buff	; Clear out the first 40 bytes of the buffer
F4C8: AF      		xor	a		; This is to emulate zero termination, due
F4C9: 77      		ld	(hl),a		; To the fact that NHACP does not zero-terminate
F4CA: 11D4FA  		ld	de,ns_buff+1	; strings coming back from the adapter...
F4CD: 012800  		ld	bc,40		
F4D0: EDB0    		ldir			
              	
              		; Lets read a directory now
F4D2: 21A0F9  		ld	hl,ns_m5	; Entry point from ns_sfir
F4D5: 0607    		ld	b,7
F4D7: CD43F8  		call	ns_send		; Get the next file
F4DA: 21D3FA  		ld	hl,ns_buff
F4DD: CD28F8  		call	ns_rece	
F4E0: 3AD3FA  		ld	a,(ns_buff)	; Ensure we got FILE-INFO
F4E3: FE86    		cp	0x86
F4E5: C27FED  		jp	nz,goback
              		
              		; Ok, time to format a directory entry
F4E8: 21E9FA  		ld	hl,ns_buff+22
F4EB: 110EFB  		ld	de,ns_name
F4EE: 0608    		ld	b,8
              		
              		; Format first part of file
F4F0: CD28F5  		call	ns_ffmt
              		
              		; Now we must skip till we either find a '.' or a '\0'
F4F3: 7E      	ns_lis1:ld	a,(hl)
F4F4: B7      		or	a
F4F5: 2805    		jr	z,ns_lis2
F4F7: 23      		inc	hl
F4F8: FE2E    		cp	'.'
F4FA: 20F7    		jr	nz,ns_lis1
              		
              		; Now the last part
F4FC: 0603    	ns_lis2:ld	b,3
F4FE: CD28F5  		call	ns_ffmt
              		
              		; Back dir entry against pattern
F501: 1103FB  		ld	de,ns_ptrn
F504: 210EFB  		ld	hl,ns_name
F507: 060B    		ld	b,11
              	
F509: 1A      	ns_lis3:ld	a,(de)
F50A: 4E      		ld	c,(hl)
F50B: 23      		inc	hl
F50C: 13      		inc	de
F50D: FE3F    		cp	'?'
F50F: 2803    		jr	z,ns_lis4
F511: B9      		cp	c
F512: 20B1    		jr	nz,ns_lis0
F514: 10F3    	ns_lis4:djnz	ns_lis3
F516: C9      		ret
              		
              	; Search for first file
              	; Opens up a directory, then skips to routines that read the first dir entry
              	; de = Address of FCB
              	;
              	; uses: all
F517: AF      	ns_sfir:xor	a
F518: 321EFB  		ld	(ns_isls),a	; Clear "isls" flag
F51B: CD65F7  		call	ns_ownr
              		
              		; Start the list-dir function
F51E: CD78F4  		call	ns_slst
              		
              		; Set isls flag
F521: 3E01    		ld	a,1
F523: 321EFB  		ld	(ns_isls),a
              		
              		; Move into ns_snxt
F526: 181C    		jr	ns_snx0
              		
              	; Format incoming files into a dir entry
              	; Will copy over characters until a '.' or '\0' is reached
              	; Any remaining characters will be filled out with spaces
              	; b = Number of characters
              	; de = Destination of data
              	; hl = Source of data
              	;
              	; uses: af, b, de, hl
F528: 7E      	ns_ffmt:ld	a,(hl)
F529: CD2AF9  		call	ns_ltou
F52C: B7      		or	a
F52D: 2804    		jr	z,ns_ffm0
F52F: FE2E    		cp	'.'
F531: 2003    		jr	nz,ns_ffm1
F533: 2B      	ns_ffm0:dec	hl
F534: 3E20    		ld	a,' '		; Turn it into a space
F536: 23      	ns_ffm1:inc	hl
F537: 12      		ld	(de),a
F538: 13      		inc	de
F539: 10ED    		djnz	ns_ffmt
F53B: C9      		ret
              		
              	; Search for next file
              	; Takes the open directory and gets the next file
              	;
              	; uses: all
F53C: 3A1EFB  	ns_snxt:ld	a,(ns_isls)
F53F: B7      		or	a
F540: C8      		ret	z
              		
              		; Set up the HCCA
F541: CD7FF3  		call	ns_hini	
              		
              		; Find the next entry
F544: CDBFF4  	ns_snx0:call	ns_list
              		
              		; Copy to directory entry
F547: ED5B49EF		ld	de,(biodma)
F54B: 3A4CE3  		ld	a,(userno)
F54E: 12      		ld	(de),a
F54F: 13      		inc	de
F550: 210EFB  		ld	hl,ns_name
F553: 010B00  		ld	bc,11
F556: EDB0    		ldir
              		
              		; Get file size
F558: CD47F7  		call	ns_nblk
              		
F55B: AF      		xor	a
F55C: B8      		cp	b
F55D: 0610    		ld	b,16
F55F: 200F    		jr	nz,ns_snx1
F561: AF      		xor	a
F562: CB39    		srl	c
F564: 17      		rla
F565: CB39    		srl	c
F567: 17      		rla
F568: CB39    		srl	c
F56A: 17      		rla
F56B: B7      		or	a
F56C: 41      		ld	b,c
F56D: 2801    		jr	z,ns_snx1
F56F: 04      		inc	b
              		
              		
              		; Set the records to 0
F570: 48      	ns_snx1:ld	c,b
F571: 0604    		ld	b,4
F573: AF      		xor	a
F574: 12      	ns_snx2:ld	(de),a
F575: 13      		inc	de
F576: 10FC    		djnz	ns_snx2
              		
              		; Spoof file size 1-16KB
F578: 0610    		ld	b,16
F57A: 79      		ld	a,c
F57B: 12      	ns_snx3:ld	(de),a
F57C: 13      		inc	de
F57D: B7      		or	a
F57E: 2801    		jr	z,ns_snx4
F580: 3D      		dec	a
F581: 10F8    	ns_snx4:djnz	ns_snx3
              		
              		; Set status to 0 and return
F583: 210000  		ld	hl,0
F586: 2250E3  		ld	(status),hl
F589: C37FED  		jp	goback
              		
              	; Delete files based on pattern
              	; Will return error if less than 1 file is found
              	; de = Address to FCB
              	;
              	; uses: all
F58C: CD65F7  	ns_dele:call	ns_ownr
              	
              		; Set first part of remove message prototype
F58F: F5      		push	af
F590: EB      		ex	de,hl
F591: 11AFF9  		ld	de,ns_m6na
F594: CD17F9  		call	ns_sdir
F597: 3E2F    		ld	a,'/'
F599: 12      		ld	(de),a
F59A: EB      		ex	de,hl
F59B: F1      		pop	af
              	
              		; Start the list-dir function
F59C: CD78F4  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F59F: CDC5F4  	ns_del0:call	ns_lis0
              	
              		; Copy over file name into message
F5A2: 11B2F9  		ld	de,ns_m6na+3
F5A5: 21E9FA  		ld	hl,ns_buff+22
F5A8: 011000  		ld	bc,16
F5AB: EDB0    		ldir
              		
              		; Send delete message
F5AD: 21A7F9  		ld	hl,ns_m6
F5B0: 061B    		ld	b,27
F5B2: CD43F8  		call	ns_send
F5B5: 21D3FA  		ld	hl,ns_buff
F5B8: CD28F8  		call	ns_rece
              		
              		; Set status to 0, and get next element
F5BB: 210000  		ld	hl,0
F5BE: 2250E3  		ld	(status),hl
F5C1: 18DC    		jr	ns_del0
              	
              		
              	; Prepare to access a file
              	; Checks the magic number to ensure that the file is in fact open
              	; Also checks ns_dore and ns_cfcb to see if a reopen is required
              	; If so, copy filename from FCB and do NHACP open
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, hl
F5C3: 4F      	ns_aces:ld	c,a
F5C4: 210D00  		ld	hl,13
F5C7: 19      		add	hl,de
F5C8: 7E      		ld	a,(hl)
F5C9: FEE7    		cp	0xE7
F5CB: 2809    		jr	z,ns_ace0
              		
              		; Return invalid FCB
F5CD: 210900  		ld	hl,9
F5D0: 2250E3  		ld	(status),hl
F5D3: C37FED  		jp	goback
              		
              		; Check to see if it is currently being accessed
F5D6: 2A1BFB  	ns_ace0:ld	hl,(ns_cfcb)
F5D9: ED52    		sbc	hl,de
F5DB: 2005    		jr	nz,ns_ace1
              		
              		; See if a reopen is needed
F5DD: 3A1DFB  		ld	a,(ns_dore)
F5E0: B7      		or	a
F5E1: C8      		ret	z
              		
              		; A reopen is needed, do it!
F5E2: 21FF00  	ns_ace1:ld	hl,0x00FF
F5E5: 2250E3  		ld	(status),hl
              		
              		; Set the current FCB to this one
F5E8: ED531BFB		ld	(ns_cfcb),de
              		
              		; Clear ns_dore flag
F5EC: AF      		xor	a
F5ED: 321DFB  		ld	(ns_dore),a
              		
              		; Copy over the true filename
F5F0: 211000  		ld	hl,16
F5F3: 19      		add	hl,de
F5F4: D5      		push	de
F5F5: 1167F9  		ld	de,ns_m0na
F5F8: 79      		ld	a,c
F5F9: CD17F9  		call	ns_sdir
F5FC: 3E2F    		ld	a,'/'
F5FE: 12      		ld	(de),a
F5FF: 13      		inc	de
F600: 011000  		ld	bc,16
F603: EDB0    		ldir
              		
              		; Now open the file
F605: CD97F7  		call	ns_open
F608: D1      		pop	de
F609: C9      		ret
              		
              	; Takes in a FCB, and returns the current record to access
              	; de = Address to FCB
              	;
              	; Returns record # in bc
              	; uses: af, bc, hl
F60A: 210C00  	ns_gcre:ld	hl,0x0C
F60D: 19      		add	hl,de
F60E: 46      		ld	b,(hl)
F60F: 0E00    		ld	c,0
F611: CB38    		srl	b
F613: CB19    		rr	c
F615: 23      		inc	hl
F616: 23      		inc	hl
F617: 7E      		ld	a,(hl)
F618: 07      		rlca
F619: 07      		rlca
F61A: 07      		rlca
F61B: 07      		rlca
F61C: B0      		or	b
F61D: 47      		ld	b,a
F61E: 212000  		ld	hl,0x20
F621: 19      		add	hl,de
F622: 7E      		ld	a,(hl)
F623: B1      		or	c
F624: 4F      		ld	c,a
F625: C9      		ret
              		
              	; Takes in a random record, and writes it to the FCB
              	; bc = Record #
              	; de = Address to FCB
              	;
              	; uses: af, bc, hl
F626: 212000  	ns_scre:ld	hl,0x20
F629: 19      		add	hl,de
F62A: 79      		ld	a,c
F62B: E67F    		and	0x7F
F62D: 77      		ld	(hl),a
F62E: 210E00  		ld	hl,0x0E
F631: 19      		add	hl,de
F632: 78      		ld	a,b
F633: 0F      		rrca
F634: 0F      		rrca
F635: 0F      		rrca
F636: 0F      		rrca
F637: E60F    		and	0x0F
F639: 77      		ld	(hl),a
F63A: 2B      		dec	hl
F63B: 2B      		dec	hl
F63C: CB21    		sla	c
F63E: CB10    		rl	b
F640: 78      		ld	a,b
F641: E60F    		and	0x0F
F643: 77      		ld	(hl),a
F644: C9      		ret
              			
              	; Read next record
              	; Reads the next 128 bytes in a file into the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F645: CD65F7  	ns_frea:call	ns_ownr
              	
              		; Set file up to access
F648: CDC3F5  		call	ns_aces
              		
              		; Get the record to read
F64B: CD0AF6  		call	ns_gcre
              		
              		; Set up and do read
F64E: C5      		push	bc
F64F: D5      		push	de
F650: 50      	ns_fre0:ld	d,b
F651: 59      		ld	e,c
F652: 2A49EF  		ld	hl,(biodma)
F655: CDB9F7  		call	ns_getb
              		
              		; Make sure there were no issues
F658: DA7FED  	ns_fre1:jp	c,goback
              		
              		; Increment and writeback
F65B: D1      		pop	de
F65C: C1      		pop	bc
F65D: 03      		inc	bc
F65E: CD26F6  		call	ns_scre
              		
              		; Set return status
F661: 210000  		ld	hl,0
F664: 3A1FFB  		ld	a,(ns_tran)
F667: B7      		or	a
F668: 2001    		jr	nz,ns_fre2
F66A: 23      		inc	hl
              		
F66B: 2250E3  	ns_fre2:ld	(status),hl
F66E: C37FED  		jp	goback
              		
              	; Write next record
              	; Writes the next 128 bytes into a file from the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F671: CD65F7  	ns_fwri:call	ns_ownr
              	
              		; Set file up to access
F674: CDC3F5  		call	ns_aces
              		
              		; Get the record to write
F677: CD0AF6  		call	ns_gcre
              		
              		; Set up and do write
F67A: C5      		push	bc
F67B: D5      		push	de
F67C: 50      	ns_fwr0:ld	d,b
F67D: 59      		ld	e,c
F67E: 2A49EF  		ld	hl,(biodma)
F681: CDFAF7  		call	ns_putb
              		
              		; Set amount transfered to 128
F684: 3E80    		ld	a,128
F686: 321FFB  		ld	(ns_tran),a
              		
              		; Continue in read
F689: 18CD    		jr	ns_fre1
              		
              	; Read record random
              	; Takes the random address and read a sector from it
F68B: CD65F7  	ns_rrea:call	ns_ownr
              	
              		; Set file up to access
F68E: CDC3F5  		call	ns_aces
              		
              		; Decode random address
F691: CDBCF6  		call	ns_deco
F694: 0B      		dec	bc
F695: C5      		push	bc
F696: D5      		push	de
F697: 03      		inc	bc
F698: 18B6    		jr	ns_fre0
              		
              	; Write record random
              	; Takes the random address and write a sector to it
              	; de = Address to FCB
              	;
              	; uses: all
F69A: CD65F7  	ns_rwri:call	ns_ownr
              	
              		; Set file up to access
F69D: CDC3F5  		call	ns_aces
              		
              		; Decode random address
F6A0: CDBCF6  		call	ns_deco
F6A3: 0B      		dec	bc
F6A4: C5      		push	bc
F6A5: D5      		push	de
F6A6: 03      		inc	bc
F6A7: 18D3    		jr	ns_fwr0
              		
              	; Set random record
              	; de = Address to FCB
              	;
              	; uses: all
F6A9: CD65F7  	ns_rrec:call	ns_ownr
              		
              		; Get current address from FCB
F6AC: CD0AF6  		call	ns_gcre
              		
              		; Set FCB random record
F6AF: 212100  		ld	hl,0x21
F6B2: 19      		add	hl,de
F6B3: 71      		ld	(hl),c
F6B4: 23      		inc	hl
F6B5: 70      		ld	(hl),b
F6B6: 23      		inc	hl
F6B7: 3600    		ld	(hl),0
              		
              		; Done
F6B9: C37FED  		jp	goback
              		
              	; Decodes random address
              	; de = Address to FCB
              	;
              	; Returns block number in bc
              	; uses: af, bc, hl
F6BC: 212100  	ns_deco:ld	hl,0x21
F6BF: 19      		add	hl,de
F6C0: 4E      		ld	c,(hl)
F6C1: 23      		inc	hl
F6C2: 46      		ld	b,(hl)
F6C3: C9      		ret
              		
              	; Make new file
              	; Reboot the system if the file already exists
              	; de = Address to FCB
              	;
              	; uses: all
F6C4: CD65F7  	ns_fmak:call	ns_ownr
              	
              		; We either succeed or die trying
F6C7: 210000  		ld	hl,0
F6CA: 2250E3  		ld	(status),hl
              	
              		; Decode filename into open buffer
F6CD: 2167F9  		ld	hl,ns_m0na
F6D0: D5      		push	de
F6D1: EB      		ex	de,hl
F6D2: 23      		inc	hl
F6D3: CDDFF8  		call	ns_form
              		
              		; Set the flag and open
F6D6: 213000  		ld	hl,0x0030
F6D9: 2264F9  		ld	(ns_m0fl),hl
F6DC: CD9AF7  		call	ns_opef
              		
              		; Error? time to reboot!
F6DF: C20000  		jp	nz,0
              		
              		; Nope? Activate FCB
F6E2: D1      		pop	de
              		
              		; Force reopen
F6E3: 3E01    		ld	a,1
F6E5: 321DFB  		ld	(ns_dore),a
              		
              		; Do an open
F6E8: C326F4  		jp	ns_fopn
              		
              	; Rename file
              	; Similar to delete, wildcards are allowed
              	; de = Address to FCB
              	;
              	; uses: all
F6EB: CD65F7  	ns_frnm:call	ns_ownr
              	
              		; Set first part of rename message prototype
F6EE: F5      		push	af
F6EF: EB      		ex	de,hl
F6F0: 11C8F9  		ld	de,ns_m7n0
F6F3: CD17F9  		call	ns_sdir
F6F6: 3E2F    		ld	a,'/'
F6F8: 12      		ld	(de),a
F6F9: F1      		pop	af
F6FA: F5      		push	af
F6FB: E5      		push	hl
F6FC: 111100  		ld	de,17
F6FF: 19      		add	hl,de
F700: 11DCF9  		ld	de,ns_m7n1
F703: CDDFF8  		call	ns_form
F706: D1      		pop	de
F707: F1      		pop	af
              		
              	
              		; Start the list-dir function
F708: CD78F4  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F70B: CDC5F4  	ns_frn0:call	ns_lis0
              	
              		; Copy over file name into message
F70E: 11CBF9  		ld	de,ns_m7n0+3
F711: 21E9FA  		ld	hl,ns_buff+22
F714: 011000  		ld	bc,16
F717: EDB0    		ldir
              		
              		; Send rename message
F719: 21C2F9  		ld	hl,ns_m7
F71C: 062D    		ld	b,45
F71E: CD43F8  		call	ns_send
F721: 21D3FA  		ld	hl,ns_buff
F724: CD28F8  		call	ns_rece
              		
              		; Set status to 0, and get next element
F727: 210000  		ld	hl,0
F72A: 2250E3  		ld	(status),hl
F72D: 18DC    		jr	ns_frn0
              		
              	; Place size of file into FCB
              	; de = Address to FCB
              	;
              	; uses: all
F72F: CD65F7  	ns_size:call	ns_ownr
              	
              		; Find file
F732: D5      		push	de
F733: CDBCF4  		call	ns_find
F736: D1      		pop	de
              		
              		; Get number of blocks
F737: CD47F7  		call	ns_nblk
              		
              		; Set in FCB
F73A: 212100  		ld	hl,0x21
F73D: 19      		add	hl,de
F73E: 71      		ld	(hl),c
F73F: 23      		inc	hl
F740: 70      		ld	(hl),b
F741: 23      		inc	hl
F742: 3600    		ld	(hl),0
              	
F744: C37FED  		jp	goback	
              		
              	; Use a FILE-INFO block in ns_buff to calculate
              	; the number of blocks in a file
              	;
              	; Returns number of blocks in bc
              	; uses: af, bc, hl
F747: 21E6FA  	ns_nblk:ld	hl,ns_buff+19
F74A: 46      		ld	b,(hl)
F74B: 2B      		dec	hl
F74C: 4E      		ld	c,(hl)
F74D: 2B      		dec	hl
F74E: 7E      		ld	a,(hl)
F74F: CB27    		sla	a
F751: CB11    		rl	c
F753: CB10    		rl	b
F755: B7      		or	a
F756: C8      		ret	z
F757: 03      		inc	bc
F758: C9      		ret
              		
              	; Set a 16 bit mask based on a number from 0-15
              	; a = Bit to set
              	;
              	; Returns bit mask in bc
              	; uses: af, bc
F759: 010100  	ns_domk:ld	bc,1
F75C: B7      		or	a
F75D: C8      	ns_dom0:ret	z
F75E: CB21    		sla	c
F760: CB10    		rl	b
F762: 3D      		dec	a
F763: 18F8    		jr	ns_dom0
              		
              	; Check if driver owns device
              	; Bail if it does not
              	; If it does, get the logical NHACP device
              	; de = Address of FCB
              	;
              	; Returns logical device in a
              	; uses: af, hl
F765: C5      	ns_ownr:push	bc
F766: CD90F7  		call	ns_getd		; Get FCB device
F769: CD59F7  		call	ns_domk		; Create bitmask
F76C: 2A19FB  		ld	hl,(ns_mask)
F76F: 7C      		ld	a,h
F770: A0      		and	b
F771: 2002    		jr	nz,ns_own0
F773: 7D      		ld	a,l
F774: A1      		and	c
F775: 2816    	ns_own0:jr	z,ns_exit	; Exit if does not own	
F777: 2179EF  		ld	hl,bdevsw+2
F77A: CD90F7  		call	ns_getd		; Get FCB device
F77D: 010400  		ld	bc,4
F780: B7      		or	a
F781: 2804    	ns_own1:jr	z,ns_own2
F783: 09      		add	hl,bc
F784: 3D      		dec	a
F785: 18FA    		jr	ns_own1
F787: CD7FF3  	ns_own2:call	ns_hini		; We are commited at this point, init HCCA
F78A: 7E      		ld	a,(hl)		; a = Logical NHACP device
F78B: C1      		pop	bc
F78C: C9      		ret
              	
              	; Exit, do not return to caller
F78D: C1      	ns_exit:pop	bc
F78E: F1      		pop	af		; Throw away caller address
F78F: C9      		ret
              	
              	; Gets the logical device number from a FCB
              	; de = Address of FCB
              	; 
              	; Logical device returns in a
              	; uses: af
F790: 1A      	ns_getd:ld	a,(de)
F791: 3D      		dec	a
F792: F0      		ret	p
F793: 3A4DE3  		ld	a,(active)
F796: C9      		ret
              	
              	; Open the prepared file
              	; Closes the existing file too
              	; ns_opef can be called to set custom flag
              	;
              	; Flag z cleared on error
              	; uses: af, b, hl
F797: 210200  	ns_open:ld	hl,0x0002	; Read/Write Protect flag
F79A: 2264F9  	ns_opef:ld	(ns_m0fl),hl
F79D: 217BF9  		ld	hl,ns_m1
F7A0: 0606    		ld	b,6
F7A2: CD43F8  		call	ns_send
F7A5: 215EF9  		ld	hl,ns_m0
F7A8: 061C    		ld	b,28
F7AA: CD43F8  		call	ns_send
F7AD: 21D3FA  		ld	hl,ns_buff
F7B0: CD28F8  		call	ns_rece
F7B3: 3AD3FA  		ld	a,(ns_buff)
F7B6: FE83    		cp	0x83
F7B8: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F7B9: CDBFF7  	ns_getb:call	ns_get0
F7BC: C395F3  		jp	ns_dflt
F7BF: EB      	ns_get0:ex	de,hl
F7C0: 2287F9  		ld	(ns_m2bn),hl
F7C3: EB      		ex	de,hl
F7C4: E5      		push	hl
F7C5: 2181F9  		ld	hl,ns_m2
F7C8: 060C    		ld	b,12
F7CA: CD43F8  		call	ns_send
F7CD: E1      		pop	hl
F7CE: D8      		ret	c
F7CF: CD4CF8  		call	ns_hcrd
F7D2: CD4FF8  		call	ns_hcre
F7D5: D8      		ret	c
F7D6: FE84    		cp	0x84
F7D8: 37      		scf
F7D9: 2017    		jr	nz,ns_get2
F7DB: CD4FF8  		call	ns_hcre
F7DE: 321FFB  		ld	(ns_tran),a
F7E1: 47      		ld	b,a
F7E2: CD4FF8  		call	ns_hcre
F7E5: 78      		ld	a,b
F7E6: B7      		or	a
F7E7: C8      		ret	z
F7E8: CD4FF8  	ns_get1:call	ns_hcre
F7EB: D8      		ret	c
F7EC: 77      		ld	(hl),a
F7ED: 23      		inc	hl
F7EE: 10F8    		djnz	ns_get1
F7F0: B7      		or	a
F7F1: C9      		ret
F7F2: CD4CF8  	ns_get2:call	ns_hcrd	; Read the error message and exit
F7F5: CD4FF8  		call	ns_hcre
F7F8: 37      		scf
F7F9: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F7FA: CD00F8  	ns_putb:call	ns_put0
F7FD: C395F3  		jp	ns_dflt
F800: EB      	ns_put0:ex	de,hl
F801: 2293F9  		ld	(ns_m3bn),hl
F804: EB      		ex	de,hl
F805: E5      		push	hl
F806: 218DF9  		ld	hl,ns_m3
F809: 060C    		ld	b,12
F80B: CD43F8  		call	ns_send		; Send message precursor
F80E: E1      		pop	hl
F80F: D8      		ret	c
F810: 0680    		ld	b,128
F812: 7E      	ns_put1:ld	a,(hl)		; Send the block
F813: CD95F8  		call	ns_hcwr
F816: D8      		ret	c
F817: 23      		inc	hl
F818: 10F8    		djnz	ns_put1
F81A: 21D3FA  		ld	hl,ns_buff
F81D: CD28F8  		call	ns_rece
F820: 3AD3FA  		ld	a,(ns_buff)
F823: FE81    		cp	0x81
F825: C8      		ret	z
F826: 37      		scf
F827: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F828: CD2EF8  	ns_rece:call	ns_rec0
F82B: C395F3  		jp	ns_dflt
F82E: CD4FF8  	ns_rec0:call	ns_hcre
F831: D8      		ret	c		; Existing error
F832: 47      		ld	b,a
F833: CD4FF8  		call	ns_hcre
F836: D8      		ret	c		; Existing error
F837: 37      		scf
F838: C0      		ret	nz		; Message too big!
F839: CD4FF8  	ns_rec1:call	ns_hcre
F83C: D8      		ret	c		; Error!
F83D: 77      		ld	(hl),a
F83E: 23      		inc	hl
F83F: 10F8    		djnz	ns_rec1
F841: B7      		or	a
F842: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F843: 7E      	ns_send:ld	a,(hl)
F844: 23      		inc	hl
F845: CD95F8  		call	ns_hcwr
F848: D8      		ret	c		; Error!
F849: 10F8    		djnz	ns_send
F84B: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns result in a
              	; Carry flag set on error
              	; Uses: af
F84C: CD4FF8  	ns_hcrd:call	ns_hcre
F84F: D5      	ns_hcre:push	de
F850: 3E09    		ld	a,0x09
F852: D300    		out	(ns_nctl),a	; Turn on recv light
F854: 11FFFF  		ld	de,0xFFFF
F857: 3A43F9  	ns_hcr0:ld	a,(ns_inf)
F85A: B7      		or	a
F85B: 201D    		jr	nz,ns_hcr2
F85D: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcr0	; Await an interrupt
              		;bit	1,a
              		;jr	z,ns_hcr1
F85F: E60F    		and	0x0F
F861: EE01    		xor	0b00000001
F863: 280C    		jr	z,ns_hcr1
F865: 1B      		dec	de
F866: 7B      		ld	a,e
F867: B2      		or	d
F868: 20ED    		jr	nz,ns_hcr0
F86A: 3E01    	ns_hcer:ld	a,0x01
F86C: D300    		out	(ns_nctl),a	; Turn off recv light
F86E: 37      		scf
F86F: D1      		pop	de
F870: C9      		ret			; Timed out waiting
F871: 3E01    	ns_hcr1:ld	a,0x01
F873: D300    		out	(ns_nctl),a	; Turn off recv light
F875: DB80    		in	a,(ns_hcca)
F877: D1      		pop	de
F878: B7      		or	a
F879: C9      		ret
F87A: 3E01    	ns_hcr2:ld	a,0x01
F87C: D300    		out	(ns_nctl),a	; Turn off recv light
F87E: AF      		xor	a
F87F: 3243F9  		ld	(ns_inf),a
F882: 3A42F9  		ld	a,(ns_inb)
F885: D1      		pop	de
F886: C9      		ret
              		
              	; HCCA read interrupt
              	; Reads from the HCCA, buffers it, and then sets the flag
              	;
              	; uses: none
F887: F5      	ns_rirq:push	af
F888: DB80    		in	a,(ns_hcca)
F88A: 3242F9  		ld	(ns_inb),a
F88D: 3E01    		ld	a,1
F88F: 3243F9  		ld	(ns_inf),a
F892: F1      		pop	af
F893: FB      		ei
F894: C9      		ret
              		
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F895: D5      	ns_hcwr:push	de
F896: 3240F9  		ld	(ns_outb),a
F899: AF      		xor	a
F89A: 3241F9  		ld	(ns_outf),a
F89D: CDA2F3  		call	ns_esnd
F8A0: 11FFFF  		ld	de,0xFFFF
F8A3: 3E21    		ld	a,0x21
F8A5: D300    		out	(ns_nctl),a	; Turn on send light
F8A7: 3A41F9  	ns_hcw0:ld	a,(ns_outf)
F8AA: B7      		or	a
F8AB: 2017    		jr	nz,ns_hcw2
F8AD: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcw0	; Await an interrupt
              		;bit	1,a
              		;jr	nz,ns_hcw1
F8AF: E60F    		and	0x0F
F8B1: EE03    		xor	0b00000011
F8B3: 280A    		jr	z,ns_hcw1
F8B5: 1B      		dec	de
F8B6: 7B      		ld	a,e
F8B7: B2      		or	d
F8B8: 20ED    		jr	nz,ns_hcw0
F8BA: CDACF3  		call	ns_dsnd
F8BD: 18AB    		jr	ns_hcer		; Timed out waiting
F8BF: 3A40F9  	ns_hcw1:ld	a,(ns_outb)
F8C2: D380    		out	(ns_hcca),a
F8C4: D1      	ns_hcw2:pop	de
F8C5: 3E01    		ld	a,0x01
F8C7: D300    		out	(ns_nctl),a	; Turn off send light
F8C9: CDACF3  		call	ns_dsnd
F8CC: B7      		or	a
F8CD: C9      		ret
              		
              	; HCCA write interrupt
              	; Writes to the HCCA from the buffer, and 
F8CE: F5      	ns_wirq:push	af
F8CF: 3A40F9  		ld	a,(ns_outb)
F8D2: D380    		out	(ns_hcca),a
F8D4: 3E01    		ld	a,1
F8D6: 3241F9  		ld	(ns_outf),a
F8D9: CDACF3  		call	ns_dsnd		; Y'all can't behave, turning off
F8DC: F1      		pop	af
F8DD: FB      		ei
F8DE: C9      		ret
              		
              		
              	; Takes a FCB-style name and formats it to standard notation
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	; hl = Source FCB file name
              	;
              	; uses: all
F8DF: CD17F9  	ns_form:call	ns_sdir
F8E2: 3E2F    		ld	a,'/'
F8E4: CD27F9  		call	ns_wchd
F8E7: 0608    		ld	b,8		; Look at all 8 possible name chars
F8E9: 7E      	ns_for1:ld	a,(hl)
F8EA: E67F    		and	0x7F
F8EC: CD35F9  		call	ns_utol
F8EF: FE21    		cp	0x21
F8F1: 3806    		jr	c,ns_for2
F8F3: CD27F9  		call	ns_wchd
F8F6: 23      		inc	hl
F8F7: 10F0    		djnz	ns_for1
F8F9: 3E2E    	ns_for2:ld	a,0x2E		; '.'
F8FB: CD27F9  		call	ns_wchd
F8FE: 48      		ld	c,b
F8FF: 0600    		ld	b,0
F901: 09      		add	hl,bc		; Fast forward to extenstion
F902: 0603    		ld	b,3		; Copy over extension
F904: 7E      	ns_for3:ld	a,(hl)
F905: E67F    		and	0x7F
F907: CD35F9  		call	ns_utol
F90A: FE21    		cp	0x21
F90C: 3806    		jr	c,ns_for4
F90E: CD27F9  		call	ns_wchd
F911: 23      		inc	hl
F912: 10F0    		djnz	ns_for3
F914: AF      	ns_for4:xor	a		; Zero terminate
F915: 12      		ld	(de),a
F916: C9      		ret
              		
              	; Part of ns_form, but sometimes is called independently
              	; Sets the directory to access files from
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	;
              	; uses: af, de
F917: C641    	ns_sdir:add	a,'A'
F919: CD27F9  		call	ns_wchd
F91C: 3A4CE3  		ld	a,(userno)
F91F: C630    		add	a,'0'
F921: FE3A    		cp	':'
F923: 3802    		jr	c,ns_wchd
F925: C607    		add	a,7
              		
              		; Fall to ns_wchd
              		
              	; Writes a byte to (de), then increments de
              	; a = Character to write
              	; de = Destination for character
              	;
              	; Returns de=de+1
              	; uses: af, de
F927: 12      	ns_wchd:ld	(de),a
F928: 13      		inc	de
F929: C9      		ret
              	
              	; Converts lowercase to uppercase
              	; a = Character to convert
              	;
              	; Returns uppercase in A
              	; uses: af
F92A: E67F    	ns_ltou:and	0x7F
F92C: FE61    		cp	0x61		; 'a'
F92E: D8      		ret	c
F92F: FE7B    		cp	0x7B		; '{'
F931: D0      		ret	nc
F932: D620    		sub	0x20
F934: C9      		ret
              		
              	; Converts uppercase to lowercase
              	; a = Character to convert
              	;
              	; Returns lowercase in A
              	; uses: af
F935: E67F    	ns_utol:and	0x7F
F937: FE41    		cp	0x41		; 'A'
F939: D8      		ret	c
F93A: FE5B    		cp	0x5B		; '['
F93C: D0      		ret	nc
F93D: C620    		add	0x20
F93F: C9      		ret
              		
              	; Byte to send out of HCCA
F940: 00      	ns_outb:defb	0
              	
              	; HCCA output flag
F941: 00      	ns_outf:defb	0
              	
              	; Byte received from HCCA
F942: 00      	ns_inb:	defb	0
              	
              	; HCCA input flag
F943: 00      	ns_inf: defb	0
              		
              	; Path to CP/M image
              	; Total length: 13 bytes
F944: 41302F43	ns_p0:	defb	'A0/CPM22.SYS',0
F948: 504D3232	
F94C: 2E535953	
F950: 00      	
              	
              	; Path to GRB image
              	; Total length: 13 bytes
F951: 41302F46	ns_p1:	defb	'A0/FONT.GRB',0,0
F955: 4F4E542E	
F959: 47524200	
F95D: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 28 bytes
F95E: 8F00    	ns_m0:	defb	0x8F,0x00
F960: 1800    		defw	24		; Message length
F962: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F963: 80      		defb	ns_fild		; Default file descriptor
F964: 0000    	ns_m0fl:defw	0x0000		; Read/Write flags
F966: 13      		defb	19		; File name length
F967: 58585858	ns_m0na:defs	19,'X'		; File name field
F96B: 58...   	
F97A: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F97B: 8F00    	ns_m1:	defb	0x8F,0x00
F97D: 0200    		defw	2		; Message length
F97F: 05      		defb	0x05		; Cmd: FILE-CLOSE
F980: 80      		defb	ns_fild		; Default file descriptor
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F981: 8F00    	ns_m2:	defb	0x8F,0x00
F983: 0800    		defw	8		; Message length
F985: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F986: 80      		defb	ns_fild		; Default file descritor
F987: 00000000	ns_m2bn:defw	0x00,0x00	; Block number
F98B: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F98D: 8F00    	ns_m3:	defb	0x8F,0x00
F98F: 8800    		defw	136		; Message length
F991: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F992: 80      		defb	ns_fild		; Default file descritor
F993: 00000000	ns_m3bn:defw	0x00,0x00	; Block number
F997: 8000    		defw	128		; Block length
              		
              	; Message prototype to start a list-dir
              	; Total length: 7 bytes
F999: 8F00    	ns_m4:	defb	0x8F,0x00
F99B: 0300    		defw	3		; Message length
F99D: 0E      		defb	0x0E		; Cmd: LIST-DIR
F99E: 80      		defb	ns_fild		; Default file descriptor
F99F: 00      		defb	0x00		; Null string
              		
              	; Message prototype to get the next dir entry
              	; Total length: 7 bytes
F9A0: 8F00    	ns_m5:	defb	0x8F,0x00
F9A2: 0300    		defw	3		; Message length
F9A4: 0F      		defb	0x0F		; Cmd: GET-DIR-ENTRY
F9A5: 80      		defb	ns_fild		; Default file descriptor
F9A6: 10      		defb	16		; Max length of file
              		
              	; Message prototype to remove a file
              	; Total length: 27 bytes
F9A7: 8F00    	ns_m6:	defb	0x8F,0x00
F9A9: 1700    		defw	23		; Message length
F9AB: 10      		defb	0x10		; Cmd: REMOVE
F9AC: 0000    		defw	0x0000		; Remove regular file
F9AE: 13      		defb	19		; File name length
F9AF: 58585858	ns_m6na:defs	19,'X'		; File name field
F9B3: 58...   	
              	
              	; Message prototype to rename a file
              	; Total length: 45 bytes
F9C2: 8F00    	ns_m7:	defb	0x8F,0x00
F9C4: 2900    		defw	41		; Message length
F9C6: 11      		defb	0x11		; Cmd: RENAME
F9C7: 13      		defb	19		; File name #1 length
F9C8: 58585858	ns_m7n0:defs	19,'X'		; File name #1 field
F9CC: 58...   	
F9DB: 13      		defb	19		; File name #2 length
F9DC: 58585858	ns_m7n1:defs	19,'X'		; File name #2 field
F9E0: 58...   	
              	#include "../dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F9EF: B7      	prtdev:	or	a
F9F0: 2808    		jr	z,pr_init
F9F2: 3D      		dec	a
F9F3: 2806    		jr	z,pr_stat
F9F5: 3D      		dec	a
F9F6: 2805    		jr	z,pr_read
F9F8: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F9FA: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F9FB: AF      	pr_stat:xor	a
F9FC: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F9FD: AF      	pr_read:xor	a
F9FE: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F9FF: 3E0F    	pr_writ:ld	a,0x0F
FA01: D341    		out	(pr_atla),a	; AY register = 15
              		
FA03: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
FA05: E610    		and	0x10
FA07: 20FA    		jr	nz,pr_wri0
              		
FA09: 79      		ld	a,c
FA0A: D3B0    		out	(pr_prnt),a	; Write data
              		
FA0C: 3E05    		ld	a,0x05		; Strobe
FA0E: D300    		out	(pr_ctrl),a
              		
FA10: 0620    		ld	b,32		
FA12: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
FA14: 3E01    		ld	a,0x01		; Strobe off
FA16: D300    		out	(pr_ctrl),a
              		
FA18: C9      		ret
              		
              	#include "../dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
FA19: B7      	siodev:	or	a
FA1A: 2808    		jr	z,so_init
FA1C: 3D      		dec	a
FA1D: 2833    		jr	z,so_stat
FA1F: 3D      		dec	a
FA20: 2841    		jr	z,so_read
FA22: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
FA24: 1189FA  	so_init:ld	de,so_atab
FA27: 45      		ld	b,l
FA28: 04      		inc	b		; Slot 1,2,3,...
FA29: 19      		add	hl,de 		; Get address table entry
FA2A: 0ECF    		ld	c,0xCF		; First slot
              		
FA2C: ED78    	so_ini0:in	a,(c)
FA2E: FE08    		cp	0x08
FA30: 2807    		jr	z,so_ini2
              		
FA32: 3E10    	so_ini1:ld	a,0x10
FA34: 81      		add	c
FA35: F0      		ret	p		; Can't find, failure
FA36: 4F      		ld	c,a
FA37: 18F3    		jr	so_ini0
              		
FA39: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
FA3B: 79      		ld	a,c
FA3C: D60F    		sub	0x0F
FA3E: 4F      		ld	c,a
FA3F: 71      		ld	(hl),c
FA40: 118DFA  		ld	de,so_conf
FA43: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
FA45: 1A      	so_ini3:ld	a,(de)
FA46: 13      		inc	de
FA47: 86      		add	a,(hl)
FA48: 4F      		ld	c,a
FA49: 1A      		ld	a,(de)
FA4A: 13      		inc	de
FA4B: ED79    		out	(c),a
FA4D: E5      		push	hl
FA4E: E1      		pop	hl	; Small delay
FA4F: 10F4    		djnz	so_ini3
FA51: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
FA52: 1189FA  	so_stat:ld	de,so_atab
FA55: 19      		add	hl,de
FA56: AF      		xor	a
FA57: BE      		cp	(hl)
FA58: C8      		ret	z	; No device, return 0
FA59: 4E      		ld	c,(hl)
FA5A: 0C      		inc	c
FA5B: ED78    	so_sta0:in	a,(c)	; Check status register
FA5D: E602    		and	0x02
FA5F: C8      		ret	z
FA60: 3EFF    		ld	a,0xFF
FA62: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
FA63: 1189FA  	so_read:ld	de,so_atab
FA66: 19      		add	hl,de
FA67: AF      		xor	a
FA68: BE      		cp	(hl)
FA69: C8      		ret	z	; No device, return 0
FA6A: 4E      		ld	c,(hl)
FA6B: 0C      		inc	c
FA6C: CD5BFA  	so_rea0:call	so_sta0	; Wait for a character
FA6F: 28FB    		jr	z,so_rea0
FA71: 0D      		dec	c
FA72: ED78    		in	a,(c)
FA74: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
FA75: 41      	so_writ:ld	b,c
FA76: 1189FA  		ld	de,so_atab
FA79: 19      		add	hl,de
FA7A: AF      		xor	a
FA7B: BE      		cp	(hl)
FA7C: C8      		ret	z	; No device, return 0
FA7D: 4E      		ld	c,(hl)
FA7E: 0C      		inc	c
FA7F: ED78    	so_wri0:in	a,(c)
FA81: E601    		and	0x01
FA83: 28FA    		jr	z,so_wri0
FA85: 0D      		dec	c
FA86: ED41    		out	(c),b
FA88: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
FA89: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
FA8D: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
FA8F: 0412    		defb	0x04,0x12
FA91: 0400    		defb	0x04,0x00
FA93: 0777    		defb	0x07,0x77	; Counter 2 setup
FA95: 0512    		defb	0x05,0x12
FA97: 0500    		defb	0x05,0x00
              		
FA99: 0100    		defb	0x01,0x00	; 8251 setup
FA9B: 0100    		defb	0x01,0x00
FA9D: 0100    		defb	0x01,0x00
FA9F: 0100    		defb	0x01,0x00
FAA1: 0140    		defb	0x01,0x40
FAA3: 014E    		defb	0x01,0x4E
FAA5: 0137    		defb	0x01,0x37


; +++ segments +++

#CODE _TEXT        = $D800 = 55296,  size = $22A7 =  8871
#DATA _BSS         = $FAA7 = 64167,  size = $0079 =   121
#DATA _JUMP_TABLE  = $FF00 = 65280,  size = $0090 =   144

; +++ global symbols +++

_BSS             = $FAA7 = 64167  _BSS        config_nfs.asm:44 (unused)
_BSS_end         = $FB20 = 64288  _BSS        config_nfs.asm:44 (unused)
_BSS_size        = $0079 =   121  _BSS        config_nfs.asm:44
_JUMP_TABLE      = $FF00 = 65280  _JUMP_TABLE config_nfs.asm:45 (unused)
_JUMP_TABLE_end  = $FF90 = 65424  _JUMP_TABLE config_nfs.asm:45 (unused)
_JUMP_TABLE_size = $0090 =   144  _JUMP_TABLE config_nfs.asm:45 (unused)
_TEXT            = $D800 = 55296  _TEXT       config_nfs.asm:43 (unused)
_TEXT_end        = $FAA7 = 64167  _TEXT       config_nfs.asm:43
_TEXT_size       = $22A7 =  8871  _TEXT       config_nfs.asm:43 (unused)
active           = $E34D = 58189  _TEXT       CPM22.asm:1726
adda2hl          = $E56F = 58735  _TEXT       CPM22.asm:2155
addhl            = $DA61 = 55905  _TEXT       CPM22.asm:442
alloc0           = $EDD5 = 60885  _TEXT       CPM22.asm:3703
alloc1           = $EDD7 = 60887  _TEXT       CPM22.asm:3704
alocvect         = $EDCA = 60874  _TEXT       CPM22.asm:3693
auto             = $EDE9 = 60905  _TEXT       CPM22.asm:3718
autoflag         = $EDEB = 60907  _TEXT       CPM22.asm:3720
autosel          = $EC5C = 60508  _TEXT       CPM22.asm:3433
autosl1          = $EC80 = 60544  _TEXT       CPM22.asm:3449
backup           = $E1AF = 57775  _TEXT       CPM22.asm:1486
backup1          = $E1B7 = 57783  _TEXT       CPM22.asm:1489
badload          = $DF77 = 57207  _TEXT       CPM22.asm:1206
badsctr          = $E00C = 57356  _TEXT       CPM22.asm:1267
badsec           = $E0D5 = 57557  _TEXT       CPM22.asm:1341
badsel           = $E0E0 = 57568  _TEXT       CPM22.asm:1342
badslct          = $E00E = 57358  _TEXT       CPM22.asm:1268
batch            = $DFB8 = 57272  _TEXT       CPM22.asm:1239
batchfcb         = $DFB9 = 57273  _TEXT       CPM22.asm:1240
bdevsw           = $EF77 = 61303  _TEXT       config_nfs.asm:164
bdosdrv          = $E0D1 = 57553  _TEXT       CPM22.asm:1340
bdoserr          = $E0C5 = 57541  _TEXT       CPM22.asm:1339
bigdisk          = $EDE8 = 60904  _TEXT       CPM22.asm:3717
biodma           = $EF49 = 61257  _TEXT       bios.asm:326
bitmap           = $E6AE = 59054  _TEXT       CPM22.asm:2448
bitmap1          = $E6BC = 59068  _TEXT       CPM22.asm:2463
bitmap2          = $E6DD = 59101  _TEXT       CPM22.asm:2484
bitmap3          = $E701 = 59137  _TEXT       CPM22.asm:2501
blkmask          = $EDCF = 60879  _TEXT       CPM22.asm:3699
blknmbr          = $EDF0 = 60912  _TEXT       CPM22.asm:3724
blkshft          = $EDCE = 60878  _TEXT       CPM22.asm:3698
boot             = $EE3A = 60986  _TEXT       bios.asm:42
bs               = $0008 =     8  _TEXT       CPM22.asm:31
callbd           = $EEF8 = 61176  _TEXT       bios.asm:225
callmj           = $EF46 = 61254  _TEXT       bios.asm:320
cbase            = $D800 = 55296  _TEXT       CPM22.asm:44
cbinit           = $EF65 = 61285  _TEXT       config_nfs.asm:95
ccpstack         = $DFB8 = 57272  _TEXT       CPM22.asm:1235
cdevsw           = $EFB7 = 61367  _TEXT       config_nfs.asm:203
cdindi0          = $EF1E = 61214  _TEXT       bios.asm:285
cdindi1          = $EF24 = 61220  _TEXT       bios.asm:289
cdindir          = $EF1A = 61210  _TEXT       bios.asm:283
cdrive           = $DFFC = 57340  _TEXT       CPM22.asm:1246
cfirq            = $EF6B = 61291  _TEXT       config_nfs.asm:111
charbuf          = $E319 = 58137  _TEXT       CPM22.asm:1715
check            = $DA38 = 55864  _TEXT       CPM22.asm:408
checkdir         = $E5A9 = 58793  _TEXT       CPM22.asm:2228
checksum         = $E502 = 58626  _TEXT       CPM22.asm:2067
chgdrv           = $DFFD = 57341  _TEXT       CPM22.asm:1247
chgnam1          = $E832 = 59442  _TEXT       CPM22.asm:2740
chgnames         = $E821 = 59425  _TEXT       CPM22.asm:2732
chkblk           = $E48F = 58511  _TEXT       CPM22.asm:1974
chkchar          = $E11F = 57631  _TEXT       CPM22.asm:1383
chkcon           = $D9CA = 55754  _TEXT       CPM22.asm:333
chkdir1          = $E5CF = 58831  _TEXT       CPM22.asm:2248
chknmbr          = $E597 = 58775  _TEXT       CPM22.asm:2201
chkrofl          = $E54F = 58703  _TEXT       CPM22.asm:2131
chksum1          = $E508 = 58632  _TEXT       CPM22.asm:2070
chkvect          = $EDC8 = 60872  _TEXT       CPM22.asm:3692
chkwprt          = $E55F = 58719  _TEXT       CPM22.asm:2142
chrout           = $EEBB = 61115  _TEXT       bios.asm:166
ckbitmap         = $E640 = 58944  _TEXT       CPM22.asm:2342
ckbmap1          = $E661 = 58977  _TEXT       CPM22.asm:2377
ckcon1           = $E14D = 57677  _TEXT       CPM22.asm:1413
ckcon2           = $E150 = 57680  _TEXT       CPM22.asm:1414
ckconsol         = $E12E = 57646  _TEXT       CPM22.asm:1399
ckfilpos         = $E600 = 58880  _TEXT       CPM22.asm:2291
ckrof1           = $E552 = 58706  _TEXT       CPM22.asm:2132
cksumtbl         = $EDF7 = 60919  _TEXT       CPM22.asm:3732
clearbuf         = $DB60 = 56160  _TEXT       CPM22.asm:608
clears2          = $E57D = 58749  _TEXT       CPM22.asm:2172
close            = $D8D9 = 55513  _TEXT       CPM22.asm:138
closefil         = $ECB0 = 60592  _TEXT       CPM22.asm:3480
closeflg         = $EDDD = 60893  _TEXT       CPM22.asm:3709
closeit          = $E8AD = 59565  _TEXT       CPM22.asm:2826
closeit1         = $E8D8 = 59608  _TEXT       CPM22.asm:2846
closeit2         = $E8E6 = 59622  _TEXT       CPM22.asm:2854
closeit3         = $E8EC = 59628  _TEXT       CPM22.asm:2858
closeit4         = $E8F3 = 59635  _TEXT       CPM22.asm:2861
closeit5         = $E908 = 59656  _TEXT       CPM22.asm:2874
closeit6         = $E922 = 59682  _TEXT       CPM22.asm:2892
closeit7         = $E92A = 59690  _TEXT       CPM22.asm:2895
cmdadr           = $DBCE = 56270  _TEXT       CPM22.asm:685
cmdtbl           = $DB18 = 56088  _TEXT       CPM22.asm:562
cmmnd1           = $DB87 = 56199  _TEXT       CPM22.asm:643
cmmnd2           = $DBA5 = 56229  _TEXT       CPM22.asm:657
cntrlc           = $0003 =     3  _TEXT       CPM22.asm:29
cntrle           = $0005 =     5  _TEXT       CPM22.asm:30
cntrlp           = $0010 =    16  _TEXT       CPM22.asm:36
cntrlr           = $0012 =    18  _TEXT       CPM22.asm:37
cntrls           = $0013 =    19  _TEXT       CPM22.asm:38
cntrlu           = $0015 =    21  _TEXT       CPM22.asm:39
cntrlx           = $0018 =    24  _TEXT       CPM22.asm:40
cntrlz           = $001A =    26  _TEXT       CPM22.asm:41
comblk           = $E482 = 58498  _TEXT       CPM22.asm:1965
comfile          = $DF80 = 57216  _TEXT       CPM22.asm:1207
command          = $DB64 = 56164  _TEXT       CPM22.asm:618
comprand         = $EBB0 = 60336  _TEXT       CPM22.asm:3299
conin            = $EEAD = 61101  _TEXT       bios.asm:153
conout           = $EEB9 = 61113  _TEXT       bios.asm:165
const            = $EEA2 = 61090  _TEXT       bios.asm:141
convert          = $DA68 = 55912  _TEXT       CPM22.asm:456
convfst          = $DA66 = 55910  _TEXT       CPM22.asm:450
convrt1          = $DA91 = 55953  _TEXT       CPM22.asm:479
convrt2          = $DA98 = 55960  _TEXT       CPM22.asm:482
convrt3          = $DA9E = 55966  _TEXT       CPM22.asm:489
convrt4          = $DAA0 = 55968  _TEXT       CPM22.asm:490
convrt5          = $DAB1 = 55985  _TEXT       CPM22.asm:497
convrt6          = $DAB3 = 55987  _TEXT       CPM22.asm:499
convrt7          = $DAB7 = 55991  _TEXT       CPM22.asm:501
convrt8          = $DAC1 = 56001  _TEXT       CPM22.asm:505
counter          = $EDE3 = 60899  _TEXT       CPM22.asm:3715
cpmlow           = $EE9A = 61082  _TEXT       bios.asm:130
cr               = $000D =    13  _TEXT       CPM22.asm:35
create           = $D908 = 55560  _TEXT       CPM22.asm:188
crlf             = $D898 = 55448  _TEXT       CPM22.asm:80
curpos           = $E317 = 58135  _TEXT       CPM22.asm:1713
de2hl            = $E35A = 58202  _TEXT       CPM22.asm:1744
de2hl1           = $E35B = 58203  _TEXT       CPM22.asm:1745
decode           = $DC05 = 56325  _TEXT       CPM22.asm:712
decode1          = $DC15 = 56341  _TEXT       CPM22.asm:718
decode2          = $DC37 = 56375  _TEXT       CPM22.asm:738 (unused)
decode3          = $DC40 = 56384  _TEXT       CPM22.asm:743
decode4          = $DC47 = 56391  _TEXT       CPM22.asm:747 (unused)
default          = $0000 =     0              config_nfs.asm:19
defdma           = $E5E5 = 58853  _TEXT       CPM22.asm:2266
del              = $007F =   127  _TEXT       CPM22.asm:42
delbatch         = $D9E5 = 55781  _TEXT       CPM22.asm:358
delete           = $D8EE = 55534  _TEXT       CPM22.asm:159
delfile          = $ECE2 = 60642  _TEXT       CPM22.asm:3511
dirbuf           = $EDC4 = 60868  _TEXT       CPM22.asm:3690
dirc1            = $E2EB = 58091  _TEXT       CPM22.asm:1671
dircbuf          = $FF10 = 65296  _JUMP_TABLE config_nfs.asm:47
dircio           = $E2DF = 58079  _TEXT       CPM22.asm:1665
dirdma           = $E5EB = 58859  _TEXT       CPM22.asm:2271
dirdma1          = $E5EE = 58862  _TEXT       CPM22.asm:2276
direct           = $DC84 = 56452  _TEXT       CPM22.asm:809
direct1          = $DC95 = 56469  _TEXT       CPM22.asm:816
direct2          = $DC9C = 56476  _TEXT       CPM22.asm:820
direct3          = $DCA5 = 56485  _TEXT       CPM22.asm:824
direct4          = $DCD9 = 56537  _TEXT       CPM22.asm:851
direct5          = $DCE1 = 56545  _TEXT       CPM22.asm:854
direct6          = $DCE6 = 56550  _TEXT       CPM22.asm:856
direct7          = $DD1B = 56603  _TEXT       CPM22.asm:880
direct8          = $DD1C = 56604  _TEXT       CPM22.asm:881
direct9          = $DD28 = 56616  _TEXT       CPM22.asm:885
dirread          = $E5DF = 58847  _TEXT       CPM22.asm:2261
dirsize          = $EDD3 = 60883  _TEXT       CPM22.asm:3702
dirwrite         = $E5D1 = 58833  _TEXT       CPM22.asm:2253
diskpb           = $EDC6 = 60870  _TEXT       CPM22.asm:3691
diskro           = $E0EC = 57580  _TEXT       CPM22.asm:1344
dmaset           = $D9E0 = 55776  _TEXT       CPM22.asm:353
doread           = $E3BD = 58301  _TEXT       CPM22.asm:1815
dowrite          = $E3C3 = 58307  _TEXT       CPM22.asm:1820
drect63          = $DD04 = 56580  _TEXT       CPM22.asm:870
drect65          = $DD06 = 56582  _TEXT       CPM22.asm:871
dselect          = $DC61 = 56417  _TEXT       CPM22.asm:779
dsksel           = $D8BC = 55484  _TEXT       CPM22.asm:112
dsksize          = $EDD1 = 60881  _TEXT       CPM22.asm:3701
emptyfcb         = $EDB7 = 60855  _TEXT       CPM22.asm:3677
entry            = $0005 =     5  _TEXT       CPM22.asm:22
entry1           = $D8C2 = 55490  _TEXT       CPM22.asm:119
entry2           = $D8F3 = 55539  _TEXT       CPM22.asm:165
eparam           = $EDE1 = 60897  _TEXT       CPM22.asm:3713
erafil1          = $E7AF = 59311  _TEXT       CPM22.asm:2618
erafile          = $E7A7 = 59303  _TEXT       CPM22.asm:2615
erase            = $DD2C = 56620  _TEXT       CPM22.asm:894
erase1           = $DD4F = 56655  _TEXT       CPM22.asm:909
error1           = $E09F = 57503  _TEXT       CPM22.asm:1320
error2           = $E0AB = 57515  _TEXT       CPM22.asm:1326
error3           = $E0B1 = 57521  _TEXT       CPM22.asm:1329
error4           = $E0B7 = 57527  _TEXT       CPM22.asm:1332
error5           = $E0BA = 57530  _TEXT       CPM22.asm:1334
exists           = $DE8D = 56973  _TEXT       CPM22.asm:1071
extblk           = $E469 = 58473  _TEXT       CPM22.asm:1946
extblk1          = $E47C = 58492  _TEXT       CPM22.asm:1956
extmask          = $EDD0 = 60880  _TEXT       CPM22.asm:3700
extract          = $DC58 = 56408  _TEXT       CPM22.asm:769
fbase            = $E006 = 57350  _TEXT       CPM22.asm:1262
fbase1           = $E014 = 57364  _TEXT       CPM22.asm:1275
fcb              = $DFDA = 57306  _TEXT       CPM22.asm:1244
fcb2hl           = $E569 = 58729  _TEXT       CPM22.asm:2150
fcbpos           = $EDF4 = 60916  _TEXT       CPM22.asm:3726
fcbset           = $E808 = 59400  _TEXT       CPM22.asm:2710
fcreate          = $ECF7 = 60663  _TEXT       CPM22.asm:3528
ff               = $000C =    12  _TEXT       CPM22.asm:34 (unused)
filepos          = $EDF5 = 60917  _TEXT       CPM22.asm:3727
filero           = $E0E7 = 57575  _TEXT       CPM22.asm:1343
filesize         = $ED58 = 60760  _TEXT       CPM22.asm:3602
findfst          = $E723 = 59171  _TEXT       CPM22.asm:2535
findnxt          = $E738 = 59192  _TEXT       CPM22.asm:2548
fndnxt1          = $E755 = 59221  _TEXT       CPM22.asm:2561
fndnxt2          = $E75E = 59230  _TEXT       CPM22.asm:2565
fndnxt3          = $E77E = 59262  _TEXT       CPM22.asm:2581
fndnxt4          = $E787 = 59271  _TEXT       CPM22.asm:2590
fndnxt5          = $E78E = 59278  _TEXT       CPM22.asm:2595
fndnxt6          = $E79F = 59295  _TEXT       CPM22.asm:2608
fndspa1          = $E7CB = 59339  _TEXT       CPM22.asm:2648
fndspa2          = $E7DC = 59356  _TEXT       CPM22.asm:2671
fndspa3          = $E7F7 = 59383  _TEXT       CPM22.asm:2692
fndspa4          = $E7FF = 59391  _TEXT       CPM22.asm:2702
fndspace         = $E7C9 = 59337  _TEXT       CPM22.asm:2642
fndstat          = $EDDF = 60895  _TEXT       CPM22.asm:3711
functns          = $E04D = 57421  _TEXT       CPM22.asm:1311
getaloc          = $ED1C = 60700  _TEXT       CPM22.asm:3556
getback          = $DF83 = 57219  _TEXT       CPM22.asm:1213
getback1         = $DF86 = 57222  _TEXT       CPM22.asm:1214
getblk1          = $E450 = 58448  _TEXT       CPM22.asm:1924
getblk2          = $E45E = 58462  _TEXT       CPM22.asm:1933
getblk3          = $E467 = 58471  _TEXT       CPM22.asm:1938
getblock         = $E449 = 58441  _TEXT       CPM22.asm:1921
getchar          = $E106 = 57606  _TEXT       CPM22.asm:1361
getcon           = $E2D3 = 58067  _TEXT       CPM22.asm:1653
getcrnt          = $ED0F = 60687  _TEXT       CPM22.asm:3545
getcsts          = $E309 = 58121  _TEXT       CPM22.asm:1698
getdsk           = $D9D8 = 55768  _TEXT       CPM22.asm:344
getecho          = $E111 = 57617  _TEXT       CPM22.asm:1370
getempty         = $E92F = 59695  _TEXT       CPM22.asm:2902
getext           = $DAC8 = 56008  _TEXT       CPM22.asm:512
getext1          = $DAD0 = 56016  _TEXT       CPM22.asm:516
getext2          = $DAE1 = 56033  _TEXT       CPM22.asm:523
getext3          = $DAE3 = 56035  _TEXT       CPM22.asm:525
getext4          = $DAE7 = 56039  _TEXT       CPM22.asm:527
getext5          = $DAF1 = 56049  _TEXT       CPM22.asm:531
getext6          = $DAF8 = 56056  _TEXT       CPM22.asm:535
getext7          = $DAFA = 56058  _TEXT       CPM22.asm:536
getext8          = $DB09 = 56073  _TEXT       CPM22.asm:548
getext9          = $DB11 = 56081  _TEXT       CPM22.asm:553
getfst           = $ECB6 = 60598  _TEXT       CPM22.asm:3487
getfst1          = $ECCD = 60621  _TEXT       CPM22.asm:3498
getinp           = $D938 = 55608  _TEXT       CPM22.asm:239
getinp0          = $D954 = 55636  _TEXT       CPM22.asm:255
getinp1          = $D9A0 = 55712  _TEXT       CPM22.asm:305
getinp2          = $D9B1 = 55729  _TEXT       CPM22.asm:314
getinp3          = $D9B5 = 55733  _TEXT       CPM22.asm:316
getinp4          = $D9C2 = 55746  _TEXT       CPM22.asm:325
getiob           = $E2F8 = 58104  _TEXT       CPM22.asm:1679
getlog           = $ED09 = 60681  _TEXT       CPM22.asm:3540
getmt1           = $E951 = 59729  _TEXT       CPM22.asm:2918
getnext          = $E965 = 59749  _TEXT       CPM22.asm:2932
getnxt           = $ECD3 = 60627  _TEXT       CPM22.asm:3503
getparm          = $ED31 = 60721  _TEXT       CPM22.asm:3573
getprm1          = $ED34 = 60724  _TEXT       CPM22.asm:3574
getrdr           = $E2D9 = 58073  _TEXT       CPM22.asm:1658
getrov           = $ED22 = 60706  _TEXT       CPM22.asm:3561
gets2            = $E574 = 58740  _TEXT       CPM22.asm:2164
getsetuc         = $D914 = 55572  _TEXT       CPM22.asm:204
getuser          = $ED38 = 60728  _TEXT       CPM22.asm:3581
getusr           = $D912 = 55570  _TEXT       CPM22.asm:199
getver           = $EC89 = 60553  _TEXT       CPM22.asm:3457
getwprt          = $E529 = 58665  _TEXT       CPM22.asm:2104
goback           = $ED7F = 60799  _TEXT       CPM22.asm:3637
goback1          = $ED9C = 60828  _TEXT       CPM22.asm:3649
gtnext1          = $E98E = 59790  _TEXT       CPM22.asm:2952
gtnext2          = $E999 = 59801  _TEXT       CPM22.asm:2961
gtnext3          = $E9B7 = 59831  _TEXT       CPM22.asm:2972
gtnext4          = $E9BA = 59834  _TEXT       CPM22.asm:2973
gtnext5          = $E9C1 = 59841  _TEXT       CPM22.asm:2980
halt             = $DBDC = 56284  _TEXT       CPM22.asm:690
hl2de            = $DC4F = 56399  _TEXT       CPM22.asm:759
home             = $EEDB = 61147  _TEXT       bios.asm:199
homedrv          = $E3AC = 58284  _TEXT       CPM22.asm:1801
inbuff           = $D806 = 55302  _TEXT       CPM22.asm:51
inpoint          = $D888 = 55432  _TEXT       CPM22.asm:60
intvec           = $FF00 = 65280  _JUMP_TABLE config_nfs.asm:46
iobyte           = $0003 =     3  _TEXT       CPM22.asm:20
ioerr1           = $E310 = 58128  _TEXT       CPM22.asm:1708
ioret            = $E3C6 = 58310  _TEXT       CPM22.asm:1821
jumphl           = $E355 = 58197  _TEXT       CPM22.asm:1736
lf               = $000A =    10  _TEXT       CPM22.asm:33
list             = $EEC5 = 61125  _TEXT       bios.asm:176
logical          = $E495 = 58517  _TEXT       CPM22.asm:1985
logicl1          = $E49B = 58523  _TEXT       CPM22.asm:1987
login            = $EDBA = 60858  _TEXT       CPM22.asm:3679
logindrv         = $EC2C = 60460  _TEXT       CPM22.asm:3401
logoff           = $ED5E = 60766  _TEXT       CPM22.asm:3611
logsect          = $EDF2 = 60914  _TEXT       CPM22.asm:3725
mem              = $0036 =    54              config_nfs.asm:38
mode             = $EDE0 = 60896  _TEXT       CPM22.asm:3712
morefls          = $E58A = 58762  _TEXT       CPM22.asm:2188
move3            = $DC4D = 56397  _TEXT       CPM22.asm:755
movecd           = $D928 = 55592  _TEXT       CPM22.asm:221
movedir          = $E5F4 = 58868  _TEXT       CPM22.asm:2283
moveword         = $E89F = 59551  _TEXT       CPM22.asm:2809
namepnt          = $D88A = 55434  _TEXT       CPM22.asm:61
nbytes           = $DFFE = 57342  _TEXT       CPM22.asm:1248
newline          = $E1BC = 57788  _TEXT       CPM22.asm:1495
newln1           = $E1C4 = 57796  _TEXT       CPM22.asm:1498
nfsdev           = $F356 = 62294  _TEXT       nabu_nfs.asm:73
nfuncts          = $0029 =    41  _TEXT       CPM22.asm:1309
nofile           = $DBFD = 56317  _TEXT       CPM22.asm:705
nonblank         = $DA57 = 55895  _TEXT       CPM22.asm:432
none             = $DBF7 = 56311  _TEXT       CPM22.asm:703
nospace          = $DE14 = 56852  _TEXT       CPM22.asm:1013
ns_ace0          = $F5D6 = 62934  _TEXT       nabu_nfs.asm:592
ns_ace1          = $F5E2 = 62946  _TEXT       nabu_nfs.asm:602
ns_aces          = $F5C3 = 62915  _TEXT       nabu_nfs.asm:579
ns_alv           = $F355 = 62293  _TEXT       nabu_nfs.asm:67
ns_atla          = $0041 =    65  _TEXT       nabu_nfs.asm:31
ns_ayda          = $0040 =    64  _TEXT       nabu_nfs.asm:30
ns_buff          = $FAD3 = 64211  _BSS        nabu_nfs.asm:20
ns_ccp           = $F3B6 = 62390  _TEXT       nabu_nfs.asm:163
ns_cfcb          = $FB1B = 64283  _BSS        nabu_nfs.asm:24
ns_deco          = $F6BC = 63164  _TEXT       nabu_nfs.asm:814
ns_del0          = $F59F = 62879  _TEXT       nabu_nfs.asm:550
ns_dele          = $F58C = 62860  _TEXT       nabu_nfs.asm:534
ns_dfl0          = $F39D = 62365  _TEXT       nabu_nfs.asm:139
ns_dflt          = $F395 = 62357  _TEXT       nabu_nfs.asm:134
ns_dom0          = $F75D = 63325  _TEXT       nabu_nfs.asm:957
ns_domk          = $F759 = 63321  _TEXT       nabu_nfs.asm:955
ns_dore          = $FB1D = 64285  _BSS        nabu_nfs.asm:25
ns_dpb           = $F346 = 62278  _TEXT       nabu_nfs.asm:55
ns_dph           = $F336 = 62262  _TEXT       nabu_nfs.asm:47
ns_dsnd          = $F3AC = 62380  _TEXT       nabu_nfs.asm:156
ns_esnd          = $F3A2 = 62370  _TEXT       nabu_nfs.asm:147
ns_exit          = $F78D = 63373  _TEXT       nabu_nfs.asm:994
ns_fcls          = $F466 = 62566  _TEXT       nabu_nfs.asm:293
ns_ffm0          = $F533 = 62771  _TEXT       nabu_nfs.asm:455
ns_ffm1          = $F536 = 62774  _TEXT       nabu_nfs.asm:457
ns_ffmt          = $F528 = 62760  _TEXT       nabu_nfs.asm:449
ns_fild          = $0080 =   128  _TEXT       nabu_nfs.asm:35
ns_find          = $F4BC = 62652  _TEXT       nabu_nfs.asm:355
ns_fmak          = $F6C4 = 63172  _TEXT       nabu_nfs.asm:826
ns_fop0          = $F463 = 62563  _TEXT       nabu_nfs.asm:285
ns_fopn          = $F426 = 62502  _TEXT       nabu_nfs.asm:236
ns_for1          = $F8E9 = 63721  _TEXT       nabu_nfs.asm:1264
ns_for2          = $F8F9 = 63737  _TEXT       nabu_nfs.asm:1272
ns_for3          = $F904 = 63748  _TEXT       nabu_nfs.asm:1278
ns_for4          = $F914 = 63764  _TEXT       nabu_nfs.asm:1286
ns_form          = $F8DF = 63711  _TEXT       nabu_nfs.asm:1260
ns_fre0          = $F650 = 63056  _TEXT       nabu_nfs.asm:702
ns_fre1          = $F658 = 63064  _TEXT       nabu_nfs.asm:708
ns_fre2          = $F66B = 63083  _TEXT       nabu_nfs.asm:723
ns_frea          = $F645 = 63045  _TEXT       nabu_nfs.asm:691
ns_frn0          = $F70B = 63243  _TEXT       nabu_nfs.asm:886
ns_frnm          = $F6EB = 63211  _TEXT       nabu_nfs.asm:862
ns_fwr0          = $F67C = 63100  _TEXT       nabu_nfs.asm:743
ns_fwri          = $F671 = 63089  _TEXT       nabu_nfs.asm:732
ns_gcre          = $F60A = 62986  _TEXT       nabu_nfs.asm:635
ns_get0          = $F7BF = 63423  _TEXT       nabu_nfs.asm:1039
ns_get1          = $F7E8 = 63464  _TEXT       nabu_nfs.asm:1061
ns_get2          = $F7F2 = 63474  _TEXT       nabu_nfs.asm:1068
ns_getb          = $F7B9 = 63417  _TEXT       nabu_nfs.asm:1037
ns_getd          = $F790 = 63376  _TEXT       nabu_nfs.asm:1003
ns_grb           = $F3BB = 62395  _TEXT       nabu_nfs.asm:167
ns_grb0          = $F3BE = 62398  _TEXT       nabu_nfs.asm:168
ns_grb1          = $F3D5 = 62421  _TEXT       nabu_nfs.asm:176
ns_hcca          = $0080 =   128  _TEXT       nabu_nfs.asm:32
ns_hcer          = $F86A = 63594  _TEXT       nabu_nfs.asm:1167
ns_hcr0          = $F857 = 63575  _TEXT       nabu_nfs.asm:1152
ns_hcr1          = $F871 = 63601  _TEXT       nabu_nfs.asm:1172
ns_hcr2          = $F87A = 63610  _TEXT       nabu_nfs.asm:1178
ns_hcrd          = $F84C = 63564  _TEXT       nabu_nfs.asm:1147
ns_hcre          = $F84F = 63567  _TEXT       nabu_nfs.asm:1148
ns_hcw0          = $F8A7 = 63655  _TEXT       nabu_nfs.asm:1215
ns_hcw1          = $F8BF = 63679  _TEXT       nabu_nfs.asm:1232
ns_hcw2          = $F8C4 = 63684  _TEXT       nabu_nfs.asm:1234
ns_hcwr          = $F895 = 63637  _TEXT       nabu_nfs.asm:1207
ns_hini          = $F37F = 62335  _TEXT       nabu_nfs.asm:118
ns_inb           = $F942 = 63810  _TEXT       nabu_nfs.asm:1349
ns_inf           = $F943 = 63811  _TEXT       nabu_nfs.asm:1352
ns_init          = $F360 = 62304  _TEXT       nabu_nfs.asm:87
ns_isls          = $FB1E = 64286  _BSS        nabu_nfs.asm:26
ns_lis0          = $F4C5 = 62661  _TEXT       nabu_nfs.asm:369
ns_lis1          = $F4F3 = 62707  _TEXT       nabu_nfs.asm:395
ns_lis2          = $F4FC = 62716  _TEXT       nabu_nfs.asm:403
ns_lis3          = $F509 = 62729  _TEXT       nabu_nfs.asm:411
ns_lis4          = $F514 = 62740  _TEXT       nabu_nfs.asm:419
ns_list          = $F4BF = 62655  _TEXT       nabu_nfs.asm:365
ns_ltou          = $F92A = 63786  _TEXT       nabu_nfs.asm:1321
ns_m0            = $F95E = 63838  _TEXT       nabu_nfs.asm:1364
ns_m0fl          = $F964 = 63844  _TEXT       nabu_nfs.asm:1368
ns_m0na          = $F967 = 63847  _TEXT       nabu_nfs.asm:1370
ns_m1            = $F97B = 63867  _TEXT       nabu_nfs.asm:1375
ns_m2            = $F981 = 63873  _TEXT       nabu_nfs.asm:1382
ns_m2bn          = $F987 = 63879  _TEXT       nabu_nfs.asm:1386
ns_m3            = $F98D = 63885  _TEXT       nabu_nfs.asm:1391
ns_m3bn          = $F993 = 63891  _TEXT       nabu_nfs.asm:1395
ns_m4            = $F999 = 63897  _TEXT       nabu_nfs.asm:1400
ns_m5            = $F9A0 = 63904  _TEXT       nabu_nfs.asm:1408
ns_m6            = $F9A7 = 63911  _TEXT       nabu_nfs.asm:1416
ns_m6na          = $F9AF = 63919  _TEXT       nabu_nfs.asm:1421
ns_m7            = $F9C2 = 63938  _TEXT       nabu_nfs.asm:1425
ns_m7n0          = $F9C8 = 63944  _TEXT       nabu_nfs.asm:1429
ns_m7n1          = $F9DC = 63964  _TEXT       nabu_nfs.asm:1431
ns_mask          = $FB19 = 64281  _BSS        nabu_nfs.asm:23
ns_name          = $FB0E = 64270  _BSS        nabu_nfs.asm:22
ns_nblk          = $F747 = 63303  _TEXT       nabu_nfs.asm:936
ns_nctl          = $0000 =     0  _TEXT       nabu_nfs.asm:33
ns_opef          = $F79A = 63386  _TEXT       nabu_nfs.asm:1016
ns_open          = $F797 = 63383  _TEXT       nabu_nfs.asm:1015
ns_outb          = $F940 = 63808  _TEXT       nabu_nfs.asm:1343
ns_outf          = $F941 = 63809  _TEXT       nabu_nfs.asm:1346
ns_own0          = $F775 = 63349  _TEXT       nabu_nfs.asm:979
ns_own1          = $F781 = 63361  _TEXT       nabu_nfs.asm:984
ns_own2          = $F787 = 63367  _TEXT       nabu_nfs.asm:988
ns_ownr          = $F765 = 63333  _TEXT       nabu_nfs.asm:970
ns_p0            = $F944 = 63812  _TEXT       nabu_nfs.asm:1356
ns_p1            = $F951 = 63825  _TEXT       nabu_nfs.asm:1360
ns_ptrn          = $FB03 = 64259  _BSS        nabu_nfs.asm:21
ns_put0          = $F800 = 63488  _TEXT       nabu_nfs.asm:1082
ns_put1          = $F812 = 63506  _TEXT       nabu_nfs.asm:1092
ns_putb          = $F7FA = 63482  _TEXT       nabu_nfs.asm:1080
ns_rec0          = $F82E = 63534  _TEXT       nabu_nfs.asm:1112
ns_rec1          = $F839 = 63545  _TEXT       nabu_nfs.asm:1119
ns_rece          = $F828 = 63528  _TEXT       nabu_nfs.asm:1110
ns_rirq          = $F887 = 63623  _TEXT       nabu_nfs.asm:1190
ns_rrea          = $F68B = 63115  _TEXT       nabu_nfs.asm:757
ns_rrec          = $F6A9 = 63145  _TEXT       nabu_nfs.asm:792
ns_rwri          = $F69A = 63130  _TEXT       nabu_nfs.asm:775
ns_scre          = $F626 = 63014  _TEXT       nabu_nfs.asm:662
ns_sdir          = $F917 = 63767  _TEXT       nabu_nfs.asm:1296
ns_sel           = $F371 = 62321  _TEXT       nabu_nfs.asm:105
ns_send          = $F843 = 63555  _TEXT       nabu_nfs.asm:1133
ns_sfir          = $F517 = 62743  _TEXT       nabu_nfs.asm:427
ns_size          = $F72F = 63279  _TEXT       nabu_nfs.asm:910
ns_sls0          = $F4B3 = 62643  _TEXT       nabu_nfs.asm:341
ns_slst          = $F478 = 62584  _TEXT       nabu_nfs.asm:312
ns_snx0          = $F544 = 62788  _TEXT       nabu_nfs.asm:475
ns_snx1          = $F570 = 62832  _TEXT       nabu_nfs.asm:507
ns_snx2          = $F574 = 62836  _TEXT       nabu_nfs.asm:510
ns_snx3          = $F57B = 62843  _TEXT       nabu_nfs.asm:517
ns_snx4          = $F581 = 62849  _TEXT       nabu_nfs.asm:522
ns_snxt          = $F53C = 62780  _TEXT       nabu_nfs.asm:467
ns_stmp          = $F420 = 62496  _TEXT       nabu_nfs.asm:225
ns_sysh          = $F3DF = 62431  _TEXT       nabu_nfs.asm:187
ns_tran          = $FB1F = 64287  _BSS        nabu_nfs.asm:27
ns_utol          = $F935 = 63797  _TEXT       nabu_nfs.asm:1334
ns_wchd          = $F927 = 63783  _TEXT       nabu_nfs.asm:1312
ns_wirq          = $F8CE = 63694  _TEXT       nabu_nfs.asm:1243
nulldev          = $EF45 = 61253  _TEXT       bios.asm:317 (unused)
numcmds          = $0006 =     6  _TEXT       CPM22.asm:561
nxent1           = $E624 = 58916  _TEXT       CPM22.asm:2321
nxent2           = $E62B = 58923  _TEXT       CPM22.asm:2324
nxentry          = $E610 = 58896  _TEXT       CPM22.asm:2313
offset           = $EDD9 = 60889  _TEXT       CPM22.asm:3705
olddrv           = $EDEA = 60906  _TEXT       CPM22.asm:3719
open             = $D8CA = 55498  _TEXT       CPM22.asm:126
openfcb          = $D8CF = 55503  _TEXT       CPM22.asm:131
openfil          = $ECA7 = 60583  _TEXT       CPM22.asm:3474
openit           = $E85C = 59484  _TEXT       CPM22.asm:2766
openit1          = $E865 = 59493  _TEXT       CPM22.asm:2770
openit2          = $E896 = 59542  _TEXT       CPM22.asm:2798
outchar          = $E153 = 57683  _TEXT       CPM22.asm:1421
outchr1          = $E16D = 57709  _TEXT       CPM22.asm:1435
outchr2          = $E184 = 57732  _TEXT       CPM22.asm:1451
outcon           = $E19B = 57755  _TEXT       CPM22.asm:1472
outcon1          = $E1A1 = 57761  _TEXT       CPM22.asm:1475
outcrlf          = $E1D4 = 57812  _TEXT       CPM22.asm:1508
outflag          = $E315 = 58133  _TEXT       CPM22.asm:1711
params           = $E34E = 58190  _TEXT       CPM22.asm:1727
pattrn1          = $DB30 = 56112  _TEXT       CPM22.asm:572
pattrn2          = $E000 = 57344  _TEXT       CPM22.asm:1254
pline            = $D8A6 = 55462  _TEXT       CPM22.asm:93
pline2           = $D8AB = 55467  _TEXT       CPM22.asm:96
position         = $EB0E = 60174  _TEXT       CPM22.asm:3176
positn1          = $EB12 = 60178  _TEXT       CPM22.asm:3181
positn2          = $EB52 = 60242  _TEXT       CPM22.asm:3227
positn3          = $EB8A = 60298  _TEXT       CPM22.asm:3259
positn4          = $EB8F = 60303  _TEXT       CPM22.asm:3265
positn5          = $EB96 = 60310  _TEXT       CPM22.asm:3272
pr_atla          = $0041 =    65  _TEXT       nabu_prt.asm:14
pr_ayda          = $0040 =    64  _TEXT       nabu_prt.asm:13
pr_ctrl          = $0000 =     0  _TEXT       nabu_prt.asm:16
pr_init          = $F9FA = 63994  _TEXT       nabu_prt.asm:31
pr_prnt          = $00B0 =   176  _TEXT       nabu_prt.asm:15
pr_read          = $F9FD = 63997  _TEXT       nabu_prt.asm:46
pr_stat          = $F9FB = 63995  _TEXT       nabu_prt.asm:38
pr_wri0          = $FA03 = 64003  _TEXT       nabu_prt.asm:56
pr_wri1          = $FA12 = 64018  _TEXT       nabu_prt.asm:67
pr_writ          = $F9FF = 63999  _TEXT       nabu_prt.asm:53
print            = $D88C = 55436  _TEXT       CPM22.asm:66
printb           = $D892 = 55442  _TEXT       CPM22.asm:72
printdc          = $DF98 = 57240  _TEXT       CPM22.asm:1223
prstat           = $EF14 = 61204  _TEXT       bios.asm:271
prtdev           = $F9EF = 63983  _TEXT       nabu_prt.asm:19
prterr           = $E0F0 = 57584  _TEXT       CPM22.asm:1348
prtflag          = $E318 = 58136  _TEXT       CPM22.asm:1714
prtmesg          = $E1DE = 57822  _TEXT       CPM22.asm:1515
prtstr           = $E303 = 58115  _TEXT       CPM22.asm:1691
punch            = $EEC9 = 61129  _TEXT       bios.asm:182
putdma           = $ED15 = 60693  _TEXT       CPM22.asm:3550
ransiz1          = $EBEF = 60399  _TEXT       CPM22.asm:3355
ransiz2          = $EC11 = 60433  _TEXT       CPM22.asm:3377
ransiz3          = $EC17 = 60439  _TEXT       CPM22.asm:3379
ransize          = $EBDD = 60381  _TEXT       CPM22.asm:3344
rdbuf1           = $E1FA = 57850  _TEXT       CPM22.asm:1534
rdbuf10          = $E27B = 57979  _TEXT       CPM22.asm:1596
rdbuf11          = $E283 = 57987  _TEXT       CPM22.asm:1602
rdbuf12          = $E295 = 58005  _TEXT       CPM22.asm:1614
rdbuf13          = $E2A4 = 58020  _TEXT       CPM22.asm:1621
rdbuf14          = $E2B1 = 58033  _TEXT       CPM22.asm:1629
rdbuf15          = $E2B4 = 58036  _TEXT       CPM22.asm:1632
rdbuf16          = $E2C8 = 58056  _TEXT       CPM22.asm:1644
rdbuf17          = $E2CC = 58060  _TEXT       CPM22.asm:1646
rdbuf2           = $E1FC = 57852  _TEXT       CPM22.asm:1536
rdbuf3           = $E221 = 57889  _TEXT       CPM22.asm:1553
rdbuf4           = $E231 = 57905  _TEXT       CPM22.asm:1562
rdbuf5           = $E242 = 57922  _TEXT       CPM22.asm:1570
rdbuf6           = $E253 = 57939  _TEXT       CPM22.asm:1579
rdbuf7           = $E259 = 57945  _TEXT       CPM22.asm:1582
rdbuf8           = $E26A = 57962  _TEXT       CPM22.asm:1589
rdbuf9           = $E276 = 57974  _TEXT       CPM22.asm:1594
rdbuff           = $E1EC = 57836  _TEXT       CPM22.asm:1527
rderr            = $DBEC = 56300  _TEXT       CPM22.asm:699
rderror          = $DBE6 = 56294  _TEXT       CPM22.asm:697
rdrandom         = $ED4C = 60748  _TEXT       CPM22.asm:3592
rdrec            = $D8F8 = 55544  _TEXT       CPM22.asm:172
rdseq            = $E9C7 = 59847  _TEXT       CPM22.asm:2985
rdseq1           = $E9CC = 59852  _TEXT       CPM22.asm:2987
rdseq2           = $E9F1 = 59889  _TEXT       CPM22.asm:3002
rdseq3           = $EA06 = 59910  _TEXT       CPM22.asm:3012
rdwrtflg         = $EDDE = 60894  _TEXT       CPM22.asm:3710
read             = $EF0C = 61196  _TEXT       bios.asm:256
reader           = $EECD = 61133  _TEXT       bios.asm:188
readfcb          = $D8FD = 55549  _TEXT       CPM22.asm:177
readran          = $EB9E = 60318  _TEXT       CPM22.asm:3279
readseq          = $ECEB = 60651  _TEXT       CPM22.asm:3518
relblock         = $EDE2 = 60898  _TEXT       CPM22.asm:3714
renam            = $D90D = 55565  _TEXT       CPM22.asm:194
rename           = $DE1D = 56861  _TEXT       CPM22.asm:1021
rename1          = $DE4C = 56908  _TEXT       CPM22.asm:1039
rename2          = $DE65 = 56933  _TEXT       CPM22.asm:1053
rename3          = $DE6A = 56938  _TEXT       CPM22.asm:1056 (unused)
rename4          = $DE78 = 56952  _TEXT       CPM22.asm:1064
rename5          = $DE7E = 56958  _TEXT       CPM22.asm:1066
rename6          = $DE84 = 56964  _TEXT       CPM22.asm:1068
renfile          = $ED00 = 60672  _TEXT       CPM22.asm:3534
resccp           = $EF71 = 61297  _TEXT       config_nfs.asm:153
resdsk           = $D8B7 = 55479  _TEXT       CPM22.asm:107
resetdr          = $DC73 = 56435  _TEXT       CPM22.asm:793
resgrb           = $EF74 = 61300  _TEXT       config_nfs.asm:159
rodisk           = $E010 = 57360  _TEXT       CPM22.asm:1269
rofile           = $E012 = 57362  _TEXT       CPM22.asm:1270
rstdsk           = $EC8E = 60558  _TEXT       CPM22.asm:3462
rtn              = $E30F = 58127  _TEXT       CPM22.asm:1704
rtncode          = $DFFB = 57339  _TEXT       CPM22.asm:1245
samext           = $E712 = 59154  _TEXT       CPM22.asm:2516
savatr1          = $E84B = 59467  _TEXT       CPM22.asm:2756
save             = $DDBA = 56762  _TEXT       CPM22.asm:966
save1            = $DDE1 = 56801  _TEXT       CPM22.asm:984
save2            = $DDFE = 56830  _TEXT       CPM22.asm:1002
save3            = $DE08 = 56840  _TEXT       CPM22.asm:1009
save4            = $DE0E = 56846  _TEXT       CPM22.asm:1011
saveattr         = $E846 = 59462  _TEXT       CPM22.asm:2754
savefcb          = $EDE4 = 60900  _TEXT       CPM22.asm:3716
savext           = $EDED = 60909  _TEXT       CPM22.asm:3722
savnrec          = $EDEE = 60910  _TEXT       CPM22.asm:3723
savnxt           = $EDEC = 60908  _TEXT       CPM22.asm:3721
scratch1         = $EDBE = 60862  _TEXT       CPM22.asm:3684
scratch2         = $EDC0 = 60864  _TEXT       CPM22.asm:3685
scratch3         = $EDC2 = 60866  _TEXT       CPM22.asm:3686
search           = $DB36 = 56118  _TEXT       CPM22.asm:580
search1          = $DB3B = 56123  _TEXT       CPM22.asm:582
search2          = $DB44 = 56132  _TEXT       CPM22.asm:587
search3          = $DB57 = 56151  _TEXT       CPM22.asm:599
search4          = $DB5C = 56156  _TEXT       CPM22.asm:602
sectors          = $EDCC = 60876  _TEXT       CPM22.asm:3697
sectrn           = $EF17 = 61207  _TEXT       bios.asm:276
seldsk           = $EEE0 = 61152  _TEXT       bios.asm:208
select           = $E364 = 58212  _TEXT       CPM22.asm:1755
select1          = $E3A8 = 58280  _TEXT       CPM22.asm:1795
setattr          = $ED28 = 60712  _TEXT       CPM22.asm:3566
setbit           = $E516 = 58646  _TEXT       CPM22.asm:2087
setcdrv          = $D919 = 55577  _TEXT       CPM22.asm:209
setdir           = $E5A7 = 58791  _TEXT       CPM22.asm:2221
setdma           = $EF06 = 61190  _TEXT       bios.asm:248
setdsk           = $EC50 = 60496  _TEXT       CPM22.asm:3422
setext           = $E4B1 = 58545  _TEXT       CPM22.asm:2002
setfile          = $E676 = 58998  _TEXT       CPM22.asm:2406
setfl1           = $E680 = 59008  _TEXT       CPM22.asm:2411
setfl2           = $E693 = 59027  _TEXT       CPM22.asm:2423
setfl3           = $E699 = 59033  _TEXT       CPM22.asm:2429
setfl4           = $E6A8 = 59048  _TEXT       CPM22.asm:2438
sethlde          = $E4B9 = 58553  _TEXT       CPM22.asm:2010
setiob           = $E2FE = 58110  _TEXT       CPM22.asm:1684
setnrec          = $E4DD = 58589  _TEXT       CPM22.asm:2036
setran           = $EC19 = 60441  _TEXT       CPM22.asm:3385
sets2b7          = $E583 = 58755  _TEXT       CPM22.asm:2178
setsec           = $EF02 = 61186  _TEXT       bios.asm:241
setstat          = $E30C = 58124  _TEXT       CPM22.asm:1703
settrk           = $EEFE = 61182  _TEXT       bios.asm:234
setuser          = $ED46 = 60742  _TEXT       CPM22.asm:3586
shiftl           = $E50F = 58639  _TEXT       CPM22.asm:2078
shiftl1          = $E510 = 58640  _TEXT       CPM22.asm:2079
shiftr           = $E4F5 = 58613  _TEXT       CPM22.asm:2052
shiftr1          = $E4F6 = 58614  _TEXT       CPM22.asm:2053
showit           = $E18A = 57738  _TEXT       CPM22.asm:1459
siodev           = $FA19 = 64025  _TEXT       nabu_sio.asm:20
slcterr          = $E352 = 58194  _TEXT       CPM22.asm:1732
so_atab          = $FA89 = 64137  _TEXT       nabu_sio.asm:131
so_conf          = $FA8D = 64141  _TEXT       nabu_sio.asm:135
so_ini0          = $FA2C = 64044  _TEXT       nabu_sio.asm:39
so_ini1          = $FA32 = 64050  _TEXT       nabu_sio.asm:43
so_ini2          = $FA39 = 64057  _TEXT       nabu_sio.asm:49
so_ini3          = $FA45 = 64069  _TEXT       nabu_sio.asm:59
so_init          = $FA24 = 64036  _TEXT       nabu_sio.asm:33
so_rea0          = $FA6C = 64108  _TEXT       nabu_sio.asm:102
so_read          = $FA63 = 64099  _TEXT       nabu_sio.asm:95
so_sta0          = $FA5B = 64091  _TEXT       nabu_sio.asm:83
so_stat          = $FA52 = 64082  _TEXT       nabu_sio.asm:76
so_wri0          = $FA7F = 64127  _TEXT       nabu_sio.asm:121
so_writ          = $FA75 = 64117  _TEXT       nabu_sio.asm:113
space            = $D8A1 = 55457  _TEXT       CPM22.asm:87
srchfcb          = $D8E8 = 55528  _TEXT       CPM22.asm:154
srchfst          = $D8DE = 55518  _TEXT       CPM22.asm:144
srchnxt          = $D8E3 = 55523  _TEXT       CPM22.asm:149
starting         = $E316 = 58134  _TEXT       CPM22.asm:1712
status           = $E350 = 58192  _TEXT       CPM22.asm:1728
stbitmap         = $E667 = 58983  _TEXT       CPM22.asm:2386
stbmap1          = $E66F = 58991  _TEXT       CPM22.asm:2397
stddma           = $D9DD = 55773  _TEXT       CPM22.asm:349
stfilpos         = $E609 = 58889  _TEXT       CPM22.asm:2301
stkarea          = $E34C = 58188  _TEXT       CPM22.asm:1723
stnrec1          = $E4E9 = 58601  _TEXT       CPM22.asm:2041
strdata          = $E4C6 = 58566  _TEXT       CPM22.asm:2020
ststatus         = $E70C = 59148  _TEXT       CPM22.asm:2508
subhl            = $E5A0 = 58784  _TEXT       CPM22.asm:2211
swindi0          = $EF2D = 61229  _TEXT       bios.asm:300
swindi1          = $EF33 = 61235  _TEXT       bios.asm:304
swindir          = $EF29 = 61225  _TEXT       bios.asm:298
synerr           = $DA11 = 55825  _TEXT       CPM22.asm:387
synerr1          = $DA17 = 55831  _TEXT       CPM22.asm:389
synerr2          = $DA2A = 55850  _TEXT       CPM22.asm:399
synerrt          = $DE81 = 56961  _TEXT       CPM22.asm:1067
syshook          = $EF6E = 61294  _TEXT       config_nfs.asm:131
tab              = $0009 =     9  _TEXT       CPM22.asm:32
tbase            = $0100 =   256  _TEXT       CPM22.asm:25
tbuff            = $0080 =   128  _TEXT       CPM22.asm:24
tdrive           = $0004 =     4  _TEXT       CPM22.asm:21
tfcb             = $005C =    92  _TEXT       CPM22.asm:23
tm_40c           = $F1E5 = 61925  _TEXT       nabu_vdp.asm:450
tm_80c           = $F1F2 = 61938  _TEXT       nabu_vdp.asm:457
tm_addh          = $F309 = 62217  _TEXT       nabu_vdp.asm:695
tm_addr          = $F30B = 62219  _TEXT       nabu_vdp.asm:697
tm_atla          = $0041 =    65  _TEXT       nabu_vdp.asm:37
tm_ayda          = $0040 =    64  _TEXT       nabu_vdp.asm:36
tm_bs            = $F13B = 61755  _TEXT       nabu_vdp.asm:336
tm_cbuf          = $FAAB = 64171  _BSS        nabu_vdp.asm:26
tm_cha0          = $F2AD = 62125  _TEXT       nabu_vdp.asm:618
tm_chat          = $F2A7 = 62119  _TEXT       nabu_vdp.asm:613
tm_cle0          = $F1D1 = 61905  _TEXT       nabu_vdp.asm:435
tm_clea          = $F1C2 = 61890  _TEXT       nabu_vdp.asm:426
tm_cles          = $F1C0 = 61888  _TEXT       nabu_vdp.asm:425
tm_cloc          = $F058 = 61528  _TEXT       nabu_vdp.asm:166
tm_cls           = $F2EE = 62190  _TEXT       nabu_vdp.asm:672
tm_cls0          = $F2F7 = 62199  _TEXT       nabu_vdp.asm:675
tm_cold          = $F335 = 62261  _TEXT       nabu_vdp.asm:738
tm_colr          = $F330 = 62256  _TEXT       nabu_vdp.asm:733
tm_cr            = $F138 = 61752  _TEXT       nabu_vdp.asm:333
tm_cshm          = $F14A = 61770  _TEXT       nabu_vdp.asm:350
tm_cupd          = $F1E9 = 61929  _TEXT       nabu_vdp.asm:452
tm_curx          = $F333 = 62259  _TEXT       nabu_vdp.asm:736
tm_cury          = $F334 = 62260  _TEXT       nabu_vdp.asm:737
tm_data          = $00A0 =   160  _TEXT       nabu_vdp.asm:30
tm_dint          = $F31C = 62236  _TEXT       nabu_vdp.asm:716
tm_dsc0          = $F218 = 61976  _TEXT       nabu_vdp.asm:483
tm_dsco          = $F205 = 61957  _TEXT       nabu_vdp.asm:476
tm_eint          = $F325 = 62245  _TEXT       nabu_vdp.asm:725
tm_esc           = $F17F = 61823  _TEXT       nabu_vdp.asm:382
tm_esc0          = $F190 = 61840  _TEXT       nabu_vdp.asm:393
tm_esc1          = $F1AA = 61866  _TEXT       nabu_vdp.asm:408
tm_esc2          = $F1B5 = 61877  _TEXT       nabu_vdp.asm:415
tm_escd          = $F18B = 61835  _TEXT       nabu_vdp.asm:390
tm_esci          = $F1A4 = 61860  _TEXT       nabu_vdp.asm:405
tm_escr          = $F18C = 61836  _TEXT       nabu_vdp.asm:391
tm_escs          = $FAA9 = 64169  _BSS        nabu_vdp.asm:24
tm_get0          = $F241 = 62017  _TEXT       nabu_vdp.asm:518
tm_getc          = $F22B = 61995  _TEXT       nabu_vdp.asm:504
tm_home          = $F14D = 61773  _TEXT       nabu_vdp.asm:351
tm_inb           = $F331 = 62257  _TEXT       nabu_vdp.asm:734
tm_inf           = $F332 = 62258  _TEXT       nabu_vdp.asm:735
tm_ini0          = $F02B = 61483  _TEXT       nabu_vdp.asm:134
tm_ini1          = $F04B = 61515  _TEXT       nabu_vdp.asm:155
tm_inir          = $EFDD = 61405  _TEXT       nabu_vdp.asm:79
tm_init          = $F003 = 61443  _TEXT       nabu_vdp.asm:110
tm_inr0          = $EFDE = 61406  _TEXT       nabu_vdp.asm:80
tm_keyd          = $0090 =   144  _TEXT       nabu_vdp.asm:33
tm_keys          = $0091 =   145  _TEXT       nabu_vdp.asm:34
tm_kirq          = $F249 = 62025  _TEXT       nabu_vdp.asm:527
tm_last          = $FAAA = 64170  _BSS        nabu_vdp.asm:25
tm_latc          = $00A1 =   161  _TEXT       nabu_vdp.asm:31
tm_lf            = $F12C = 61740  _TEXT       nabu_vdp.asm:324
tm_map           = $F257 = 62039  _TEXT       nabu_vdp.asm:542
tm_map0          = $F25B = 62043  _TEXT       nabu_vdp.asm:546
tm_map2          = $F267 = 62055  _TEXT       nabu_vdp.asm:559
tm_mapt          = $F26E = 62062  _TEXT       nabu_vdp.asm:566
tm_mode          = $F32E = 62254  _TEXT       nabu_vdp.asm:732
tm_oti0          = $EFD5 = 61397  _TEXT       nabu_vdp.asm:66
tm_otir          = $EFD4 = 61396  _TEXT       nabu_vdp.asm:65
tm_outc          = $FAA7 = 64167  _BSS        nabu_vdp.asm:22
tm_putc          = $F283 = 62083  _TEXT       nabu_vdp.asm:584
tm_putf          = $F291 = 62097  _TEXT       nabu_vdp.asm:592 (unused)
tm_rea0          = $F0BB = 61627  _TEXT       nabu_vdp.asm:237
tm_rea1          = $F0D0 = 61648  _TEXT       nabu_vdp.asm:250
tm_rea2          = $F0E0 = 61664  _TEXT       nabu_vdp.asm:260
tm_read          = $F0A5 = 61605  _TEXT       nabu_vdp.asm:225
tm_ri            = $F125 = 61733  _TEXT       nabu_vdp.asm:318
tm_sclf          = $F070 = 61552  _TEXT       nabu_vdp.asm:182
tm_scol          = $F1F8 = 61944  _TEXT       nabu_vdp.asm:462
tm_scr0          = $F068 = 61544  _TEXT       nabu_vdp.asm:179
tm_scr1          = $F06E = 61550  _TEXT       nabu_vdp.asm:181
tm_scri          = $F05E = 61534  _TEXT       nabu_vdp.asm:174
tm_scro          = $FAA8 = 64168  _BSS        nabu_vdp.asm:23
tm_setp          = $F07A = 61562  _TEXT       nabu_vdp.asm:192
tm_sta0          = $EFF1 = 61425  _TEXT       nabu_vdp.asm:97
tm_sta1          = $F0F1 = 61681  _TEXT       nabu_vdp.asm:274
tm_stal          = $F0EE = 61678  _TEXT       nabu_vdp.asm:272
tm_stat          = $EFE6 = 61414  _TEXT       nabu_vdp.asm:92
tm_up            = $F145 = 61765  _TEXT       nabu_vdp.asm:345
tm_updc          = $F1FC = 61948  _TEXT       nabu_vdp.asm:466
tm_usc0          = $F2DA = 62170  _TEXT       nabu_vdp.asm:651
tm_usco          = $F2CB = 62155  _TEXT       nabu_vdp.asm:644
tm_vcpy          = $F2B3 = 62131  _TEXT       nabu_vdp.asm:630
tm_virq          = $F316 = 62230  _TEXT       nabu_vdp.asm:706
tm_wri0          = $F112 = 61714  _TEXT       nabu_vdp.asm:306
tm_wri1          = $F151 = 61777  _TEXT       nabu_vdp.asm:356
tm_writ          = $F0F7 = 61687  _TEXT       nabu_vdp.asm:286
trksec           = $E3CE = 58318  _TEXT       CPM22.asm:1829
trksec1          = $E3DC = 58332  _TEXT       CPM22.asm:1838
trksec2          = $E3EF = 58351  _TEXT       CPM22.asm:1851
trksec3          = $E405 = 58373  _TEXT       CPM22.asm:1867
trksec4          = $E41A = 58394  _TEXT       CPM22.asm:1884
type             = $DD6A = 56682  _TEXT       CPM22.asm:923
type1            = $DD81 = 56705  _TEXT       CPM22.asm:931
type2            = $DD84 = 56708  _TEXT       CPM22.asm:932 (unused)
type3            = $DD94 = 56724  _TEXT       CPM22.asm:941
type4            = $DDAD = 56749  _TEXT       CPM22.asm:954
type5            = $DDB4 = 56756  _TEXT       CPM22.asm:957
unknown          = $DEAE = 57006  _TEXT       CPM22.asm:1095
unkwn0           = $DF6F = 57199  _TEXT       CPM22.asm:1203
unkwn1           = $DECC = 57036  _TEXT       CPM22.asm:1110
unkwn2           = $DED4 = 57044  _TEXT       CPM22.asm:1114 (unused)
unkwn3           = $DEE8 = 57064  _TEXT       CPM22.asm:1125
unkwn4           = $DF05 = 57093  _TEXT       CPM22.asm:1144
unkwn5           = $DF33 = 57139  _TEXT       CPM22.asm:1165
unkwn6           = $DF3E = 57150  _TEXT       CPM22.asm:1175
unkwn7           = $DF43 = 57155  _TEXT       CPM22.asm:1177
unkwn8           = $DF4D = 57165  _TEXT       CPM22.asm:1185
unkwn9           = $DF69 = 57193  _TEXT       CPM22.asm:1201
update           = $E80C = 59404  _TEXT       CPM22.asm:2717
update1          = $E81B = 59419  _TEXT       CPM22.asm:2725
upper            = $D92F = 55599  _TEXT       CPM22.asm:228
user             = $DE99 = 56985  _TEXT       CPM22.asm:1079
userdma          = $EDBC = 60860  _TEXT       CPM22.asm:3680
userno           = $E34C = 58188  _TEXT       CPM22.asm:1725
usrstack         = $E31A = 58138  _TEXT       CPM22.asm:1719
vdpdev           = $EFC7 = 61383  _TEXT       nabu_vdp.asm:51
verify           = $D9FD = 55805  _TEXT       CPM22.asm:373
verify1          = $DA05 = 55813  _TEXT       CPM22.asm:376
wbinit           = $EF4B = 61259  _TEXT       config_nfs.asm:64
wboot            = $EE48 = 61000  _TEXT       bios.asm:57
wboot0           = $EE6F = 61039  _TEXT       bios.asm:94
wbootin          = $EE0A = 60938  _TEXT       bios.asm:22
wbootr           = $EE5F = 61023  _TEXT       bios.asm:82
write            = $EF10 = 61200  _TEXT       bios.asm:263
writeran         = $EBA7 = 60327  _TEXT       CPM22.asm:3286
wrtprt           = $EDB8 = 60856  _TEXT       CPM22.asm:3678
wrtprtd          = $E537 = 58679  _TEXT       CPM22.asm:2114
wrtrec           = $D903 = 55555  _TEXT       CPM22.asm:183
wrtseq           = $ECF1 = 60657  _TEXT       CPM22.asm:3523
wtrandom         = $ED52 = 60754  _TEXT       CPM22.asm:3597
wtseq            = $EA09 = 59913  _TEXT       CPM22.asm:3016
wtseq1           = $EA0E = 59918  _TEXT       CPM22.asm:3018
wtseq10          = $EADD = 60125  _TEXT       CPM22.asm:3133
wtseq11          = $EB09 = 60169  _TEXT       CPM22.asm:3157
wtseq12          = $EB0B = 60171  _TEXT       CPM22.asm:3158
wtseq2           = $EA46 = 59974  _TEXT       CPM22.asm:3041
wtseq3           = $EA53 = 59987  _TEXT       CPM22.asm:3047
wtseq4           = $EA6F = 60015  _TEXT       CPM22.asm:3059
wtseq5           = $EA77 = 60023  _TEXT       CPM22.asm:3066
wtseq6           = $EA79 = 60025  _TEXT       CPM22.asm:3067
wtseq7           = $EA97 = 60055  _TEXT       CPM22.asm:3090
wtseq8           = $EAA5 = 60069  _TEXT       CPM22.asm:3097
wtseq9           = $EAC6 = 60102  _TEXT       CPM22.asm:3117
wtseq99          = $EAEA = 60138  _TEXT       CPM22.asm:3144 (unused)
wtspecl          = $EDA6 = 60838  _TEXT       CPM22.asm:3663
xlate            = $EDDB = 60891  _TEXT       CPM22.asm:3706
yesno            = $DD5F = 56671  _TEXT       CPM22.asm:915


total time: 0.0684 sec.
no errors
