              	; --------------------------------------
              	; zasm: assemble "config\config_ndsk.asm"
              	; date: 2023-06-08 23:34:31
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0037:         	mem	equ	55		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
DC00:         	#code	_TEXT,(mem)*1024
FA95:         	#data	_BSS,_TEXT_end
FF00:         	#data	_JUMP_TABLE,0xFF00
FF00: 00000000	intvec:	defs	16
FF04: 00...   	
FF10: 00000000	dircbuf:defs	128
FF14: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "CPM22.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	;
              	;   set origin for cp/m
              	;
              	;	org	(mem)*1024
              	;
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
DC00: C364DF  	cbase:	jp	command		;execute command processor (ccp).
DC03: C360DF  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
DC06: 7F      	inbuff:	defb	127		;length of input buffer.
DC07: 00      		defb	0		;current length of contents.
DC08: 494E4954		defb	'INIT '
DC0C: 20      	
DC0D: FF000000		defb	255,0,0,0
DC11: 20313937		defb	' 1979 (c) by Digital Research      '
DC15: 39202863	
DC19: 29206279	
DC1D: 20446967	
DC21: 6974616C	
DC25: 20526573	
DC29: 65617263	
DC2D: 68202020	
DC31: 202020  	
DC34: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC38: 00...   	
DC4B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC4F: 00...   	
DC62: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC66: 00...   	
DC79: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC7D: 00...   	
DC88: 08DC    	inpoint:defw	inbuff+2	;input line pointer
DC8A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
DC8C: 5F      	print:	ld	e,a		;setup bdos call.
DC8D: 0E02    		ld	c,2
DC8F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
DC92: C5      	printb:	push	bc
DC93: CD8CDC  		call	print
DC96: C1      		pop	bc
DC97: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
DC98: 3E0D    	crlf:	ld	a,cr
DC9A: CD92DC  		call	printb
DC9D: 3E0A    		ld	a,lf
DC9F: 18F1    		jr	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
DCA1: 3E20    	space:	ld	a,' '
DCA3: C392DC  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
DCA6: C5      	pline:	push	bc
DCA7: CD98DC  		call	crlf
DCAA: E1      		pop	hl
DCAB: 7E      	pline2:	ld	a,(hl)
DCAC: B7      		or	a
DCAD: C8      		ret	z
DCAE: 23      		inc	hl
DCAF: E5      		push	hl
DCB0: CD8CDC  		call	print
DCB3: E1      		pop	hl
DCB4: C3ABDC  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
DCB7: 0E0D    	resdsk:	ld	c,13
DCB9: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
DCBC: 5F      	dsksel:	ld	e,a
DCBD: 0E0E    		ld	c,14
DCBF: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
DCC2: CD0500  	entry1:	call	entry
DCC5: 32FBE3  		ld	(rtncode),a	;save return code.
DCC8: 3C      		inc	a		;set zero if 0ffh returned.
DCC9: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
DCCA: 0E0F    	open:	ld	c,15
DCCC: C3C2DC  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
DCCF: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
DCD0: 32FAE3  		ld	(fcb+32),a
DCD3: 11DAE3  		ld	de,fcb
DCD6: C3CADC  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
DCD9: 0E10    	close:	ld	c,16
DCDB: C3C2DC  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
DCDE: 0E11    	srchfst:ld	c,17
DCE0: C3C2DC  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
DCE3: 0E12    	srchnxt:ld	c,18
DCE5: C3C2DC  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
DCE8: 11DAE3  	srchfcb:ld	de,fcb
DCEB: C3DEDC  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
DCEE: 0E13    	delete:	ld	c,19
DCF0: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
DCF3: CD0500  	entry2:	call	entry
DCF6: B7      		or	a		;set zero flag if appropriate.
DCF7: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
DCF8: 0E14    	rdrec:	ld	c,20
DCFA: C3F3DC  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
DCFD: 11DAE3  	readfcb:ld	de,fcb
DD00: C3F8DC  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
DD03: 0E15    	wrtrec:	ld	c,21
DD05: C3F3DC  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
DD08: 0E16    	create:	ld	c,22
DD0A: C3C2DC  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
DD0D: 0E17    	renam:	ld	c,23
DD0F: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
DD12: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
DD14: 0E20    	getsetuc: ld	c,32
DD16: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
DD19: CD12DD  	setcdrv:call	getusr		;get user number
DD1C: 87      		add	a,a		;and shift into the upper 4 bits.
DD1D: 87      		add	a,a
DD1E: 87      		add	a,a
DD1F: 87      		add	a,a
DD20: 21FCE3  		ld	hl,cdrive	;now add in the current drive number.
DD23: B6      		or	(hl)
DD24: 320400  		ld	(tdrive),a	;and save.
DD27: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
DD28: 3AFCE3  	movecd:	ld	a,(cdrive)
DD2B: 320400  		ld	(tdrive),a
DD2E: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
DD2F: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
DD31: D8      		ret	c
DD32: FE7B    		cp	'{'
DD34: D0      		ret	nc
DD35: E65F    		and	5fh		;convert it if found.
DD37: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
DD38: 3AB8E3  	getinp:	ld	a,(batch)	;if =0, then use console input.
DD3B: B7      		or	a
DD3C: CAA0DD  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
DD3F: 3AFCE3  		ld	a,(cdrive)	;select drive 0 if need be.
DD42: B7      		or	a
DD43: 3E00    		ld	a,0		;always use drive a for submit.
DD45: C4BCDC  		call	nz,dsksel	;select it if required.
DD48: 11B9E3  		ld	de,batchfcb
DD4B: CDCADC  		call	open		;look for it.
DD4E: CAA0DD  		jp	z,getinp1	;if not there, use normal input.
DD51: 3AC8E3  		ld	a,(batchfcb+15)	;get last record number+1.
DD54: 3D      	getinp0:dec	a
DD55: 32D9E3  		ld	(batchfcb+32),a
DD58: 11B9E3  		ld	de,batchfcb
DD5B: F5      		push	af
DD5C: CDF8DC  		call	rdrec		;read last record.
DD5F: D1      		pop	de
DD60: C2A0DD  		jp	nz,getinp1	;quit on end of file.
DD63: 218000  		ld	hl,tbuff	;data was read into buffer here.
DD66: AF      		xor	a		;skip if entry has nothing in it
DD67: BE      		cp	(hl)
DD68: 7A      		ld	a,d
DD69: 28E9    		jr	z,getinp0
              	
              	;   move this record into input buffer.
              	;
DD6B: 1107DC  		ld	de,inbuff+1
DD6E: 0680    		ld	b,128		;all 128 characters may be used.
DD70: E5      		push	hl		;save tbuff
DD71: CD4FE0  		call	hl2de		;(hl) to (de), (b) bytes.
DD74: E1      		pop	hl		;zero out first in tbuff
DD75: 3600    		ld	(hl),0
DD77: 21D9E3  		ld	hl,batchfcb+32
DD7A: 35      		dec	(hl)		;decrement the record count.
DD7B: 11B9E3  		ld	de,batchfcb	;close the batch file now.
DD7E: D5      		push	de
DD7F: CD03DD  		call	wrtrec		;write out record
DD82: D1      		pop	de
DD83: CDD9DC  		call	close
DD86: 2818    		jr	z,getinp1	;quit on an error.
DD88: 3AFCE3  		ld	a,(cdrive)	;re-select previous drive if need be.
DD8B: B7      		or	a
DD8C: C4BCDC  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
DD8F: 2108DC  		ld	hl,inbuff+2
DD92: CDABDC  		call	pline2
DD95: CDCADD  		call	chkcon		;check console, quit on a key.
DD98: 2817    		jr	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
DD9A: CDE5DD  		call	delbatch	;delete the batch file.
DD9D: C387DF  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
DDA0: CDE5DD  	getinp1:call	delbatch	;delete file ($$$.sub).
DDA3: CD19DD  		call	setcdrv		;reset active disk.
DDA6: 0E0A    		ld	c,10		;get line from console device.
DDA8: 1106DC  		ld	de,inbuff
DDAB: CD0500  		call	entry
DDAE: CD28DD  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
DDB1: 2107DC  	getinp2:ld	hl,inbuff+1
DDB4: 46      		ld	b,(hl)		;(b)=character counter.
DDB5: 23      	getinp3:inc	hl
DDB6: 78      		ld	a,b		;end of the line?
DDB7: B7      		or	a
DDB8: 2808    		jr	z,getinp4
DDBA: 7E      		ld	a,(hl)		;convert to upper case.
DDBB: CD2FDD  		call	upper
DDBE: 77      		ld	(hl),a
DDBF: 05      		dec	b		;adjust character count.
DDC0: 18F3    		jr	getinp3
DDC2: 77      	getinp4:ld	(hl),a		;add trailing null.
DDC3: 2108DC  		ld	hl,inbuff+2
DDC6: 2288DC  		ld	(inpoint),hl	;reset input line pointer.
DDC9: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
DDCA: 0E0B    	chkcon:	ld	c,11		;check console.
DDCC: CD0500  		call	entry
DDCF: B7      		or	a
DDD0: C8      		ret	z		;return if nothing.
DDD1: 0E01    		ld	c,1		;else get character.
DDD3: CD0500  		call	entry
DDD6: B7      		or	a		;clear zero flag and return.
DDD7: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
DDD8: 0E19    	getdsk:	ld	c,25
DDDA: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
DDDD: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
DDE0: 0E1A    	dmaset:	ld	c,26
DDE2: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
DDE5: 21B8E3  	delbatch: ld	hl,batch	;is batch active?
DDE8: 7E      		ld	a,(hl)
DDE9: B7      		or	a
DDEA: C8      		ret	z
DDEB: 3600    		ld	(hl),0		;yes, de-activate it.
DDED: AF      		xor	a
DDEE: CDBCDC  		call	dsksel		;select drive 0 for sure.
DDF1: 11B9E3  		ld	de,batchfcb	;and delete this file.
DDF4: CDEEDC  		call	delete
DDF7: 3AFCE3  		ld	a,(cdrive)	;reset current drive.
DDFA: C3BCDC  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
DDFD: 1132DF  	verify:	ld	de,pattrn1+2	;these are the serial number bytes.
DE00: 2102E4  		ld	hl,pattrn2+2	;ditto, but how could they be different?
DE03: 0604    		ld	b,4		;6 bytes each.
DE05: 1A      	verify1:ld	a,(de)
DE06: BE      		cp	(hl)
DE07: C2DCDF  		jp	nz,halt		;jump to halt routine.
DE0A: 13      		inc	de
DE0B: 23      		inc	hl
DE0C: 05      		dec	b
DE0D: C205DE  		jp	nz,verify1
DE10: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
DE11: CD98DC  	synerr:	call	crlf		;end current line.
DE14: 2A8ADC  		ld	hl,(namepnt)	;this points to name in error.
DE17: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
DE18: FE20    		cp	' '
DE1A: CA2ADE  		jp	z,synerr2
DE1D: B7      		or	a
DE1E: CA2ADE  		jp	z,synerr2
DE21: E5      		push	hl
DE22: CD8CDC  		call	print
DE25: E1      		pop	hl
DE26: 23      		inc	hl
DE27: C317DE  		jp	synerr1
DE2A: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
DE2C: CD8CDC  		call	print
DE2F: CD98DC  		call	crlf
DE32: CDE5DD  		call	delbatch	;delete any batch file.
DE35: C387DF  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
DE38: 1A      	check:	ld	a,(de)
DE39: B7      		or	a
DE3A: C8      		ret	z
DE3B: FE20    		cp	' '		;control characters are not legal here.
DE3D: DA11DE  		jp	c,synerr
DE40: C8      		ret	z		;check for valid delimiter.
DE41: FE3D    		cp	'='
DE43: C8      		ret	z
DE44: FE5F    		cp	'_'
DE46: C8      		ret	z
DE47: FE2E    		cp	'.'
DE49: C8      		ret	z
DE4A: FE3A    		cp	':'
DE4C: C8      		ret	z
DE4D: FE3B    		cp	';'
DE4F: C8      		ret	z
DE50: FE3C    		cp	'<'
DE52: C8      		ret	z
DE53: FE3E    		cp	'>'
DE55: C8      		ret	z
DE56: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
DE57: 1A      	nonblank: ld	a,(de)
DE58: B7      		or	a		;string ends with a null.
DE59: C8      		ret	z
DE5A: FE20    		cp	' '
DE5C: C0      		ret	nz
DE5D: 13      		inc	de
DE5E: C357DE  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
DE61: 85      	addhl:	add	a,l
DE62: 6F      		ld	l,a
DE63: D0      		ret	nc		;take care of any carry.
DE64: 24      		inc	h
DE65: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
DE66: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
DE68: 21DAE3  	convert:ld	hl,fcb
DE6B: CD61DE  		call	addhl
DE6E: E5      		push	hl
DE6F: E5      		push	hl
DE70: AF      		xor	a
DE71: 32FDE3  		ld	(chgdrv),a	;initialize drive change flag.
DE74: 2A88DC  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
DE77: EB      		ex	de,hl
DE78: CD57DE  		call	nonblank	;get next non-blank character.
DE7B: EB      		ex	de,hl
DE7C: 228ADC  		ld	(namepnt),hl	;save pointer here for any error message.
DE7F: EB      		ex	de,hl
DE80: E1      		pop	hl
DE81: 1A      		ld	a,(de)		;get first character.
DE82: B7      		or	a
DE83: CA91DE  		jp	z,convrt1
DE86: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
DE88: 47      		ld	b,a		;and save.
DE89: 13      		inc	de		;check next character for a ':'.
DE8A: 1A      		ld	a,(de)
DE8B: FE3A    		cp	':'
DE8D: CA98DE  		jp	z,convrt2
DE90: 1B      		dec	de		;nope, move pointer back to the start of the line.
DE91: 3AFCE3  	convrt1:ld	a,(cdrive)
DE94: 77      		ld	(hl),a
DE95: C39EDE  		jp	convrt3
DE98: 78      	convrt2:ld	a,b
DE99: 32FDE3  		ld	(chgdrv),a	;set change in drives flag.
DE9C: 70      		ld	(hl),b
DE9D: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
DE9E: 0608    	convrt3:ld	b,08h
DEA0: CD38DE  	convrt4:call	check
DEA3: CAC1DE  		jp	z,convrt8
DEA6: 23      		inc	hl
DEA7: FE2A    		cp	'*'		;note that an '*' will fill the remaining
DEA9: C2B1DE  		jp	nz,convrt5	;field with '?'.
DEAC: 363F    		ld	(hl),'?'
DEAE: C3B3DE  		jp	convrt6
DEB1: 77      	convrt5:ld	(hl),a
DEB2: 13      		inc	de
DEB3: 05      	convrt6:dec	b
DEB4: C2A0DE  		jp	nz,convrt4
DEB7: CD38DE  	convrt7:call	check		;get next delimiter.
DEBA: CAC8DE  		jp	z,getext
DEBD: 13      		inc	de
DEBE: C3B7DE  		jp	convrt7
DEC1: 23      	convrt8:inc	hl		;blank fill the file name.
DEC2: 3620    		ld	(hl),' '
DEC4: 05      		dec	b
DEC5: C2C1DE  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
DEC8: 0603    	getext:	ld	b,03h
DECA: FE2E    		cp	'.'
DECC: C2F1DE  		jp	nz,getext5
DECF: 13      		inc	de
DED0: CD38DE  	getext1:call	check
DED3: CAF1DE  		jp	z,getext5
DED6: 23      		inc	hl
DED7: FE2A    		cp	'*'
DED9: C2E1DE  		jp	nz,getext2
DEDC: 363F    		ld	(hl),'?'
DEDE: C3E3DE  		jp	getext3
DEE1: 77      	getext2:ld	(hl),a
DEE2: 13      		inc	de
DEE3: 05      	getext3:dec	b
DEE4: C2D0DE  		jp	nz,getext1
DEE7: CD38DE  	getext4:call	check
DEEA: CAF8DE  		jp	z,getext6
DEED: 13      		inc	de
DEEE: C3E7DE  		jp	getext4
DEF1: 23      	getext5:inc	hl
DEF2: 3620    		ld	(hl),' '
DEF4: 05      		dec	b
DEF5: C2F1DE  		jp	nz,getext5
DEF8: 0603    	getext6:ld	b,3
DEFA: 23      	getext7:inc	hl
DEFB: 3600    		ld	(hl),0
DEFD: 05      		dec	b
DEFE: C2FADE  		jp	nz,getext7
DF01: EB      		ex	de,hl
DF02: 2288DC  		ld	(inpoint),hl	;save input line pointer.
DF05: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
DF06: 010B00  		ld	bc,11		;set name length.
DF09: 23      	getext8:inc	hl
DF0A: 7E      		ld	a,(hl)
DF0B: FE3F    		cp	'?'		;any question marks?
DF0D: C211DF  		jp	nz,getext9
DF10: 04      		inc	b		;count them.
DF11: 0D      	getext9:dec	c
DF12: C209DF  		jp	nz,getext8
DF15: 78      		ld	a,b
DF16: B7      		or	a
DF17: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
DF18: 44495220	cmdtbl:	defb	'DIR '
DF1C: 45524120		defb	'ERA '
DF20: 54595045		defb	'TYPE'
DF24: 53415645		defb	'SAVE'
DF28: 52454E20		defb	'REN '
DF2C: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
DF30: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
DF34: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
DF36: 2118DF  	search:	ld	hl,cmdtbl
DF39: 0E00    		ld	c,0
DF3B: 79      	search1:ld	a,c
DF3C: FE06    		cp	numcmds		;this commands exists.
DF3E: D0      		ret	nc
DF3F: 11DBE3  		ld	de,fcb+1	;check this one.
DF42: 0604    		ld	b,4		;max command length.
DF44: 1A      	search2:ld	a,(de)
DF45: BE      		cp	(hl)
DF46: C257DF  		jp	nz,search3	;not a match.
DF49: 13      		inc	de
DF4A: 23      		inc	hl
DF4B: 05      		dec	b
DF4C: C244DF  		jp	nz,search2
DF4F: 1A      		ld	a,(de)		;allow a 3 character command to match.
DF50: FE20    		cp	' '
DF52: C25CDF  		jp	nz,search4
DF55: 79      		ld	a,c		;set return register for this command.
DF56: C9      		ret	
DF57: 23      	search3:inc	hl
DF58: 05      		dec	b
DF59: C257DF  		jp	nz,search3
DF5C: 0C      	search4:inc	c
DF5D: C33BDF  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
DF60: AF      	clearbuf: xor	a
DF61: 3207DC  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
DF64: 31B8E3  	command:ld	sp,ccpstack	;setup stack area.
DF67: C5      		push	bc		;note that (c) should be equal to:
DF68: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
DF69: 1F      		rra			;and 'dddd' is the drive number.
DF6A: 1F      		rra	
DF6B: 1F      		rra	
DF6C: 1F      		rra	
DF6D: E60F    		and	0fh		;isolate the user number.
DF6F: 5F      		ld	e,a
DF70: CD14DD  		call	getsetuc	;and set it.
DF73: CDB7DC  		call	resdsk		;reset the disk system.
              		;ld	(batch),a	;clear batch mode flag.
DF76: C1      		pop	bc
DF77: 79      		ld	a,c
DF78: E60F    		and	0fh		;isolate the drive number.
DF7A: 32FCE3  		ld	(cdrive),a	;and save.
DF7D: CDBCDC  		call	dsksel		;...and select.
DF80: 3A07DC  		ld	a,(inbuff+1)
DF83: B7      		or	a		;anything in input buffer already?
DF84: C2A5DF  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
DF87: 31B8E3  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
DF8A: CD98DC  		call	crlf		;start a new line on the screen.
DF8D: CDD8DD  		call	getdsk		;get current drive.
DF90: C641    		add	a,'A'
DF92: CD8CDC  		call	print		;print current drive.
DF95: CD12DD  		call	getusr		;get current user.
DF98: C630    		add	a,'0'
DF9A: CD98E3  		call	printdc		;print current user.
DF9D: 3E3E    		ld	a,'>'
DF9F: CD8CDC  		call	print		;and add prompt.
DFA2: CD38DD  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
DFA5: 118000  	cmmnd2:	ld	de,tbuff
DFA8: CDE0DD  		call	dmaset		;set standard dma address.
DFAB: CDD8DD  		call	getdsk
DFAE: 32FCE3  		ld	(cdrive),a	;set current drive.
DFB1: CD66DE  		call	convfst		;convert name typed in.
DFB4: C411DE  		call	nz,synerr	;wild cards are not allowed.
DFB7: 3AFDE3  		ld	a,(chgdrv)	;if a change in drives was indicated,
DFBA: B7      		or	a		;then treat this as an unknown command
DFBB: C2AEE2  		jp	nz,unknown	;which gets executed.
DFBE: CD36DF  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
DFC1: 21CEDF  		ld	hl,cmdadr	;now, look thru our address table for command (a).
DFC4: 5F      		ld	e,a		;set (de) to command number.
DFC5: 1600    		ld	d,0
DFC7: 19      		add	hl,de
DFC8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
DFC9: 7E      		ld	a,(hl)		;now pick out this address.
DFCA: 23      		inc	hl
DFCB: 66      		ld	h,(hl)
DFCC: 6F      		ld	l,a
DFCD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
DFCE: 84E02CE1	cmdadr:	defw	direct,erase,type,save
DFD2: 6AE1BAE1	
DFD6: 1DE299E2		defw	rename,user,unknown
DFDA: AEE2    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
DFDC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
DFDF: 2200DC  		ld	(cbase),hl
DFE2: 2100DC  		ld	hl,cbase
DFE5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
DFE6: 01ECDF  	rderror:ld	bc,rderr
DFE9: C3A6DC  		jp	pline
DFEC: 72656164	rderr:	defb	'read error',0
DFF0: 20657272	
DFF4: 6F7200  	
              	;
              	;   required file was not located.
              	;
DFF7: 01FDDF  	none:	ld	bc,nofile
DFFA: C3A6DC  		jp	pline
DFFD: 6E6F2066	nofile:	defb	'no file',0
E001: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
E005: CD66DE  	decode:	call	convfst		;convert filename.
E008: 3AFDE3  		ld	a,(chgdrv)	;do not allow a drive to be specified.
E00B: B7      		or	a
E00C: C211DE  		jp	nz,synerr
E00F: 21DBE3  		ld	hl,fcb+1	;convert number now.
E012: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
E015: 7E      	decode1:ld	a,(hl)
E016: FE20    		cp	' '		;a space terminates the numeral.
E018: CA40E0  		jp	z,decode3
E01B: 23      		inc	hl
E01C: D630    		sub	'0'		;make binary from ascii.
E01E: FE0A    		cp	10		;legal digit?
E020: D211DE  		jp	nc,synerr
E023: 57      		ld	d,a		;yes, save it in (d).
E024: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
E025: E6E0    		and	0e0h
E027: C211DE  		jp	nz,synerr
E02A: 78      		ld	a,b
E02B: 07      		rlca	
E02C: 07      		rlca	
E02D: 07      		rlca			;(a)=(b)*8
E02E: 80      		add	a,b		;.......*9
E02F: DA11DE  		jp	c,synerr
E032: 80      		add	a,b		;.......*10
E033: DA11DE  		jp	c,synerr
E036: 82      		add	a,d		;add in new digit now.
E037: DA11DE  	decode2:jp	c,synerr
E03A: 47      		ld	b,a		;and save result.
E03B: 0D      		dec	c		;only look at 11 digits.
E03C: C215E0  		jp	nz,decode1
E03F: C9      		ret	
E040: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
E041: FE20    		cp	' '
E043: C211DE  		jp	nz,synerr
E046: 23      		inc	hl
E047: 0D      	decode4:dec	c
E048: C240E0  		jp	nz,decode3
E04B: 78      		ld	a,b		;set (a)=the numeric value entered.
E04C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
E04D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
E04F: 7E      	hl2de:	ld	a,(hl)
E050: 12      		ld	(de),a
E051: 23      		inc	hl
E052: 13      		inc	de
E053: 05      		dec	b
E054: C24FE0  		jp	nz,hl2de
E057: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
E058: 218000  	extract:ld	hl,tbuff
E05B: 81      		add	a,c
E05C: CD61DE  		call	addhl
E05F: 7E      		ld	a,(hl)
E060: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E061: AF      	dselect:xor	a		;null out first byte of fcb.
E062: 32DAE3  		ld	(fcb),a
E065: 3AFDE3  		ld	a,(chgdrv)	;a drive change indicated?
E068: B7      		or	a
E069: C8      		ret	z
E06A: 3D      		dec	a		;yes, is it the same as the current drive?
E06B: 21FCE3  		ld	hl,cdrive
E06E: BE      		cp	(hl)
E06F: C8      		ret	z
E070: C3BCDC  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E073: 3AFDE3  	resetdr:ld	a,(chgdrv)	;drive change indicated?
E076: B7      		or	a
E077: C8      		ret	z
E078: 3D      		dec	a		;yes, was it a different drive?
E079: 21FCE3  		ld	hl,cdrive
E07C: BE      		cp	(hl)
E07D: C8      		ret	z
E07E: 3AFCE3  		ld	a,(cdrive)	;yes, re-select our old drive.
E081: C3BCDC  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E084: CD66DE  	direct:	call	convfst		;convert file name.
E087: CD61E0  		call	dselect		;select indicated drive.
E08A: 21DBE3  		ld	hl,fcb+1	;was any file indicated?
E08D: 7E      		ld	a,(hl)
E08E: FE20    		cp	' '
E090: C29CE0  		jp	nz,direct2
E093: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
E095: 363F    	direct1:ld	(hl),'?'
E097: 23      		inc	hl
E098: 05      		dec	b
E099: C295E0  		jp	nz,direct1
E09C: 1E00    	direct2:ld	e,0		;set initial cursor position.
E09E: D5      		push	de
E09F: CDE8DC  		call	srchfcb		;get first file name.
E0A2: CCF7DF  		call	z,none		;none found at all?
E0A5: CA28E1  	direct3:jp	z,direct9	;terminate if no more names.
E0A8: 3AFBE3  		ld	a,(rtncode)	;get file's position in segment (0-3).
E0AB: 0F      		rrca	
E0AC: 0F      		rrca	
E0AD: 0F      		rrca	
E0AE: E660    		and	60h		;(a)=position*32
E0B0: 4F      		ld	c,a
E0B1: 3E0A    		ld	a,10
E0B3: CD58E0  		call	extract		;extract the tenth entry in fcb.
E0B6: 17      		rla			;check system file status bit.
E0B7: DA1CE1  		jp	c,direct8	;we don't list them.
E0BA: D1      		pop	de
E0BB: 7B      		ld	a,e		;bump name count.
E0BC: 1C      		inc	e
E0BD: D5      		push	de
E0BE: E603    		and	03h		;at end of line?
E0C0: F5      		push	af
E0C1: C2D9E0  		jp	nz,direct4
E0C4: CD98DC  		call	crlf		;yes, end this line and start another.
E0C7: C5      		push	bc
E0C8: CDD8DD  		call	getdsk		;start line with ('a:').
E0CB: C1      		pop	bc
E0CC: C641    		add	a,'A'
E0CE: CD92DC  		call	printb
E0D1: 3E3A    		ld	a,':'
E0D3: CD92DC  		call	printb
E0D6: C3E1E0  		jp	direct5
E0D9: CDA1DC  	direct4:call	space		;add seperator between file names.
E0DC: 3E3A    		ld	a,':'
E0DE: CD92DC  		call	printb
E0E1: CDA1DC  	direct5:call	space
E0E4: 0601    		ld	b,1		;'extract' each file name character at a time.
E0E6: 78      	direct6:ld	a,b
E0E7: CD58E0  		call	extract
E0EA: E67F    		and	7fh		;strip bit 7 (status bit).
E0EC: FE20    		cp	' '		;are we at the end of the name?
E0EE: C206E1  		jp	nz,drect65
E0F1: F1      		pop	af		;yes, don't print spaces at the end of a line.
E0F2: F5      		push	af
E0F3: FE03    		cp	3
E0F5: C204E1  		jp	nz,drect63
E0F8: 3E09    		ld	a,9		;first check for no extension.
E0FA: CD58E0  		call	extract
E0FD: E67F    		and	7fh
E0FF: FE20    		cp	' '
E101: CA1BE1  		jp	z,direct7	;don't print spaces.
E104: 3E20    	drect63:ld	a,' '		;else print them.
E106: CD92DC  	drect65:call	printb
E109: 04      		inc	b		;bump to next character psoition.
E10A: 78      		ld	a,b
E10B: FE0C    		cp	12		;end of the name?
E10D: D21BE1  		jp	nc,direct7
E110: FE09    		cp	9		;nope, starting extension?
E112: C2E6E0  		jp	nz,direct6
E115: CDA1DC  		call	space		;yes, add seperating space.
E118: C3E6E0  		jp	direct6
E11B: F1      	direct7:pop	af		;get the next file name.
E11C: CDCADD  	direct8:call	chkcon		;first check console, quit on anything.
E11F: C228E1  		jp	nz,direct9
E122: CDE3DC  		call	srchnxt		;get next name.
E125: C3A5E0  		jp	direct3		;and continue with our list.
E128: D1      	direct9:pop	de		;restore the stack and return to command level.
E129: C383E3  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E12C: CD66DE  	erase:	call	convfst		;convert file name.
E12F: FE0B    		cp	11		;was '*.*' entered?
E131: C24FE1  		jp	nz,erase1
E134: 015FE1  		ld	bc,yesno	;yes, ask for confirmation.
E137: CDA6DC  		call	pline
E13A: CD38DD  		call	getinp
E13D: 2107DC  		ld	hl,inbuff+1
E140: 35      		dec	(hl)		;must be exactly 'y'.
E141: C287DF  		jp	nz,cmmnd1
E144: 23      		inc	hl
E145: 7E      		ld	a,(hl)
E146: FE79    		cp	'y'
E148: C287DF  		jp	nz,cmmnd1
E14B: 23      		inc	hl
E14C: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E14F: CD61E0  	erase1:	call	dselect		;select desired disk.
E152: 11DAE3  		ld	de,fcb
E155: CDEEDC  		call	delete		;delete the file.
E158: 3C      		inc	a
E159: CCF7DF  		call	z,none		;not there?
E15C: C383E3  		jp	getback		;return to command level now.
E15F: 616C6C20	yesno:	defb	'all (y/n)?',0
E163: 28792F6E	
E167: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E16A: CD66DE  	type:	call	convfst		;convert file name.
E16D: C211DE  		jp	nz,synerr	;wild cards not allowed.
E170: CD61E0  		call	dselect		;select indicated drive.
E173: CDCFDC  		call	openfcb		;open the file.
E176: CAB4E1  		jp	z,type5		;not there?
E179: CD98DC  		call	crlf		;ok, start a new line on the screen.
E17C: 21FEE3  		ld	hl,nbytes	;initialize byte counter.
E17F: 36FF    		ld	(hl),0ffh	;set to read first sector.
E181: 21FEE3  	type1:	ld	hl,nbytes
E184: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
E185: FE80    		cp	128
E187: DA94E1  		jp	c,type3
E18A: E5      		push	hl		;yes, read in the next one.
E18B: CDFDDC  		call	readfcb
E18E: E1      		pop	hl
E18F: C2ADE1  		jp	nz,type4	;end or error?
E192: AF      		xor	a		;ok, clear byte counter.
E193: 77      		ld	(hl),a
E194: 34      	type3:	inc	(hl)		;count this byte.
E195: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
E198: CD61DE  		call	addhl
E19B: 7E      		ld	a,(hl)
E19C: FE1A    		cp	cntrlz		;end of file mark?
E19E: CA83E3  		jp	z,getback
E1A1: CD8CDC  		call	print		;no, print it.
E1A4: CDCADD  		call	chkcon		;check console, quit if anything ready.
E1A7: C283E3  		jp	nz,getback
E1AA: C381E1  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
E1AD: 3D      	type4:	dec	a		;read error?
E1AE: CA83E3  		jp	z,getback
E1B1: CDE6DF  		call	rderror		;yes, print message.
E1B4: CD73E0  	type5:	call	resetdr		;and reset proper drive
E1B7: C311DE  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E1BA: CD05E0  	save:	call	decode		;get numeric number that follows save.
E1BD: F5      		push	af		;save number of pages to write.
E1BE: CD66DE  		call	convfst		;convert file name.
E1C1: C211DE  		jp	nz,synerr	;wild cards not allowed.
E1C4: CD61E0  		call	dselect		;select specified drive.
E1C7: 11DAE3  		ld	de,fcb		;now delete this file.
E1CA: D5      		push	de
E1CB: CDEEDC  		call	delete
E1CE: D1      		pop	de
E1CF: CD08DD  		call	create		;and create it again.
E1D2: CA08E2  		jp	z,save3		;can't create?
E1D5: AF      		xor	a		;clear record number byte.
E1D6: 32FAE3  		ld	(fcb+32),a
E1D9: F1      		pop	af		;convert pages to sectors.
E1DA: 6F      		ld	l,a
E1DB: 2600    		ld	h,0
E1DD: 29      		add	hl,hl		;(hl)=number of sectors to write.
E1DE: 110001  		ld	de,tbase	;and we start from here.
E1E1: 7C      	save1:	ld	a,h		;done yet?
E1E2: B5      		or	l
E1E3: CAFEE1  		jp	z,save2
E1E6: 2B      		dec	hl		;nope, count this and compute the start
E1E7: E5      		push	hl		;of the next 128 byte sector.
E1E8: 218000  		ld	hl,128
E1EB: 19      		add	hl,de
E1EC: E5      		push	hl		;save it and set the transfer address.
E1ED: CDE0DD  		call	dmaset
E1F0: 11DAE3  		ld	de,fcb		;write out this sector now.
E1F3: CD03DD  		call	wrtrec
E1F6: D1      		pop	de		;reset (de) to the start of the last sector.
E1F7: E1      		pop	hl		;restore sector count.
E1F8: C208E2  		jp	nz,save3	;write error?
E1FB: C3E1E1  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
E1FE: 11DAE3  	save2:	ld	de,fcb		;now close the file.
E201: CDD9DC  		call	close
E204: 3C      		inc	a		;did it close ok?
E205: C20EE2  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
E208: 0114E2  	save3:	ld	bc,nospace
E20B: CDA6DC  		call	pline
E20E: CDDDDD  	save4:	call	stddma		;reset the standard dma address.
E211: C383E3  		jp	getback
E214: 6E6F2073	nospace:defb	'no space',0
E218: 70616365	
E21C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E21D: CD66DE  	rename:	call	convfst		;convert first file name.
E220: C211DE  		jp	nz,synerr	;wild cards not allowed.
E223: 3AFDE3  		ld	a,(chgdrv)	;remember any change in drives specified.
E226: F5      		push	af
E227: CD61E0  		call	dselect		;and select this drive.
E22A: CDE8DC  		call	srchfcb		;is this file present?
E22D: C284E2  		jp	nz,rename6	;yes, print error message.
E230: 21DAE3  		ld	hl,fcb		;yes, move this name into second slot.
E233: 11EAE3  		ld	de,fcb+16
E236: 0610    		ld	b,16
E238: CD4FE0  		call	hl2de
E23B: 2A88DC  		ld	hl,(inpoint)	;get input pointer.
E23E: EB      		ex	de,hl
E23F: CD57DE  		call	nonblank	;get next non blank character.
E242: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
E244: CA4CE2  		jp	z,rename1
E247: FE5F    		cp	'_'
E249: C27EE2  		jp	nz,rename5
E24C: EB      	rename1:ex	de,hl
E24D: 23      		inc	hl		;ok, skip seperator.
E24E: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E251: CD66DE  		call	convfst		;convert this second file name now.
E254: C27EE2  		jp	nz,rename5	;again, no wild cards.
E257: F1      		pop	af		;if a drive was specified, then it
E258: 47      		ld	b,a		;must be the same as before.
E259: 21FDE3  		ld	hl,chgdrv
E25C: 7E      		ld	a,(hl)
E25D: B7      		or	a
E25E: CA65E2  		jp	z,rename2
E261: B8      		cp	b
E262: 70      		ld	(hl),b
E263: 2019    		jr	nz,rename5	;they were different, error.
E265: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
E266: AF      		xor	a
E267: 32DAE3  		ld	(fcb),a		;clear the drive byte of the fcb.
E26A: CDE8DC  	rename3:call	srchfcb		;and go look for second file.
E26D: 2809    		jr	z,rename4	;doesn't exist?
E26F: 11DAE3  		ld	de,fcb
E272: CD0DDD  		call	renam		;ok, rename the file.
E275: C383E3  		jp	getback
              	;
              	;   process rename errors here.
              	;
E278: CDF7DF  	rename4:call	none		;file not there.
E27B: C383E3  		jp	getback
E27E: CD73E0  	rename5:call	resetdr		;bad command format.
E281: C311DE  	synerrt:jp	synerr
E284: 018DE2  	rename6:ld	bc,exists	;destination file already exists.
E287: CDA6DC  		call	pline
E28A: C383E3  		jp	getback
E28D: 66696C65	exists:	defb	'file exists',0
E291: 20657869	
E295: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
E299: CD05E0  	user:	call	decode		;get numeric value following command.
E29C: FE10    		cp	16		;legal user number?
E29E: 30E1    		jr	nc,synerrt
E2A0: 5F      		ld	e,a		;yes but is there anything else?
E2A1: 3ADBE3  		ld	a,(fcb+1)
E2A4: FE20    		cp	' '
E2A6: 28D9    		jr	z,synerrt	;yes, that is not allowed.
E2A8: CD14DD  		call	getsetuc	;ok, set user code.
E2AB: C386E3  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
E2AE: CDFDDD  	unknown:call	verify		;check for valid system (why?).
E2B1: 3ADBE3  		ld	a,(fcb+1)	;anything to execute?
E2B4: FE20    		cp	' '
E2B6: 2014    		jr	nz,unkwn1
E2B8: 3AFDE3  		ld	a,(chgdrv)	;nope, only a drive change?
E2BB: B7      		or	a
E2BC: CA86E3  		jp	z,getback1	;neither???
E2BF: 3D      		dec	a
E2C0: 32FCE3  		ld	(cdrive),a	;ok, store new drive.
E2C3: CD28DD  		call	movecd		;set (tdrive) also.
E2C6: CDBCDC  		call	dsksel		;and select this drive.
E2C9: C386E3  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
E2CC: 11E3E3  	unkwn1:	ld	de,fcb+9	;an extension specified?
E2CF: 1A      		ld	a,(de)
E2D0: FE20    		cp	' '
E2D2: 20AD    		jr	nz,synerrt	;yes, not allowed.
E2D4: D5      	unkwn2:	push	de
E2D5: CD61E0  		call	dselect		;select specified drive.
E2D8: D1      		pop	de
E2D9: 2180E3  		ld	hl,comfile	;set the extension to 'com'.
E2DC: CD4DE0  		call	move3
E2DF: CDCFDC  		call	openfcb		;and open this file.
E2E2: CA69E3  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
E2E5: 210001  		ld	hl,tbase	;store the program starting here.
E2E8: E5      	unkwn3:	push	hl
E2E9: EB      		ex	de,hl
E2EA: CDE0DD  		call	dmaset		;set transfer address.
E2ED: 11DAE3  		ld	de,fcb		;and read the next record.
E2F0: CDF8DC  		call	rdrec
E2F3: 2010    		jr	nz,unkwn4	;end of file or read error?
E2F5: E1      		pop	hl		;nope, bump pointer for next sector.
E2F6: 118000  		ld	de,128
E2F9: 19      		add	hl,de
E2FA: 1100DC  		ld	de,cbase	;enough room for the whole file?
E2FD: 7D      		ld	a,l
E2FE: 93      		sub	e
E2FF: 7C      		ld	a,h
E300: 9A      		sbc	a,d
E301: 306C    		jr	nc,unkwn0	;no, it can't fit.
E303: 18E3    		jr	unkwn3
              	;
              	;   get here after finished reading.
              	;
E305: E1      	unkwn4:	pop	hl
E306: 3D      		dec	a		;normal end of file?
E307: 2066    		jr	nz,unkwn0
E309: CD73E0  		call	resetdr		;yes, reset previous drive.
E30C: CD66DE  		call	convfst		;convert the first file name that follows
E30F: 21FDE3  		ld	hl,chgdrv	;command name.
E312: E5      		push	hl
E313: 7E      		ld	a,(hl)		;set drive code in default fcb.
E314: 32DAE3  		ld	(fcb),a
E317: 3E10    		ld	a,16		;put second name 16 bytes later.
E319: CD68DE  		call	convert		;convert second file name.
E31C: E1      		pop	hl
E31D: 7E      		ld	a,(hl)		;and set the drive for this second file.
E31E: 32EAE3  		ld	(fcb+16),a
E321: AF      		xor	a		;clear record byte in fcb.
E322: 32FAE3  		ld	(fcb+32),a
E325: 115C00  		ld	de,tfcb		;move it into place at(005ch).
E328: 21DAE3  		ld	hl,fcb
E32B: 0621    		ld	b,33
E32D: CD4FE0  		call	hl2de
E330: 2108DC  		ld	hl,inbuff+2	;now move the remainder of the input
E333: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
E334: B7      		or	a		;or a null.
E335: 2807    		jr	z,unkwn6
E337: FE20    		cp	' '
E339: 2803    		jr	z,unkwn6
E33B: 23      		inc	hl
E33C: 18F5    		jr	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
E33E: 0600    	unkwn6:	ld	b,0		;keep a character count.
E340: 118100  		ld	de,tbuff+1	;data gets put here.
E343: 7E      	unkwn7:	ld	a,(hl)		;move it now.
E344: 12      		ld	(de),a
E345: B7      		or	a
E346: 2805    		jr	z,unkwn8
E348: 04      		inc	b
E349: 23      		inc	hl
E34A: 13      		inc	de
E34B: 18F6    		jr	unkwn7
E34D: 78      	unkwn8:	ld	a,b		;now store the character count.
E34E: 328000  		ld	(tbuff),a
E351: CD98DC  		call	crlf		;clean up the screen.
E354: CDDDDD  		call	stddma		;set standard transfer address.
E357: CD19DD  		call	setcdrv		;reset current drive.
E35A: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
E35D: 31B8E3  		ld	sp,batch	;set stack first off.
E360: CD28DD  		call	movecd		;move current drive into place (tdrive).
E363: CDBCDC  		call	dsksel		;and reselect it.
E366: C387DF  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
E369: CD73E0  	unkwn9:	call	resetdr		;inproper format.
E36C: C311DE  		jp	synerr
E36F: 0177E3  	unkwn0:	ld	bc,badload	;read error or won't fit.
E372: CDA6DC  		call	pline
E375: 180C    		jr	getback
E377: 42616420	badload:defb	'Bad load',0
E37B: 6C6F6164	
E37F: 00      	
E380: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
E383: CD73E0  	getback:call	resetdr		;reset previous drive.
E386: CD66DE  	getback1: call	convfst		;convert first name in (fcb).
E389: 3ADBE3  		ld	a,(fcb+1)	;if this was just a drive change request,
E38C: D620    		sub	' '		;make sure it was valid.
E38E: 21FDE3  		ld	hl,chgdrv
E391: B6      		or	(hl)
E392: C211DE  		jp	nz,synerr
E395: C387DF  		jp	cmmnd1		;ok, return to command level.
              		
              	; Small routine to print a decimal 0-19
E398: FE3A    	printdc:cp	':'
E39A: DA8CDC  		jp	c,print
E39D: D60A    		sub	10
E39F: F5      		push	af
E3A0: 3E31    		ld	a,'1'
E3A2: CD8CDC  		call	print
E3A5: F1      		pop	af
E3A6: 18F0    		jr	printdc
              	;
              	;   ccp stack area.
              	;
E3A8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3AC: 00...   	
E3B8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
E3B8: 00      	batch:	defb	0		;batch mode flag (0=not active).
E3B9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3BD: 20202020	
E3C1: 20535542	
E3C5: 00000000	
E3C9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
E3DA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
E3DE: 20202020	
E3E2: 20202020	
E3E6: 00000000	
E3EA: 00202020	
E3EE: 20202020	
E3F2: 20202020	
E3F6: 00000000	
E3FA: 00      	
E3FB: 00      	rtncode:defb	0		;status returned from bdos call.
E3FC: 00      	cdrive:	defb	0		;currently active drive.
E3FD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
E3FE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E400: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E404: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E406: C314E4  	fbase:	jp	fbase1
E409: C33AF2  		jp	boot
              	;
              	;   bdos error table.
              	;
E40C: 9FE4    	badsctr:defw	error1		;bad sector on read or write.
E40E: ABE4    	badslct:defw	error2		;bad disk select.
E410: B1E4    	rodisk:	defw	error3		;disk is read only.
E412: B7E4    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E414: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E415: 224EE7  		ld	(params),hl
E418: EB      		ex	de,hl
E419: 7B      		ld	a,e		;and save register (e) in particular.
E41A: 32E1F1  		ld	(eparam),a
E41D: 210000  		ld	hl,0
E420: 2250E7  		ld	(status),hl	;clear return status.
E423: 39      		add	hl,sp
E424: 221AE7  		ld	(usrstack),hl	;save users stack pointer.
E427: 314CE7  		ld	sp,stkarea	;and set our own.
E42A: AF      		xor	a		;clear auto select storage space.
E42B: 32EBF1  		ld	(autoflag),a
E42E: 32E9F1  		ld	(auto),a
E431: 217FF1  		ld	hl,goback	;set return address.
E434: E5      		push	hl
E435: CD63F3  		call	syshook		; see if anyone wants to intercept the call
E438: 79      		ld	a,c		;get function number.
E439: FE29    		cp	nfuncts		;valid function number?
E43B: D0      		ret	nc
E43C: 4B      		ld	c,e		;keep single register function here.
E43D: 214DE4  		ld	hl,functns	;now look thru the function table.
E440: 5F      		ld	e,a
E441: 1600    		ld	d,0		;(de)=function number.
E443: 19      		add	hl,de
E444: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E445: 5E      		ld	e,(hl)
E446: 23      		inc	hl
E447: 56      		ld	d,(hl)		;now (de)=address for this function.
E448: 2A4EE7  		ld	hl,(params)	;retrieve parameters.
E44B: EB      		ex	de,hl		;now (de) has the original parameters.
E44C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E44D: 48F2D3E6	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E451: 9BE5D9E6	
E455: C9F2C5F2	
E459: DFE6F8E6	
E45D: FEE603E7		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E461: ECE509E7	
E465: 89F08EF0	
E469: 50F0A7F0	
E46D: B0F0B6F0		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E471: D3F0E2F0	
E475: EBF0F1F0	
E479: F7F0    	
E47B: 00F109F1		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E47F: 0FF115F1	
E483: 1CF137E9	
E487: 22F128F1	
E48B: 31F138F1		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E48F: 4CF152F1	
E493: 58F119F0	
E497: 5EF10FE7	
E49B: 0FE7A6F1		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E49F: 21D5E4  	error1:	ld	hl,badsec	;bad sector message.
E4A2: CDF0E4  		call	prterr		;print it and get a 1 char responce.
E4A5: FE03    		cp	cntrlc		;re-boot request (control-c)?
E4A7: CA0000  		jp	z,0		;yes.
E4AA: C9      		ret			;no, return to retry i/o function.
              	;
E4AB: 21E0E4  	error2:	ld	hl,badsel	;bad drive selected.
E4AE: C3BAE4  		jp	error5
              	;
E4B1: 21ECE4  	error3:	ld	hl,diskro	;disk is read only.
E4B4: C3BAE4  		jp	error5
              	;
E4B7: 21E7E4  	error4:	ld	hl,filero	;file is read only.
              	;
E4BA: 3E00    	error5:	ld	a,default
E4BC: 320400  		ld	(tdrive),a
E4BF: CDF0E4  		call	prterr
E4C2: C30000  		jp	0		;always reboot on these errors.
              	;
E4C5: 42646F73	bdoserr:defb	'Bdos Err on '
E4C9: 20457272	
E4CD: 206F6E20	
E4D1: 203A2024	bdosdrv:defb	' : $'
E4D5: 42616420	badsec:	defb	'Bad Sector$'
E4D9: 53656374	
E4DD: 6F7224  	
E4E0: 53656C65	badsel:	defb	'Select$'
E4E4: 637424  	
E4E7: 46696C65	filero:	defb	'File '
E4EB: 20      	
E4EC: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E4F0: E5      	prterr:	push	hl		;save second message pointer.
E4F1: CDD4E5  		call	outcrlf		;send (cr)(lf).
E4F4: 3A4DE7  		ld	a,(active)	;get active drive.
E4F7: C641    		add	a,'A'		;make ascii.
E4F9: 32D1E4  		ld	(bdosdrv),a	;and put in message.
E4FC: 01C5E4  		ld	bc,bdoserr	;and print it.
E4FF: CDDEE5  		call	prtmesg
E502: C1      		pop	bc		;print second message line now.
E503: CDDEE5  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E506: 2119E7  	getchar:ld	hl,charbuf	;check character buffer.
E509: 7E      		ld	a,(hl)		;anything present already?
E50A: 3600    		ld	(hl),0		;...either case clear it.
E50C: B7      		or	a
E50D: C0      		ret	nz		;yes, use it.
E50E: C3ADF2  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E511: CD06E5  	getecho:call	getchar		;input a character.
E514: CD1FE5  		call	chkchar		;carriage control?
E517: D8      		ret	c		;no, a regular control char so don't echo.
E518: F5      		push	af		;ok, save character now.
E519: 4F      		ld	c,a
E51A: CD9BE5  		call	outcon		;and echo it.
E51D: F1      		pop	af		;get character and return.
E51E: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E51F: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E521: C8      		ret	z		;or a tab.
E522: FE0A    		cp	lf
E524: C8      		ret	z
E525: FE09    		cp	tab
E527: C8      		ret	z
E528: FE08    		cp	bs
E52A: C8      		ret	z
E52B: FE20    		cp	' '		;other control char? set carry flag.
E52D: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E52E: 3A19E7  	ckconsol: ld	a,(charbuf)	;check buffer.
E531: B7      		or	a		;if anything, just return without checking.
E532: C250E5  		jp	nz,ckcon2
E535: CDA2F2  		call	const		;nothing in buffer. check console.
E538: E601    		and	01h		;look at bit 0.
E53A: C8      		ret	z		;return if nothing.
E53B: CDADF2  		call	conin		;ok, get it.
E53E: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E540: C24DE5  		jp	nz,ckcon1
E543: CDADF2  		call	conin		;halt processing until another char
E546: FE03    		cp	cntrlc		;is typed. control-c?
E548: CA0000  		jp	z,0		;yes, reboot now.
E54B: AF      		xor	a		;no, just pretend nothing was ever ready.
E54C: C9      		ret	
E54D: 3219E7  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E550: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E552: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E553: 3A15E7  	outchar:ld	a,(outflag)	;check output flag.
E556: B7      		or	a		;anything and we won't generate output.
E557: C26DE5  		jp	nz,outchr1
E55A: C5      		push	bc
E55B: CD2EE5  		call	ckconsol	;check console (we don't care whats there).
E55E: C1      		pop	bc
E55F: C5      		push	bc
E560: CDB9F2  		call	conout		;output (c) to the screen.
E563: C1      		pop	bc
E564: C5      		push	bc
E565: 3A18E7  		ld	a,(prtflag)	;check printer flip-flop flag.
E568: B7      		or	a
E569: C4C5F2  		call	nz,list		;print it also if non-zero.
E56C: C1      		pop	bc
E56D: 79      	outchr1:ld	a,c		;update cursors position.
E56E: 2117E7  		ld	hl,curpos
E571: FE7F    		cp	del		;rubouts don't do anything here.
E573: C8      		ret	z
E574: 34      		inc	(hl)		;bump line pointer.
E575: FE20    		cp	' '		;and return if a normal character.
E577: D0      		ret	nc
E578: 35      		dec	(hl)		;restore and check for the start of the line.
E579: 7E      		ld	a,(hl)
E57A: B7      		or	a
E57B: C8      		ret	z		;ingnore control characters at the start of the line.
E57C: 79      		ld	a,c
E57D: FE08    		cp	bs		;is it a backspace?
E57F: C284E5  		jp	nz,outchr2
E582: 35      		dec	(hl)		;yes, backup pointer.
E583: C9      		ret	
E584: FE0A    	outchr2:cp	lf		;is it a line feed?
E586: C0      		ret	nz		;ignore anything else.
E587: 3600    		ld	(hl),0		;reset pointer to start of line.
E589: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E58A: 79      	showit:	ld	a,c
E58B: CD1FE5  		call	chkchar		;check character.
E58E: D29BE5  		jp	nc,outcon	;not a control, use normal output.
E591: F5      		push	af
E592: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E594: CD53E5  		call	outchar
E597: F1      		pop	af
E598: F640    		or	'@'		;and then use the letter equivelant.
E59A: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E59B: 79      	outcon:	ld	a,c
E59C: FE09    		cp	tab		;is it a tab?
E59E: C253E5  		jp	nz,outchar	;use regular output.
E5A1: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E5A3: CD53E5  		call	outchar
E5A6: 3A17E7  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E5A9: E607    		and	07h		;position.
E5AB: C2A1E5  		jp	nz,outcon1
E5AE: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E5AF: CDB7E5  	backup:	call	backup1		;backup the screen 1 place.
E5B2: 0E20    		ld	c,' '		;then blank that character.
E5B4: CDB9F2  		call	conout
E5B7: 0E08    	backup1:ld	c,bs		;then back space once more.
E5B9: C3B9F2  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E5BC: 0E23    	newline:ld	c,'#'
E5BE: CD53E5  		call	outchar		;print this.
E5C1: CDD4E5  		call	outcrlf		;start new line.
E5C4: 3A17E7  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E5C7: 2116E7  		ld	hl,starting
E5CA: BE      		cp	(hl)
E5CB: D0      		ret	nc		;there yet?
E5CC: 0E20    		ld	c,' '
E5CE: CD53E5  		call	outchar		;nope, keep going.
E5D1: C3C4E5  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E5D4: 0E0D    	outcrlf:ld	c,cr
E5D6: CD53E5  		call	outchar
E5D9: 0E0A    		ld	c,lf
E5DB: C353E5  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E5DE: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E5DF: FE24    		cp	'$'
E5E1: C8      		ret	z
E5E2: 03      		inc	bc
E5E3: C5      		push	bc		;otherwise, bump pointer and print it.
E5E4: 4F      		ld	c,a
E5E5: CD9BE5  		call	outcon
E5E8: C1      		pop	bc
E5E9: C3DEE5  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E5EC: 3A17E7  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E5EF: 3216E7  		ld	(starting),a
E5F2: 2A4EE7  		ld	hl,(params)	;get the maximum buffer space.
E5F5: 4E      		ld	c,(hl)
E5F6: 23      		inc	hl		;point to first available space.
E5F7: E5      		push	hl		;and save.
E5F8: 0600    		ld	b,0		;keep a character count.
E5FA: C5      	rdbuf1:	push	bc
E5FB: E5      		push	hl
E5FC: CD06E5  	rdbuf2:	call	getchar		;get the next input character.
E5FF: E67F    		and	7fh		;strip bit 7.
E601: E1      		pop	hl		;reset registers.
E602: C1      		pop	bc
E603: FE0D    		cp	cr		;en of the line?
E605: CACCE6  		jp	z,rdbuf17
E608: FE0A    		cp	lf
E60A: CACCE6  		jp	z,rdbuf17
E60D: FE08    		cp	bs		;how about a backspace?
E60F: C221E6  		jp	nz,rdbuf3
E612: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E613: B7      		or	a
E614: CAFAE5  		jp	z,rdbuf1
E617: 05      		dec	b		;ok, update counter.
E618: 3A17E7  		ld	a,(curpos)	;if we backspace to the start of the line,
E61B: 3215E7  		ld	(outflag),a	;treat as a cancel (control-x).
E61E: C37BE6  		jp	rdbuf10
E621: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E623: C231E6  		jp	nz,rdbuf4
E626: 78      		ld	a,b		;ignore at the start of the line.
E627: B7      		or	a
E628: CAFAE5  		jp	z,rdbuf1
E62B: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E62C: 05      		dec	b		;and reset pointers (counters).
E62D: 2B      		dec	hl
E62E: C3B4E6  		jp	rdbuf15
E631: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E633: C242E6  		jp	nz,rdbuf5
E636: C5      		push	bc		;yes, do it.
E637: E5      		push	hl
E638: CDD4E5  		call	outcrlf
E63B: AF      		xor	a		;and update starting position.
E63C: 3216E7  		ld	(starting),a
E63F: C3FCE5  		jp	rdbuf2
E642: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E644: C253E6  		jp	nz,rdbuf6
E647: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E648: 2118E7  		ld	hl,prtflag
E64B: 3E01    		ld	a,1		;prtflag=1-prtflag
E64D: 96      		sub	(hl)
E64E: 77      		ld	(hl),a
E64F: E1      		pop	hl
E650: C3FAE5  		jp	rdbuf1
E653: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E655: C26AE6  		jp	nz,rdbuf8
E658: E1      		pop	hl
E659: 3A16E7  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E65C: 2117E7  		ld	hl,curpos
E65F: BE      		cp	(hl)
E660: D2ECE5  		jp	nc,rdbuff	;done yet?
E663: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E664: CDAFE5  		call	backup
E667: C359E6  		jp	rdbuf7
E66A: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E66C: C276E6  		jp	nz,rdbuf9
E66F: CDBCE5  		call	newline		;start a new line.
E672: E1      		pop	hl
E673: C3ECE5  		jp	rdbuff
E676: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E678: C2B1E6  		jp	nz,rdbuf14
E67B: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E67C: CDBCE5  		call	newline
E67F: C1      		pop	bc
E680: E1      		pop	hl
E681: E5      		push	hl
E682: C5      		push	bc
E683: 78      	rdbuf11:ld	a,b		;done whole line yet?
E684: B7      		or	a
E685: CA95E6  		jp	z,rdbuf12
E688: 23      		inc	hl		;nope, get next character.
E689: 4E      		ld	c,(hl)
E68A: 05      		dec	b		;count it.
E68B: C5      		push	bc
E68C: E5      		push	hl
E68D: CD8AE5  		call	showit		;and display it.
E690: E1      		pop	hl
E691: C1      		pop	bc
E692: C383E6  		jp	rdbuf11
E695: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E696: 3A15E7  		ld	a,(outflag)	;then update cursor position.
E699: B7      		or	a
E69A: CAFCE5  		jp	z,rdbuf2
E69D: 2117E7  		ld	hl,curpos	;because this line is shorter, we must
E6A0: 96      		sub	(hl)		;back up the cursor (not the screen however)
E6A1: 3215E7  		ld	(outflag),a	;some number of positions.
E6A4: CDAFE5  	rdbuf13:call	backup		;note that as long as (outflag) is non
E6A7: 2115E7  		ld	hl,outflag	;zero, the screen will not be changed.
E6AA: 35      		dec	(hl)
E6AB: C2A4E6  		jp	nz,rdbuf13
E6AE: C3FCE5  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E6B1: 23      	rdbuf14:inc	hl
E6B2: 77      		ld	(hl),a		;store character.
E6B3: 04      		inc	b		;and count it.
E6B4: C5      	rdbuf15:push	bc
E6B5: E5      		push	hl
E6B6: 4F      		ld	c,a		;echo it now.
E6B7: CD8AE5  		call	showit
E6BA: E1      		pop	hl
E6BB: C1      		pop	bc
E6BC: 7E      		ld	a,(hl)		;was it an abort request?
E6BD: FE03    		cp	cntrlc		;control-c abort?
E6BF: 78      		ld	a,b
E6C0: C2C8E6  		jp	nz,rdbuf16
E6C3: FE01    		cp	1		;only if at start of line.
E6C5: CA0000  		jp	z,0
E6C8: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E6C9: DAFAE5  		jp	c,rdbuf1
E6CC: E1      	rdbuf17:pop	hl		;yes end the line and return.
E6CD: 70      		ld	(hl),b
E6CE: 0E0D    		ld	c,cr
E6D0: C353E5  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E6D3: CD11E5  	getcon:	call	getecho		;get and echo.
E6D6: C30CE7  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E6D9: CDCDF2  	getrdr:	call	reader		;get a character from reader, set status and return.
E6DC: C30CE7  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E6DF: 79      	dircio:	ld	a,c		;test for (ff).
E6E0: 3C      		inc	a
E6E1: CAEBE6  		jp	z,dirc1
E6E4: 3C      		inc	a		;test for (fe).
E6E5: CAA2F2  		jp	z,const
E6E8: C3B9F2  		jp	conout		;just output (c).
E6EB: CDA2F2  	dirc1:	call	const		;this is an input request.
E6EE: B7      		or	a
E6EF: CA9CF1  		jp	z,goback1	;not ready? just return (directly).
E6F2: CDADF2  		call	conin		;yes, get character.
E6F5: C30CE7  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E6F8: 3A0300  	getiob:	ld	a,(iobyte)
E6FB: C30CE7  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E6FE: 210300  	setiob:	ld	hl,iobyte
E701: 71      		ld	(hl),c
E702: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E703: EB      	prtstr:	ex	de,hl
E704: 4D      		ld	c,l
E705: 44      		ld	b,h		;now (bc) points to it.
E706: C3DEE5  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E709: CD2EE5  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E70C: 3250E7  	setstat:ld	(status),a
E70F: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E710: 3E01    	ioerr1:	ld	a,1
E712: C30CE7  		jp	setstat
              	;
E715: 00      	outflag:defb	0		;output flag (non zero means no output).
E716: 02      	starting: defb	2		;starting position for cursor.
E717: 00      	curpos:	defb	0		;cursor position (0=start of line).
E718: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E719: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E71A: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E71C: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E720: 00...   	
E734: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E738: 00...   	
E74C:         	stkarea equ	$		;end of stack area.
              	;
E74C: 00      	userno:	defb	0		;current user number.
E74D: 00      	active:	defb	0		;currently active drive.
E74E: 0000    	params:	defw	0		;save (de) parameters here on entry.
E750: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E752: 210EE4  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E755: 5E      	jumphl:	ld	e,(hl)
E756: 23      		inc	hl
E757: 56      		ld	d,(hl)		;now (de) contain the desired address.
E758: EB      		ex	de,hl
E759: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E75A: 0C      	de2hl:	inc	c		;is count down to zero?
E75B: 0D      	de2hl1:	dec	c
E75C: C8      		ret	z		;yes, we are done.
E75D: 1A      		ld	a,(de)		;no, move one more byte.
E75E: 77      		ld	(hl),a
E75F: 13      		inc	de
E760: 23      		inc	hl
E761: C35BE7  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E764: 3A4DE7  	select:	ld	a,(active)	;get active disk.
E767: 4F      		ld	c,a
E768: CDE0F2  		call	seldsk		;select it.
E76B: 7C      		ld	a,h		;valid drive?
E76C: B5      		or	l		;valid drive?
E76D: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E76E: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E76F: 23      		inc	hl
E770: 56      		ld	d,(hl)
E771: 23      		inc	hl
E772: 22BEF1  		ld	(scratch1),hl	;save pointers to scratch areas.
E775: 23      		inc	hl
E776: 23      		inc	hl
E777: 22C0F1  		ld	(scratch2),hl	;ditto.
E77A: 23      		inc	hl
E77B: 23      		inc	hl
E77C: 22C2F1  		ld	(scratch3),hl	;ditto.
E77F: 23      		inc	hl
E780: 23      		inc	hl
E781: EB      		ex	de,hl		;now save the translation table address.
E782: 22DBF1  		ld	(xlate),hl
E785: 21C4F1  		ld	hl,dirbuf	;put the next 8 bytes here.
E788: 0E08    		ld	c,8		;they consist of the directory buffer
E78A: CD5AE7  		call	de2hl		;pointer, parameter block pointer,
E78D: 2AC6F1  		ld	hl,(diskpb)	;check and allocation vectors.
E790: EB      		ex	de,hl
E791: 21CCF1  		ld	hl,sectors	;move parameter block into our ram.
E794: 0E0F    		ld	c,15		;it is 15 bytes long.
E796: CD5AE7  		call	de2hl
E799: 2AD1F1  		ld	hl,(dsksize)	;check disk size.
E79C: 7C      		ld	a,h		;more than 256 blocks on this?
E79D: 21E8F1  		ld	hl,bigdisk
E7A0: 36FF    		ld	(hl),0ffh	;set to samll.
E7A2: B7      		or	a
E7A3: CAA8E7  		jp	z,select1
E7A6: 3600    		ld	(hl),0		;wrong, set to large.
E7A8: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E7AA: B7      		or	a
E7AB: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E7AC: CDDBF2  	homedrv:call	home		;home the head.
E7AF: AF      		xor	a
E7B0: 2AC0F1  		ld	hl,(scratch2)	;set our track pointer also.
E7B3: 77      		ld	(hl),a
E7B4: 23      		inc	hl
E7B5: 77      		ld	(hl),a
E7B6: 2AC2F1  		ld	hl,(scratch3)	;and our sector pointer.
E7B9: 77      		ld	(hl),a
E7BA: 23      		inc	hl
E7BB: 77      		ld	(hl),a
E7BC: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E7BD: CD0CF3  	doread:	call	read
E7C0: C3C6E7  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E7C3: CD10F3  	dowrite:call	write
E7C6: B7      	ioret:	or	a
E7C7: C8      		ret	z		;return unless an error occured.
E7C8: 210CE4  		ld	hl,badsctr	;bad read/write on this sector.
E7CB: C355E7  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E7CE: 2AF5F1  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E7D1: 0E02    		ld	c,2		;in directory and compute sector #.
E7D3: CDF5E8  		call	shiftr		;sector #=file-position/4.
E7D6: 22F0F1  		ld	(blknmbr),hl	;save this as the block number of interest.
E7D9: 22F7F1  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E7DC: 21F0F1  	trksec1:ld	hl,blknmbr
E7DF: 4E      		ld	c,(hl)		;move sector number into (bc).
E7E0: 23      		inc	hl
E7E1: 46      		ld	b,(hl)
E7E2: 2AC2F1  		ld	hl,(scratch3)	;get current sector number and
E7E5: 5E      		ld	e,(hl)		;move this into (de).
E7E6: 23      		inc	hl
E7E7: 56      		ld	d,(hl)
E7E8: 2AC0F1  		ld	hl,(scratch2)	;get current track number.
E7EB: 7E      		ld	a,(hl)		;and this into (hl).
E7EC: 23      		inc	hl
E7ED: 66      		ld	h,(hl)
E7EE: 6F      		ld	l,a
E7EF: 79      	trksec2:ld	a,c		;is desired sector before current one?
E7F0: 93      		sub	e
E7F1: 78      		ld	a,b
E7F2: 9A      		sbc	a,d
E7F3: D205E8  		jp	nc,trksec3
E7F6: E5      		push	hl		;yes, decrement sectors by one track.
E7F7: 2ACCF1  		ld	hl,(sectors)	;get sectors per track.
E7FA: 7B      		ld	a,e
E7FB: 95      		sub	l
E7FC: 5F      		ld	e,a
E7FD: 7A      		ld	a,d
E7FE: 9C      		sbc	a,h
E7FF: 57      		ld	d,a		;now we have backed up one full track.
E800: E1      		pop	hl
E801: 2B      		dec	hl		;adjust track counter.
E802: C3EFE7  		jp	trksec2
E805: E5      	trksec3:push	hl		;desired sector is after current one.
E806: 2ACCF1  		ld	hl,(sectors)	;get sectors per track.
E809: 19      		add	hl,de		;bump sector pointer to next track.
E80A: DA1AE8  		jp	c,trksec4
E80D: 79      		ld	a,c		;is desired sector now before current one?
E80E: 95      		sub	l
E80F: 78      		ld	a,b
E810: 9C      		sbc	a,h
E811: DA1AE8  		jp	c,trksec4
E814: EB      		ex	de,hl		;not yes, increment track counter
E815: E1      		pop	hl		;and continue until it is.
E816: 23      		inc	hl
E817: C305E8  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E81A: E1      	trksec4:pop	hl		;get track number (hl).
E81B: C5      		push	bc
E81C: D5      		push	de
E81D: E5      		push	hl
E81E: EB      		ex	de,hl
E81F: 2AD9F1  		ld	hl,(offset)	;adjust for first track offset.
E822: 19      		add	hl,de
E823: 44      		ld	b,h
E824: 4D      		ld	c,l
E825: CDFEF2  		call	settrk		;select this track.
E828: D1      		pop	de		;reset current track pointer.
E829: 2AC0F1  		ld	hl,(scratch2)
E82C: 73      		ld	(hl),e
E82D: 23      		inc	hl
E82E: 72      		ld	(hl),d
E82F: D1      		pop	de
E830: 2AC2F1  		ld	hl,(scratch3)	;reset the first sector on this track.
E833: 73      		ld	(hl),e
E834: 23      		inc	hl
E835: 72      		ld	(hl),d
E836: C1      		pop	bc
E837: 79      		ld	a,c		;now subtract the desired one.
E838: 93      		sub	e		;to make it relative (1-# sectors/track).
E839: 4F      		ld	c,a
E83A: 78      		ld	a,b
E83B: 9A      		sbc	a,d
E83C: 47      		ld	b,a
E83D: 2ADBF1  		ld	hl,(xlate)	;translate this sector according to this table.
E840: EB      		ex	de,hl
E841: CD17F3  		call	sectrn		;let the bios translate it.
E844: 4D      		ld	c,l
E845: 44      		ld	b,h
E846: C302F3  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E849: 21CEF1  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E84C: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E84D: 3AEEF1  		ld	a,(savnrec)	;get record number.
E850: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E851: 1F      		rra	
E852: 0D      		dec	c
E853: C250E8  		jp	nz,getblk1
E856: 47      		ld	b,a		;save result in (b).
E857: 3E08    		ld	a,8
E859: 96      		sub	(hl)
E85A: 4F      		ld	c,a		;compute (c)=8-blkshft.
E85B: 3AEDF1  		ld	a,(savext)
E85E: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E85F: CA67E8  		jp	z,getblk3
E862: B7      		or	a
E863: 17      		rla	
E864: C35EE8  		jp	getblk2
E867: 80      	getblk3:add	a,b
E868: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E869: 2A4EE7  	extblk:	ld	hl,(params)	;get fcb address.
E86C: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E86F: 19      		add	hl,de
E870: 09      		add	hl,bc
E871: 3AE8F1  		ld	a,(bigdisk)	;are we using a big-disk?
E874: B7      		or	a
E875: CA7CE8  		jp	z,extblk1
E878: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E879: 2600    		ld	h,0
E87B: C9      		ret	
E87C: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E87D: 5E      		ld	e,(hl)
E87E: 23      		inc	hl
E87F: 56      		ld	d,(hl)
E880: EB      		ex	de,hl		;return in (hl).
E881: C9      		ret	
              	;
              	;   compute block number.
              	;
E882: CD49E8  	comblk:	call	getblock
E885: 4F      		ld	c,a
E886: 0600    		ld	b,0
E888: CD69E8  		call	extblk
E88B: 22F0F1  		ld	(blknmbr),hl
E88E: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E88F: 2AF0F1  	chkblk:	ld	hl,(blknmbr)
E892: 7D      		ld	a,l		;is it zero?
E893: B4      		or	h
E894: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E895: 3ACEF1  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E898: 2AF0F1  		ld	hl,(blknmbr)	;get physical sector desired.
E89B: 29      	logicl1:add	hl,hl		;compute logical sector number.
E89C: 3D      		dec	a		;note logical sectors are 128 bytes long.
E89D: C29BE8  		jp	nz,logicl1
E8A0: 22F2F1  		ld	(logsect),hl	;save logical sector.
E8A3: 3ACFF1  		ld	a,(blkmask)	;get block mask.
E8A6: 4F      		ld	c,a
E8A7: 3AEEF1  		ld	a,(savnrec)	;get next sector to access.
E8AA: A1      		and	c		;extract the relative position within physical block.
E8AB: B5      		or	l		;and add it too logical sector.
E8AC: 6F      		ld	l,a
E8AD: 22F0F1  		ld	(blknmbr),hl	;and store.
E8B0: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E8B1: 2A4EE7  	setext:	ld	hl,(params)
E8B4: 110C00  		ld	de,12		;it is the twelth byte.
E8B7: 19      		add	hl,de
E8B8: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E8B9: 2A4EE7  	sethlde:ld	hl,(params)
E8BC: 110F00  		ld	de,15		;record count byte (#15).
E8BF: 19      		add	hl,de
E8C0: EB      		ex	de,hl
E8C1: 211100  		ld	hl,17		;next record number (#32).
E8C4: 19      		add	hl,de
E8C5: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E8C6: CDB9E8  	strdata:call	sethlde
E8C9: 7E      		ld	a,(hl)		;get and store record count byte.
E8CA: 32EEF1  		ld	(savnrec),a
E8CD: EB      		ex	de,hl
E8CE: 7E      		ld	a,(hl)		;get and store next record number byte.
E8CF: 32ECF1  		ld	(savnxt),a
E8D2: CDB1E8  		call	setext		;point to extent byte.
E8D5: 3AD0F1  		ld	a,(extmask)	;get extent mask.
E8D8: A6      		and	(hl)
E8D9: 32EDF1  		ld	(savext),a	;and save extent here.
E8DC: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E8DD: CDB9E8  	setnrec:call	sethlde
E8E0: 3AE0F1  		ld	a,(mode)	;get sequential flag (=1).
E8E3: FE02    		cp	2		;a 2 indicates that no adder is needed.
E8E5: C2E9E8  		jp	nz,stnrec1
E8E8: AF      		xor	a		;clear adder (random access?).
E8E9: 4F      	stnrec1:ld	c,a
E8EA: 3AEEF1  		ld	a,(savnrec)	;get last record number.
E8ED: 81      		add	a,c		;increment record count.
E8EE: 77      		ld	(hl),a		;and set fcb's next record byte.
E8EF: EB      		ex	de,hl
E8F0: 3AECF1  		ld	a,(savnxt)	;get next record byte from storage.
E8F3: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E8F4: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E8F5: 0C      	shiftr:	inc	c
E8F6: 0D      	shiftr1:dec	c
E8F7: C8      		ret	z
E8F8: 7C      		ld	a,h
E8F9: B7      		or	a
E8FA: 1F      		rra	
E8FB: 67      		ld	h,a
E8FC: 7D      		ld	a,l
E8FD: 1F      		rra	
E8FE: 6F      		ld	l,a
E8FF: C3F6E8  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E902: 0E80    	checksum: ld	c,128		;length of buffer.
E904: 2AC4F1  		ld	hl,(dirbuf)	;get its location.
E907: AF      		xor	a		;clear summation byte.
E908: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E909: 23      		inc	hl
E90A: 0D      		dec	c
E90B: C208E9  		jp	nz,chksum1
E90E: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E90F: 0C      	shiftl:	inc	c
E910: 0D      	shiftl1:dec	c
E911: C8      		ret	z
E912: 29      		add	hl,hl		;shift left 1 bit.
E913: C310E9  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E916: C5      	setbit:	push	bc		;save 16 bit word.
E917: 3A4DE7  		ld	a,(active)	;get active drive.
E91A: 4F      		ld	c,a
E91B: 210100  		ld	hl,1
E91E: CD0FE9  		call	shiftl		;shift bit 0 into place.
E921: C1      		pop	bc		;now 'or' this with the original word.
E922: 79      		ld	a,c
E923: B5      		or	l
E924: 6F      		ld	l,a		;low byte done, do high byte.
E925: 78      		ld	a,b
E926: B4      		or	h
E927: 67      		ld	h,a
E928: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E929: 2AB8F1  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E92C: 3A4DE7  		ld	a,(active)	;which drive is current?
E92F: 4F      		ld	c,a
E930: CDF5E8  		call	shiftr		;shift status such that bit 0 is the
E933: 7D      		ld	a,l		;one of interest for this drive.
E934: E601    		and	01h		;and isolate it.
E936: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E937: 21B8F1  	wrtprtd:ld	hl,wrtprt	;point to status word.
E93A: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E93B: 23      		inc	hl
E93C: 46      		ld	b,(hl)
E93D: CD16E9  		call	setbit		;and set this bit according to current drive.
E940: 22B8F1  		ld	(wrtprt),hl	;then save.
E943: 2AD3F1  		ld	hl,(dirsize)	;now save directory size limit.
E946: 23      		inc	hl		;remember the last one.
E947: EB      		ex	de,hl
E948: 2ABEF1  		ld	hl,(scratch1)	;and store it here.
E94B: 73      		ld	(hl),e		;put low byte.
E94C: 23      		inc	hl
E94D: 72      		ld	(hl),d		;then high byte.
E94E: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E94F: CD69E9  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E952: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E955: 19      		add	hl,de
E956: 7E      		ld	a,(hl)
E957: 17      		rla	
E958: D0      		ret	nc		;return if ok.
E959: 2112E4  		ld	hl,rofile	;else, print error message and terminate.
E95C: C355E7  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E95F: CD29E9  	chkwprt:call	getwprt
E962: C8      		ret	z		;return if ok.
E963: 2110E4  		ld	hl,rodisk	;else print message and terminate.
E966: C355E7  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E969: 2AC4F1  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E96C: 3AF4F1  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E96F: 85      	adda2hl:add	a,l
E970: 6F      		ld	l,a
E971: D0      		ret	nc
E972: 24      		inc	h		;take care of any carry.
E973: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E974: 2A4EE7  	gets2:	ld	hl,(params)	;get address of fcb.
E977: 110E00  		ld	de,14		;relative position of 's2'.
E97A: 19      		add	hl,de
E97B: 7E      		ld	a,(hl)		;extract this byte.
E97C: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E97D: CD74E9  	clears2:call	gets2		;this sets (hl) pointing to it.
E980: 3600    		ld	(hl),0		;now clear it.
E982: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E983: CD74E9  	sets2b7:call	gets2		;get the byte.
E986: F680    		or	80h		;and set bit 7.
E988: 77      		ld	(hl),a		;then store.
E989: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E98A: 2AF5F1  	morefls:ld	hl,(filepos)	;we are here.
E98D: EB      		ex	de,hl
E98E: 2ABEF1  		ld	hl,(scratch1)	;and don't go past here.
E991: 7B      		ld	a,e		;compute difference but don't keep.
E992: 96      		sub	(hl)
E993: 23      		inc	hl
E994: 7A      		ld	a,d
E995: 9E      		sbc	a,(hl)		;set carry if no more names.
E996: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E997: CD8AE9  	chknmbr:call	morefls		;scratch1 too big?
E99A: D8      		ret	c
E99B: 13      		inc	de		;yes, reset it to (filepos).
E99C: 72      		ld	(hl),d
E99D: 2B      		dec	hl
E99E: 73      		ld	(hl),e
E99F: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E9A0: 7B      	subhl:	ld	a,e		;compute difference.
E9A1: 95      		sub	l
E9A2: 6F      		ld	l,a		;store low byte.
E9A3: 7A      		ld	a,d
E9A4: 9C      		sbc	a,h
E9A5: 67      		ld	h,a		;and then high byte.
E9A6: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E9A7: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E9A9: 2AF7F1  	checkdir: ld	hl,(cksumtbl)
E9AC: EB      		ex	de,hl
E9AD: 2AD7F1  		ld	hl,(alloc1)
E9B0: CDA0E9  		call	subhl
E9B3: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E9B4: C5      		push	bc
E9B5: CD02E9  		call	checksum	;else compute checksum.
E9B8: 2AC8F1  		ld	hl,(chkvect)	;get address of checksum table.
E9BB: EB      		ex	de,hl
E9BC: 2AF7F1  		ld	hl,(cksumtbl)
E9BF: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E9C0: C1      		pop	bc
E9C1: 0C      		inc	c		;set or check ?
E9C2: CACFE9  		jp	z,chkdir1
E9C5: BE      		cp	(hl)		;check them.
E9C6: C8      		ret	z		;return if they are the same.
E9C7: CD8AE9  		call	morefls		;not the same, do we care?
E9CA: D0      		ret	nc
E9CB: CD37E9  		call	wrtprtd		;yes, mark this as write protected.
E9CE: C9      		ret	
E9CF: 77      	chkdir1:ld	(hl),a		;just set the byte.
E9D0: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E9D1: CDA7E9  	dirwrite: call	setdir		;set checksum byte.
E9D4: CDEBE9  		call	dirdma		;set directory dma address.
E9D7: 0E01    		ld	c,1		;tell the bios to actually write.
E9D9: CDC3E7  		call	dowrite		;then do the write.
E9DC: C3E5E9  		jp	defdma
              	;
              	;   read from the directory.
              	;
E9DF: CDEBE9  	dirread:call	dirdma		;set the directory dma address.
E9E2: CDBDE7  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E9E5: 21BCF1  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E9E8: C3EEE9  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E9EB: 21C4F1  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E9EE: 4E      	dirdma1:ld	c,(hl)
E9EF: 23      		inc	hl
E9F0: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E9F1: C306F3  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E9F4: 2AC4F1  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E9F7: EB      		ex	de,hl
E9F8: 2ABCF1  		ld	hl,(userdma)	; put it here.
E9FB: 0E80    		ld	c,128		;this is its length.
E9FD: C35AE7  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
EA00: 21F5F1  	ckfilpos: ld	hl,filepos
EA03: 7E      		ld	a,(hl)
EA04: 23      		inc	hl
EA05: BE      		cp	(hl)		;are both bytes the same?
EA06: C0      		ret	nz
EA07: 3C      		inc	a		;yes, but are they each 0ffh?
EA08: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
EA09: 21FFFF  	stfilpos: ld	hl,0ffffh
EA0C: 22F5F1  		ld	(filepos),hl
EA0F: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
EA10: 2AD3F1  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
EA13: EB      		ex	de,hl
EA14: 2AF5F1  		ld	hl,(filepos)	;get current count.
EA17: 23      		inc	hl		;go on to the next one.
EA18: 22F5F1  		ld	(filepos),hl
EA1B: CDA0E9  		call	subhl		;(hl)=(dirsize)-(filepos)
EA1E: D224EA  		jp	nc,nxent1	;is there more room left?
EA21: C309EA  		jp	stfilpos	;no. set this flag and return.
EA24: 3AF5F1  	nxent1:	ld	a,(filepos)	;get file position within directory.
EA27: E603    		and	03h		;only look within this sector (only 4 entries fit).
EA29: 0605    		ld	b,5		;convert to relative position (32 bytes each).
EA2B: 87      	nxent2:	add	a,a		;note that this is not efficient code.
EA2C: 05      		dec	b		;5 'add a's would be better.
EA2D: C22BEA  		jp	nz,nxent2
EA30: 32F4F1  		ld	(fcbpos),a	;save it as position of fcb.
EA33: B7      		or	a
EA34: C0      		ret	nz		;return if we are within buffer.
EA35: C5      		push	bc
EA36: CDCEE7  		call	trksec		;we need the next directory sector.
EA39: CDDFE9  		call	dirread
EA3C: C1      		pop	bc
EA3D: C3A9E9  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
EA40: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
EA41: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
EA43: 3C      		inc	a
EA44: 5F      		ld	e,a		;save particular bit number.
EA45: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
EA46: 79      		ld	a,c
EA47: 0F      		rrca			;now shift right 3 bits.
EA48: 0F      		rrca	
EA49: 0F      		rrca	
EA4A: E61F    		and	1fh		;and clear bits 7,6,5.
EA4C: 4F      		ld	c,a
EA4D: 78      		ld	a,b
EA4E: 87      		add	a,a		;now shift (b) into bits 7,6,5.
EA4F: 87      		add	a,a
EA50: 87      		add	a,a
EA51: 87      		add	a,a
EA52: 87      		add	a,a
EA53: B1      		or	c		;and add in (c).
EA54: 4F      		ld	c,a		;ok, (c) ha been completed.
EA55: 78      		ld	a,b		;is there a better way of doing this?
EA56: 0F      		rrca	
EA57: 0F      		rrca	
EA58: 0F      		rrca	
EA59: E61F    		and	1fh
EA5B: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
EA5C: 2ACAF1  		ld	hl,(alocvect)
EA5F: 09      		add	hl,bc
EA60: 7E      		ld	a,(hl)		;now get correct byte.
EA61: 07      	ckbmap1:rlca			;get correct bit into position 0.
EA62: 1D      		dec	e
EA63: C261EA  		jp	nz,ckbmap1
EA66: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
EA67: D5      	stbitmap: push	de
EA68: CD40EA  		call	ckbitmap	;get the byte of interest.
EA6B: E6FE    		and	0feh		;clear the affected bit.
EA6D: C1      		pop	bc
EA6E: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
EA6F: 0F      	stbmap1:rrca			;restore original bit position.
EA70: 15      		dec	d
EA71: C26FEA  		jp	nz,stbmap1
EA74: 77      		ld	(hl),a		;and stor byte in table.
EA75: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
EA76: CD69E9  	setfile:call	fcb2hl		;get address of fcb
EA79: 111000  		ld	de,16
EA7C: 19      		add	hl,de		;get to block number bytes.
EA7D: C5      		push	bc
EA7E: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
EA80: D1      	setfl1:	pop	de
EA81: 0D      		dec	c		;done all bytes yet?
EA82: C8      		ret	z
EA83: D5      		push	de
EA84: 3AE8F1  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
EA87: B7      		or	a
EA88: CA93EA  		jp	z,setfl2
EA8B: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
EA8C: E5      		push	hl
EA8D: 4E      		ld	c,(hl)		;get low byte from table, always
EA8E: 0600    		ld	b,0		;set high byte to zero.
EA90: C399EA  		jp	setfl3
EA93: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
EA94: C5      		push	bc
EA95: 4E      		ld	c,(hl)		;now get both the low and high bytes.
EA96: 23      		inc	hl
EA97: 46      		ld	b,(hl)
EA98: E5      		push	hl
EA99: 79      	setfl3:	ld	a,c		;block used?
EA9A: B0      		or	b
EA9B: CAA8EA  		jp	z,setfl4
EA9E: 2AD1F1  		ld	hl,(dsksize)	;is this block number within the
EAA1: 7D      		ld	a,l		;space on the disk?
EAA2: 91      		sub	c
EAA3: 7C      		ld	a,h
EAA4: 98      		sbc	a,b
EAA5: D467EA  		call	nc,stbitmap	;yes, set the proper bit.
EAA8: E1      	setfl4:	pop	hl		;point to next block number in fcb.
EAA9: 23      		inc	hl
EAAA: C1      		pop	bc
EAAB: C380EA  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
EAAE: 2AD1F1  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
EAB1: 0E03    		ld	c,3
EAB3: CDF5E8  		call	shiftr		;(hl)=(hl)/8.
EAB6: 23      		inc	hl		;at lease 1 byte.
EAB7: 44      		ld	b,h
EAB8: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
EAB9: 2ACAF1  		ld	hl,(alocvect)	;now zero out the table now.
EABC: 3600    	bitmap1:ld	(hl),0
EABE: 23      		inc	hl
EABF: 0B      		dec	bc
EAC0: 78      		ld	a,b
EAC1: B1      		or	c
EAC2: C2BCEA  		jp	nz,bitmap1
EAC5: 2AD5F1  		ld	hl,(alloc0)	;get initial space used by directory.
EAC8: EB      		ex	de,hl
EAC9: 2ACAF1  		ld	hl,(alocvect)	;and put this into map.
EACC: 73      		ld	(hl),e
EACD: 23      		inc	hl
EACE: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
EACF: CDACE7  		call	homedrv		;now home the drive.
EAD2: 2ABEF1  		ld	hl,(scratch1)
EAD5: 3603    		ld	(hl),3		;force next directory request to read
EAD7: 23      		inc	hl		;in a sector.
EAD8: 3600    		ld	(hl),0
EADA: CD09EA  		call	stfilpos	;clear initial file position also.
EADD: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
EADF: CD10EA  		call	nxentry		;and set checksum byte.
EAE2: CD00EA  		call	ckfilpos	;is there another file?
EAE5: C8      		ret	z
EAE6: CD69E9  		call	fcb2hl		;yes, get its address.
EAE9: 3EE5    		ld	a,0e5h
EAEB: BE      		cp	(hl)		;empty file entry?
EAEC: CADDEA  		jp	z,bitmap2
EAEF: 3A4CE7  		ld	a,(userno)	;no, correct user number?
EAF2: BE      		cp	(hl)
EAF3: C201EB  		jp	nz,bitmap3
EAF6: 23      		inc	hl
EAF7: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
EAF8: D624    		sub	'$'
EAFA: C201EB  		jp	nz,bitmap3
EAFD: 3D      		dec	a		;yes, set atatus to minus one.
EAFE: 3250E7  		ld	(status),a
EB01: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
EB03: CD76EA  		call	setfile
EB06: CD97E9  		call	chknmbr		;keep (scratch1) in bounds.
EB09: C3DDEA  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
EB0C: 3ADFF1  	ststatus: ld	a,(fndstat)
EB0F: C30CE7  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
EB12: C5      	samext:	push	bc
EB13: F5      		push	af
EB14: 3AD0F1  		ld	a,(extmask)	;get extent mask and use it to
EB17: 2F      		cpl			;to compare both extent numbers.
EB18: 47      		ld	b,a		;save resulting mask here.
EB19: 79      		ld	a,c		;mask first extent and save in (c).
EB1A: A0      		and	b
EB1B: 4F      		ld	c,a
EB1C: F1      		pop	af		;now mask second extent and compare
EB1D: A0      		and	b		;with the first one.
EB1E: 91      		sub	c
EB1F: E61F    		and	1fh		;(* only check buts 0-4 *)
EB21: C1      		pop	bc		;the zero flag is set if they are the same.
EB22: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
EB23: 3EFF    	findfst:ld	a,0ffh
EB25: 32DFF1  		ld	(fndstat),a
EB28: 21E3F1  		ld	hl,counter	;save character count.
EB2B: 71      		ld	(hl),c
EB2C: 2A4EE7  		ld	hl,(params)	;get filename to match.
EB2F: 22E4F1  		ld	(savefcb),hl	;and save.
EB32: CD09EA  		call	stfilpos	;clear initial file position (set to 0ffffh).
EB35: CDACE7  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
EB38: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
EB3A: CD10EA  		call	nxentry		;get next filename entry in directory.
EB3D: CD00EA  		call	ckfilpos	;is file position = 0ffffh?
EB40: CA9FEB  		jp	z,fndnxt6	;yes, exit now then.
EB43: 2AE4F1  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
EB46: EB      		ex	de,hl
EB47: 1A      		ld	a,(de)
EB48: FEE5    		cp	0e5h		;empty directory entry?
EB4A: CA55EB  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
EB4D: D5      		push	de
EB4E: CD8AE9  		call	morefls		;more files in directory?
EB51: D1      		pop	de
EB52: D29FEB  		jp	nc,fndnxt6	;no more. exit now.
EB55: CD69E9  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
EB58: 3AE3F1  		ld	a,(counter)	;get number of bytes (characters) to check.
EB5B: 4F      		ld	c,a
EB5C: 0600    		ld	b,0		;initialize byte position counter.
EB5E: 79      	fndnxt2:ld	a,c		;are we done with the compare?
EB5F: B7      		or	a
EB60: CA8EEB  		jp	z,fndnxt5
EB63: 1A      		ld	a,(de)		;no, check next byte.
EB64: FE3F    		cp	'?'		;don't care about this character?
EB66: CA87EB  		jp	z,fndnxt4
EB69: 78      		ld	a,b		;get bytes position in fcb.
EB6A: FE0D    		cp	13		;don't care about the thirteenth byte either.
EB6C: CA87EB  		jp	z,fndnxt4
EB6F: FE0C    		cp	12		;extent byte?
EB71: 1A      		ld	a,(de)
EB72: CA7EEB  		jp	z,fndnxt3
EB75: 96      		sub	(hl)		;otherwise compare characters.
EB76: E67F    		and	7fh
EB78: C238EB  		jp	nz,findnxt	;not the same, check next entry.
EB7B: C387EB  		jp	fndnxt4		;so far so good, keep checking.
EB7E: C5      	fndnxt3:push	bc		;check the extent byte here.
EB7F: 4E      		ld	c,(hl)
EB80: CD12EB  		call	samext
EB83: C1      		pop	bc
EB84: C238EB  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
EB87: 13      	fndnxt4:inc	de		;bump pointers.
EB88: 23      		inc	hl
EB89: 04      		inc	b
EB8A: 0D      		dec	c		;adjust character counter.
EB8B: C35EEB  		jp	fndnxt2
EB8E: 3AF5F1  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
EB91: E603    		and	03h
EB93: 3250E7  		ld	(status),a
EB96: 21DFF1  		ld	hl,fndstat
EB99: 7E      		ld	a,(hl)
EB9A: 17      		rla	
EB9B: D0      		ret	nc
EB9C: AF      		xor	a
EB9D: 77      		ld	(hl),a
EB9E: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
EB9F: CD09EA  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
EBA2: 3EFF    		ld	a,0ffh		;say not located.
EBA4: C30CE7  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
EBA7: CD5FE9  	erafile:call	chkwprt		;is disk write protected?
EBAA: 0E0C    		ld	c,12		;only compare file names.
EBAC: CD23EB  		call	findfst		;get first file name.
EBAF: CD00EA  	erafil1:call	ckfilpos	;any found?
EBB2: C8      		ret	z		;nope, we must be done.
EBB3: CD4FE9  		call	chkrofl		;is file read only?
EBB6: CD69E9  		call	fcb2hl		;nope, get address of fcb and
EBB9: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
EBBB: 0E00    		ld	c,0		;clear the space from the bit map.
EBBD: CD76EA  		call	setfile
EBC0: CDD1E9  		call	dirwrite	;now write the directory sector back out.
EBC3: CD38EB  		call	findnxt		;find the next file name.
EBC6: C3AFEB  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
EBC9: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
EBCA: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
EBCB: 79      	fndspa1:ld	a,c		;is block 0 specified?
EBCC: B0      		or	b
EBCD: CADCEB  		jp	z,fndspa2
EBD0: 0B      		dec	bc		;nope, check previous block.
EBD1: D5      		push	de
EBD2: C5      		push	bc
EBD3: CD40EA  		call	ckbitmap
EBD6: 1F      		rra			;is this block empty?
EBD7: D2F7EB  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
EBDA: C1      		pop	bc		;nope, check some more.
EBDB: D1      		pop	de
              	;
              	;   now look after target block.
              	;
EBDC: 2AD1F1  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
EBDF: 7B      		ld	a,e
EBE0: 95      		sub	l
EBE1: 7A      		ld	a,d
EBE2: 9C      		sbc	a,h
EBE3: D2FFEB  		jp	nc,fndspa4
EBE6: 13      		inc	de		;yes, move on to next one.
EBE7: C5      		push	bc
EBE8: D5      		push	de
EBE9: 42      		ld	b,d
EBEA: 4B      		ld	c,e
EBEB: CD40EA  		call	ckbitmap	;check it.
EBEE: 1F      		rra			;empty?
EBEF: D2F7EB  		jp	nc,fndspa3
EBF2: D1      		pop	de		;nope, continue searching.
EBF3: C1      		pop	bc
EBF4: C3CBEB  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
EBF7: 17      	fndspa3:rla			;reset byte.
EBF8: 3C      		inc	a		;and set bit 0.
EBF9: CD6FEA  		call	stbmap1		;update bit map.
EBFC: E1      		pop	hl		;set return registers.
EBFD: D1      		pop	de
EBFE: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
EBFF: 79      	fndspa4:ld	a,c
EC00: B0      		or	b
EC01: C2CBEB  		jp	nz,fndspa1
EC04: 210000  		ld	hl,0		;set 'not found' status.
EC07: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
EC08: 0E00    	fcbset:	ld	c,0
EC0A: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
EC0C: D5      	update:	push	de
EC0D: 0600    		ld	b,0		;set (bc) to relative byte position.
EC0F: 2A4EE7  		ld	hl,(params)	;get address of fcb.
EC12: 09      		add	hl,bc		;compute starting byte.
EC13: EB      		ex	de,hl
EC14: CD69E9  		call	fcb2hl		;get address of fcb to update in directory.
EC17: C1      		pop	bc		;set (c) to number of bytes to change.
EC18: CD5AE7  		call	de2hl
EC1B: CDCEE7  	update1:call	trksec		;determine the track and sector affected.
EC1E: C3D1E9  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
EC21: CD5FE9  	chgnames: call	chkwprt		;check for a write protected disk.
EC24: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
EC26: CD23EB  		call	findfst		;get first name.
EC29: 2A4EE7  		ld	hl,(params)	;get address of fcb.
EC2C: 7E      		ld	a,(hl)		;get user number.
EC2D: 111000  		ld	de,16		;move over to desired name.
EC30: 19      		add	hl,de
EC31: 77      		ld	(hl),a		;keep same user number.
EC32: CD00EA  	chgnam1:call	ckfilpos	;any matching file found?
EC35: C8      		ret	z		;no, we must be done.
EC36: CD4FE9  		call	chkrofl		;check for read only file.
EC39: 0E10    		ld	c,16		;start 16 bytes into fcb.
EC3B: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
EC3D: CD0CEC  		call	update
EC40: CD38EB  		call	findnxt		;get te next file name.
EC43: C332EC  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
EC46: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
EC48: CD23EB  		call	findfst		;look for first filename.
EC4B: CD00EA  	savatr1:call	ckfilpos	;was one found?
EC4E: C8      		ret	z		;nope, we must be done.
EC4F: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
EC51: 1E0C    		ld	e,12
EC53: CD0CEC  		call	update		;update filename and write directory.
EC56: CD38EB  		call	findnxt		;and get the next file.
EC59: C34BEC  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
EC5C: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
EC5E: CD23EB  		call	findfst		;get the first one in directory.
EC61: CD00EA  		call	ckfilpos	;any at all?
EC64: C8      		ret	z
EC65: CDB1E8  	openit1:call	setext		;point to extent byte within users fcb.
EC68: 7E      		ld	a,(hl)		;and get it.
EC69: F5      		push	af		;save it and address.
EC6A: E5      		push	hl
EC6B: CD69E9  		call	fcb2hl		;point to fcb in directory.
EC6E: EB      		ex	de,hl
EC6F: 2A4EE7  		ld	hl,(params)	;this is the users copy.
EC72: 0E20    		ld	c,32		;move it into users space.
EC74: D5      		push	de
EC75: CD5AE7  		call	de2hl
EC78: CD83E9  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
EC7B: D1      		pop	de		;now get the extent byte from this fcb.
EC7C: 210C00  		ld	hl,12
EC7F: 19      		add	hl,de
EC80: 4E      		ld	c,(hl)		;into (c).
EC81: 210F00  		ld	hl,15		;now get the record count byte into (b).
EC84: 19      		add	hl,de
EC85: 46      		ld	b,(hl)
EC86: E1      		pop	hl		;keep the same extent as the user had originally.
EC87: F1      		pop	af
EC88: 77      		ld	(hl),a
EC89: 79      		ld	a,c		;is it the same as in the directory fcb?
EC8A: BE      		cp	(hl)
EC8B: 78      		ld	a,b		;if yes, then use the same record count.
EC8C: CA96EC  		jp	z,openit2
EC8F: 3E00    		ld	a,0		;if the user specified an extent greater than
EC91: DA96EC  		jp	c,openit2	;the one in the directory, then set record count to 0.
EC94: 3E80    		ld	a,128		;otherwise set to maximum.
EC96: 2A4EE7  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
EC99: 110F00  		ld	de,15
EC9C: 19      		add	hl,de		;compute relative position.
EC9D: 77      		ld	(hl),a		;and set the record count.
EC9E: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
EC9F: 7E      	moveword: ld	a,(hl)		;check for a zero word.
ECA0: 23      		inc	hl
ECA1: B6      		or	(hl)		;both bytes zero?
ECA2: 2B      		dec	hl
ECA3: C0      		ret	nz		;nope, just return.
ECA4: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
ECA5: 77      		ld	(hl),a		;this zero space.
ECA6: 13      		inc	de
ECA7: 23      		inc	hl
ECA8: 1A      		ld	a,(de)
ECA9: 77      		ld	(hl),a
ECAA: 1B      		dec	de		;don't disturb these registers.
ECAB: 2B      		dec	hl
ECAC: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
ECAD: AF      	closeit:xor	a		;clear status and file position bytes.
ECAE: 3250E7  		ld	(status),a
ECB1: 32F5F1  		ld	(filepos),a
ECB4: 32F6F1  		ld	(filepos+1),a
ECB7: CD29E9  		call	getwprt		;get write protect bit for this drive.
ECBA: C0      		ret	nz		;just return if it is set.
ECBB: CD74E9  		call	gets2		;else get the 's2' byte.
ECBE: E680    		and	80h		;and look at bit 7 (file unmodified?).
ECC0: C0      		ret	nz		;just return if set.
ECC1: 0E0F    		ld	c,15		;else look up this file in directory.
ECC3: CD23EB  		call	findfst
ECC6: CD00EA  		call	ckfilpos	;was it found?
ECC9: C8      		ret	z		;just return if not.
ECCA: 011000  		ld	bc,16		;set (hl) pointing to records used section.
ECCD: CD69E9  		call	fcb2hl
ECD0: 09      		add	hl,bc
ECD1: EB      		ex	de,hl
ECD2: 2A4EE7  		ld	hl,(params)	;do the same for users specified fcb.
ECD5: 09      		add	hl,bc
ECD6: 0E10    		ld	c,16		;this many bytes are present in this extent.
ECD8: 3AE8F1  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
ECDB: B7      		or	a
ECDC: CAF3EC  		jp	z,closeit4
ECDF: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
ECE0: B7      		or	a
ECE1: 1A      		ld	a,(de)		;now get one from directory fcb.
ECE2: C2E6EC  		jp	nz,closeit2
ECE5: 77      		ld	(hl),a		;users byte was zero. update from directory.
ECE6: B7      	closeit2: or	a
ECE7: C2ECEC  		jp	nz,closeit3
ECEA: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
ECEB: 12      		ld	(de),a
ECEC: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
ECED: C22AED  		jp	nz,closeit7	;then close error if they are not the same.
ECF0: C308ED  		jp	closeit5	;ok so far, get to next byte in fcbs.
ECF3: CD9FEC  	closeit4: call	moveword	;update users fcb if it is zero.
ECF6: EB      		ex	de,hl
ECF7: CD9FEC  		call	moveword	;update directories fcb if it is zero.
ECFA: EB      		ex	de,hl
ECFB: 1A      		ld	a,(de)		;if these two values are no different,
ECFC: BE      		cp	(hl)		;then a close error occured.
ECFD: C22AED  		jp	nz,closeit7
ED00: 13      		inc	de		;check second byte.
ED01: 23      		inc	hl
ED02: 1A      		ld	a,(de)
ED03: BE      		cp	(hl)
ED04: C22AED  		jp	nz,closeit7
ED07: 0D      		dec	c		;remember 16 bit values.
ED08: 13      	closeit5: inc	de		;bump to next item in table.
ED09: 23      		inc	hl
ED0A: 0D      		dec	c		;there are 16 entries only.
ED0B: C2D8EC  		jp	nz,closeit1	;continue if more to do.
ED0E: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
ED11: 09      		add	hl,bc
ED12: EB      		ex	de,hl
ED13: 09      		add	hl,bc
ED14: 1A      		ld	a,(de)
ED15: BE      		cp	(hl)		;directory's extent already greater than the
ED16: DA22ED  		jp	c,closeit6	;users extent?
ED19: 77      		ld	(hl),a		;no, update directory extent.
ED1A: 010300  		ld	bc,3		;and update the record count byte in
ED1D: 09      		add	hl,bc		;directories fcb.
ED1E: EB      		ex	de,hl
ED1F: 09      		add	hl,bc
ED20: 7E      		ld	a,(hl)		;get from user.
ED21: 12      		ld	(de),a		;and put in directory.
ED22: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
ED24: 32DDF1  		ld	(closeflg),a
ED27: C31BEC  		jp	update1		;update the directory now.
ED2A: 2150E7  	closeit7: ld	hl,status	;set return status and then return.
ED2D: 35      		dec	(hl)
ED2E: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
ED2F: CD5FE9  	getempty: call	chkwprt		;make sure disk is not write protected.
ED32: 2A4EE7  		ld	hl,(params)	;save current parameters (fcb).
ED35: E5      		push	hl
ED36: 21B7F1  		ld	hl,emptyfcb	;use special one for empty space.
ED39: 224EE7  		ld	(params),hl
ED3C: 0E01    		ld	c,1		;search for first empty spot in directory.
ED3E: CD23EB  		call	findfst		;(* only check first byte *)
ED41: CD00EA  		call	ckfilpos	;none?
ED44: E1      		pop	hl
ED45: 224EE7  		ld	(params),hl	;restore original fcb address.
ED48: C8      		ret	z		;return if no more space.
ED49: EB      		ex	de,hl
ED4A: 210F00  		ld	hl,15		;point to number of records for this file.
ED4D: 19      		add	hl,de
ED4E: 0E11    		ld	c,17		;and clear all of this space.
ED50: AF      		xor	a
ED51: 77      	getmt1:	ld	(hl),a
ED52: 23      		inc	hl
ED53: 0D      		dec	c
ED54: C251ED  		jp	nz,getmt1
ED57: 210D00  		ld	hl,13		;clear the 's1' byte also.
ED5A: 19      		add	hl,de
ED5B: 77      		ld	(hl),a
ED5C: CD97E9  		call	chknmbr		;keep (scratch1) within bounds.
ED5F: CD08EC  		call	fcbset		;write out this fcb entry to directory.
ED62: C383E9  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
ED65: AF      	getnext:xor	a
ED66: 32DDF1  		ld	(closeflg),a	;clear close flag.
ED69: CDADEC  		call	closeit		;close this extent.
ED6C: CD00EA  		call	ckfilpos
ED6F: C8      		ret	z		;not there???
ED70: 2A4EE7  		ld	hl,(params)	;get extent byte.
ED73: 010C00  		ld	bc,12
ED76: 09      		add	hl,bc
ED77: 7E      		ld	a,(hl)		;and increment it.
ED78: 3C      		inc	a
ED79: E61F    		and	1fh		;keep within range 0-31.
ED7B: 77      		ld	(hl),a
ED7C: CA8EED  		jp	z,gtnext1	;overflow?
ED7F: 47      		ld	b,a		;mask extent byte.
ED80: 3AD0F1  		ld	a,(extmask)
ED83: A0      		and	b
ED84: 21DDF1  		ld	hl,closeflg	;check close flag (0ffh is ok).
ED87: A6      		and	(hl)
ED88: CA99ED  		jp	z,gtnext2	;if zero, we must read in next extent.
ED8B: C3B7ED  		jp	gtnext3		;else, it is already in memory.
ED8E: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
ED91: 09      		add	hl,bc
ED92: 34      		inc	(hl)		;and bump it.
ED93: 7E      		ld	a,(hl)		;too many extents?
ED94: E60F    		and	0fh
ED96: CAC1ED  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
ED99: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
ED9B: CD23EB  		call	findfst		;find the first one.
ED9E: CD00EA  		call	ckfilpos	;none available?
EDA1: C2B7ED  		jp	nz,gtnext3
EDA4: 3ADEF1  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
EDA7: 3C      		inc	a		;0ffh means reading (so not possible).
EDA8: CAC1ED  		jp	z,gtnext5	;or an error.
EDAB: CD2FED  		call	getempty	;we are writing, get an empty entry.
EDAE: CD00EA  		call	ckfilpos	;none?
EDB1: CAC1ED  		jp	z,gtnext5	;error if true.
EDB4: C3BAED  		jp	gtnext4		;else we are almost done.
EDB7: CD65EC  	gtnext3:call	openit1		;open this extent.
EDBA: CDC6E8  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
EDBD: AF      		xor	a		;clear status and return.
EDBE: C30CE7  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
EDC1: CD10E7  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
EDC4: C383E9  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
EDC7: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
EDC9: 32E0F1  		ld	(mode),a
EDCC: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
EDCE: 32DEF1  		ld	(rdwrtflg),a
EDD1: CDC6E8  		call	strdata		;put rec# and ext# into fcb.
EDD4: 3AEEF1  		ld	a,(savnrec)	;get next record to read.
EDD7: 21ECF1  		ld	hl,savnxt	;get number of records in extent.
EDDA: BE      		cp	(hl)		;within this extent?
EDDB: DAF1ED  		jp	c,rdseq2
EDDE: FE80    		cp	128		;no. is this extent fully used?
EDE0: C206EE  		jp	nz,rdseq3	;no. end-of-file.
EDE3: CD65ED  		call	getnext		;yes, open the next one.
EDE6: AF      		xor	a		;reset next record to read.
EDE7: 32EEF1  		ld	(savnrec),a
EDEA: 3A50E7  		ld	a,(status)	;check on open, successful?
EDED: B7      		or	a
EDEE: C206EE  		jp	nz,rdseq3	;no, error.
EDF1: CD82E8  	rdseq2:	call	comblk		;ok. compute block number to read.
EDF4: CD8FE8  		call	chkblk		;check it. within bounds?
EDF7: CA06EE  		jp	z,rdseq3	;no, error.
EDFA: CD95E8  		call	logical		;convert (blknmbr) to logical sector (128 byte).
EDFD: CDDCE7  		call	trksec1		;set the track and sector for this block #.
EE00: CDBDE7  		call	doread		;and read it.
EE03: C3DDE8  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EE06: C310E7  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EE09: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EE0B: 32E0F1  		ld	(mode),a
EE0E: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EE10: 32DEF1  		ld	(rdwrtflg),a
EE13: CD5FE9  		call	chkwprt		;check write protect status.
EE16: 2A4EE7  		ld	hl,(params)
EE19: CD52E9  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EE1C: CDC6E8  		call	strdata		;put updated data into fcb.
EE1F: 3AEEF1  		ld	a,(savnrec)	;get record number to write.
EE22: FE80    		cp	128		;within range?
EE24: D210E7  		jp	nc,ioerr1	;no, error(?).
EE27: CD82E8  		call	comblk		;compute block number.
EE2A: CD8FE8  		call	chkblk		;check number.
EE2D: 0E00    		ld	c,0		;is there one to write to?
EE2F: C279EE  		jp	nz,wtseq6	;yes, go do it.
EE32: CD49E8  		call	getblock	;get next block number within fcb to use.
EE35: 32E2F1  		ld	(relblock),a	;and save.
EE38: 010000  		ld	bc,0		;start looking for space from the start
EE3B: B7      		or	a		;if none allocated as yet.
EE3C: CA46EE  		jp	z,wtseq2
EE3F: 4F      		ld	c,a		;extract previous block number from fcb
EE40: 0B      		dec	bc		;so we can be closest to it.
EE41: CD69E8  		call	extblk
EE44: 44      		ld	b,h
EE45: 4D      		ld	c,l
EE46: CDC9EB  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EE49: 7D      		ld	a,l		;check for a zero number.
EE4A: B4      		or	h
EE4B: C253EE  		jp	nz,wtseq3
EE4E: 3E02    		ld	a,2		;no more space?
EE50: C30CE7  		jp	setstat
EE53: 22F0F1  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EE56: EB      		ex	de,hl		;put block number into (de).
EE57: 2A4EE7  		ld	hl,(params)	;now we must update the fcb for this
EE5A: 011000  		ld	bc,16		;newly allocated block.
EE5D: 09      		add	hl,bc
EE5E: 3AE8F1  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EE61: B7      		or	a
EE62: 3AE2F1  		ld	a,(relblock)	;(* update this entry *)
EE65: CA6FEE  		jp	z,wtseq4	;zero means 16 bit ones.
EE68: CD6FE9  		call	adda2hl		;(hl)=(hl)+(a)
EE6B: 73      		ld	(hl),e		;store new block number.
EE6C: C377EE  		jp	wtseq5
EE6F: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EE70: 0600    		ld	b,0
EE72: 09      		add	hl,bc
EE73: 09      		add	hl,bc
EE74: 73      		ld	(hl),e		;stuff block number (de) there.
EE75: 23      		inc	hl
EE76: 72      		ld	(hl),d
EE77: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EE79: 3A50E7  	wtseq6:	ld	a,(status)	;are we ok so far?
EE7C: B7      		or	a
EE7D: C0      		ret	nz
EE7E: C5      		push	bc		;yes, save write flag for bios (register c).
EE7F: CD95E8  		call	logical		;convert (blknmbr) over to loical sectors.
EE82: 3AE0F1  		ld	a,(mode)	;get access mode flag (1=sequential,
EE85: 3D      		dec	a		;0=random, 2=special?).
EE86: 3D      		dec	a
EE87: C2C6EE  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EE8A: C1      		pop	bc
EE8B: C5      		push	bc
EE8C: 79      		ld	a,c		;get write status flag (2=writing unused space).
EE8D: 3D      		dec	a
EE8E: 3D      		dec	a
EE8F: C2C6EE  		jp	nz,wtseq9
EE92: E5      		push	hl
EE93: 2AC4F1  		ld	hl,(dirbuf)	;zero out the directory buffer.
EE96: 57      		ld	d,a		;note that (a) is zero here.
EE97: 77      	wtseq7:	ld	(hl),a
EE98: 23      		inc	hl
EE99: 14      		inc	d		;do 128 bytes.
EE9A: F297EE  		jp	p,wtseq7
EE9D: CDEBE9  		call	dirdma		;tell the bios the dma address for directory access.
EEA0: 2AF2F1  		ld	hl,(logsect)	;get sector that starts current block.
EEA3: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EEA5: 22F0F1  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EEA8: C5      		push	bc
EEA9: CDDCE7  		call	trksec1		;determine its track and sector numbers.
EEAC: C1      		pop	bc
EEAD: CDC3E7  		call	dowrite		;now write out 128 bytes of zeros.
EEB0: 2AF0F1  		ld	hl,(blknmbr)	;get sector number.
EEB3: 0E00    		ld	c,0		;set normal write flag.
EEB5: 3ACFF1  		ld	a,(blkmask)	;determine if we have written the entire
EEB8: 47      		ld	b,a		;physical block.
EEB9: A5      		and	l
EEBA: B8      		cp	b
EEBB: 23      		inc	hl		;prepare for the next one.
EEBC: C2A5EE  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EEBF: E1      		pop	hl		;reset next sector number.
EEC0: 22F0F1  		ld	(blknmbr),hl
EEC3: CDE5E9  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EEC6: CDDCE7  	wtseq9:	call	trksec1		;determine track and sector for this write.
EEC9: C1      		pop	bc		;get write status flag.
EECA: C5      		push	bc
EECB: CDC3E7  		call	dowrite		;and write this out.
EECE: C1      		pop	bc
EECF: 3AEEF1  		ld	a,(savnrec)	;get number of records in file.
EED2: 21ECF1  		ld	hl,savnxt	;get last record written.
EED5: BE      		cp	(hl)
EED6: DADDEE  		jp	c,wtseq10
EED9: 77      		ld	(hl),a		;we have to update record count.
EEDA: 34      		inc	(hl)
EEDB: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EEDD: 00      	wtseq10:nop			;was 'dcr c'
EEDE: 00      		nop			;was 'dcr c'
EEDF: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EEE2: F5      		push	af
EEE3: CD74E9  		call	gets2		;set 'extent written to' flag.
EEE6: E67F    		and	7fh		;(* clear bit 7 *)
EEE8: 77      		ld	(hl),a
EEE9: F1      		pop	af		;get record count for this extent.
EEEA: FE7F    	wtseq99:cp	127		;is it full?
EEEC: C20BEF  		jp	nz,wtseq12
EEEF: 3AE0F1  		ld	a,(mode)	;yes, are we in sequential mode?
EEF2: FE01    		cp	1
EEF4: C20BEF  		jp	nz,wtseq12
EEF7: CDDDE8  		call	setnrec		;yes, set next record number.
EEFA: CD65ED  		call	getnext		;and get next empty space in directory.
EEFD: 2150E7  		ld	hl,status	;ok?
EF00: 7E      		ld	a,(hl)
EF01: B7      		or	a
EF02: C209EF  		jp	nz,wtseq11
EF05: 3D      		dec	a		;yes, set record count to -1.
EF06: 32EEF1  		ld	(savnrec),a
EF09: 3600    	wtseq11:ld	(hl),0		;clear status.
EF0B: C3DDE8  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EF0E: AF      	position: xor	a		;set random i/o flag.
EF0F: 32E0F1  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EF12: C5      	positn1:push	bc		;save read/write flag.
EF13: 2A4EE7  		ld	hl,(params)	;get address of fcb.
EF16: EB      		ex	de,hl
EF17: 212100  		ld	hl,33		;now get byte 'r0'.
EF1A: 19      		add	hl,de
EF1B: 7E      		ld	a,(hl)
EF1C: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EF1E: F5      		push	af
EF1F: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF20: 17      		rla	
EF21: 23      		inc	hl
EF22: 7E      		ld	a,(hl)
EF23: 17      		rla	
EF24: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EF26: 4F      		ld	c,a		;this is the extent byte.
EF27: 7E      		ld	a,(hl)		;now get the extra extent byte.
EF28: 1F      		rra	
EF29: 1F      		rra	
EF2A: 1F      		rra	
EF2B: 1F      		rra	
EF2C: E60F    		and	0fh
EF2E: 47      		ld	b,a		;and save it in (b).
EF2F: F1      		pop	af		;get record number back to (a).
EF30: 23      		inc	hl		;check overflow byte 'r2'.
EF31: 6E      		ld	l,(hl)
EF32: 2C      		inc	l
EF33: 2D      		dec	l
EF34: 2E06    		ld	l,6		;prepare for error.
EF36: C296EF  		jp	nz,positn5	;out of disk space error.
EF39: 212000  		ld	hl,32		;store record number into fcb.
EF3C: 19      		add	hl,de
EF3D: 77      		ld	(hl),a
EF3E: 210C00  		ld	hl,12		;and now check the extent byte.
EF41: 19      		add	hl,de
EF42: 79      		ld	a,c
EF43: 96      		sub	(hl)		;same extent as before?
EF44: C252EF  		jp	nz,positn2
EF47: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EF4A: 19      		add	hl,de
EF4B: 78      		ld	a,b
EF4C: 96      		sub	(hl)
EF4D: E67F    		and	7fh
EF4F: CA8AEF  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EF52: C5      	positn2:push	bc
EF53: D5      		push	de
EF54: CDADEC  		call	closeit		;close current extent.
EF57: D1      		pop	de
EF58: C1      		pop	bc
EF59: 2E03    		ld	l,3		;prepare for error.
EF5B: 3A50E7  		ld	a,(status)
EF5E: 3C      		inc	a
EF5F: CA8FEF  		jp	z,positn4	;close error.
EF62: 210C00  		ld	hl,12		;put desired extent into fcb now.
EF65: 19      		add	hl,de
EF66: 71      		ld	(hl),c
EF67: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EF6A: 19      		add	hl,de
EF6B: 70      		ld	(hl),b
EF6C: CD5CEC  		call	openit		;try and get this extent.
EF6F: 3A50E7  		ld	a,(status)	;was it there?
EF72: 3C      		inc	a
EF73: C28AEF  		jp	nz,positn3
EF76: C1      		pop	bc		;no. can we create a new one (writing?).
EF77: C5      		push	bc
EF78: 2E04    		ld	l,4		;prepare for error.
EF7A: 0C      		inc	c
EF7B: CA8FEF  		jp	z,positn4	;nope, reading unwritten space error.
EF7E: CD2FED  		call	getempty	;yes we can, try to find space.
EF81: 2E05    		ld	l,5		;prepare for error.
EF83: 3A50E7  		ld	a,(status)
EF86: 3C      		inc	a
EF87: CA8FEF  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EF8A: C1      	positn3:pop	bc		;restore stack.
EF8B: AF      		xor	a		;and clear error code byte.
EF8C: C30CE7  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EF8F: E5      	positn4:push	hl
EF90: CD74E9  		call	gets2
EF93: 36C0    		ld	(hl),0c0h
EF95: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EF96: C1      	positn5:pop	bc
EF97: 7D      		ld	a,l		;get error code.
EF98: 3250E7  		ld	(status),a
EF9B: C383E9  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EF9E: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EFA0: CD0EEF  		call	position	;position the file to proper record.
EFA3: CCCCED  		call	z,rdseq1	;and read it as usual (if no errors).
EFA6: C9      		ret	
              	;
              	;   write to a random record.
              	;
EFA7: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EFA9: CD0EEF  		call	position	;position the file to proper record.
EFAC: CC0EEE  		call	z,wtseq1	;and write as usual (if no errors).
EFAF: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EFB0: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EFB1: 19      		add	hl,de		;compute relative position of record #.
EFB2: 4E      		ld	c,(hl)		;get record number into (bc).
EFB3: 0600    		ld	b,0
EFB5: 210C00  		ld	hl,12		;now get extent.
EFB8: 19      		add	hl,de
EFB9: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EFBA: 0F      		rrca			;move lower bit into bit 7.
EFBB: E680    		and	80h		;and ignore all other bits.
EFBD: 81      		add	a,c		;add to our record number.
EFBE: 4F      		ld	c,a
EFBF: 3E00    		ld	a,0		;take care of any carry.
EFC1: 88      		adc	a,b
EFC2: 47      		ld	b,a
EFC3: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EFC4: 0F      		rrca			;bit positions 0-3.
EFC5: E60F    		and	0fh		;and ignore all others.
EFC7: 80      		add	a,b		;add this in to 'r1' byte.
EFC8: 47      		ld	b,a
EFC9: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EFCC: 19      		add	hl,de
EFCD: 7E      		ld	a,(hl)
EFCE: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EFCF: 87      		add	a,a
EFD0: 87      		add	a,a
EFD1: 87      		add	a,a
EFD2: F5      		push	af		;save carry flag (bit 0 of flag byte).
EFD3: 80      		add	a,b		;now add extra extent into 'r1'.
EFD4: 47      		ld	b,a
EFD5: F5      		push	af		;and save carry (overflow byte 'r2').
EFD6: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EFD7: 7D      		ld	a,l
EFD8: E1      		pop	hl		;and same for first carry flag.
EFD9: B5      		or	l		;either one of these set?
EFDA: E601    		and	01h		;only check the carry flags.
EFDC: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EFDD: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EFDF: CD23EB  		call	findfst		;this name.
EFE2: 2A4EE7  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EFE5: 112100  		ld	de,33
EFE8: 19      		add	hl,de
EFE9: E5      		push	hl
EFEA: 72      		ld	(hl),d		;note that (d)=0.
EFEB: 23      		inc	hl
EFEC: 72      		ld	(hl),d
EFED: 23      		inc	hl
EFEE: 72      		ld	(hl),d
EFEF: CD00EA  	ransiz1:call	ckfilpos	;is there an extent to process?
EFF2: CA17F0  		jp	z,ransiz3	;no, we are done.
EFF5: CD69E9  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EFF8: 110F00  		ld	de,15		;point to last record in extent.
EFFB: CDB0EF  		call	comprand	;and compute random parameters.
EFFE: E1      		pop	hl
EFFF: E5      		push	hl		;now check these values against those
F000: 5F      		ld	e,a		;already in fcb.
F001: 79      		ld	a,c		;the carry flag will be set if those
F002: 96      		sub	(hl)		;in the fcb represent a larger size than
F003: 23      		inc	hl		;this extent does.
F004: 78      		ld	a,b
F005: 9E      		sbc	a,(hl)
F006: 23      		inc	hl
F007: 7B      		ld	a,e
F008: 9E      		sbc	a,(hl)
F009: DA11F0  		jp	c,ransiz2
F00C: 73      		ld	(hl),e		;we found a larger (in size) extent.
F00D: 2B      		dec	hl		;stuff these values into fcb.
F00E: 70      		ld	(hl),b
F00F: 2B      		dec	hl
F010: 71      		ld	(hl),c
F011: CD38EB  	ransiz2:call	findnxt		;now get the next extent.
F014: C3EFEF  		jp	ransiz1		;continue til all done.
F017: E1      	ransiz3:pop	hl		;we are done, restore the stack and
F018: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F019: 2A4EE7  	setran:	ld	hl,(params)	;point to fcb.
F01C: 112000  		ld	de,32		;and to last used record.
F01F: CDB0EF  		call	comprand	;compute random position.
F022: 212100  		ld	hl,33		;now stuff these values into fcb.
F025: 19      		add	hl,de
F026: 71      		ld	(hl),c		;move 'r0'.
F027: 23      		inc	hl
F028: 70      		ld	(hl),b		;and 'r1'.
F029: 23      		inc	hl
F02A: 77      		ld	(hl),a		;and lastly 'r2'.
F02B: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F02C: 2ABAF1  	logindrv: ld	hl,(login)	;get the login vector.
F02F: 3A4DE7  		ld	a,(active)	;get the default drive.
F032: 4F      		ld	c,a
F033: CDF5E8  		call	shiftr		;position active bit for this drive
F036: E5      		push	hl		;into bit 0.
F037: EB      		ex	de,hl
F038: CD64E7  		call	select		;select this drive.
F03B: E1      		pop	hl
F03C: CC52E7  		call	z,slcterr	;valid drive?
F03F: 7D      		ld	a,l		;is this a newly activated drive?
F040: 1F      		rra	
F041: D8      		ret	c
F042: 2ABAF1  		ld	hl,(login)	;yes, update the login vector.
F045: 4D      		ld	c,l
F046: 44      		ld	b,h
F047: CD16E9  		call	setbit
F04A: 22BAF1  		ld	(login),hl	;and save.
F04D: C3AEEA  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
F050: 3AE1F1  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
F053: 214DE7  		ld	hl,active	;represents a change in drives.
F056: BE      		cp	(hl)
F057: C8      		ret	z
F058: 77      		ld	(hl),a		;yes it does, log it in.
F059: C32CF0  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
F05C: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
F05E: 32E9F1  		ld	(auto),a
F061: 2A4EE7  		ld	hl,(params)	;get drive specified.
F064: 7E      		ld	a,(hl)
F065: E61F    		and	1fh		;look at lower 5 bits.
F067: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
F068: 32E1F1  		ld	(eparam),a	;and save for the select routine.
F06B: FE1E    		cp	1eh		;check for 'no change' condition.
F06D: D280F0  		jp	nc,autosl1	;yes, don't change.
F070: 3A4DE7  		ld	a,(active)	;we must change, save currently active
F073: 32EAF1  		ld	(olddrv),a	;drive.
F076: 7E      		ld	a,(hl)		;and save first byte of fcb also.
F077: 32EBF1  		ld	(autoflag),a	;this must be non-zero.
F07A: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
F07C: 77      		ld	(hl),a		;something)?
F07D: CD50F0  		call	setdsk		;select and log in this drive.
F080: 3A4CE7  	autosl1:ld	a,(userno)	;move user number into fcb.
F083: 2A4EE7  		ld	hl,(params)	;(* upper half of first byte *)
F086: B6      		or	(hl)
F087: 77      		ld	(hl),a
F088: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
F089: 3E22    	getver:	ld	a,022h		;version 2.2
F08B: C30CE7  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
F08E: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
F091: 22B8F1  		ld	(wrtprt),hl	;in vector.
F094: 22BAF1  		ld	(login),hl
F097: AF      		xor	a		;select drive 'a'.
F098: 324DE7  		ld	(active),a
F09B: 218000  		ld	hl,tbuff	;setup default dma address.
F09E: 22BCF1  		ld	(userdma),hl
F0A1: CDE5E9  		call	defdma
F0A4: C32CF0  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
F0A7: CD7DE9  	openfil:call	clears2		;clear 's2' byte.
F0AA: CD5CF0  		call	autosel		;select proper disk.
F0AD: C35CEC  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
F0B0: CD5CF0  	closefil: call	autosel		;select proper disk.
F0B3: C3ADEC  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F0B6: 0E00    	getfst:	ld	c,0		;prepare for special search.
F0B8: EB      		ex	de,hl
F0B9: 7E      		ld	a,(hl)		;is first byte a '?'?
F0BA: FE3F    		cp	'?'
F0BC: CACDF0  		jp	z,getfst1	;yes, just get very first entry (zero length match).
F0BF: CDB1E8  		call	setext		;get the extension byte from fcb.
F0C2: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
F0C3: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
F0C5: C47DE9  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
F0C8: CD5CF0  		call	autosel		;select proper drive.
F0CB: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
F0CD: CD23EB  	getfst1:call	findfst		;find an entry and then move it into
F0D0: C3F4E9  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
F0D3: 2AE4F1  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
F0D6: 224EE7  		ld	(params),hl	;other dbos calls are allowed.
F0D9: CD5CF0  		call	autosel		;no error will be returned, but the
F0DC: CD38EB  		call	findnxt		;results will be wrong.
F0DF: C3F4E9  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
F0E2: CD5CF0  	delfile:call	autosel		;select proper drive.
F0E5: CDA7EB  		call	erafile		;erase the file.
F0E8: C30CEB  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
F0EB: CD5CF0  	readseq:call	autosel		;select proper drive then read.
F0EE: C3C7ED  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
F0F1: CD5CF0  	wrtseq:	call	autosel		;select proper drive then write.
F0F4: C309EE  		jp	wtseq
              	;
              	;   create a file function.
              	;
F0F7: CD7DE9  	fcreate:call	clears2		;clear the 's2' byte on all creates.
F0FA: CD5CF0  		call	autosel		;select proper drive and get the next
F0FD: C32FED  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
F100: CD5CF0  	renfile:call	autosel		;select proper drive and then switch
F103: CD21EC  		call	chgnames	;file names.
F106: C30CEB  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
F109: 2ABAF1  	getlog:	ld	hl,(login)
F10C: C334F1  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
F10F: 3A4DE7  	getcrnt:ld	a,(active)
F112: C30CE7  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
F115: EB      	putdma:	ex	de,hl
F116: 22BCF1  		ld	(userdma),hl	;save in our space and then get to
F119: C3E5E9  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
F11C: 2ACAF1  	getaloc:ld	hl,(alocvect)
F11F: C334F1  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
F122: 2AB8F1  	getrov:	ld	hl,(wrtprt)
F125: C334F1  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
F128: CD5CF0  	setattr:call	autosel		;select proper drive then save attributes.
F12B: CD46EC  		call	saveattr
F12E: C30CEB  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
F131: 2AC6F1  	getparm:ld	hl,(diskpb)
F134: 2250E7  	getprm1:ld	(status),hl
F137: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
F138: 3AE1F1  	getuser:ld	a,(eparam)	;get parameter.
F13B: FEFF    		cp	0ffh		;get user number?
F13D: C246F1  		jp	nz,setuser
F140: 3A4CE7  		ld	a,(userno)	;yes, just do it.
F143: C30CE7  		jp	setstat
F146: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
F148: 324CE7  		ld	(userno),a	;bits (0-4) only.
F14B: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
F14C: CD5CF0  	rdrandom: call	autosel		;select proper drive and read.
F14F: C39EEF  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
F152: CD5CF0  	wtrandom: call	autosel		;select proper drive and write.
F155: C3A7EF  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
F158: CD5CF0  	filesize: call	autosel		;select proper drive and check file length
F15B: C3DDEF  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
F15E: 2A4EE7  	logoff:	ld	hl,(params)	;get drives to log off.
F161: 7D      		ld	a,l		;for each bit that is set, we want
F162: 2F      		cpl			;to clear that bit in (login)
F163: 5F      		ld	e,a		;and (wrtprt).
F164: 7C      		ld	a,h
F165: 2F      		cpl	
F166: 2ABAF1  		ld	hl,(login)	;reset the login vector.
F169: A4      		and	h
F16A: 57      		ld	d,a
F16B: 7D      		ld	a,l
F16C: A3      		and	e
F16D: 5F      		ld	e,a
F16E: 2AB8F1  		ld	hl,(wrtprt)
F171: EB      		ex	de,hl
F172: 22BAF1  		ld	(login),hl	;and save.
F175: 7D      		ld	a,l		;now do the write protect vector.
F176: A3      		and	e
F177: 6F      		ld	l,a
F178: 7C      		ld	a,h
F179: A2      		and	d
F17A: 67      		ld	h,a
F17B: 22B8F1  		ld	(wrtprt),hl	;and save. all done.
F17E: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
F17F: 3AE9F1  	goback:	ld	a,(auto)	;was auto select activated?
F182: B7      		or	a
F183: CA9CF1  		jp	z,goback1
F186: 2A4EE7  		ld	hl,(params)	;yes, but was a change made?
F189: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
F18B: 3AEBF1  		ld	a,(autoflag)
F18E: B7      		or	a
F18F: CA9CF1  		jp	z,goback1
F192: 77      		ld	(hl),a		;yes, reset first byte properly.
F193: 3AEAF1  		ld	a,(olddrv)	;and get the old drive and select it.
F196: 32E1F1  		ld	(eparam),a
F199: CD50F0  		call	setdsk
F19C: 2A1AE7  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
F19F: F9      		ld	sp,hl
F1A0: 2A50E7  		ld	hl,(status)	;get return status.
F1A3: 7D      		ld	a,l		;force version 1.4 compatability.
F1A4: 44      		ld	b,h
F1A5: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F1A6: CD5CF0  	wtspecl:call	autosel		;select proper drive.
F1A9: 3E02    		ld	a,2		;use special write mode.
F1AB: 32E0F1  		ld	(mode),a
F1AE: 0E00    		ld	c,0		;set write indicator.
F1B0: CD12EF  		call	positn1		;position the file.
F1B3: CC0EEE  		call	z,wtseq1	;and write (if no errors).
F1B6: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
F1B7: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
F1B8: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
F1BA: 0000    	login:	defw	0		;drive active word (1 bit per drive).
F1BC: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
F1BE: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
F1C0: 0000    	scratch2: defw	0		;last selected track number.
F1C2: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
F1C4: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
F1C6: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
F1C8: 0000    	chkvect:defw	0		;address of check vector.
F1CA: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
F1CC: 0000    	sectors:defw	0		;sectors per track from bios.
F1CE: 00      	blkshft:defb	0		;block shift.
F1CF: 00      	blkmask:defb	0		;block mask.
F1D0: 00      	extmask:defb	0		;extent mask.
F1D1: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
F1D3: 0000    	dirsize:defw	0		;directory size.
F1D5: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
F1D7: 0000    	alloc1:	defw	0
F1D9: 0000    	offset:	defw	0		;first usable track number.
F1DB: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
F1DD: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
F1DE: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
F1DF: 00      	fndstat:defb	0		;filename found status (0=found first entry).
F1E0: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
F1E1: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
F1E2: 00      	relblock: defb	0		;relative position within fcb of block number written.
F1E3: 00      	counter:defb	0		;byte counter for directory name searches.
F1E4: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
F1E8: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
F1E9: 00      	auto:	defb	0		;if non-zero, then auto select activated.
F1EA: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
F1EB: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
F1EC: 00      	savnxt:	defb	0		;storage for next record number to access.
F1ED: 00      	savext:	defb	0		;storage for extent number of file.
F1EE: 0000    	savnrec:defw	0		;storage for number of records in file.
F1F0: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
F1F2: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
F1F4: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
F1F5: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
F1F7: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F1FB: 00...   	
              	
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS. 
              	;*
              	;**************************************************************
              	;
F207: C33AF2  		jp	boot
F20A: C348F2  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
F20D: C3A2F2  		jp	const
F210: C3ADF2  		jp	conin
F213: C3B9F2  		jp	conout
F216: C3C5F2  		jp	list
F219: C3C9F2  		jp	punch
F21C: C3CDF2  		jp	reader
F21F: C3DBF2  		jp	home
F222: C3E0F2  		jp	seldsk
F225: C3FEF2  		jp	settrk
F228: C302F3  		jp	setsec
F22B: C306F3  		jp	setdma
F22E: C30CF3  		jp	read
F231: C310F3  		jp	write
F234: C314F3  		jp	prstat
F237: C317F3  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
F23A: 3100DC  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
F23D: CD5FF2  		call	wbootr
              		
              		; Special conditions for a cold boot
F240: CD5AF3  		call	cbinit
              	
              		; Jump to CP/M
F243: 0E00    		ld	c,default
F245: C300DC  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
F248: 3100DC  	wboot:	ld	sp,cbase
              	
              		; Save current drive + user
F24B: 3A0400  		ld	a,(tdrive)
F24E: F5      		push	af
              	
              		; Save IOBYTE
F24F: 3A0300  		ld	a,(iobyte)
F252: F5      		push	af
              	
              		; Warm boot
F253: CD5FF2  		call	wbootr
              		
              		; Restore IOBYTE
F256: F1      		pop	af
F257: 320300  		ld	(iobyte),a
              		
              		; Restore tdrive and warm boot
F25A: F1      		pop	af
F25B: 4F      		ld	c,a
F25C: C300DC  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
F25F: F3      	wbootr:	di
              		
              		; Zero out BSS
F260: AF      		xor	a
F261: 2195FA  		ld	hl,_TEXT_end
F264: 77      		ld	(hl),a
F265: 1196FA  		ld	de,_TEXT_end+1
F268: 017201  		ld	bc,_BSS_size
F26B: EDB0    		ldir
              	
              		; Send init signals to all devices
F26D: 0600    		ld	b,0
F26F: C5      	wboot0:	push	bc
F270: 216AF3  		ld	hl,bdevsw
F273: 78      		ld	a,b
F274: CD29F3  		call	swindir
F277: AF      		xor	a
F278: 14      		inc	d
F279: CC46F3  		call	z,callmj
F27C: C1      		pop	bc
F27D: 04      		inc	b
F27E: 3E14    		ld	a,20
F280: B8      		cp	b
F281: 20EC    		jr	nz,wboot0
              	
              		; Turn off batch mode
F283: 3E00    		ld	a,0
F285: 32B8E3  		ld	(batch),a
              	
              		; Load the CCP
F288: CD64F3  		call	resccp
              	
              		; Call config init
F28B: CD4BF3  		call	wbinit
              		
              		; Set up lower memory
F28E: 219AF2  		ld	hl,cpmlow
F291: 110000  		ld	de,0
F294: 010800  		ld	bc,8
F297: EDB0    		ldir
              	
              	
              		; Return
F299: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
F29A: C30AF2  	cpmlow:	jp	wbootin	; Call jump table version instead
F29D: 81      		defb	0x81	; Default IOBYTE
F29E: 00      		defb	0	; Default drive
F29F: C302E4  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
F2A2: 0600    	const:	ld	b,0
F2A4: CD1AF3  		call	cdindir
F2A7: 14      		inc	d
F2A8: C0      		ret	nz
F2A9: 3C      		inc	a
F2AA: C346F3  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
F2AD: 0600    	conin:	ld	b,0
F2AF: CD1AF3  		call	cdindir
F2B2: 14      		inc	d
F2B3: C0      		ret	nz
F2B4: 3E02    		ld	a,2
F2B6: C346F3  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
F2B9: 0600    	conout:	ld	b,0
F2BB: CD1AF3  	chrout:	call	cdindir
F2BE: 14      		inc	d
F2BF: C0      		ret	nz
F2C0: 3E03    		ld	a,3
F2C2: C346F3  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
F2C5: 0606    	list:	ld	b,6
F2C7: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
F2C9: 0604    	punch:	ld	b,4
F2CB: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
F2CD: 0602    	reader:	ld	b,2
F2CF: CD1AF3  		call	cdindir
F2D2: 14      		inc	d
F2D3: 3E1A    		ld	a,0x1A
F2D5: C0      		ret	nz
F2D6: 3E02    		ld	a,2
F2D8: C346F3  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
F2DB: 3E01    	home:	ld	a,1
F2DD: C3F8F2  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
F2E0: 79      	seldsk:	ld	a,c
F2E1: 43      		ld	b,e
F2E2: 216AF3  		ld	hl,bdevsw
F2E5: CD29F3  		call	swindir
F2E8: 22F9F2  		ld	(callbd+1),hl
F2EB: 210000  		ld	hl,0
F2EE: 14      		inc	d
F2EF: C0      		ret	nz
F2F0: 2A47F3  		ld	hl,(callmj+1)
F2F3: 22FCF2  		ld	(callbd+4),hl
F2F6: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
F2F8: 21      	callbd:	defb	0x21
F2F9: 0000    		defw	0
F2FB: C3      		defb	0xC3
F2FC: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
F2FE: 3E03    	settrk:	ld	a,3
F300: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
F302: 3E04    	setsec:	ld	a,4
F304: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
F306: 60      	setdma:	ld	h,b
F307: 69      		ld	l,c
F308: 2249F3  		ld	(biodma),hl
F30B: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
F30C: 3E05    	read:	ld	a,5
F30E: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
F310: 3E06    	write:	ld	a,6
F312: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
F314: 3EFF    	prstat:	ld	a,0xFF
F316: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
F317: 60      	sectrn:	ld	h,b
F318: 69      		ld	l,c
F319: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
F31A: 04      	cdindir:inc	b
F31B: 3A0300  		ld	a,(iobyte)
F31E: 05      	cdindi0:dec	b
F31F: 2803    		jr	z,cdindi1
F321: 1F      		rra
F322: 18FA    		jr	cdindi0
F324: E603    	cdindi1:and	0x03
F326: 21AAF3  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
F329: 110400  	swindir:ld	de,4
F32C: B7      		or	a
F32D: 2804    	swindi0:jr	z,swindi1
F32F: 19      		add	hl,de
F330: 3D      		dec	a
F331: 18FA    		jr	swindi0
F333: 7E      	swindi1:ld	a,(hl)
F334: 3247F3  		ld	(callmj+1),a
F337: 23      		inc	hl
F338: B6      		or	(hl)
F339: C8      		ret	z
F33A: 7E      		ld	a,(hl)
F33B: 3248F3  		ld	(callmj+2),a
F33E: 23      		inc	hl
F33F: 7E      		ld	a,(hl)
F340: 23      		inc	hl
F341: 66      		ld	h,(hl)
F342: 6F      		ld	l,a
F343: 16FF    		ld	d,255
F345: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
F346: C3      	callmj: defb	0xC3
F347: 0000    		defw	0
              	
              	
              	
              	; Variables
F349: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff.
              	;*
              	;**************************************************************
              	;
              	
F34B: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
F34D: D300    		out	(0x00),a
              	
              		; Turn on batch mode
F34F: 3EFF    		ld	a,0xFF
F351: 32B8E3  		ld	(batch),a
              		
              		; Also set interrupt mode 2 stuff
F354: ED47    		ld	i,a
F356: ED5E    		im	2		; Start interrupts
F358: FB      		ei
              		
F359: C9      		ret
              		
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
F35A: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
F35C: 3207DC  		ld	(inbuff+1),a
F35F: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
F360: FB      	cfirq:	ei
F361: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
F363: C9      	syshook:ret
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
F364: C316F8  	resccp:	jp	nd_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
F367: C31BF8  	resgrb:	jp	nd_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F36A: 58F70000	bdevsw:	defw	ndkdev,	0	; 'A'
F36E: 58F70100		defw	ndkdev,	1	; 'B'
F372: 00000000		defw	0,	0	; 'C'
F376: 00000000		defw	0,	0	; 'D'
F37A: 00000000		defw	0,	0	; 'E'
F37E: 00000000		defw	0,	0	; 'F'
F382: 00000000		defw	0,	0	; 'G'
F386: 00000000		defw	0,	0	; 'H'
F38A: 00000000		defw	0,	0	; 'I'
F38E: 00000000		defw	0,	0	; 'J'
F392: 00000000		defw	0,	0	; 'K'
F396: 00000000		defw	0,	0	; 'L'
F39A: 00000000		defw	0,	0	; 'M'
F39E: 00000000		defw	0,	0	; 'N'
F3A2: 00000000		defw	0,	0	; 'O'
F3A6: 00000000		defw	0,	0	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F3AA: 07FA0000	cdevsw:	defw	siodev,	0	; TTY device
F3AE: BAF30000		defw	vdpdev,	0	; Console device
F3B2: DDF90000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
F3B6: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FA95: 00      	tm_outc:defs	1	; Output character
FA96: 00      	tm_scro:defs	1	; Scroll width
FA97: 00      	tm_escs:defs	1	; Escape state
FA98: 00      	tm_last:defs	1	; Last character read
FA99: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
FA9D: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
0040:         	tm_ayda	equ	0x40	; AY-3-8910 data port
0041:         	tm_atla	equ	0x41	; AY-3-8910 latch port
              	
              	; --- VRAM MAP ---
              	; 0x0000 - 0x07FF: Font
              	; 0x0800 - 0x0BFF: 40 column screen buffer
              	; 0x0C00 - 0x0FFF: Unused
              	; 0x1000 - 0x17FF: 80 column screen buffer
              	;
              	; Serial #
              	; 0x17FE: 0xE5
              	; 0x17FF: 0x81
              	
              	
              	; Driver jump table
F3BA: B7      	vdpdev:	or	a
F3BB: 2839    		jr	z,tm_init
F3BD: 3D      		dec	a
F3BE: 2819    		jr	z,tm_stat
F3C0: 3D      		dec	a
F3C1: CA98F4  		jp	z,tm_read
F3C4: C3EAF4  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F3C7: F5      	tm_otir:push	af
F3C8: 7E      	tm_oti0:ld	a,(hl)
F3C9: ED79    		out	(c),a
F3CB: 23      		inc	hl
F3CC: 10FA    		djnz	tm_oti0
F3CE: F1      		pop	af
F3CF: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F3D0: F5      	tm_inir:push	af
F3D1: ED78    	tm_inr0:in	a,(c)
F3D3: 77      		ld	(hl),a
F3D4: 23      		inc	hl
F3D5: 10FA    		djnz	tm_inr0
F3D7: F1      		pop	af
F3D8: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
F3D9: 3A98FA  	tm_stat:ld	a,(tm_last)
F3DC: FEE4    		cp	0xE4
F3DE: 2871    		jr	z,tm_scri
F3E0: FEE5    		cp	0xE5
F3E2: 287F    		jr	z,tm_sclf
F3E4: 3A95FA  	tm_sta0:ld	a,(tm_outc)
F3E7: 3C      		inc	a
F3E8: 3EFF    		ld	a,0xFF
F3EA: C0      		ret	nz
F3EB: CD1EF6  		call	tm_getc
F3EE: 3295FA  		ld	(tm_outc),a
F3F1: 3C      		inc	a
F3F2: C8      		ret	z
F3F3: 3EFF    		ld	a,0xFF
F3F5: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
F3F6: CD67F3  	tm_init:call	resgrb
              	
              		; Set up registers
F3F9: CD6DF4  		call	tm_setp
              		
              		; Set up interrupt vectors (if needed)
F3FC: 2109F7  		ld	hl,tm_virq
F3FF: 2206FF  		ld	(intvec+6),hl
F402: 213CF6  		ld	hl,tm_kirq
F405: 2204FF  		ld	(intvec+4),hl
              		
              		; Set TMS pattern generator block to 0
F408: DBA1    		in	a,(tm_latc)
F40A: AF      		xor	a
F40B: D3A1    		out	(tm_latc),a
F40D: 3E84    		ld	a,0x84
F40F: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F411: 010040  		ld	bc,0x4000
F414: CDFEF6  		call	tm_addr
F417: 2100DC  		ld	hl,cbase
F41A: 0EA0    		ld	c,tm_data
F41C: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F41E: 0600    	tm_ini0:ld	b,0
F420: CDC7F3  		call	tm_otir
F423: 3D      		dec	a
F424: 20F8    		jr	nz,tm_ini0
              		
              		; Cold boot?
F426: 3A28F7  		ld	a,(tm_cold)
F429: B7      		or	a
F42A: 2012    		jr	nz,tm_ini1
              		
              		; Check serial #
F42C: 01FE17  		ld	bc,0x17FE
F42F: CDFEF6  		call	tm_addr
F432: ED78    		in	a,(c)
F434: FEE5    		cp	0xE5
F436: 2006    		jr	nz,tm_ini1
F438: ED78    		in	a,(c)
F43A: FE81    		cp	0x81
F43C: 280D    		jr	z,tm_cloc
              		
              		; Reset the terminal
F43E: CDE1F6  	tm_ini1:call	tm_cls
F441: AF      		xor	a
F442: 3226F7  		ld	(tm_curx),a
F445: 3227F7  		ld	(tm_cury),a
F448: 3228F7  		ld	(tm_cold),a
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F44B: 3EFF    	tm_cloc:ld	a,0xFF
F44D: 3295FA  		ld	(tm_outc),a
              	
F450: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F451: 3A96FA  	tm_scri:ld	a,(tm_scro)
F454: B7      		or	a
F455: FE28    		cp	40
F457: 2808    		jr	z,tm_scr1
F459: C604    		add	a,4
F45B: 3296FA  	tm_scr0:ld	(tm_scro),a
F45E: CDBEF6  		call	tm_usco
F461: 1881    	tm_scr1:jr	tm_sta0
F463: 3A96FA  	tm_sclf:ld	a,(tm_scro)
F466: B7      		or	a
F467: 28F8    		jr	z,tm_scr1
F469: D604    		sub	4
F46B: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
F46D: 2A21F7  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
F470: DBA1    		in	a,(tm_latc)
F472: 7C      		ld	a,h
F473: D3A1    		out	(tm_latc),a
F475: 3E80    		ld	a,0x80
F477: D3A1    		out	(tm_latc),a
F479: DBA1    		in	a,(tm_latc)
F47B: 3EF0    		ld	a,0xF0
F47D: D3A1    		out	(tm_latc),a
F47F: 3E81    		ld	a,0x81
F481: D3A1    		out	(tm_latc),a
              		
              		; Set TMS color
F483: DBA1    		in	a,(tm_latc)
F485: 3A23F7  		ld	a,(tm_colr)
F488: D3A1    		out	(tm_latc),a
F48A: 3E87    		ld	a,0x87
F48C: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F48E: DBA1    		in	a,(tm_latc)
F490: 7D      		ld	a,l
F491: D3A1    		out	(tm_latc),a
F493: 3E82    		ld	a,0x82
F495: D3A1    		out	(tm_latc),a
F497: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F498: 3A26F7  	tm_read:ld	a,(tm_curx)
F49B: 4F      		ld	c,a
F49C: 3A27F7  		ld	a,(tm_cury)
F49F: 57      		ld	d,a
F4A0: 210010  		ld	hl,0x1000
F4A3: 3E50    		ld	a,80
F4A5: CD9AF6  		call	tm_chat
F4A8: DBA0    		in	a,(tm_data)	; char is in A
F4AA: 57      		ld	d,a		; char key
F4AB: 5F      		ld	e,a		; blinking char
F4AC: 0601    		ld	b,1
              		
F4AE: D5      	tm_rea0:push	de
F4AF: CDD9F3  		call	tm_stat
F4B2: D1      		pop	de
F4B3: 3C      		inc	a
F4B4: 200D    		jr	nz,tm_rea1
F4B6: 5A      		ld	e,d
F4B7: CDD3F4  		call	tm_rea2
F4BA: 3A95FA  		ld	a,(tm_outc)
F4BD: 47      		ld	b,a
F4BE: CD4BF4  		call	tm_cloc
F4C1: 78      		ld	a,b
F4C2: C9      		ret
              		
F4C3: CDE1F4  	tm_rea1:call	tm_stal
F4C6: 10E6    		djnz	tm_rea0
F4C8: 3E80    		ld	a,0x80
F4CA: AB      		xor	e
F4CB: 5F      		ld	e,a
F4CC: CDD3F4  		call	tm_rea2
F4CF: 06BE    		ld	b,190
F4D1: 18DB    		jr	tm_rea0
              	
              	
F4D3: D5      	tm_rea2:push	de
F4D4: 3A26F7  		ld	a,(tm_curx)
F4D7: 4F      		ld	c,a
F4D8: 3A27F7  		ld	a,(tm_cury)
F4DB: 57      		ld	d,a
F4DC: CD76F6  		call	tm_putc
F4DF: D1      		pop	de
F4E0: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F4E1: C5      	tm_stal:push	bc
F4E2: 06FF    		ld	b,255
F4E4: C5      	tm_sta1:push	bc
F4E5: C1      		pop	bc
F4E6: 10FC    		djnz	tm_sta1
F4E8: C1      		pop	bc
F4E9: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F4EA: CD0FF7  	tm_writ:call	tm_dint
F4ED: 59      		ld	e,c
F4EE: 3A26F7  		ld	a,(tm_curx)
F4F1: 4F      		ld	c,a
F4F2: 3A27F7  		ld	a,(tm_cury)
F4F5: 57      		ld	d,a
F4F6: CD05F5  		call	tm_wri0
F4F9: 78      		ld	a,b
F4FA: 3227F7  		ld	(tm_cury),a
F4FD: 79      		ld	a,c
F4FE: 3226F7  		ld	(tm_curx),a
F501: CD18F7  		call	tm_eint
F504: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F505: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F506: 3A97FA  		ld	a,(tm_escs)
F509: B7      		or	a		; Process escape code
F50A: C272F5  		jp	nz,tm_esc
F50D: 3E1F    		ld	a,0x1F
F50F: BB      		cp	e
F510: D244F5  		jp	nc,tm_wri1	; Process control code
F513: C5      		push	bc
F514: CD76F6  		call	tm_putc		; Write character
F517: C1      		pop	bc
              		
              		; Increment character
F518: 0C      	tm_ri	inc	c
F519: 3E50    		ld	a,80
F51B: B9      		cp	c
F51C: C0      		ret	nz
F51D: AF      		xor	a
F51E: 4F      		ld	c,a
F51F: 04      	tm_lf:  inc	b	; Line feed
F520: 3E18    		ld	a,24
F522: B8      		cp	b
F523: C0      		ret	nz
F524: C5      		push	bc
F525: CDF8F5  		call	tm_dsco
F528: C1      		pop	bc
F529: 05      		dec	b
F52A: C9      		ret
F52B: AF      	tm_cr:	xor	a	; Carriage return
F52C: 4F      		ld	c,a
F52D: C9      		ret
F52E: 0D      	tm_bs:	dec	c	; Backspace 
F52F: F0      		ret	p
F530: 0E4F    		ld	c,79
F532: 05      		dec	b
F533: F0      		ret	p
F534: AF      		xor	a
F535: 47      		ld	b,a
F536: 4F      		ld	c,a
F537: C9      		ret
F538: AF      	tm_up:	xor	a	; Move up
F539: B8      		cp	b
F53A: C8      		ret	z
F53B: 05      		dec	b
F53C: C9      		ret
F53D: CDE1F6  	tm_cshm:call	tm_cls
F540: AF      	tm_home:xor	a
F541: 47      		ld	b,a
F542: 4F      		ld	c,a
F543: C9      		ret
              	
F544: 7B      	tm_wri1:ld	a,e
F545: FE08    		cp	0x08	; '\b' (Cursor left)
F547: 28E5    		jr	z,tm_bs
F549: FE12    		cp	0x12	; Cursor right
F54B: 28CB    		jr	z,tm_ri
F54D: FE0A    		cp	0x0A	; '\n' (Cursor down)
F54F: 28CE    		jr	z,tm_lf
F551: FE0B    		cp	0x0B	; Cursor up
F553: 28E3    		jr	z,tm_up
F555: FE0D    		cp	0x0D	; '\r' 
F557: 28D2    		jr	z,tm_cr
F559: FE17    		cp	0x17	; Clear end of screen
F55B: 2856    		jr	z,tm_cles
F55D: FE18    		cp	0x18	; Clear end of line
F55F: 2854    		jr	z,tm_clea
F561: FE1A    		cp	0x1A	; Clear screen, home cursor
F563: 28D8    		jr	z,tm_cshm
F565: FE1E    		cp	0x1E	; Home cursor
F567: 28D7    		jr	z,tm_home
F569: FE1B    		cp	0x1B	; Escape
F56B: C0      		ret	nz
F56C: 3E01    		ld	a,1
F56E: 3297FA  		ld	(tm_escs),a
F571: C9      		ret
              		
              		; Handle escape sequence
F572: 3D      	tm_esc:	dec	a
F573: 280E    		jr	z,tm_esc0
F575: 3D      		dec	a
F576: 2825    		jr	z,tm_esc1
F578: 3D      		dec	a
F579: 282D    		jr	z,tm_esc2
F57B: 3D      		dec	a
F57C: 2871    		jr	z,tm_updc
F57E: AF      	tm_escd:xor	a	; Escape done
F57F: 3297FA  	tm_escr:ld	(tm_escs),a
F582: C9      		ret
F583: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
F585: BB      		cp	e
F586: 2850    		jr	z,tm_40c
F588: 3EFE    		ld	a,0xFE	; Do 80-col
F58A: BB      		cp	e
F58B: 2858    		jr	z,tm_80c
F58D: 3EFD    		ld	a,0xFD	; Set color
F58F: BB      		cp	e
F590: 2859    		jr	z,tm_scol
F592: 3E3D    		ld	a,0x3D	; '='
F594: BB      		cp	e
F595: 20E7    		jr	nz,tm_escd
F597: 3A97FA  	tm_esci:ld	a,(tm_escs)
F59A: 3C      		inc	a
F59B: 18E2    		jr	tm_escr
F59D: 7B      	tm_esc1:ld	a,e
F59E: 1E20    		ld	e,0x20
F5A0: 93      		sub	e
F5A1: FE18    		cp	24
F5A3: 30D9    		jr	nc,tm_escd
F5A5: 47      		ld	b,a
F5A6: 18EF    		jr	tm_esci
F5A8: 7B      	tm_esc2:ld	a,e
F5A9: 1E20    		ld	e,0x20
F5AB: 93      		sub	e
F5AC: FE50    		cp	80
F5AE: 30CE    		jr	nc,tm_escd
F5B0: 4F      		ld	c,a
F5B1: 18CB    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F5B3: 0617    	tm_cles:ld	b,23
F5B5: 04      	tm_clea:inc	b
F5B6: 1E00    		ld	e,0
F5B8: C5      		push	bc
F5B9: D5      		push	de
F5BA: 3E50    		ld	a,80
F5BC: 210050  		ld	hl,0x5000
F5BF: CD9AF6  		call	tm_chat
F5C2: D1      		pop	de
F5C3: C1      		pop	bc
F5C4: AF      	tm_cle0:xor	a
F5C5: D3A0    		out	(tm_data),a
F5C7: 0C      		inc	c
F5C8: 3E50    		ld	a,80
F5CA: B9      		cp	c
F5CB: 20F7    		jr	nz,tm_cle0
F5CD: 14      		inc	d
F5CE: AF      		xor	a
F5CF: 4F      		ld	c,a
F5D0: 7A      		ld	a,d
F5D1: B8      		cp	b
F5D2: 20F0    		jr	nz,tm_cle0
F5D4: D1      		pop	de	; Do not update character
F5D5: C3BEF6  		jp	tm_usco
              		
F5D8: E5      	tm_40c:	push	hl
F5D9: 210200  		ld	hl,0x0002
F5DC: 2221F7  	tm_cupd:ld	(tm_mode),hl
F5DF: CD6DF4  		call	tm_setp
F5E2: E1      		pop	hl
F5E3: 1899    		jr	tm_escd
              		
F5E5: E5      	tm_80c:	push	hl
F5E6: 210704  		ld	hl,0x0407
F5E9: 18F1    		jr	tm_cupd
              		
              		; Set color command
F5EB: 3E04    	tm_scol:ld	a,4
F5ED: 1890    		jr	tm_escr
              		
              		; Update color here
F5EF: 7B      	tm_updc:ld	a,e
F5F0: 3223F7  		ld	(tm_colr),a
F5F3: CD6DF4  		call	tm_setp
F5F6: 1886    		jr	tm_escd
              		
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F5F8: 212808  	tm_dsco:ld	hl,0x0800+40
F5FB: 110048  		ld	de,0x4800
F5FE: 0618    		ld	b,24
F600: CD0BF6  		call	tm_dsc0
F603: 215010  		ld	hl,0x1000+80
F606: 110050  		ld	de,0x5000
F609: 0630    		ld	b,48
F60B: C5      	tm_dsc0:push	bc
F60C: D5      		push	de
F60D: E5      		push	hl
F60E: CDA6F6  		call	tm_vcpy
F611: E1      		pop	hl
F612: D1      		pop	de
F613: 012800  		ld	bc,40
F616: 09      		add	hl,bc
F617: EB      		ex	de,hl
F618: 09      		add	hl,bc
F619: EB      		ex	de,hl
F61A: C1      		pop	bc
F61B: 10EE    		djnz	tm_dsc0
F61D: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F61E: 3A25F7  	tm_getc:ld	a,(tm_inf)
F621: B7      		or	a
F622: 3E00    		ld	a,0
F624: 3225F7  		ld	(tm_inf),a
F627: 3A24F7  		ld	a,(tm_inb)
F62A: 2008    		jr	nz,tm_get0
              	
F62C: DB91    		in	a,(tm_keys)
F62E: E602    		and	2
F630: 3D      		dec	a
F631: F8      		ret	m
              		
              		; Grab the key
F632: DB90    		in	a,(tm_keyd)
F634: 3298FA  	tm_get0:ld	(tm_last),a
F637: CD4AF6  		call	tm_map
F63A: 79      		ld	a,c
F63B: C9      		ret
              		
              	; Handles a keyboard interrupt for the VDP terminal driver
              	; Keypress stored in tm_inb and tm_inf flag is set
              	; 
              	; uses: none
F63C: F5      	tm_kirq:push	af
F63D: DB90    		in	a,(tm_keyd)
F63F: 3224F7  		ld	(tm_inb),a
F642: 3E01    		ld	a,1
F644: 3225F7  		ld	(tm_inf),a
F647: F1      		pop	af
F648: FB      		ei
F649: C9      		ret
              		
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F64A: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
F64B: 2161F6  		ld	hl,tm_mapt
F64E: 7E      	tm_map0:ld	a,(hl)
F64F: B7      		or	a
F650: 2808    		jr	z,tm_map2
F652: B9      		cp	c
F653: 23      		inc	hl
F654: 7E      		ld	a,(hl)
F655: 23      		inc	hl
F656: 20F6    		jr	nz,tm_map0
F658: 4F      		ld	c,a
F659: C9      		ret
              		
              		
              		; Filter non-ASCII
F65A: 79      	tm_map2:ld	a,c
F65B: E680    		and	0x80	
F65D: C8      		ret	z
F65E: 0EFF    		ld	c,0xFF
F660: C9      		ret
              		
              	; Map table
F661: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
F663: E108    		defb	0xE1,0x08	; '<-' -> BS
F665: EA7F    		defb	0xEA,0x7F	; TV -> DEL
F667: E00C    		defb	0xE0,0x0C	; '->' -> Right
F669: E20B    		defb	0xE2,0x0B	; '/\' -> Up
F66B: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
F66D: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
F66F: E860    		defb	0xE8,0x60	; SYM -> '@'
F671: E67C    		defb	0xE6,0x7C	; NO -> '|'
F673: E77E    		defb	0xE7,0x7E	; YES -> '~'
F675: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F676: 210050  	tm_putc:ld	hl,0x5000
F679: 3E50    		ld	a,80
F67B: C5      		push	bc
F67C: D5      		push	de
F67D: CD9AF6  		call	tm_chat	; Place it in the 80 col buffer
F680: ED59    		out	(c),e
F682: D1      		pop	de
F683: C1      		pop	bc
F684: 3A96FA  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F687: 47      		ld	b,a
F688: 79      		ld	a,c
F689: 90      		sub	b	; If character is less than scroll...
F68A: 4F      		ld	c,a
F68B: F8      		ret	m
F68C: FE28    		cp	40	; If desired position is 40 or more
F68E: D0      		ret	nc
F68F: 210048  		ld	hl,0x4800
F692: 3E28    		ld	a,40
F694: CD9AF6  		call	tm_chat	; Place it in the 40 col screen buffer
F697: ED59    		out	(c),e
F699: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
F69A: 0600    	tm_chat:ld	b,0
F69C: 09      		add	hl,bc
F69D: 4F      		ld	c,a
F69E: AF      		xor	a
F69F: BA      		cp	d
F6A0: 285A    	tm_cha0:jr	z,tm_addh
F6A2: 09      		add	hl,bc
F6A3: 15      		dec	d
F6A4: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F6A6: CDFCF6  	tm_vcpy:call	tm_addh
F6A9: 0628    		ld	b,40
F6AB: 2199FA  		ld	hl,tm_cbuf
F6AE: CDD0F3  		call	tm_inir
F6B1: EB      		ex	de,hl
F6B2: CDFCF6  		call	tm_addh
F6B5: 0628    		ld	b,40
F6B7: 2199FA  		ld	hl,tm_cbuf
F6BA: CDC7F3  		call	tm_otir
F6BD: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F6BE: 210010  	tm_usco:ld	hl,0x1000
F6C1: 110048  		ld	de,0x4800
F6C4: 3A96FA  		ld	a,(tm_scro)
F6C7: 0600    		ld	b,0
F6C9: 4F      		ld	c,a
F6CA: 09      		add	hl,bc
F6CB: 0618    		ld	b,24
F6CD: C5      	tm_usc0:push	bc
F6CE: D5      		push	de
F6CF: E5      		push	hl
F6D0: CDA6F6  		call	tm_vcpy
F6D3: E1      		pop	hl
F6D4: D1      		pop	de
F6D5: 0E50    		ld	c,80
F6D7: 09      		add	hl,bc
F6D8: EB      		ex	de,hl
F6D9: 0E28    		ld	c,40
F6DB: 09      		add	hl,bc
F6DC: EB      		ex	de,hl
F6DD: C1      		pop	bc
F6DE: 10ED    		djnz	tm_usc0
F6E0: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F6E1: 010048  	tm_cls:	ld	bc,0x4800
F6E4: 11FE0F  		ld	de,0x1000-2
F6E7: CDFEF6  		call	tm_addr
F6EA: ED71    	tm_cls0:out	(c),0
F6EC: 1B      		dec	de
F6ED: 7A      		ld	a,d
F6EE: B3      		or	e
F6EF: 20F9    		jr	nz,tm_cls0
              		
              		; Write super special serial #
F6F1: 3EE5    		ld	a,0xE5
F6F3: ED79    		out	(c),a
F6F5: F5      		push	af
F6F6: F1      		pop	af
F6F7: 3E81    		ld	a,0x81
F6F9: ED79    		out	(c),a
F6FB: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; Returns tm_data in c
              	; uses: af, bc
F6FC: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F6FD: 4D      		ld	c,l
F6FE: DBA1    	tm_addr:in	a,(tm_latc)
F700: 79      		ld	a,c
F701: D3A1    		out	(tm_latc),a
F703: 78      		ld	a,b
F704: D3A1    		out	(tm_latc),a
F706: 0EA0    		ld	c,tm_data
F708: C9      		ret
              		
              	; Handles a TMS9918 irq
F709: F5      	tm_virq:push	af
F70A: DBA1    		in	a,(tm_latc)
F70C: F1      		pop	af
F70D: FB      		ei
F70E: C9      		ret
              		
              		
              	; Disables all interrupts while VDP operations occur
              	;
              	; uses: a
F70F: 3E0E    	tm_dint:ld	a,0x0E
F711: D341    		out	(tm_atla),a	; AY register = 14
F713: 3E00    		ld	a,0x00
F715: D340    		out	(tm_ayda),a	
F717: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
F718: 3E0E    	tm_eint:ld	a,0x0E
F71A: D341    		out	(tm_atla),a	; AY register = 14
F71C: 3EB0    		ld	a,0xB0
F71E: D340    		out	(tm_ayda),a
F720: C9      		ret
              		
              	; Variables
F721: 0200    	tm_mode:defw	0x0002
F723: E1      	tm_colr:defb	0xE1
F724: 00      	tm_inb:	defb	0
F725: 00      	tm_inf:	defb	0
F726: 00      	tm_curx:defb	0
F727: 00      	tm_cury:defb	0
F728: 01      	tm_cold:defb	1
              	#include "dev/nabu_ndsk.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   V I R T U A L   D I S K
              	;*
              	;*     This driver allows for IshkurCP/M to access a virtual
              	;*     disk using the NHACP protocol. Indiviual files are 
              	;*     mounted as file systems and accessed like a disk
              	;*     normally would.
              	;*
              	;*     This particular driver uses the Nabu HCCA port to 
              	;*     facilitate communication between it and an adapter
              	;*
              	;*     In order to service CCP and GRB requests, the 
              	;*     following special files must exist:
              	;*
              	;*     '${STORAGE}/CPM22.SYS' <- For CP/M system components
              	;*     '${STORAGE}/FONT.GRB' <- For graphical driver components
              	;*
              	;*
              	;*
              	;*
              	;*     Device requires 384 bytes of bss space (nd_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FAC1: 00      	nd_tran:defs	1	; Transfer count
FAC2: 00      	nd_csec:defs	1	; Current sector (1b)
FAC3: 0000    	nd_ctrk:defs	2	; Current track (2b)
FAC5: 00000000	nd_buff:defs	64	; Buffer (64b)
FAC9: 00...   	
FB05: 00000000	nd_asva:defs	129	; ASV #1 (129b)
FB09: 00...   	
FB86: 00000000	nd_asvb:defs	129	; ASV #1 (129b)
FB8A: 00...   	
              	.area	_TEXT
              	
0040:         	nd_ayda	equ	0x40		; AY-3-8910 data port
0041:         	nd_atla	equ	0x41		; AY-3-8910 latch port
0080:         	nd_hcca	equ	0x80		; Modem data port
0000:         	nd_nctl	equ	0x00		; NABU control port
              	
0080:         	nd_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F729: 00000000	nd_dpha:defw	0,0,0,0
F72D: 00000000	
F731: 10FF    		defw	dircbuf	; DIRBUF
F733: 49F7    		defw	nd_dpb	; DPB
F735: 0000    		defw	0	; CSV
F737: 05FB    		defw	nd_asva	; ALV (129 bytes)
              		
              	; Disk B DPH
F739: 00000000	nd_dphb:defw	0,0,0,0
F73D: 00000000	
F741: 10FF    		defw	dircbuf	; DIRBUF
F743: 49F7    		defw	nd_dpb	; DPB
F745: 0000    		defw	0	; CSV
F747: 86FB    		defw	nd_asvb	; ALV (129 bytes)
              		
              	; NSHD8 format
F749: 4000    	nd_dpb:	defw	64	; # sectors per track
F74B: 06      		defb	6	; BSH
F74C: 3F      		defb	63	; BLM
F74D: 03      		defb	3	; EXM
F74E: FF03    		defw	1023	; DSM
F750: FF00    		defw	255	; DRM
F752: 80      		defb	0x80	; AL0
F753: 00      		defb	0	; AL1
F754: 0000    		defw	0	; Size of directory check vector
F756: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F758: B7      	ndkdev:	or	a
F759: 2815    		jr	z,nd_init
F75B: 3D      		dec	a
F75C: 2813    		jr	z,nd_home
F75E: 3D      		dec	a
F75F: 2817    		jr	z,nd_sel
F761: 3D      		dec	a
F762: CAA2F7  		jp	z,nd_strk
F765: 3D      		dec	a
F766: CAA8F7  		jp	z,nd_ssec
F769: 3D      		dec	a
F76A: CAADF7  		jp	z,nd_read
F76D: C3BEF7  		jp	nd_writ
              		
              	; Inits the device
              	; Not really needed atm
              	; hl = Call argument
              	;
              	; uses: none
F770: C9      	nd_init:ret
              	
              	; Sets "track" back to zero
              	;
              	; uses: none
F771: 210000  	nd_home:ld	hl,0
F774: 22C3FA  		ld	(nd_ctrk),hl
F777: C9      		ret
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
F778: E5      	nd_sel:	push	hl
F779: CDDFF7  		call	nd_hini
F77C: E1      		pop	hl
F77D: E5      		push	hl
F77E: 7D      		ld	a,l
F77F: C641    		add	a,0x41		; Convert to ASCII
F781: 329FF9  		ld	(nd_p2im),a
F784: 219AF9  		ld	hl,nd_p2
F787: 11AEF9  		ld	de,nd_m0na
F78A: 010B00  		ld	bc,11
F78D: EDB0    		ldir
F78F: CD3FF8  		call	nd_open		; Open the file
F792: E1      		pop	hl		; Select DPH
F793: 7D      		ld	a,l
F794: B7      		or	a
F795: 2129F7  		ld	hl,nd_dpha
F798: C8      		ret	z
F799: 3D      		dec	a
F79A: 2139F7  		ld	hl,nd_dphb
F79D: C8      		ret	z
F79E: 210000  		ld	hl,0
F7A1: C9      		ret
              		
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: nonoe
F7A2: 60      	nd_strk:ld	h,b
F7A3: 69      		ld	l,c
F7A4: 22C3FA  		ld	(nd_ctrk),hl
F7A7: C9      		ret
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: none
F7A8: 79      	nd_ssec:ld	a,c
F7A9: 32C2FA  		ld	(nd_csec),a
F7AC: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
              	;
              	; uses: af
F7AD: CDDFF7  	nd_read:call	nd_hini
F7B0: CDCFF7  		call	nd_gbno
F7B3: 2A49F3  		ld	hl,(biodma)
F7B6: CD5CF8  		call	nd_getb
F7B9: 3E01    		ld	a,1
F7BB: D8      		ret	c
F7BC: AF      		xor	a
F7BD: C9      		ret
              		
              	; Write a sector from DMA
              	;
              	; uses: af
F7BE: CDDFF7  	nd_writ:call	nd_hini
F7C1: CDCFF7  		call	nd_gbno
F7C4: 2A49F3  		ld	hl,(biodma)
F7C7: CD9DF8  		call	nd_putb
F7CA: 3E01    		ld	a,1
F7CC: D8      		ret	c
F7CD: AF      		xor	a
F7CE: C9      		ret
              		
              		
              	; Gets the block # for read / write operations
              	;
              	; Returns block # in de
              	; uses: af, de, hl 
F7CF: 2AC3FA  	nd_gbno:ld	hl,(nd_ctrk)
F7D2: 29      		add	hl,hl
F7D3: 29      		add	hl,hl
F7D4: 29      		add	hl,hl
F7D5: 29      		add	hl,hl
F7D6: 29      		add	hl,hl
F7D7: 29      		add	hl,hl
F7D8: 3AC2FA  		ld	a,(nd_csec)
F7DB: B5      		or	l
F7DC: 6F      		ld	l,a
F7DD: EB      		ex	de,hl
F7DE: C9      		ret
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a, b
F7DF: 3E07    	nd_hini:ld	a,0x07
F7E1: D341    		out	(nd_atla),a	; AY register = 7
F7E3: 3E7F    		ld	a,0x7F
F7E5: D340    		out	(nd_ayda),a	; Configure AY port I/O
              		
              		; Claim interrupt vectors
F7E7: E5      		push	hl
F7E8: 212AF9  		ld	hl,nd_rirq
F7EB: 2200FF  		ld	(intvec),hl
F7EE: 2171F9  		ld	hl,nd_wirq
F7F1: 2202FF  		ld	(intvec+2),hl
F7F4: E1      		pop	hl
              		
              	; Set interrupts to their default state
              	;
              	; uses: a
F7F5: 3E0E    	nd_dflt:ld	a,0x0E
F7F7: D341    		out	(nd_atla),a	; AY register = 14
F7F9: 3EB0    		ld	a,0xB0
F7FB: D340    		out	(nd_ayda),a	; Enable HCCA receive and but not send, plus key and VDP
              		
F7FD: 3E0F    	nd_dfl0:ld	a,0x0F		
F7FF: D341    		out	(nd_atla),a	; AY register = 15
              		
F801: C9      		ret
              	
              	; Set receive and send interrupts
              	;
              	; uses: a
F802: 3E0E    	nd_esnd:ld	a,0x0E
F804: D341    		out	(nd_atla),a	; AY register = 14
F806: 3EC0    		ld	a,0xC0
F808: D340    		out	(nd_ayda),a	; Enable HCCA receive and send
F80A: 18F1    		jr	nd_dfl0
              		
              	; Set receive but not send interrupt
              	;
              	; uses: a
F80C: 3E0E    	nd_dsnd:ld	a,0x0E
F80E: D341    		out	(nd_atla),a	; AY register = 14
F810: 3E80    		ld	a,0x80
F812: D340    		out	(nd_ayda),a	; Enable HCCA receive and but not send
F814: 18E7    		jr	nd_dfl0
              	
              	
              	; Loads the CCP into the CCP space
F816: 2186F9  	nd_ccp:	ld	hl,nd_p0
F819: 1803    		jr	nd_grb0
              		
              	; Loads the GRB into the CCP space
F81B: 2190F9  	nd_grb:	ld	hl,nd_p1
F81E: 11AEF9  	nd_grb0:ld	de,nd_m0na
F821: 010A00  		ld	bc,10
F824: EDB0    		ldir			; Copy name to file open
F826: CDDFF7  		call	nd_hini		; Go to HCCA mode
F829: 210000  		ld	hl,0x0000	; O_RDONLY
F82C: CD42F8  		call	nd_opef		; Open the file
F82F: 110000  		ld	de,0
F832: 2100DC  		ld	hl,cbase
F835: CD5CF8  	nd_grb1:call	nd_getb
F838: 1C      		inc	e
F839: 3E10    		ld	a,16
F83B: BB      		cp	e
F83C: 20F7    		jr	nz,nd_grb1
F83E: C9      		ret
              		
              	
              	; Open the prepared file
              	; Closes the existing file too
              	;
              	; uses: af, b, hl
F83F: 210100  	nd_open:ld	hl,0x0001	; O_RDWR
F842: 22ABF9  	nd_opef:ld	(nd_m0fl),hl
F845: 21BDF9  		ld	hl,nd_m1
F848: 0606    		ld	b,6
F84A: CDE6F8  		call	nd_send
F84D: 21A5F9  		ld	hl,nd_m0
F850: 0617    		ld	b,23
F852: CDE6F8  		call	nd_send
F855: 21C5FA  		ld	hl,nd_buff
F858: CDCBF8  		call	nd_rece
F85B: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F85C: CD62F8  	nd_getb:call	nd_get0
F85F: C3F5F7  		jp	nd_dflt
F862: EB      	nd_get0:ex	de,hl
F863: 22CBF9  		ld	(nd_m2bn),hl
F866: EB      		ex	de,hl
F867: E5      		push	hl
F868: 21C5F9  		ld	hl,nd_m2
F86B: 060C    		ld	b,12
F86D: CDE6F8  		call	nd_send
F870: E1      		pop	hl
F871: D8      		ret	c
F872: CDEFF8  		call	nd_hcrd
F875: CDF2F8  		call	nd_hcre
F878: D8      		ret	c
F879: FE84    		cp	0x84
F87B: 37      		scf
F87C: 2017    		jr	nz,nd_get2
F87E: CDF2F8  		call	nd_hcre
F881: 32C1FA  		ld	(nd_tran),a
F884: 47      		ld	b,a
F885: CDF2F8  		call	nd_hcre
F888: 78      		ld	a,b
F889: B7      		or	a
F88A: C8      		ret	z
F88B: CDF2F8  	nd_get1:call	nd_hcre
F88E: D8      		ret	c
F88F: 77      		ld	(hl),a
F890: 23      		inc	hl
F891: 10F8    		djnz	nd_get1
F893: B7      		or	a
F894: C9      		ret
F895: CDEFF8  	nd_get2:call	nd_hcrd	; Read the error message and exit
F898: CDF2F8  		call	nd_hcre
F89B: 37      		scf
F89C: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F89D: CDA3F8  	nd_putb:call	nd_put0
F8A0: C3F5F7  		jp	nd_dflt
F8A3: EB      	nd_put0:ex	de,hl
F8A4: 22D7F9  		ld	(nd_m3bn),hl
F8A7: EB      		ex	de,hl
F8A8: E5      		push	hl
F8A9: 21D1F9  		ld	hl,nd_m3
F8AC: 060C    		ld	b,12
F8AE: CDE6F8  		call	nd_send		; Send message precursor
F8B1: E1      		pop	hl
F8B2: D8      		ret	c
F8B3: 0680    		ld	b,128
F8B5: 7E      	nd_put1:ld	a,(hl)		; Send the block
F8B6: CD38F9  		call	nd_hcwr
F8B9: D8      		ret	c
F8BA: 23      		inc	hl
F8BB: 10F8    		djnz	nd_put1
F8BD: 21C5FA  		ld	hl,nd_buff
F8C0: CDCBF8  		call	nd_rece
F8C3: 3AC5FA  		ld	a,(nd_buff)
F8C6: FE81    		cp	0x81
F8C8: C8      		ret	z
F8C9: 37      		scf
F8CA: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F8CB: CDD1F8  	nd_rece:call	nd_rec0
F8CE: C3F5F7  		jp	nd_dflt
F8D1: CDF2F8  	nd_rec0:call	nd_hcre
F8D4: D8      		ret	c		; Existing error
F8D5: 47      		ld	b,a
F8D6: CDF2F8  		call	nd_hcre
F8D9: D8      		ret	c		; Existing error
F8DA: 37      		scf
F8DB: C0      		ret	nz		; Message too big!
F8DC: CDF2F8  	nd_rec1:call	nd_hcre
F8DF: D8      		ret	c		; Error!
F8E0: 77      		ld	(hl),a
F8E1: 23      		inc	hl
F8E2: 10F8    		djnz	nd_rec1
F8E4: B7      		or	a
F8E5: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F8E6: 7E      	nd_send:ld	a,(hl)
F8E7: 23      		inc	hl
F8E8: CD38F9  		call	nd_hcwr
F8EB: D8      		ret	c		; Error!
F8EC: 10F8    		djnz	nd_send
F8EE: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns result in a
              	; Carry flag set on error
              	; Uses: af
F8EF: CDF2F8  	nd_hcrd:call	nd_hcre
F8F2: D5      	nd_hcre:push	de
F8F3: 3E09    		ld	a,0x09
F8F5: D300    		out	(nd_nctl),a	; Turn on recv light
F8F7: 11FFFF  		ld	de,0xFFFF
F8FA: 3A85F9  	nd_hcr0:ld	a,(nd_inf)
F8FD: B7      		or	a
F8FE: 201D    		jr	nz,nd_hcr2
F900: DB40    		in	a,(nd_ayda)
              		;bit	0,a
              		;jr	z,nd_hcr0	; Await an interrupt
              		;bit	1,a
              		;jr	z,nd_hcr1
F902: E60F    		and	0x0F
F904: EE01    		xor	0b00000001
F906: 280C    		jr	z,nd_hcr1
F908: 1B      		dec	de
F909: 7B      		ld	a,e
F90A: B2      		or	d
F90B: 20ED    		jr	nz,nd_hcr0
F90D: 3E01    	nd_hcer:ld	a,0x01
F90F: D300    		out	(nd_nctl),a	; Turn off recv light
F911: 37      		scf
F912: D1      		pop	de
F913: C9      		ret			; Timed out waiting
F914: 3E01    	nd_hcr1:ld	a,0x01
F916: D300    		out	(nd_nctl),a	; Turn off recv light
F918: DB80    		in	a,(nd_hcca)
F91A: D1      		pop	de
F91B: B7      		or	a
F91C: C9      		ret
F91D: 3E01    	nd_hcr2:ld	a,0x01
F91F: D300    		out	(nd_nctl),a	; Turn off recv light
F921: AF      		xor	a
F922: 3285F9  		ld	(nd_inf),a
F925: 3A84F9  		ld	a,(nd_inb)
F928: D1      		pop	de
F929: C9      		ret
              		
              	; HCCA read interrupt
              	; Reads from the HCCA, buffers it, and then sets the flag
              	;
              	; uses: none
F92A: F5      	nd_rirq:push	af
F92B: DB80    		in	a,(nd_hcca)
F92D: 3284F9  		ld	(nd_inb),a
F930: 3E01    		ld	a,1
F932: 3285F9  		ld	(nd_inf),a
F935: F1      		pop	af
F936: FB      		ei
F937: C9      		ret
              		
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F938: D5      	nd_hcwr:push	de
F939: 3282F9  		ld	(nd_outb),a
F93C: AF      		xor	a
F93D: 3283F9  		ld	(nd_outf),a
F940: CD02F8  		call	nd_esnd
F943: 11FFFF  		ld	de,0xFFFF
F946: 3E21    		ld	a,0x21
F948: D300    		out	(nd_nctl),a	; Turn on send light
F94A: 3A83F9  	nd_hcw0:ld	a,(nd_outf)
F94D: B7      		or	a
F94E: 2017    		jr	nz,nd_hcw2
F950: DB40    		in	a,(nd_ayda)
              		;bit	0,a
              		;jr	z,nd_hcw0	; Await an interrupt
              		;bit	1,a
              		;jr	nz,nd_hcw1
F952: E60F    		and	0x0F
F954: EE03    		xor	0b00000011
F956: 280A    		jr	z,nd_hcw1
F958: 1B      		dec	de
F959: 7B      		ld	a,e
F95A: B2      		or	d
F95B: 20ED    		jr	nz,nd_hcw0
F95D: CD0CF8  		call	nd_dsnd
F960: 18AB    		jr	nd_hcer		; Timed out waiting
F962: 3A82F9  	nd_hcw1:ld	a,(nd_outb)
F965: D380    		out	(nd_hcca),a
F967: D1      	nd_hcw2:pop	de
F968: 3E01    		ld	a,0x01
F96A: D300    		out	(nd_nctl),a	; Turn off send light
F96C: CD0CF8  		call	nd_dsnd
F96F: B7      		or	a
F970: C9      		ret
              		
              	; HCCA write interrupt
              	; Writes to the HCCA from the buffer, and 
F971: F5      	nd_wirq:push	af
F972: 3A82F9  		ld	a,(nd_outb)
F975: D380    		out	(nd_hcca),a
F977: 3E01    		ld	a,1
F979: 3283F9  		ld	(nd_outf),a
F97C: CD0CF8  		call	nd_dsnd		; Y'all can't behave, turning off
F97F: F1      		pop	af
F980: FB      		ei
F981: C9      		ret
              		
              	; Byte to send out of HCCA
F982: 00      	nd_outb:defb	0
              	
              	; HCCA output flag
F983: 00      	nd_outf:defb	0
              	
              	; Byte received from HCCA
F984: 00      	nd_inb:	defb	0
              	
              	; HCCA input flag
F985: 00      	nd_inf: defb	0
              		
              	; Path to CP/M image
              	; Total length: 10 bytes
F986: 43504D32	nd_p0:	defb	'CPM22.SYS',0
F98A: 322E5359	
F98E: 5300    	
              	
              	; Path to GRB image
              	; Total length: 10 bytes
F990: 464F4E54	nd_p1:	defb	'FONT.GRB',0,0
F994: 2E475242	
F998: 0000    	
              	
              	; Path to a generic disk image
              	; Total length: 11
F99A: 4E44534B	nd_p2:	defb	'NDSK_'
F99E: 5F      	
F99F: 3F      	nd_p2im:defb	'?'		; Disk image name
F9A0: 2E494D47		defb	'.IMG',0
F9A4: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 23 bytes
F9A5: 8F00    	nd_m0:	defb	0x8F,0x00
F9A7: 1300    		defw	19		; Message length
F9A9: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F9AA: 80      		defb	nd_fild		; Default file descriptor
F9AB: 0100    	nd_m0fl:defw	0x01		; Read/Write flags
F9AD: 0E      		defb	0x0E		; Message length
F9AE: 58585858	nd_m0na:defb	'XXXXXXXXXXXXXX'; File name field
F9B2: 58...   	
F9BC: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F9BD: 8F00    	nd_m1:	defb	0x8F,0x00
F9BF: 0200    		defw	2		; Message length
F9C1: 05      		defb	0x05		; Cmd: FILE-CLOSE
F9C2: 80      		defb	nd_fild		; Default file descriptor
F9C3: 0000    		defw	0x00		; Magic bytes
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F9C5: 8F00    	nd_m2:	defb	0x8F,0x00
F9C7: 0800    		defw	8		; Message length
F9C9: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F9CA: 80      		defb	nd_fild		; Default file descritor
F9CB: 00000000	nd_m2bn:defw	0x00,0x00	; Block number
F9CF: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F9D1: 8F00    	nd_m3:	defb	0x8F,0x00
F9D3: 8800    		defw	136		; Message length
F9D5: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F9D6: 80      		defb	nd_fild		; Default file descritor
F9D7: 00000000	nd_m3bn:defw	0x00,0x00	; Block number
F9DB: 8000    		defw	128		; Block length
              	#include "dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F9DD: B7      	prtdev:	or	a
F9DE: 2808    		jr	z,pr_init
F9E0: 3D      		dec	a
F9E1: 2806    		jr	z,pr_stat
F9E3: 3D      		dec	a
F9E4: 2805    		jr	z,pr_read
F9E6: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F9E8: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F9E9: AF      	pr_stat:xor	a
F9EA: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F9EB: AF      	pr_read:xor	a
F9EC: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F9ED: 3E0F    	pr_writ:ld	a,0x0F
F9EF: D341    		out	(pr_atla),a	; AY register = 15
              		
F9F1: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F9F3: E610    		and	0x10
F9F5: 20FA    		jr	nz,pr_wri0
              		
F9F7: 79      		ld	a,c
F9F8: D3B0    		out	(pr_prnt),a	; Write data
              		
F9FA: 3E05    		ld	a,0x05		; Strobe
F9FC: D300    		out	(pr_ctrl),a
              		
F9FE: 0620    		ld	b,32		
FA00: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
FA02: 3E01    		ld	a,0x01		; Strobe off
FA04: D300    		out	(pr_ctrl),a
              		
FA06: C9      		ret
              		
              	#include "dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
FA07: B7      	siodev:	or	a
FA08: 2808    		jr	z,so_init
FA0A: 3D      		dec	a
FA0B: 2833    		jr	z,so_stat
FA0D: 3D      		dec	a
FA0E: 2841    		jr	z,so_read
FA10: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
FA12: 1177FA  	so_init:ld	de,so_atab
FA15: 45      		ld	b,l
FA16: 04      		inc	b		; Slot 1,2,3,...
FA17: 19      		add	hl,de 		; Get address table entry
FA18: 0ECF    		ld	c,0xCF		; First slot
              		
FA1A: ED78    	so_ini0:in	a,(c)
FA1C: FE08    		cp	0x08
FA1E: 2807    		jr	z,so_ini2
              		
FA20: 3E10    	so_ini1:ld	a,0x10
FA22: 81      		add	c
FA23: F0      		ret	p		; Can't find, failure
FA24: 4F      		ld	c,a
FA25: 18F3    		jr	so_ini0
              		
FA27: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
FA29: 79      		ld	a,c
FA2A: D60F    		sub	0x0F
FA2C: 4F      		ld	c,a
FA2D: 71      		ld	(hl),c
FA2E: 117BFA  		ld	de,so_conf
FA31: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
FA33: 1A      	so_ini3:ld	a,(de)
FA34: 13      		inc	de
FA35: 86      		add	a,(hl)
FA36: 4F      		ld	c,a
FA37: 1A      		ld	a,(de)
FA38: 13      		inc	de
FA39: ED79    		out	(c),a
FA3B: E5      		push	hl
FA3C: E1      		pop	hl	; Small delay
FA3D: 10F4    		djnz	so_ini3
FA3F: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
FA40: 1177FA  	so_stat:ld	de,so_atab
FA43: 19      		add	hl,de
FA44: AF      		xor	a
FA45: BE      		cp	(hl)
FA46: C8      		ret	z	; No device, return 0
FA47: 4E      		ld	c,(hl)
FA48: 0C      		inc	c
FA49: ED78    	so_sta0:in	a,(c)	; Check status register
FA4B: E602    		and	0x02
FA4D: C8      		ret	z
FA4E: 3EFF    		ld	a,0xFF
FA50: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
FA51: 1177FA  	so_read:ld	de,so_atab
FA54: 19      		add	hl,de
FA55: AF      		xor	a
FA56: BE      		cp	(hl)
FA57: C8      		ret	z	; No device, return 0
FA58: 4E      		ld	c,(hl)
FA59: 0C      		inc	c
FA5A: CD49FA  	so_rea0:call	so_sta0	; Wait for a character
FA5D: 28FB    		jr	z,so_rea0
FA5F: 0D      		dec	c
FA60: ED78    		in	a,(c)
FA62: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
FA63: 41      	so_writ:ld	b,c
FA64: 1177FA  		ld	de,so_atab
FA67: 19      		add	hl,de
FA68: AF      		xor	a
FA69: BE      		cp	(hl)
FA6A: C8      		ret	z	; No device, return 0
FA6B: 4E      		ld	c,(hl)
FA6C: 0C      		inc	c
FA6D: ED78    	so_wri0:in	a,(c)
FA6F: E601    		and	0x01
FA71: 28FA    		jr	z,so_wri0
FA73: 0D      		dec	c
FA74: ED41    		out	(c),b
FA76: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
FA77: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
FA7B: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
FA7D: 0412    		defb	0x04,0x12
FA7F: 0400    		defb	0x04,0x00
FA81: 0777    		defb	0x07,0x77	; Counter 2 setup
FA83: 0512    		defb	0x05,0x12
FA85: 0500    		defb	0x05,0x00
              		
FA87: 0100    		defb	0x01,0x00	; 8251 setup
FA89: 0100    		defb	0x01,0x00
FA8B: 0100    		defb	0x01,0x00
FA8D: 0100    		defb	0x01,0x00
FA8F: 0140    		defb	0x01,0x40
FA91: 014E    		defb	0x01,0x4E
FA93: 0137    		defb	0x01,0x37


; +++ segments +++

#CODE _TEXT        = $DC00 = 56320,  size = $1E95 =  7829
#DATA _BSS         = $FA95 = 64149,  size = $0172 =   370
#DATA _JUMP_TABLE  = $FF00 = 65280,  size = $0090 =   144

; +++ global symbols +++

_BSS             = $FA95 = 64149  _BSS        config\config_ndsk.asm:44 (unused)
_BSS_end         = $FC07 = 64519  _BSS        config\config_ndsk.asm:44 (unused)
_BSS_size        = $0172 =   370  _BSS        config\config_ndsk.asm:44
_JUMP_TABLE      = $FF00 = 65280  _JUMP_TABLE config\config_ndsk.asm:45 (unused)
_JUMP_TABLE_end  = $FF90 = 65424  _JUMP_TABLE config\config_ndsk.asm:45 (unused)
_JUMP_TABLE_size = $0090 =   144  _JUMP_TABLE config\config_ndsk.asm:45 (unused)
_TEXT            = $DC00 = 56320  _TEXT       config\config_ndsk.asm:43 (unused)
_TEXT_end        = $FA95 = 64149  _TEXT       config\config_ndsk.asm:43
_TEXT_size       = $1E95 =  7829  _TEXT       config\config_ndsk.asm:43 (unused)
active           = $E74D = 59213  _TEXT       CPM22.asm:1726
adda2hl          = $E96F = 59759  _TEXT       CPM22.asm:2155
addhl            = $DE61 = 56929  _TEXT       CPM22.asm:442
alloc0           = $F1D5 = 61909  _TEXT       CPM22.asm:3703
alloc1           = $F1D7 = 61911  _TEXT       CPM22.asm:3704
alocvect         = $F1CA = 61898  _TEXT       CPM22.asm:3693
auto             = $F1E9 = 61929  _TEXT       CPM22.asm:3718
autoflag         = $F1EB = 61931  _TEXT       CPM22.asm:3720
autosel          = $F05C = 61532  _TEXT       CPM22.asm:3433
autosl1          = $F080 = 61568  _TEXT       CPM22.asm:3449
backup           = $E5AF = 58799  _TEXT       CPM22.asm:1486
backup1          = $E5B7 = 58807  _TEXT       CPM22.asm:1489
badload          = $E377 = 58231  _TEXT       CPM22.asm:1206
badsctr          = $E40C = 58380  _TEXT       CPM22.asm:1267
badsec           = $E4D5 = 58581  _TEXT       CPM22.asm:1341
badsel           = $E4E0 = 58592  _TEXT       CPM22.asm:1342
badslct          = $E40E = 58382  _TEXT       CPM22.asm:1268
batch            = $E3B8 = 58296  _TEXT       CPM22.asm:1239
batchfcb         = $E3B9 = 58297  _TEXT       CPM22.asm:1240
bdevsw           = $F36A = 62314  _TEXT       config\config_ndsk.asm:160
bdosdrv          = $E4D1 = 58577  _TEXT       CPM22.asm:1340
bdoserr          = $E4C5 = 58565  _TEXT       CPM22.asm:1339
bigdisk          = $F1E8 = 61928  _TEXT       CPM22.asm:3717
biodma           = $F349 = 62281  _TEXT       bios.asm:326
bitmap           = $EAAE = 60078  _TEXT       CPM22.asm:2448
bitmap1          = $EABC = 60092  _TEXT       CPM22.asm:2463
bitmap2          = $EADD = 60125  _TEXT       CPM22.asm:2484
bitmap3          = $EB01 = 60161  _TEXT       CPM22.asm:2501
blkmask          = $F1CF = 61903  _TEXT       CPM22.asm:3699
blknmbr          = $F1F0 = 61936  _TEXT       CPM22.asm:3724
blkshft          = $F1CE = 61902  _TEXT       CPM22.asm:3698
boot             = $F23A = 62010  _TEXT       bios.asm:42
bs               = $0008 =     8  _TEXT       CPM22.asm:31
callbd           = $F2F8 = 62200  _TEXT       bios.asm:225
callmj           = $F346 = 62278  _TEXT       bios.asm:320
cbase            = $DC00 = 56320  _TEXT       CPM22.asm:44
cbinit           = $F35A = 62298  _TEXT       config\config_ndsk.asm:91
ccpstack         = $E3B8 = 58296  _TEXT       CPM22.asm:1235
cdevsw           = $F3AA = 62378  _TEXT       config\config_ndsk.asm:199
cdindi0          = $F31E = 62238  _TEXT       bios.asm:285
cdindi1          = $F324 = 62244  _TEXT       bios.asm:289
cdindir          = $F31A = 62234  _TEXT       bios.asm:283
cdrive           = $E3FC = 58364  _TEXT       CPM22.asm:1246
cfirq            = $F360 = 62304  _TEXT       config\config_ndsk.asm:107 (unused)
charbuf          = $E719 = 59161  _TEXT       CPM22.asm:1715
check            = $DE38 = 56888  _TEXT       CPM22.asm:408
checkdir         = $E9A9 = 59817  _TEXT       CPM22.asm:2228
checksum         = $E902 = 59650  _TEXT       CPM22.asm:2067
chgdrv           = $E3FD = 58365  _TEXT       CPM22.asm:1247
chgnam1          = $EC32 = 60466  _TEXT       CPM22.asm:2740
chgnames         = $EC21 = 60449  _TEXT       CPM22.asm:2732
chkblk           = $E88F = 59535  _TEXT       CPM22.asm:1974
chkchar          = $E51F = 58655  _TEXT       CPM22.asm:1383
chkcon           = $DDCA = 56778  _TEXT       CPM22.asm:333
chkdir1          = $E9CF = 59855  _TEXT       CPM22.asm:2248
chknmbr          = $E997 = 59799  _TEXT       CPM22.asm:2201
chkrofl          = $E94F = 59727  _TEXT       CPM22.asm:2131
chksum1          = $E908 = 59656  _TEXT       CPM22.asm:2070
chkvect          = $F1C8 = 61896  _TEXT       CPM22.asm:3692
chkwprt          = $E95F = 59743  _TEXT       CPM22.asm:2142
chrout           = $F2BB = 62139  _TEXT       bios.asm:166
ckbitmap         = $EA40 = 59968  _TEXT       CPM22.asm:2342
ckbmap1          = $EA61 = 60001  _TEXT       CPM22.asm:2377
ckcon1           = $E54D = 58701  _TEXT       CPM22.asm:1413
ckcon2           = $E550 = 58704  _TEXT       CPM22.asm:1414
ckconsol         = $E52E = 58670  _TEXT       CPM22.asm:1399
ckfilpos         = $EA00 = 59904  _TEXT       CPM22.asm:2291
ckrof1           = $E952 = 59730  _TEXT       CPM22.asm:2132
cksumtbl         = $F1F7 = 61943  _TEXT       CPM22.asm:3732
clearbuf         = $DF60 = 57184  _TEXT       CPM22.asm:608
clears2          = $E97D = 59773  _TEXT       CPM22.asm:2172
close            = $DCD9 = 56537  _TEXT       CPM22.asm:138
closefil         = $F0B0 = 61616  _TEXT       CPM22.asm:3480
closeflg         = $F1DD = 61917  _TEXT       CPM22.asm:3709
closeit          = $ECAD = 60589  _TEXT       CPM22.asm:2826
closeit1         = $ECD8 = 60632  _TEXT       CPM22.asm:2846
closeit2         = $ECE6 = 60646  _TEXT       CPM22.asm:2854
closeit3         = $ECEC = 60652  _TEXT       CPM22.asm:2858
closeit4         = $ECF3 = 60659  _TEXT       CPM22.asm:2861
closeit5         = $ED08 = 60680  _TEXT       CPM22.asm:2874
closeit6         = $ED22 = 60706  _TEXT       CPM22.asm:2892
closeit7         = $ED2A = 60714  _TEXT       CPM22.asm:2895
cmdadr           = $DFCE = 57294  _TEXT       CPM22.asm:685
cmdtbl           = $DF18 = 57112  _TEXT       CPM22.asm:562
cmmnd1           = $DF87 = 57223  _TEXT       CPM22.asm:643
cmmnd2           = $DFA5 = 57253  _TEXT       CPM22.asm:657
cntrlc           = $0003 =     3  _TEXT       CPM22.asm:29
cntrle           = $0005 =     5  _TEXT       CPM22.asm:30
cntrlp           = $0010 =    16  _TEXT       CPM22.asm:36
cntrlr           = $0012 =    18  _TEXT       CPM22.asm:37
cntrls           = $0013 =    19  _TEXT       CPM22.asm:38
cntrlu           = $0015 =    21  _TEXT       CPM22.asm:39
cntrlx           = $0018 =    24  _TEXT       CPM22.asm:40
cntrlz           = $001A =    26  _TEXT       CPM22.asm:41
comblk           = $E882 = 59522  _TEXT       CPM22.asm:1965
comfile          = $E380 = 58240  _TEXT       CPM22.asm:1207
command          = $DF64 = 57188  _TEXT       CPM22.asm:618
comprand         = $EFB0 = 61360  _TEXT       CPM22.asm:3299
conin            = $F2AD = 62125  _TEXT       bios.asm:153
conout           = $F2B9 = 62137  _TEXT       bios.asm:165
const            = $F2A2 = 62114  _TEXT       bios.asm:141
convert          = $DE68 = 56936  _TEXT       CPM22.asm:456
convfst          = $DE66 = 56934  _TEXT       CPM22.asm:450
convrt1          = $DE91 = 56977  _TEXT       CPM22.asm:479
convrt2          = $DE98 = 56984  _TEXT       CPM22.asm:482
convrt3          = $DE9E = 56990  _TEXT       CPM22.asm:489
convrt4          = $DEA0 = 56992  _TEXT       CPM22.asm:490
convrt5          = $DEB1 = 57009  _TEXT       CPM22.asm:497
convrt6          = $DEB3 = 57011  _TEXT       CPM22.asm:499
convrt7          = $DEB7 = 57015  _TEXT       CPM22.asm:501
convrt8          = $DEC1 = 57025  _TEXT       CPM22.asm:505
counter          = $F1E3 = 61923  _TEXT       CPM22.asm:3715
cpmlow           = $F29A = 62106  _TEXT       bios.asm:130
cr               = $000D =    13  _TEXT       CPM22.asm:35
create           = $DD08 = 56584  _TEXT       CPM22.asm:188
crlf             = $DC98 = 56472  _TEXT       CPM22.asm:80
curpos           = $E717 = 59159  _TEXT       CPM22.asm:1713
de2hl            = $E75A = 59226  _TEXT       CPM22.asm:1744
de2hl1           = $E75B = 59227  _TEXT       CPM22.asm:1745
decode           = $E005 = 57349  _TEXT       CPM22.asm:712
decode1          = $E015 = 57365  _TEXT       CPM22.asm:718
decode2          = $E037 = 57399  _TEXT       CPM22.asm:738 (unused)
decode3          = $E040 = 57408  _TEXT       CPM22.asm:743
decode4          = $E047 = 57415  _TEXT       CPM22.asm:747 (unused)
default          = $0000 =     0              config\config_ndsk.asm:19
defdma           = $E9E5 = 59877  _TEXT       CPM22.asm:2266
del              = $007F =   127  _TEXT       CPM22.asm:42
delbatch         = $DDE5 = 56805  _TEXT       CPM22.asm:358
delete           = $DCEE = 56558  _TEXT       CPM22.asm:159
delfile          = $F0E2 = 61666  _TEXT       CPM22.asm:3511
dirbuf           = $F1C4 = 61892  _TEXT       CPM22.asm:3690
dirc1            = $E6EB = 59115  _TEXT       CPM22.asm:1671
dircbuf          = $FF10 = 65296  _JUMP_TABLE config\config_ndsk.asm:47
dircio           = $E6DF = 59103  _TEXT       CPM22.asm:1665
dirdma           = $E9EB = 59883  _TEXT       CPM22.asm:2271
dirdma1          = $E9EE = 59886  _TEXT       CPM22.asm:2276
direct           = $E084 = 57476  _TEXT       CPM22.asm:809
direct1          = $E095 = 57493  _TEXT       CPM22.asm:816
direct2          = $E09C = 57500  _TEXT       CPM22.asm:820
direct3          = $E0A5 = 57509  _TEXT       CPM22.asm:824
direct4          = $E0D9 = 57561  _TEXT       CPM22.asm:851
direct5          = $E0E1 = 57569  _TEXT       CPM22.asm:854
direct6          = $E0E6 = 57574  _TEXT       CPM22.asm:856
direct7          = $E11B = 57627  _TEXT       CPM22.asm:880
direct8          = $E11C = 57628  _TEXT       CPM22.asm:881
direct9          = $E128 = 57640  _TEXT       CPM22.asm:885
dirread          = $E9DF = 59871  _TEXT       CPM22.asm:2261
dirsize          = $F1D3 = 61907  _TEXT       CPM22.asm:3702
dirwrite         = $E9D1 = 59857  _TEXT       CPM22.asm:2253
diskpb           = $F1C6 = 61894  _TEXT       CPM22.asm:3691
diskro           = $E4EC = 58604  _TEXT       CPM22.asm:1344
dmaset           = $DDE0 = 56800  _TEXT       CPM22.asm:353
doread           = $E7BD = 59325  _TEXT       CPM22.asm:1815
dowrite          = $E7C3 = 59331  _TEXT       CPM22.asm:1820
drect63          = $E104 = 57604  _TEXT       CPM22.asm:870
drect65          = $E106 = 57606  _TEXT       CPM22.asm:871
dselect          = $E061 = 57441  _TEXT       CPM22.asm:779
dsksel           = $DCBC = 56508  _TEXT       CPM22.asm:112
dsksize          = $F1D1 = 61905  _TEXT       CPM22.asm:3701
emptyfcb         = $F1B7 = 61879  _TEXT       CPM22.asm:3677
entry            = $0005 =     5  _TEXT       CPM22.asm:22
entry1           = $DCC2 = 56514  _TEXT       CPM22.asm:119
entry2           = $DCF3 = 56563  _TEXT       CPM22.asm:165
eparam           = $F1E1 = 61921  _TEXT       CPM22.asm:3713
erafil1          = $EBAF = 60335  _TEXT       CPM22.asm:2618
erafile          = $EBA7 = 60327  _TEXT       CPM22.asm:2615
erase            = $E12C = 57644  _TEXT       CPM22.asm:894
erase1           = $E14F = 57679  _TEXT       CPM22.asm:909
error1           = $E49F = 58527  _TEXT       CPM22.asm:1320
error2           = $E4AB = 58539  _TEXT       CPM22.asm:1326
error3           = $E4B1 = 58545  _TEXT       CPM22.asm:1329
error4           = $E4B7 = 58551  _TEXT       CPM22.asm:1332
error5           = $E4BA = 58554  _TEXT       CPM22.asm:1334
exists           = $E28D = 57997  _TEXT       CPM22.asm:1071
extblk           = $E869 = 59497  _TEXT       CPM22.asm:1946
extblk1          = $E87C = 59516  _TEXT       CPM22.asm:1956
extmask          = $F1D0 = 61904  _TEXT       CPM22.asm:3700
extract          = $E058 = 57432  _TEXT       CPM22.asm:769
fbase            = $E406 = 58374  _TEXT       CPM22.asm:1262
fbase1           = $E414 = 58388  _TEXT       CPM22.asm:1275
fcb              = $E3DA = 58330  _TEXT       CPM22.asm:1244
fcb2hl           = $E969 = 59753  _TEXT       CPM22.asm:2150
fcbpos           = $F1F4 = 61940  _TEXT       CPM22.asm:3726
fcbset           = $EC08 = 60424  _TEXT       CPM22.asm:2710
fcreate          = $F0F7 = 61687  _TEXT       CPM22.asm:3528
ff               = $000C =    12  _TEXT       CPM22.asm:34 (unused)
filepos          = $F1F5 = 61941  _TEXT       CPM22.asm:3727
filero           = $E4E7 = 58599  _TEXT       CPM22.asm:1343
filesize         = $F158 = 61784  _TEXT       CPM22.asm:3602
findfst          = $EB23 = 60195  _TEXT       CPM22.asm:2535
findnxt          = $EB38 = 60216  _TEXT       CPM22.asm:2548
fndnxt1          = $EB55 = 60245  _TEXT       CPM22.asm:2561
fndnxt2          = $EB5E = 60254  _TEXT       CPM22.asm:2565
fndnxt3          = $EB7E = 60286  _TEXT       CPM22.asm:2581
fndnxt4          = $EB87 = 60295  _TEXT       CPM22.asm:2590
fndnxt5          = $EB8E = 60302  _TEXT       CPM22.asm:2595
fndnxt6          = $EB9F = 60319  _TEXT       CPM22.asm:2608
fndspa1          = $EBCB = 60363  _TEXT       CPM22.asm:2648
fndspa2          = $EBDC = 60380  _TEXT       CPM22.asm:2671
fndspa3          = $EBF7 = 60407  _TEXT       CPM22.asm:2692
fndspa4          = $EBFF = 60415  _TEXT       CPM22.asm:2702
fndspace         = $EBC9 = 60361  _TEXT       CPM22.asm:2642
fndstat          = $F1DF = 61919  _TEXT       CPM22.asm:3711
functns          = $E44D = 58445  _TEXT       CPM22.asm:1311
getaloc          = $F11C = 61724  _TEXT       CPM22.asm:3556
getback          = $E383 = 58243  _TEXT       CPM22.asm:1213
getback1         = $E386 = 58246  _TEXT       CPM22.asm:1214
getblk1          = $E850 = 59472  _TEXT       CPM22.asm:1924
getblk2          = $E85E = 59486  _TEXT       CPM22.asm:1933
getblk3          = $E867 = 59495  _TEXT       CPM22.asm:1938
getblock         = $E849 = 59465  _TEXT       CPM22.asm:1921
getchar          = $E506 = 58630  _TEXT       CPM22.asm:1361
getcon           = $E6D3 = 59091  _TEXT       CPM22.asm:1653
getcrnt          = $F10F = 61711  _TEXT       CPM22.asm:3545
getcsts          = $E709 = 59145  _TEXT       CPM22.asm:1698
getdsk           = $DDD8 = 56792  _TEXT       CPM22.asm:344
getecho          = $E511 = 58641  _TEXT       CPM22.asm:1370
getempty         = $ED2F = 60719  _TEXT       CPM22.asm:2902
getext           = $DEC8 = 57032  _TEXT       CPM22.asm:512
getext1          = $DED0 = 57040  _TEXT       CPM22.asm:516
getext2          = $DEE1 = 57057  _TEXT       CPM22.asm:523
getext3          = $DEE3 = 57059  _TEXT       CPM22.asm:525
getext4          = $DEE7 = 57063  _TEXT       CPM22.asm:527
getext5          = $DEF1 = 57073  _TEXT       CPM22.asm:531
getext6          = $DEF8 = 57080  _TEXT       CPM22.asm:535
getext7          = $DEFA = 57082  _TEXT       CPM22.asm:536
getext8          = $DF09 = 57097  _TEXT       CPM22.asm:548
getext9          = $DF11 = 57105  _TEXT       CPM22.asm:553
getfst           = $F0B6 = 61622  _TEXT       CPM22.asm:3487
getfst1          = $F0CD = 61645  _TEXT       CPM22.asm:3498
getinp           = $DD38 = 56632  _TEXT       CPM22.asm:239
getinp0          = $DD54 = 56660  _TEXT       CPM22.asm:255
getinp1          = $DDA0 = 56736  _TEXT       CPM22.asm:305
getinp2          = $DDB1 = 56753  _TEXT       CPM22.asm:314
getinp3          = $DDB5 = 56757  _TEXT       CPM22.asm:316
getinp4          = $DDC2 = 56770  _TEXT       CPM22.asm:325
getiob           = $E6F8 = 59128  _TEXT       CPM22.asm:1679
getlog           = $F109 = 61705  _TEXT       CPM22.asm:3540
getmt1           = $ED51 = 60753  _TEXT       CPM22.asm:2918
getnext          = $ED65 = 60773  _TEXT       CPM22.asm:2932
getnxt           = $F0D3 = 61651  _TEXT       CPM22.asm:3503
getparm          = $F131 = 61745  _TEXT       CPM22.asm:3573
getprm1          = $F134 = 61748  _TEXT       CPM22.asm:3574
getrdr           = $E6D9 = 59097  _TEXT       CPM22.asm:1658
getrov           = $F122 = 61730  _TEXT       CPM22.asm:3561
gets2            = $E974 = 59764  _TEXT       CPM22.asm:2164
getsetuc         = $DD14 = 56596  _TEXT       CPM22.asm:204
getuser          = $F138 = 61752  _TEXT       CPM22.asm:3581
getusr           = $DD12 = 56594  _TEXT       CPM22.asm:199
getver           = $F089 = 61577  _TEXT       CPM22.asm:3457
getwprt          = $E929 = 59689  _TEXT       CPM22.asm:2104
goback           = $F17F = 61823  _TEXT       CPM22.asm:3637
goback1          = $F19C = 61852  _TEXT       CPM22.asm:3649
gtnext1          = $ED8E = 60814  _TEXT       CPM22.asm:2952
gtnext2          = $ED99 = 60825  _TEXT       CPM22.asm:2961
gtnext3          = $EDB7 = 60855  _TEXT       CPM22.asm:2972
gtnext4          = $EDBA = 60858  _TEXT       CPM22.asm:2973
gtnext5          = $EDC1 = 60865  _TEXT       CPM22.asm:2980
halt             = $DFDC = 57308  _TEXT       CPM22.asm:690
hl2de            = $E04F = 57423  _TEXT       CPM22.asm:759
home             = $F2DB = 62171  _TEXT       bios.asm:199
homedrv          = $E7AC = 59308  _TEXT       CPM22.asm:1801
inbuff           = $DC06 = 56326  _TEXT       CPM22.asm:51
inpoint          = $DC88 = 56456  _TEXT       CPM22.asm:60
intvec           = $FF00 = 65280  _JUMP_TABLE config\config_ndsk.asm:46
iobyte           = $0003 =     3  _TEXT       CPM22.asm:20
ioerr1           = $E710 = 59152  _TEXT       CPM22.asm:1708
ioret            = $E7C6 = 59334  _TEXT       CPM22.asm:1821
jumphl           = $E755 = 59221  _TEXT       CPM22.asm:1736
lf               = $000A =    10  _TEXT       CPM22.asm:33
list             = $F2C5 = 62149  _TEXT       bios.asm:176
logical          = $E895 = 59541  _TEXT       CPM22.asm:1985
logicl1          = $E89B = 59547  _TEXT       CPM22.asm:1987
login            = $F1BA = 61882  _TEXT       CPM22.asm:3679
logindrv         = $F02C = 61484  _TEXT       CPM22.asm:3401
logoff           = $F15E = 61790  _TEXT       CPM22.asm:3611
logsect          = $F1F2 = 61938  _TEXT       CPM22.asm:3725
mem              = $0037 =    55              config\config_ndsk.asm:38
mode             = $F1E0 = 61920  _TEXT       CPM22.asm:3712
morefls          = $E98A = 59786  _TEXT       CPM22.asm:2188
move3            = $E04D = 57421  _TEXT       CPM22.asm:755
movecd           = $DD28 = 56616  _TEXT       CPM22.asm:221
movedir          = $E9F4 = 59892  _TEXT       CPM22.asm:2283
moveword         = $EC9F = 60575  _TEXT       CPM22.asm:2809
namepnt          = $DC8A = 56458  _TEXT       CPM22.asm:61
nbytes           = $E3FE = 58366  _TEXT       CPM22.asm:1248
nd_asva          = $FB05 = 64261  _BSS        nabu_ndsk.asm:33
nd_asvb          = $FB86 = 64390  _BSS        nabu_ndsk.asm:34
nd_atla          = $0041 =    65  _TEXT       nabu_ndsk.asm:38
nd_ayda          = $0040 =    64  _TEXT       nabu_ndsk.asm:37
nd_buff          = $FAC5 = 64197  _BSS        nabu_ndsk.asm:32
nd_ccp           = $F816 = 63510  _TEXT       nabu_ndsk.asm:253
nd_csec          = $FAC2 = 64194  _BSS        nabu_ndsk.asm:30
nd_ctrk          = $FAC3 = 64195  _BSS        nabu_ndsk.asm:31
nd_dfl0          = $F7FD = 63485  _TEXT       nabu_ndsk.asm:228
nd_dflt          = $F7F5 = 63477  _TEXT       nabu_ndsk.asm:223
nd_dpb           = $F749 = 63305  _TEXT       nabu_ndsk.asm:68
nd_dpha          = $F729 = 63273  _TEXT       nabu_ndsk.asm:54
nd_dphb          = $F739 = 63289  _TEXT       nabu_ndsk.asm:61
nd_dsnd          = $F80C = 63500  _TEXT       nabu_ndsk.asm:245
nd_esnd          = $F802 = 63490  _TEXT       nabu_ndsk.asm:236
nd_fild          = $0080 =   128  _TEXT       nabu_ndsk.asm:42
nd_gbno          = $F7CF = 63439  _TEXT       nabu_ndsk.asm:187
nd_get0          = $F862 = 63586  _TEXT       nabu_ndsk.asm:300
nd_get1          = $F88B = 63627  _TEXT       nabu_ndsk.asm:322
nd_get2          = $F895 = 63637  _TEXT       nabu_ndsk.asm:329
nd_getb          = $F85C = 63580  _TEXT       nabu_ndsk.asm:298
nd_grb           = $F81B = 63515  _TEXT       nabu_ndsk.asm:257
nd_grb0          = $F81E = 63518  _TEXT       nabu_ndsk.asm:258
nd_grb1          = $F835 = 63541  _TEXT       nabu_ndsk.asm:266
nd_hcca          = $0080 =   128  _TEXT       nabu_ndsk.asm:39
nd_hcer          = $F90D = 63757  _TEXT       nabu_ndsk.asm:428
nd_hcr0          = $F8FA = 63738  _TEXT       nabu_ndsk.asm:413
nd_hcr1          = $F914 = 63764  _TEXT       nabu_ndsk.asm:433
nd_hcr2          = $F91D = 63773  _TEXT       nabu_ndsk.asm:439
nd_hcrd          = $F8EF = 63727  _TEXT       nabu_ndsk.asm:408
nd_hcre          = $F8F2 = 63730  _TEXT       nabu_ndsk.asm:409
nd_hcw0          = $F94A = 63818  _TEXT       nabu_ndsk.asm:476
nd_hcw1          = $F962 = 63842  _TEXT       nabu_ndsk.asm:493
nd_hcw2          = $F967 = 63847  _TEXT       nabu_ndsk.asm:495
nd_hcwr          = $F938 = 63800  _TEXT       nabu_ndsk.asm:468
nd_hini          = $F7DF = 63455  _TEXT       nabu_ndsk.asm:207
nd_home          = $F771 = 63345  _TEXT       nabu_ndsk.asm:107
nd_inb           = $F984 = 63876  _TEXT       nabu_ndsk.asm:521
nd_inf           = $F985 = 63877  _TEXT       nabu_ndsk.asm:524
nd_init          = $F770 = 63344  _TEXT       nabu_ndsk.asm:102
nd_m0            = $F9A5 = 63909  _TEXT       nabu_ndsk.asm:542
nd_m0fl          = $F9AB = 63915  _TEXT       nabu_ndsk.asm:546
nd_m0na          = $F9AE = 63918  _TEXT       nabu_ndsk.asm:548
nd_m1            = $F9BD = 63933  _TEXT       nabu_ndsk.asm:553
nd_m2            = $F9C5 = 63941  _TEXT       nabu_ndsk.asm:561
nd_m2bn          = $F9CB = 63947  _TEXT       nabu_ndsk.asm:565
nd_m3            = $F9D1 = 63953  _TEXT       nabu_ndsk.asm:570
nd_m3bn          = $F9D7 = 63959  _TEXT       nabu_ndsk.asm:574
nd_nctl          = $0000 =     0  _TEXT       nabu_ndsk.asm:40
nd_opef          = $F842 = 63554  _TEXT       nabu_ndsk.asm:279
nd_open          = $F83F = 63551  _TEXT       nabu_ndsk.asm:278
nd_outb          = $F982 = 63874  _TEXT       nabu_ndsk.asm:515
nd_outf          = $F983 = 63875  _TEXT       nabu_ndsk.asm:518
nd_p0            = $F986 = 63878  _TEXT       nabu_ndsk.asm:528
nd_p1            = $F990 = 63888  _TEXT       nabu_ndsk.asm:532
nd_p2            = $F99A = 63898  _TEXT       nabu_ndsk.asm:536
nd_p2im          = $F99F = 63903  _TEXT       nabu_ndsk.asm:537
nd_put0          = $F8A3 = 63651  _TEXT       nabu_ndsk.asm:343
nd_put1          = $F8B5 = 63669  _TEXT       nabu_ndsk.asm:353
nd_putb          = $F89D = 63645  _TEXT       nabu_ndsk.asm:341
nd_read          = $F7AD = 63405  _TEXT       nabu_ndsk.asm:161
nd_rec0          = $F8D1 = 63697  _TEXT       nabu_ndsk.asm:373
nd_rec1          = $F8DC = 63708  _TEXT       nabu_ndsk.asm:380
nd_rece          = $F8CB = 63691  _TEXT       nabu_ndsk.asm:371
nd_rirq          = $F92A = 63786  _TEXT       nabu_ndsk.asm:451
nd_sel           = $F778 = 63352  _TEXT       nabu_ndsk.asm:116
nd_send          = $F8E6 = 63718  _TEXT       nabu_ndsk.asm:394
nd_ssec          = $F7A8 = 63400  _TEXT       nabu_ndsk.asm:154
nd_strk          = $F7A2 = 63394  _TEXT       nabu_ndsk.asm:144
nd_tran          = $FAC1 = 64193  _BSS        nabu_ndsk.asm:29
nd_wirq          = $F971 = 63857  _TEXT       nabu_ndsk.asm:504
nd_writ          = $F7BE = 63422  _TEXT       nabu_ndsk.asm:173
ndkdev           = $F758 = 63320  _TEXT       nabu_ndsk.asm:83
newline          = $E5BC = 58812  _TEXT       CPM22.asm:1495
newln1           = $E5C4 = 58820  _TEXT       CPM22.asm:1498
nfuncts          = $0029 =    41  _TEXT       CPM22.asm:1309
nofile           = $DFFD = 57341  _TEXT       CPM22.asm:705
nonblank         = $DE57 = 56919  _TEXT       CPM22.asm:432
none             = $DFF7 = 57335  _TEXT       CPM22.asm:703
nospace          = $E214 = 57876  _TEXT       CPM22.asm:1013
nulldev          = $F345 = 62277  _TEXT       bios.asm:317 (unused)
numcmds          = $0006 =     6  _TEXT       CPM22.asm:561
nxent1           = $EA24 = 59940  _TEXT       CPM22.asm:2321
nxent2           = $EA2B = 59947  _TEXT       CPM22.asm:2324
nxentry          = $EA10 = 59920  _TEXT       CPM22.asm:2313
offset           = $F1D9 = 61913  _TEXT       CPM22.asm:3705
olddrv           = $F1EA = 61930  _TEXT       CPM22.asm:3719
open             = $DCCA = 56522  _TEXT       CPM22.asm:126
openfcb          = $DCCF = 56527  _TEXT       CPM22.asm:131
openfil          = $F0A7 = 61607  _TEXT       CPM22.asm:3474
openit           = $EC5C = 60508  _TEXT       CPM22.asm:2766
openit1          = $EC65 = 60517  _TEXT       CPM22.asm:2770
openit2          = $EC96 = 60566  _TEXT       CPM22.asm:2798
outchar          = $E553 = 58707  _TEXT       CPM22.asm:1421
outchr1          = $E56D = 58733  _TEXT       CPM22.asm:1435
outchr2          = $E584 = 58756  _TEXT       CPM22.asm:1451
outcon           = $E59B = 58779  _TEXT       CPM22.asm:1472
outcon1          = $E5A1 = 58785  _TEXT       CPM22.asm:1475
outcrlf          = $E5D4 = 58836  _TEXT       CPM22.asm:1508
outflag          = $E715 = 59157  _TEXT       CPM22.asm:1711
params           = $E74E = 59214  _TEXT       CPM22.asm:1727
pattrn1          = $DF30 = 57136  _TEXT       CPM22.asm:572
pattrn2          = $E400 = 58368  _TEXT       CPM22.asm:1254
pline            = $DCA6 = 56486  _TEXT       CPM22.asm:93
pline2           = $DCAB = 56491  _TEXT       CPM22.asm:96
position         = $EF0E = 61198  _TEXT       CPM22.asm:3176
positn1          = $EF12 = 61202  _TEXT       CPM22.asm:3181
positn2          = $EF52 = 61266  _TEXT       CPM22.asm:3227
positn3          = $EF8A = 61322  _TEXT       CPM22.asm:3259
positn4          = $EF8F = 61327  _TEXT       CPM22.asm:3265
positn5          = $EF96 = 61334  _TEXT       CPM22.asm:3272
pr_atla          = $0041 =    65  _TEXT       nabu_prt.asm:14
pr_ayda          = $0040 =    64  _TEXT       nabu_prt.asm:13
pr_ctrl          = $0000 =     0  _TEXT       nabu_prt.asm:16
pr_init          = $F9E8 = 63976  _TEXT       nabu_prt.asm:31
pr_prnt          = $00B0 =   176  _TEXT       nabu_prt.asm:15
pr_read          = $F9EB = 63979  _TEXT       nabu_prt.asm:46
pr_stat          = $F9E9 = 63977  _TEXT       nabu_prt.asm:38
pr_wri0          = $F9F1 = 63985  _TEXT       nabu_prt.asm:56
pr_wri1          = $FA00 = 64000  _TEXT       nabu_prt.asm:67
pr_writ          = $F9ED = 63981  _TEXT       nabu_prt.asm:53
print            = $DC8C = 56460  _TEXT       CPM22.asm:66
printb           = $DC92 = 56466  _TEXT       CPM22.asm:72
printdc          = $E398 = 58264  _TEXT       CPM22.asm:1223
prstat           = $F314 = 62228  _TEXT       bios.asm:271
prtdev           = $F9DD = 63965  _TEXT       nabu_prt.asm:19
prterr           = $E4F0 = 58608  _TEXT       CPM22.asm:1348
prtflag          = $E718 = 59160  _TEXT       CPM22.asm:1714
prtmesg          = $E5DE = 58846  _TEXT       CPM22.asm:1515
prtstr           = $E703 = 59139  _TEXT       CPM22.asm:1691
punch            = $F2C9 = 62153  _TEXT       bios.asm:182
putdma           = $F115 = 61717  _TEXT       CPM22.asm:3550
ransiz1          = $EFEF = 61423  _TEXT       CPM22.asm:3355
ransiz2          = $F011 = 61457  _TEXT       CPM22.asm:3377
ransiz3          = $F017 = 61463  _TEXT       CPM22.asm:3379
ransize          = $EFDD = 61405  _TEXT       CPM22.asm:3344
rdbuf1           = $E5FA = 58874  _TEXT       CPM22.asm:1534
rdbuf10          = $E67B = 59003  _TEXT       CPM22.asm:1596
rdbuf11          = $E683 = 59011  _TEXT       CPM22.asm:1602
rdbuf12          = $E695 = 59029  _TEXT       CPM22.asm:1614
rdbuf13          = $E6A4 = 59044  _TEXT       CPM22.asm:1621
rdbuf14          = $E6B1 = 59057  _TEXT       CPM22.asm:1629
rdbuf15          = $E6B4 = 59060  _TEXT       CPM22.asm:1632
rdbuf16          = $E6C8 = 59080  _TEXT       CPM22.asm:1644
rdbuf17          = $E6CC = 59084  _TEXT       CPM22.asm:1646
rdbuf2           = $E5FC = 58876  _TEXT       CPM22.asm:1536
rdbuf3           = $E621 = 58913  _TEXT       CPM22.asm:1553
rdbuf4           = $E631 = 58929  _TEXT       CPM22.asm:1562
rdbuf5           = $E642 = 58946  _TEXT       CPM22.asm:1570
rdbuf6           = $E653 = 58963  _TEXT       CPM22.asm:1579
rdbuf7           = $E659 = 58969  _TEXT       CPM22.asm:1582
rdbuf8           = $E66A = 58986  _TEXT       CPM22.asm:1589
rdbuf9           = $E676 = 58998  _TEXT       CPM22.asm:1594
rdbuff           = $E5EC = 58860  _TEXT       CPM22.asm:1527
rderr            = $DFEC = 57324  _TEXT       CPM22.asm:699
rderror          = $DFE6 = 57318  _TEXT       CPM22.asm:697
rdrandom         = $F14C = 61772  _TEXT       CPM22.asm:3592
rdrec            = $DCF8 = 56568  _TEXT       CPM22.asm:172
rdseq            = $EDC7 = 60871  _TEXT       CPM22.asm:2985
rdseq1           = $EDCC = 60876  _TEXT       CPM22.asm:2987
rdseq2           = $EDF1 = 60913  _TEXT       CPM22.asm:3002
rdseq3           = $EE06 = 60934  _TEXT       CPM22.asm:3012
rdwrtflg         = $F1DE = 61918  _TEXT       CPM22.asm:3710
read             = $F30C = 62220  _TEXT       bios.asm:256
reader           = $F2CD = 62157  _TEXT       bios.asm:188
readfcb          = $DCFD = 56573  _TEXT       CPM22.asm:177
readran          = $EF9E = 61342  _TEXT       CPM22.asm:3279
readseq          = $F0EB = 61675  _TEXT       CPM22.asm:3518
relblock         = $F1E2 = 61922  _TEXT       CPM22.asm:3714
renam            = $DD0D = 56589  _TEXT       CPM22.asm:194
rename           = $E21D = 57885  _TEXT       CPM22.asm:1021
rename1          = $E24C = 57932  _TEXT       CPM22.asm:1039
rename2          = $E265 = 57957  _TEXT       CPM22.asm:1053
rename3          = $E26A = 57962  _TEXT       CPM22.asm:1056 (unused)
rename4          = $E278 = 57976  _TEXT       CPM22.asm:1064
rename5          = $E27E = 57982  _TEXT       CPM22.asm:1066
rename6          = $E284 = 57988  _TEXT       CPM22.asm:1068
renfile          = $F100 = 61696  _TEXT       CPM22.asm:3534
resccp           = $F364 = 62308  _TEXT       config\config_ndsk.asm:149
resdsk           = $DCB7 = 56503  _TEXT       CPM22.asm:107
resetdr          = $E073 = 57459  _TEXT       CPM22.asm:793
resgrb           = $F367 = 62311  _TEXT       config\config_ndsk.asm:155
rodisk           = $E410 = 58384  _TEXT       CPM22.asm:1269
rofile           = $E412 = 58386  _TEXT       CPM22.asm:1270
rstdsk           = $F08E = 61582  _TEXT       CPM22.asm:3462
rtn              = $E70F = 59151  _TEXT       CPM22.asm:1704
rtncode          = $E3FB = 58363  _TEXT       CPM22.asm:1245
samext           = $EB12 = 60178  _TEXT       CPM22.asm:2516
savatr1          = $EC4B = 60491  _TEXT       CPM22.asm:2756
save             = $E1BA = 57786  _TEXT       CPM22.asm:966
save1            = $E1E1 = 57825  _TEXT       CPM22.asm:984
save2            = $E1FE = 57854  _TEXT       CPM22.asm:1002
save3            = $E208 = 57864  _TEXT       CPM22.asm:1009
save4            = $E20E = 57870  _TEXT       CPM22.asm:1011
saveattr         = $EC46 = 60486  _TEXT       CPM22.asm:2754
savefcb          = $F1E4 = 61924  _TEXT       CPM22.asm:3716
savext           = $F1ED = 61933  _TEXT       CPM22.asm:3722
savnrec          = $F1EE = 61934  _TEXT       CPM22.asm:3723
savnxt           = $F1EC = 61932  _TEXT       CPM22.asm:3721
scratch1         = $F1BE = 61886  _TEXT       CPM22.asm:3684
scratch2         = $F1C0 = 61888  _TEXT       CPM22.asm:3685
scratch3         = $F1C2 = 61890  _TEXT       CPM22.asm:3686
search           = $DF36 = 57142  _TEXT       CPM22.asm:580
search1          = $DF3B = 57147  _TEXT       CPM22.asm:582
search2          = $DF44 = 57156  _TEXT       CPM22.asm:587
search3          = $DF57 = 57175  _TEXT       CPM22.asm:599
search4          = $DF5C = 57180  _TEXT       CPM22.asm:602
sectors          = $F1CC = 61900  _TEXT       CPM22.asm:3697
sectrn           = $F317 = 62231  _TEXT       bios.asm:276
seldsk           = $F2E0 = 62176  _TEXT       bios.asm:208
select           = $E764 = 59236  _TEXT       CPM22.asm:1755
select1          = $E7A8 = 59304  _TEXT       CPM22.asm:1795
setattr          = $F128 = 61736  _TEXT       CPM22.asm:3566
setbit           = $E916 = 59670  _TEXT       CPM22.asm:2087
setcdrv          = $DD19 = 56601  _TEXT       CPM22.asm:209
setdir           = $E9A7 = 59815  _TEXT       CPM22.asm:2221
setdma           = $F306 = 62214  _TEXT       bios.asm:248
setdsk           = $F050 = 61520  _TEXT       CPM22.asm:3422
setext           = $E8B1 = 59569  _TEXT       CPM22.asm:2002
setfile          = $EA76 = 60022  _TEXT       CPM22.asm:2406
setfl1           = $EA80 = 60032  _TEXT       CPM22.asm:2411
setfl2           = $EA93 = 60051  _TEXT       CPM22.asm:2423
setfl3           = $EA99 = 60057  _TEXT       CPM22.asm:2429
setfl4           = $EAA8 = 60072  _TEXT       CPM22.asm:2438
sethlde          = $E8B9 = 59577  _TEXT       CPM22.asm:2010
setiob           = $E6FE = 59134  _TEXT       CPM22.asm:1684
setnrec          = $E8DD = 59613  _TEXT       CPM22.asm:2036
setran           = $F019 = 61465  _TEXT       CPM22.asm:3385
sets2b7          = $E983 = 59779  _TEXT       CPM22.asm:2178
setsec           = $F302 = 62210  _TEXT       bios.asm:241
setstat          = $E70C = 59148  _TEXT       CPM22.asm:1703
settrk           = $F2FE = 62206  _TEXT       bios.asm:234
setuser          = $F146 = 61766  _TEXT       CPM22.asm:3586
shiftl           = $E90F = 59663  _TEXT       CPM22.asm:2078
shiftl1          = $E910 = 59664  _TEXT       CPM22.asm:2079
shiftr           = $E8F5 = 59637  _TEXT       CPM22.asm:2052
shiftr1          = $E8F6 = 59638  _TEXT       CPM22.asm:2053
showit           = $E58A = 58762  _TEXT       CPM22.asm:1459
siodev           = $FA07 = 64007  _TEXT       nabu_sio.asm:20
slcterr          = $E752 = 59218  _TEXT       CPM22.asm:1732
so_atab          = $FA77 = 64119  _TEXT       nabu_sio.asm:131
so_conf          = $FA7B = 64123  _TEXT       nabu_sio.asm:135
so_ini0          = $FA1A = 64026  _TEXT       nabu_sio.asm:39
so_ini1          = $FA20 = 64032  _TEXT       nabu_sio.asm:43
so_ini2          = $FA27 = 64039  _TEXT       nabu_sio.asm:49
so_ini3          = $FA33 = 64051  _TEXT       nabu_sio.asm:59
so_init          = $FA12 = 64018  _TEXT       nabu_sio.asm:33
so_rea0          = $FA5A = 64090  _TEXT       nabu_sio.asm:102
so_read          = $FA51 = 64081  _TEXT       nabu_sio.asm:95
so_sta0          = $FA49 = 64073  _TEXT       nabu_sio.asm:83
so_stat          = $FA40 = 64064  _TEXT       nabu_sio.asm:76
so_wri0          = $FA6D = 64109  _TEXT       nabu_sio.asm:121
so_writ          = $FA63 = 64099  _TEXT       nabu_sio.asm:113
space            = $DCA1 = 56481  _TEXT       CPM22.asm:87
srchfcb          = $DCE8 = 56552  _TEXT       CPM22.asm:154
srchfst          = $DCDE = 56542  _TEXT       CPM22.asm:144
srchnxt          = $DCE3 = 56547  _TEXT       CPM22.asm:149
starting         = $E716 = 59158  _TEXT       CPM22.asm:1712
status           = $E750 = 59216  _TEXT       CPM22.asm:1728
stbitmap         = $EA67 = 60007  _TEXT       CPM22.asm:2386
stbmap1          = $EA6F = 60015  _TEXT       CPM22.asm:2397
stddma           = $DDDD = 56797  _TEXT       CPM22.asm:349
stfilpos         = $EA09 = 59913  _TEXT       CPM22.asm:2301
stkarea          = $E74C = 59212  _TEXT       CPM22.asm:1723
stnrec1          = $E8E9 = 59625  _TEXT       CPM22.asm:2041
strdata          = $E8C6 = 59590  _TEXT       CPM22.asm:2020
ststatus         = $EB0C = 60172  _TEXT       CPM22.asm:2508
subhl            = $E9A0 = 59808  _TEXT       CPM22.asm:2211
swindi0          = $F32D = 62253  _TEXT       bios.asm:300
swindi1          = $F333 = 62259  _TEXT       bios.asm:304
swindir          = $F329 = 62249  _TEXT       bios.asm:298
synerr           = $DE11 = 56849  _TEXT       CPM22.asm:387
synerr1          = $DE17 = 56855  _TEXT       CPM22.asm:389
synerr2          = $DE2A = 56874  _TEXT       CPM22.asm:399
synerrt          = $E281 = 57985  _TEXT       CPM22.asm:1067
syshook          = $F363 = 62307  _TEXT       config\config_ndsk.asm:127
tab              = $0009 =     9  _TEXT       CPM22.asm:32
tbase            = $0100 =   256  _TEXT       CPM22.asm:25
tbuff            = $0080 =   128  _TEXT       CPM22.asm:24
tdrive           = $0004 =     4  _TEXT       CPM22.asm:21
tfcb             = $005C =    92  _TEXT       CPM22.asm:23
tm_40c           = $F5D8 = 62936  _TEXT       nabu_vdp.asm:450
tm_80c           = $F5E5 = 62949  _TEXT       nabu_vdp.asm:457
tm_addh          = $F6FC = 63228  _TEXT       nabu_vdp.asm:695
tm_addr          = $F6FE = 63230  _TEXT       nabu_vdp.asm:697
tm_atla          = $0041 =    65  _TEXT       nabu_vdp.asm:37
tm_ayda          = $0040 =    64  _TEXT       nabu_vdp.asm:36
tm_bs            = $F52E = 62766  _TEXT       nabu_vdp.asm:336
tm_cbuf          = $FA99 = 64153  _BSS        nabu_vdp.asm:26
tm_cha0          = $F6A0 = 63136  _TEXT       nabu_vdp.asm:618
tm_chat          = $F69A = 63130  _TEXT       nabu_vdp.asm:613
tm_cle0          = $F5C4 = 62916  _TEXT       nabu_vdp.asm:435
tm_clea          = $F5B5 = 62901  _TEXT       nabu_vdp.asm:426
tm_cles          = $F5B3 = 62899  _TEXT       nabu_vdp.asm:425
tm_cloc          = $F44B = 62539  _TEXT       nabu_vdp.asm:166
tm_cls           = $F6E1 = 63201  _TEXT       nabu_vdp.asm:672
tm_cls0          = $F6EA = 63210  _TEXT       nabu_vdp.asm:675
tm_cold          = $F728 = 63272  _TEXT       nabu_vdp.asm:738
tm_colr          = $F723 = 63267  _TEXT       nabu_vdp.asm:733
tm_cr            = $F52B = 62763  _TEXT       nabu_vdp.asm:333
tm_cshm          = $F53D = 62781  _TEXT       nabu_vdp.asm:350
tm_cupd          = $F5DC = 62940  _TEXT       nabu_vdp.asm:452
tm_curx          = $F726 = 63270  _TEXT       nabu_vdp.asm:736
tm_cury          = $F727 = 63271  _TEXT       nabu_vdp.asm:737
tm_data          = $00A0 =   160  _TEXT       nabu_vdp.asm:30
tm_dint          = $F70F = 63247  _TEXT       nabu_vdp.asm:716
tm_dsc0          = $F60B = 62987  _TEXT       nabu_vdp.asm:483
tm_dsco          = $F5F8 = 62968  _TEXT       nabu_vdp.asm:476
tm_eint          = $F718 = 63256  _TEXT       nabu_vdp.asm:725
tm_esc           = $F572 = 62834  _TEXT       nabu_vdp.asm:382
tm_esc0          = $F583 = 62851  _TEXT       nabu_vdp.asm:393
tm_esc1          = $F59D = 62877  _TEXT       nabu_vdp.asm:408
tm_esc2          = $F5A8 = 62888  _TEXT       nabu_vdp.asm:415
tm_escd          = $F57E = 62846  _TEXT       nabu_vdp.asm:390
tm_esci          = $F597 = 62871  _TEXT       nabu_vdp.asm:405
tm_escr          = $F57F = 62847  _TEXT       nabu_vdp.asm:391
tm_escs          = $FA97 = 64151  _BSS        nabu_vdp.asm:24
tm_get0          = $F634 = 63028  _TEXT       nabu_vdp.asm:518
tm_getc          = $F61E = 63006  _TEXT       nabu_vdp.asm:504
tm_home          = $F540 = 62784  _TEXT       nabu_vdp.asm:351
tm_inb           = $F724 = 63268  _TEXT       nabu_vdp.asm:734
tm_inf           = $F725 = 63269  _TEXT       nabu_vdp.asm:735
tm_ini0          = $F41E = 62494  _TEXT       nabu_vdp.asm:134
tm_ini1          = $F43E = 62526  _TEXT       nabu_vdp.asm:155
tm_inir          = $F3D0 = 62416  _TEXT       nabu_vdp.asm:79
tm_init          = $F3F6 = 62454  _TEXT       nabu_vdp.asm:110
tm_inr0          = $F3D1 = 62417  _TEXT       nabu_vdp.asm:80
tm_keyd          = $0090 =   144  _TEXT       nabu_vdp.asm:33
tm_keys          = $0091 =   145  _TEXT       nabu_vdp.asm:34
tm_kirq          = $F63C = 63036  _TEXT       nabu_vdp.asm:527
tm_last          = $FA98 = 64152  _BSS        nabu_vdp.asm:25
tm_latc          = $00A1 =   161  _TEXT       nabu_vdp.asm:31
tm_lf            = $F51F = 62751  _TEXT       nabu_vdp.asm:324
tm_map           = $F64A = 63050  _TEXT       nabu_vdp.asm:542
tm_map0          = $F64E = 63054  _TEXT       nabu_vdp.asm:546
tm_map2          = $F65A = 63066  _TEXT       nabu_vdp.asm:559
tm_mapt          = $F661 = 63073  _TEXT       nabu_vdp.asm:566
tm_mode          = $F721 = 63265  _TEXT       nabu_vdp.asm:732
tm_oti0          = $F3C8 = 62408  _TEXT       nabu_vdp.asm:66
tm_otir          = $F3C7 = 62407  _TEXT       nabu_vdp.asm:65
tm_outc          = $FA95 = 64149  _BSS        nabu_vdp.asm:22
tm_putc          = $F676 = 63094  _TEXT       nabu_vdp.asm:584
tm_putf          = $F684 = 63108  _TEXT       nabu_vdp.asm:592 (unused)
tm_rea0          = $F4AE = 62638  _TEXT       nabu_vdp.asm:237
tm_rea1          = $F4C3 = 62659  _TEXT       nabu_vdp.asm:250
tm_rea2          = $F4D3 = 62675  _TEXT       nabu_vdp.asm:260
tm_read          = $F498 = 62616  _TEXT       nabu_vdp.asm:225
tm_ri            = $F518 = 62744  _TEXT       nabu_vdp.asm:318
tm_sclf          = $F463 = 62563  _TEXT       nabu_vdp.asm:182
tm_scol          = $F5EB = 62955  _TEXT       nabu_vdp.asm:462
tm_scr0          = $F45B = 62555  _TEXT       nabu_vdp.asm:179
tm_scr1          = $F461 = 62561  _TEXT       nabu_vdp.asm:181
tm_scri          = $F451 = 62545  _TEXT       nabu_vdp.asm:174
tm_scro          = $FA96 = 64150  _BSS        nabu_vdp.asm:23
tm_setp          = $F46D = 62573  _TEXT       nabu_vdp.asm:192
tm_sta0          = $F3E4 = 62436  _TEXT       nabu_vdp.asm:97
tm_sta1          = $F4E4 = 62692  _TEXT       nabu_vdp.asm:274
tm_stal          = $F4E1 = 62689  _TEXT       nabu_vdp.asm:272
tm_stat          = $F3D9 = 62425  _TEXT       nabu_vdp.asm:92
tm_up            = $F538 = 62776  _TEXT       nabu_vdp.asm:345
tm_updc          = $F5EF = 62959  _TEXT       nabu_vdp.asm:466
tm_usc0          = $F6CD = 63181  _TEXT       nabu_vdp.asm:651
tm_usco          = $F6BE = 63166  _TEXT       nabu_vdp.asm:644
tm_vcpy          = $F6A6 = 63142  _TEXT       nabu_vdp.asm:630
tm_virq          = $F709 = 63241  _TEXT       nabu_vdp.asm:706
tm_wri0          = $F505 = 62725  _TEXT       nabu_vdp.asm:306
tm_wri1          = $F544 = 62788  _TEXT       nabu_vdp.asm:356
tm_writ          = $F4EA = 62698  _TEXT       nabu_vdp.asm:286
trksec           = $E7CE = 59342  _TEXT       CPM22.asm:1829
trksec1          = $E7DC = 59356  _TEXT       CPM22.asm:1838
trksec2          = $E7EF = 59375  _TEXT       CPM22.asm:1851
trksec3          = $E805 = 59397  _TEXT       CPM22.asm:1867
trksec4          = $E81A = 59418  _TEXT       CPM22.asm:1884
type             = $E16A = 57706  _TEXT       CPM22.asm:923
type1            = $E181 = 57729  _TEXT       CPM22.asm:931
type2            = $E184 = 57732  _TEXT       CPM22.asm:932 (unused)
type3            = $E194 = 57748  _TEXT       CPM22.asm:941
type4            = $E1AD = 57773  _TEXT       CPM22.asm:954
type5            = $E1B4 = 57780  _TEXT       CPM22.asm:957
unknown          = $E2AE = 58030  _TEXT       CPM22.asm:1095
unkwn0           = $E36F = 58223  _TEXT       CPM22.asm:1203
unkwn1           = $E2CC = 58060  _TEXT       CPM22.asm:1110
unkwn2           = $E2D4 = 58068  _TEXT       CPM22.asm:1114 (unused)
unkwn3           = $E2E8 = 58088  _TEXT       CPM22.asm:1125
unkwn4           = $E305 = 58117  _TEXT       CPM22.asm:1144
unkwn5           = $E333 = 58163  _TEXT       CPM22.asm:1165
unkwn6           = $E33E = 58174  _TEXT       CPM22.asm:1175
unkwn7           = $E343 = 58179  _TEXT       CPM22.asm:1177
unkwn8           = $E34D = 58189  _TEXT       CPM22.asm:1185
unkwn9           = $E369 = 58217  _TEXT       CPM22.asm:1201
update           = $EC0C = 60428  _TEXT       CPM22.asm:2717
update1          = $EC1B = 60443  _TEXT       CPM22.asm:2725
upper            = $DD2F = 56623  _TEXT       CPM22.asm:228
user             = $E299 = 58009  _TEXT       CPM22.asm:1079
userdma          = $F1BC = 61884  _TEXT       CPM22.asm:3680
userno           = $E74C = 59212  _TEXT       CPM22.asm:1725
usrstack         = $E71A = 59162  _TEXT       CPM22.asm:1719
vdpdev           = $F3BA = 62394  _TEXT       nabu_vdp.asm:51
verify           = $DDFD = 56829  _TEXT       CPM22.asm:373
verify1          = $DE05 = 56837  _TEXT       CPM22.asm:376
wbinit           = $F34B = 62283  _TEXT       config\config_ndsk.asm:65
wboot            = $F248 = 62024  _TEXT       bios.asm:57
wboot0           = $F26F = 62063  _TEXT       bios.asm:94
wbootin          = $F20A = 61962  _TEXT       bios.asm:22
wbootr           = $F25F = 62047  _TEXT       bios.asm:82
write            = $F310 = 62224  _TEXT       bios.asm:263
writeran         = $EFA7 = 61351  _TEXT       CPM22.asm:3286
wrtprt           = $F1B8 = 61880  _TEXT       CPM22.asm:3678
wrtprtd          = $E937 = 59703  _TEXT       CPM22.asm:2114
wrtrec           = $DD03 = 56579  _TEXT       CPM22.asm:183
wrtseq           = $F0F1 = 61681  _TEXT       CPM22.asm:3523
wtrandom         = $F152 = 61778  _TEXT       CPM22.asm:3597
wtseq            = $EE09 = 60937  _TEXT       CPM22.asm:3016
wtseq1           = $EE0E = 60942  _TEXT       CPM22.asm:3018
wtseq10          = $EEDD = 61149  _TEXT       CPM22.asm:3133
wtseq11          = $EF09 = 61193  _TEXT       CPM22.asm:3157
wtseq12          = $EF0B = 61195  _TEXT       CPM22.asm:3158
wtseq2           = $EE46 = 60998  _TEXT       CPM22.asm:3041
wtseq3           = $EE53 = 61011  _TEXT       CPM22.asm:3047
wtseq4           = $EE6F = 61039  _TEXT       CPM22.asm:3059
wtseq5           = $EE77 = 61047  _TEXT       CPM22.asm:3066
wtseq6           = $EE79 = 61049  _TEXT       CPM22.asm:3067
wtseq7           = $EE97 = 61079  _TEXT       CPM22.asm:3090
wtseq8           = $EEA5 = 61093  _TEXT       CPM22.asm:3097
wtseq9           = $EEC6 = 61126  _TEXT       CPM22.asm:3117
wtseq99          = $EEEA = 61162  _TEXT       CPM22.asm:3144 (unused)
wtspecl          = $F1A6 = 61862  _TEXT       CPM22.asm:3663
xlate            = $F1DB = 61915  _TEXT       CPM22.asm:3706
yesno            = $E15F = 57695  _TEXT       CPM22.asm:915


total time: 0.0600 sec.
no errors
