              	; --------------------------------------
              	; zasm: assemble "config\config_nfs_hybrid.asm"
              	; date: 2023-05-17 22:16:11
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0035:         	mem	equ	53		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
D400:         	#code	_TEXT,(mem)*1024
F7D9:         	#data	_BSS,_TEXT_end
F7D9: 00000000	dircbuf:defs	128
F7DD: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "CPM22.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	;
              	;   set origin for cp/m
              	;
              	;	org	(mem)*1024
              	;
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
D400: C35CD7  	cbase:	jp	command		;execute command processor (ccp).
D403: C358D7  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
D406: 7F      	inbuff:	defb	127		;length of input buffer.
D407: 00      		defb	0		;current length of contents.
D408: 494E4954		defb	'INIT '
D40C: 20      	
D40D: FF000000		defb	255,0,0,0
D411: 20313937		defb	' 1979 (c) by Digital Research      '
D415: 39202863	
D419: 29206279	
D41D: 20446967	
D421: 6974616C	
D425: 20526573	
D429: 65617263	
D42D: 68202020	
D431: 202020  	
D434: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D438: 00...   	
D44B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D44F: 00...   	
D462: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D466: 00...   	
D479: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D47D: 00...   	
D488: 08D4    	inpoint:defw	inbuff+2	;input line pointer
D48A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
D48C: 5F      	print:	ld	e,a		;setup bdos call.
D48D: 0E02    		ld	c,2
D48F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
D492: C5      	printb:	push	bc
D493: CD8CD4  		call	print
D496: C1      		pop	bc
D497: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
D498: 3E0D    	crlf:	ld	a,cr
D49A: CD92D4  		call	printb
D49D: 3E0A    		ld	a,lf
D49F: C392D4  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
D4A2: 3E20    	space:	ld	a,' '
D4A4: C392D4  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
D4A7: C5      	pline:	push	bc
D4A8: CD98D4  		call	crlf
D4AB: E1      		pop	hl
D4AC: 7E      	pline2:	ld	a,(hl)
D4AD: B7      		or	a
D4AE: C8      		ret	z
D4AF: 23      		inc	hl
D4B0: E5      		push	hl
D4B1: CD8CD4  		call	print
D4B4: E1      		pop	hl
D4B5: C3ACD4  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
D4B8: 0E0D    	resdsk:	ld	c,13
D4BA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
D4BD: 5F      	dsksel:	ld	e,a
D4BE: 0E0E    		ld	c,14
D4C0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
D4C3: CD0500  	entry1:	call	entry
D4C6: 32FBDB  		ld	(rtncode),a	;save return code.
D4C9: 3C      		inc	a		;set zero if 0ffh returned.
D4CA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
D4CB: 0E0F    	open:	ld	c,15
D4CD: C3C3D4  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
D4D0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
D4D1: 32FADB  		ld	(fcb+32),a
D4D4: 11DADB  		ld	de,fcb
D4D7: C3CBD4  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
D4DA: 0E10    	close:	ld	c,16
D4DC: C3C3D4  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
D4DF: 0E11    	srchfst:ld	c,17
D4E1: C3C3D4  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
D4E4: 0E12    	srchnxt:ld	c,18
D4E6: C3C3D4  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
D4E9: 11DADB  	srchfcb:ld	de,fcb
D4EC: C3DFD4  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
D4EF: 0E13    	delete:	ld	c,19
D4F1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
D4F4: CD0500  	entry2:	call	entry
D4F7: B7      		or	a		;set zero flag if appropriate.
D4F8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
D4F9: 0E14    	rdrec:	ld	c,20
D4FB: C3F4D4  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
D4FE: 11DADB  	readfcb:ld	de,fcb
D501: C3F9D4  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
D504: 0E15    	wrtrec:	ld	c,21
D506: C3F4D4  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
D509: 0E16    	create:	ld	c,22
D50B: C3C3D4  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
D50E: 0E17    	renam:	ld	c,23
D510: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
D513: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
D515: 0E20    	getsetuc: ld	c,32
D517: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
D51A: CD13D5  	setcdrv:call	getusr		;get user number
D51D: 87      		add	a,a		;and shift into the upper 4 bits.
D51E: 87      		add	a,a
D51F: 87      		add	a,a
D520: 87      		add	a,a
D521: 21FCDB  		ld	hl,cdrive	;now add in the current drive number.
D524: B6      		or	(hl)
D525: 320400  		ld	(tdrive),a	;and save.
D528: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
D529: 3AFCDB  	movecd:	ld	a,(cdrive)
D52C: 320400  		ld	(tdrive),a
D52F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
D530: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
D532: D8      		ret	c
D533: FE7B    		cp	'{'
D535: D0      		ret	nc
D536: E65F    		and	5fh		;convert it if found.
D538: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
D539: 3AB8DB  	getinp:	ld	a,(batch)	;if =0, then use console input.
D53C: B7      		or	a
D53D: CA96D5  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
D540: 3AFCDB  		ld	a,(cdrive)	;select drive 0 if need be.
D543: B7      		or	a
D544: 3E00    		ld	a,0		;always use drive a for submit.
D546: C4BDD4  		call	nz,dsksel	;select it if required.
D549: 11B9DB  		ld	de,batchfcb
D54C: CDCBD4  		call	open		;look for it.
D54F: CA96D5  		jp	z,getinp1	;if not there, use normal input.
D552: 3AC8DB  		ld	a,(batchfcb+15)	;get last record number+1.
D555: 3D      		dec	a
D556: 32D9DB  		ld	(batchfcb+32),a
D559: 11B9DB  		ld	de,batchfcb
D55C: CDF9D4  		call	rdrec		;read last record.
D55F: C296D5  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
D562: 1107D4  		ld	de,inbuff+1
D565: 218000  		ld	hl,tbuff	;data was read into buffer here.
D568: 0680    		ld	b,128		;all 128 characters may be used.
D56A: CD4FD8  		call	hl2de		;(hl) to (de), (b) bytes.
D56D: 21C7DB  		ld	hl,batchfcb+14
D570: 3600    		ld	(hl),0		;zero out the 's2' byte.
D572: 23      		inc	hl		;and decrement the record count.
D573: 35      		dec	(hl)
D574: 11B9DB  		ld	de,batchfcb	;close the batch file now.
D577: CDDAD4  		call	close
D57A: CA96D5  		jp	z,getinp1	;quit on an error.
D57D: 3AFCDB  		ld	a,(cdrive)	;re-select previous drive if need be.
D580: B7      		or	a
D581: C4BDD4  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
D584: 2108D4  		ld	hl,inbuff+2
D587: CDACD4  		call	pline2
D58A: CDC2D5  		call	chkcon		;check console, quit on a key.
D58D: CAA7D5  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
D590: CDDDD5  		call	delbatch	;delete the batch file.
D593: C382D7  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
D596: CDDDD5  	getinp1:call	delbatch	;delete file ($$$.sub).
D599: CD1AD5  		call	setcdrv		;reset active disk.
D59C: 0E0A    		ld	c,10		;get line from console device.
D59E: 1106D4  		ld	de,inbuff
D5A1: CD0500  		call	entry
D5A4: CD29D5  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
D5A7: 2107D4  	getinp2:ld	hl,inbuff+1
D5AA: 46      		ld	b,(hl)		;(b)=character counter.
D5AB: 23      	getinp3:inc	hl
D5AC: 78      		ld	a,b		;end of the line?
D5AD: B7      		or	a
D5AE: CABAD5  		jp	z,getinp4
D5B1: 7E      		ld	a,(hl)		;convert to upper case.
D5B2: CD30D5  		call	upper
D5B5: 77      		ld	(hl),a
D5B6: 05      		dec	b		;adjust character count.
D5B7: C3ABD5  		jp	getinp3
D5BA: 77      	getinp4:ld	(hl),a		;add trailing null.
D5BB: 2108D4  		ld	hl,inbuff+2
D5BE: 2288D4  		ld	(inpoint),hl	;reset input line pointer.
D5C1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
D5C2: 0E0B    	chkcon:	ld	c,11		;check console.
D5C4: CD0500  		call	entry
D5C7: B7      		or	a
D5C8: C8      		ret	z		;return if nothing.
D5C9: 0E01    		ld	c,1		;else get character.
D5CB: CD0500  		call	entry
D5CE: B7      		or	a		;clear zero flag and return.
D5CF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
D5D0: 0E19    	getdsk:	ld	c,25
D5D2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
D5D5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
D5D8: 0E1A    	dmaset:	ld	c,26
D5DA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
D5DD: 21B8DB  	delbatch: ld	hl,batch	;is batch active?
D5E0: 7E      		ld	a,(hl)
D5E1: B7      		or	a
D5E2: C8      		ret	z
D5E3: 3600    		ld	(hl),0		;yes, de-activate it.
D5E5: AF      		xor	a
D5E6: CDBDD4  		call	dsksel		;select drive 0 for sure.
D5E9: 11B9DB  		ld	de,batchfcb	;and delete this file.
D5EC: CDEFD4  		call	delete
D5EF: 3AFCDB  		ld	a,(cdrive)	;reset current drive.
D5F2: C3BDD4  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
D5F5: 112AD7  	verify:	ld	de,pattrn1+2	;these are the serial number bytes.
D5F8: 2102DC  		ld	hl,pattrn2+2	;ditto, but how could they be different?
D5FB: 0604    		ld	b,4		;6 bytes each.
D5FD: 1A      	verify1:ld	a,(de)
D5FE: BE      		cp	(hl)
D5FF: C2DCD7  		jp	nz,halt		;jump to halt routine.
D602: 13      		inc	de
D603: 23      		inc	hl
D604: 05      		dec	b
D605: C2FDD5  		jp	nz,verify1
D608: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
D609: CD98D4  	synerr:	call	crlf		;end current line.
D60C: 2A8AD4  		ld	hl,(namepnt)	;this points to name in error.
D60F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
D610: FE20    		cp	' '
D612: CA22D6  		jp	z,synerr2
D615: B7      		or	a
D616: CA22D6  		jp	z,synerr2
D619: E5      		push	hl
D61A: CD8CD4  		call	print
D61D: E1      		pop	hl
D61E: 23      		inc	hl
D61F: C30FD6  		jp	synerr1
D622: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
D624: CD8CD4  		call	print
D627: CD98D4  		call	crlf
D62A: CDDDD5  		call	delbatch	;delete any batch file.
D62D: C382D7  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
D630: 1A      	check:	ld	a,(de)
D631: B7      		or	a
D632: C8      		ret	z
D633: FE20    		cp	' '		;control characters are not legal here.
D635: DA09D6  		jp	c,synerr
D638: C8      		ret	z		;check for valid delimiter.
D639: FE3D    		cp	'='
D63B: C8      		ret	z
D63C: FE5F    		cp	'_'
D63E: C8      		ret	z
D63F: FE2E    		cp	'.'
D641: C8      		ret	z
D642: FE3A    		cp	':'
D644: C8      		ret	z
D645: FE3B    		cp	';'
D647: C8      		ret	z
D648: FE3C    		cp	'<'
D64A: C8      		ret	z
D64B: FE3E    		cp	'>'
D64D: C8      		ret	z
D64E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
D64F: 1A      	nonblank: ld	a,(de)
D650: B7      		or	a		;string ends with a null.
D651: C8      		ret	z
D652: FE20    		cp	' '
D654: C0      		ret	nz
D655: 13      		inc	de
D656: C34FD6  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
D659: 85      	addhl:	add	a,l
D65A: 6F      		ld	l,a
D65B: D0      		ret	nc		;take care of any carry.
D65C: 24      		inc	h
D65D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
D65E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
D660: 21DADB  	convert:ld	hl,fcb
D663: CD59D6  		call	addhl
D666: E5      		push	hl
D667: E5      		push	hl
D668: AF      		xor	a
D669: 32FDDB  		ld	(chgdrv),a	;initialize drive change flag.
D66C: 2A88D4  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
D66F: EB      		ex	de,hl
D670: CD4FD6  		call	nonblank	;get next non-blank character.
D673: EB      		ex	de,hl
D674: 228AD4  		ld	(namepnt),hl	;save pointer here for any error message.
D677: EB      		ex	de,hl
D678: E1      		pop	hl
D679: 1A      		ld	a,(de)		;get first character.
D67A: B7      		or	a
D67B: CA89D6  		jp	z,convrt1
D67E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
D680: 47      		ld	b,a		;and save.
D681: 13      		inc	de		;check next character for a ':'.
D682: 1A      		ld	a,(de)
D683: FE3A    		cp	':'
D685: CA90D6  		jp	z,convrt2
D688: 1B      		dec	de		;nope, move pointer back to the start of the line.
D689: 3AFCDB  	convrt1:ld	a,(cdrive)
D68C: 77      		ld	(hl),a
D68D: C396D6  		jp	convrt3
D690: 78      	convrt2:ld	a,b
D691: 32FDDB  		ld	(chgdrv),a	;set change in drives flag.
D694: 70      		ld	(hl),b
D695: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
D696: 0608    	convrt3:ld	b,08h
D698: CD30D6  	convrt4:call	check
D69B: CAB9D6  		jp	z,convrt8
D69E: 23      		inc	hl
D69F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
D6A1: C2A9D6  		jp	nz,convrt5	;field with '?'.
D6A4: 363F    		ld	(hl),'?'
D6A6: C3ABD6  		jp	convrt6
D6A9: 77      	convrt5:ld	(hl),a
D6AA: 13      		inc	de
D6AB: 05      	convrt6:dec	b
D6AC: C298D6  		jp	nz,convrt4
D6AF: CD30D6  	convrt7:call	check		;get next delimiter.
D6B2: CAC0D6  		jp	z,getext
D6B5: 13      		inc	de
D6B6: C3AFD6  		jp	convrt7
D6B9: 23      	convrt8:inc	hl		;blank fill the file name.
D6BA: 3620    		ld	(hl),' '
D6BC: 05      		dec	b
D6BD: C2B9D6  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
D6C0: 0603    	getext:	ld	b,03h
D6C2: FE2E    		cp	'.'
D6C4: C2E9D6  		jp	nz,getext5
D6C7: 13      		inc	de
D6C8: CD30D6  	getext1:call	check
D6CB: CAE9D6  		jp	z,getext5
D6CE: 23      		inc	hl
D6CF: FE2A    		cp	'*'
D6D1: C2D9D6  		jp	nz,getext2
D6D4: 363F    		ld	(hl),'?'
D6D6: C3DBD6  		jp	getext3
D6D9: 77      	getext2:ld	(hl),a
D6DA: 13      		inc	de
D6DB: 05      	getext3:dec	b
D6DC: C2C8D6  		jp	nz,getext1
D6DF: CD30D6  	getext4:call	check
D6E2: CAF0D6  		jp	z,getext6
D6E5: 13      		inc	de
D6E6: C3DFD6  		jp	getext4
D6E9: 23      	getext5:inc	hl
D6EA: 3620    		ld	(hl),' '
D6EC: 05      		dec	b
D6ED: C2E9D6  		jp	nz,getext5
D6F0: 0603    	getext6:ld	b,3
D6F2: 23      	getext7:inc	hl
D6F3: 3600    		ld	(hl),0
D6F5: 05      		dec	b
D6F6: C2F2D6  		jp	nz,getext7
D6F9: EB      		ex	de,hl
D6FA: 2288D4  		ld	(inpoint),hl	;save input line pointer.
D6FD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
D6FE: 010B00  		ld	bc,11		;set name length.
D701: 23      	getext8:inc	hl
D702: 7E      		ld	a,(hl)
D703: FE3F    		cp	'?'		;any question marks?
D705: C209D7  		jp	nz,getext9
D708: 04      		inc	b		;count them.
D709: 0D      	getext9:dec	c
D70A: C201D7  		jp	nz,getext8
D70D: 78      		ld	a,b
D70E: B7      		or	a
D70F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
D710: 44495220	cmdtbl:	defb	'DIR '
D714: 45524120		defb	'ERA '
D718: 54595045		defb	'TYPE'
D71C: 53415645		defb	'SAVE'
D720: 52454E20		defb	'REN '
D724: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
D728: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
D72C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
D72E: 2110D7  	search:	ld	hl,cmdtbl
D731: 0E00    		ld	c,0
D733: 79      	search1:ld	a,c
D734: FE06    		cp	numcmds		;this commands exists.
D736: D0      		ret	nc
D737: 11DBDB  		ld	de,fcb+1	;check this one.
D73A: 0604    		ld	b,4		;max command length.
D73C: 1A      	search2:ld	a,(de)
D73D: BE      		cp	(hl)
D73E: C24FD7  		jp	nz,search3	;not a match.
D741: 13      		inc	de
D742: 23      		inc	hl
D743: 05      		dec	b
D744: C23CD7  		jp	nz,search2
D747: 1A      		ld	a,(de)		;allow a 3 character command to match.
D748: FE20    		cp	' '
D74A: C254D7  		jp	nz,search4
D74D: 79      		ld	a,c		;set return register for this command.
D74E: C9      		ret	
D74F: 23      	search3:inc	hl
D750: 05      		dec	b
D751: C24FD7  		jp	nz,search3
D754: 0C      	search4:inc	c
D755: C333D7  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
D758: AF      	clearbuf: xor	a
D759: 3207D4  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
D75C: 31B8DB  	command:ld	sp,ccpstack	;setup stack area.
D75F: C5      		push	bc		;note that (c) should be equal to:
D760: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
D761: 1F      		rra			;and 'dddd' is the drive number.
D762: 1F      		rra	
D763: 1F      		rra	
D764: 1F      		rra	
D765: E60F    		and	0fh		;isolate the user number.
D767: 5F      		ld	e,a
D768: CD15D5  		call	getsetuc	;and set it.
D76B: CDB8D4  		call	resdsk		;reset the disk system.
D76E: 32B8DB  		ld	(batch),a	;clear batch mode flag.
D771: C1      		pop	bc
D772: 79      		ld	a,c
D773: E60F    		and	0fh		;isolate the drive number.
D775: 32FCDB  		ld	(cdrive),a	;and save.
D778: CDBDD4  		call	dsksel		;...and select.
D77B: 3A07D4  		ld	a,(inbuff+1)
D77E: B7      		or	a		;anything in input buffer already?
D77F: C2A5D7  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
D782: 31B8DB  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
D785: CD98D4  		call	crlf		;start a new line on the screen.
D788: CDD0D5  		call	getdsk		;get current drive.
D78B: C641    		add	a,'A'
D78D: CD8CD4  		call	print		;print current drive.
D790: 00      		nop
D791: 00      		nop
D792: 00      		nop
D793: 00      		nop
D794: 00      		nop
D795: CD13D5  		call	getusr		;get current user.
D798: C630    		add	a,'0'
D79A: CD02EA  		call	printdc		;print current user.
D79D: 3E3E    		ld	a,'>'
D79F: CD8CD4  		call	print		;and add prompt.
D7A2: CD39D5  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
D7A5: 118000  	cmmnd2:	ld	de,tbuff
D7A8: CDD8D5  		call	dmaset		;set standard dma address.
D7AB: CDD0D5  		call	getdsk
D7AE: 32FCDB  		ld	(cdrive),a	;set current drive.
D7B1: CD5ED6  		call	convfst		;convert name typed in.
D7B4: C409D6  		call	nz,synerr	;wild cards are not allowed.
D7B7: 3AFDDB  		ld	a,(chgdrv)	;if a change in drives was indicated,
D7BA: B7      		or	a		;then treat this as an unknown command
D7BB: C2B2DA  		jp	nz,unknown	;which gets executed.
D7BE: CD2ED7  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
D7C1: 21CED7  		ld	hl,cmdadr	;now, look thru our address table for command (a).
D7C4: 5F      		ld	e,a		;set (de) to command number.
D7C5: 1600    		ld	d,0
D7C7: 19      		add	hl,de
D7C8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
D7C9: 7E      		ld	a,(hl)		;now pick out this address.
D7CA: 23      		inc	hl
D7CB: 66      		ld	h,(hl)
D7CC: 6F      		ld	l,a
D7CD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
D7CE: 84D82CD9	cmdadr:	defw	direct,erase,type,save
D7D2: 6AD9BAD9	
D7D6: 1DDA9BDA		defw	rename,user,unknown
D7DA: B2DA    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
D7DC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
D7DF: 2200D4  		ld	(cbase),hl
D7E2: 2100D4  		ld	hl,cbase
D7E5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
D7E6: 01ECD7  	rderror:ld	bc,rderr
D7E9: C3A7D4  		jp	pline
D7EC: 72656164	rderr:	defb	'read error',0
D7F0: 20657272	
D7F4: 6F7200  	
              	;
              	;   required file was not located.
              	;
D7F7: 01FDD7  	none:	ld	bc,nofile
D7FA: C3A7D4  		jp	pline
D7FD: 6E6F2066	nofile:	defb	'no file',0
D801: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
D805: CD5ED6  	decode:	call	convfst		;convert filename.
D808: 3AFDDB  		ld	a,(chgdrv)	;do not allow a drive to be specified.
D80B: B7      		or	a
D80C: C209D6  		jp	nz,synerr
D80F: 21DBDB  		ld	hl,fcb+1	;convert number now.
D812: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
D815: 7E      	decode1:ld	a,(hl)
D816: FE20    		cp	' '		;a space terminates the numeral.
D818: CA40D8  		jp	z,decode3
D81B: 23      		inc	hl
D81C: D630    		sub	'0'		;make binary from ascii.
D81E: FE0A    		cp	10		;legal digit?
D820: D209D6  		jp	nc,synerr
D823: 57      		ld	d,a		;yes, save it in (d).
D824: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
D825: E6E0    		and	0e0h
D827: C209D6  		jp	nz,synerr
D82A: 78      		ld	a,b
D82B: 07      		rlca	
D82C: 07      		rlca	
D82D: 07      		rlca			;(a)=(b)*8
D82E: 80      		add	a,b		;.......*9
D82F: DA09D6  		jp	c,synerr
D832: 80      		add	a,b		;.......*10
D833: DA09D6  		jp	c,synerr
D836: 82      		add	a,d		;add in new digit now.
D837: DA09D6  	decode2:jp	c,synerr
D83A: 47      		ld	b,a		;and save result.
D83B: 0D      		dec	c		;only look at 11 digits.
D83C: C215D8  		jp	nz,decode1
D83F: C9      		ret	
D840: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
D841: FE20    		cp	' '
D843: C209D6  		jp	nz,synerr
D846: 23      		inc	hl
D847: 0D      	decode4:dec	c
D848: C240D8  		jp	nz,decode3
D84B: 78      		ld	a,b		;set (a)=the numeric value entered.
D84C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
D84D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
D84F: 7E      	hl2de:	ld	a,(hl)
D850: 12      		ld	(de),a
D851: 23      		inc	hl
D852: 13      		inc	de
D853: 05      		dec	b
D854: C24FD8  		jp	nz,hl2de
D857: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
D858: 218000  	extract:ld	hl,tbuff
D85B: 81      		add	a,c
D85C: CD59D6  		call	addhl
D85F: 7E      		ld	a,(hl)
D860: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
D861: AF      	dselect:xor	a		;null out first byte of fcb.
D862: 32DADB  		ld	(fcb),a
D865: 3AFDDB  		ld	a,(chgdrv)	;a drive change indicated?
D868: B7      		or	a
D869: C8      		ret	z
D86A: 3D      		dec	a		;yes, is it the same as the current drive?
D86B: 21FCDB  		ld	hl,cdrive
D86E: BE      		cp	(hl)
D86F: C8      		ret	z
D870: C3BDD4  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
D873: 3AFDDB  	resetdr:ld	a,(chgdrv)	;drive change indicated?
D876: B7      		or	a
D877: C8      		ret	z
D878: 3D      		dec	a		;yes, was it a different drive?
D879: 21FCDB  		ld	hl,cdrive
D87C: BE      		cp	(hl)
D87D: C8      		ret	z
D87E: 3AFCDB  		ld	a,(cdrive)	;yes, re-select our old drive.
D881: C3BDD4  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
D884: CD5ED6  	direct:	call	convfst		;convert file name.
D887: CD61D8  		call	dselect		;select indicated drive.
D88A: 21DBDB  		ld	hl,fcb+1	;was any file indicated?
D88D: 7E      		ld	a,(hl)
D88E: FE20    		cp	' '
D890: C29CD8  		jp	nz,direct2
D893: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
D895: 363F    	direct1:ld	(hl),'?'
D897: 23      		inc	hl
D898: 05      		dec	b
D899: C295D8  		jp	nz,direct1
D89C: 1E00    	direct2:ld	e,0		;set initial cursor position.
D89E: D5      		push	de
D89F: CDE9D4  		call	srchfcb		;get first file name.
D8A2: CCF7D7  		call	z,none		;none found at all?
D8A5: CA28D9  	direct3:jp	z,direct9	;terminate if no more names.
D8A8: 3AFBDB  		ld	a,(rtncode)	;get file's position in segment (0-3).
D8AB: 0F      		rrca	
D8AC: 0F      		rrca	
D8AD: 0F      		rrca	
D8AE: E660    		and	60h		;(a)=position*32
D8B0: 4F      		ld	c,a
D8B1: 3E0A    		ld	a,10
D8B3: CD58D8  		call	extract		;extract the tenth entry in fcb.
D8B6: 17      		rla			;check system file status bit.
D8B7: DA1CD9  		jp	c,direct8	;we don't list them.
D8BA: D1      		pop	de
D8BB: 7B      		ld	a,e		;bump name count.
D8BC: 1C      		inc	e
D8BD: D5      		push	de
D8BE: E603    		and	03h		;at end of line?
D8C0: F5      		push	af
D8C1: C2D9D8  		jp	nz,direct4
D8C4: CD98D4  		call	crlf		;yes, end this line and start another.
D8C7: C5      		push	bc
D8C8: CDD0D5  		call	getdsk		;start line with ('a:').
D8CB: C1      		pop	bc
D8CC: C641    		add	a,'A'
D8CE: CD92D4  		call	printb
D8D1: 3E3A    		ld	a,':'
D8D3: CD92D4  		call	printb
D8D6: C3E1D8  		jp	direct5
D8D9: CDA2D4  	direct4:call	space		;add seperator between file names.
D8DC: 3E3A    		ld	a,':'
D8DE: CD92D4  		call	printb
D8E1: CDA2D4  	direct5:call	space
D8E4: 0601    		ld	b,1		;'extract' each file name character at a time.
D8E6: 78      	direct6:ld	a,b
D8E7: CD58D8  		call	extract
D8EA: E67F    		and	7fh		;strip bit 7 (status bit).
D8EC: FE20    		cp	' '		;are we at the end of the name?
D8EE: C206D9  		jp	nz,drect65
D8F1: F1      		pop	af		;yes, don't print spaces at the end of a line.
D8F2: F5      		push	af
D8F3: FE03    		cp	3
D8F5: C204D9  		jp	nz,drect63
D8F8: 3E09    		ld	a,9		;first check for no extension.
D8FA: CD58D8  		call	extract
D8FD: E67F    		and	7fh
D8FF: FE20    		cp	' '
D901: CA1BD9  		jp	z,direct7	;don't print spaces.
D904: 3E20    	drect63:ld	a,' '		;else print them.
D906: CD92D4  	drect65:call	printb
D909: 04      		inc	b		;bump to next character psoition.
D90A: 78      		ld	a,b
D90B: FE0C    		cp	12		;end of the name?
D90D: D21BD9  		jp	nc,direct7
D910: FE09    		cp	9		;nope, starting extension?
D912: C2E6D8  		jp	nz,direct6
D915: CDA2D4  		call	space		;yes, add seperating space.
D918: C3E6D8  		jp	direct6
D91B: F1      	direct7:pop	af		;get the next file name.
D91C: CDC2D5  	direct8:call	chkcon		;first check console, quit on anything.
D91F: C228D9  		jp	nz,direct9
D922: CDE4D4  		call	srchnxt		;get next name.
D925: C3A5D8  		jp	direct3		;and continue with our list.
D928: D1      	direct9:pop	de		;restore the stack and return to command level.
D929: C393DB  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D92C: CD5ED6  	erase:	call	convfst		;convert file name.
D92F: FE0B    		cp	11		;was '*.*' entered?
D931: C24FD9  		jp	nz,erase1
D934: 015FD9  		ld	bc,yesno	;yes, ask for confirmation.
D937: CDA7D4  		call	pline
D93A: CD39D5  		call	getinp
D93D: 2107D4  		ld	hl,inbuff+1
D940: 35      		dec	(hl)		;must be exactly 'y'.
D941: C282D7  		jp	nz,cmmnd1
D944: 23      		inc	hl
D945: 7E      		ld	a,(hl)
D946: FE79    		cp	'y'
D948: C282D7  		jp	nz,cmmnd1
D94B: 23      		inc	hl
D94C: 2288D4  		ld	(inpoint),hl	;save input line pointer.
D94F: CD61D8  	erase1:	call	dselect		;select desired disk.
D952: 11DADB  		ld	de,fcb
D955: CDEFD4  		call	delete		;delete the file.
D958: 3C      		inc	a
D959: CCF7D7  		call	z,none		;not there?
D95C: C393DB  		jp	getback		;return to command level now.
D95F: 616C6C20	yesno:	defb	'all (y/n)?',0
D963: 28792F6E	
D967: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D96A: CD5ED6  	type:	call	convfst		;convert file name.
D96D: C209D6  		jp	nz,synerr	;wild cards not allowed.
D970: CD61D8  		call	dselect		;select indicated drive.
D973: CDD0D4  		call	openfcb		;open the file.
D976: CAB4D9  		jp	z,type5		;not there?
D979: CD98D4  		call	crlf		;ok, start a new line on the screen.
D97C: 21FEDB  		ld	hl,nbytes	;initialize byte counter.
D97F: 36FF    		ld	(hl),0ffh	;set to read first sector.
D981: 21FEDB  	type1:	ld	hl,nbytes
D984: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
D985: FE80    		cp	128
D987: DA94D9  		jp	c,type3
D98A: E5      		push	hl		;yes, read in the next one.
D98B: CDFED4  		call	readfcb
D98E: E1      		pop	hl
D98F: C2ADD9  		jp	nz,type4	;end or error?
D992: AF      		xor	a		;ok, clear byte counter.
D993: 77      		ld	(hl),a
D994: 34      	type3:	inc	(hl)		;count this byte.
D995: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
D998: CD59D6  		call	addhl
D99B: 7E      		ld	a,(hl)
D99C: FE1A    		cp	cntrlz		;end of file mark?
D99E: CA93DB  		jp	z,getback
D9A1: CD8CD4  		call	print		;no, print it.
D9A4: CDC2D5  		call	chkcon		;check console, quit if anything ready.
D9A7: C293DB  		jp	nz,getback
D9AA: C381D9  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
D9AD: 3D      	type4:	dec	a		;read error?
D9AE: CA93DB  		jp	z,getback
D9B1: CDE6D7  		call	rderror		;yes, print message.
D9B4: CD73D8  	type5:	call	resetdr		;and reset proper drive
D9B7: C309D6  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
D9BA: CD05D8  	save:	call	decode		;get numeric number that follows save.
D9BD: F5      		push	af		;save number of pages to write.
D9BE: CD5ED6  		call	convfst		;convert file name.
D9C1: C209D6  		jp	nz,synerr	;wild cards not allowed.
D9C4: CD61D8  		call	dselect		;select specified drive.
D9C7: 11DADB  		ld	de,fcb		;now delete this file.
D9CA: D5      		push	de
D9CB: CDEFD4  		call	delete
D9CE: D1      		pop	de
D9CF: CD09D5  		call	create		;and create it again.
D9D2: CA08DA  		jp	z,save3		;can't create?
D9D5: AF      		xor	a		;clear record number byte.
D9D6: 32FADB  		ld	(fcb+32),a
D9D9: F1      		pop	af		;convert pages to sectors.
D9DA: 6F      		ld	l,a
D9DB: 2600    		ld	h,0
D9DD: 29      		add	hl,hl		;(hl)=number of sectors to write.
D9DE: 110001  		ld	de,tbase	;and we start from here.
D9E1: 7C      	save1:	ld	a,h		;done yet?
D9E2: B5      		or	l
D9E3: CAFED9  		jp	z,save2
D9E6: 2B      		dec	hl		;nope, count this and compute the start
D9E7: E5      		push	hl		;of the next 128 byte sector.
D9E8: 218000  		ld	hl,128
D9EB: 19      		add	hl,de
D9EC: E5      		push	hl		;save it and set the transfer address.
D9ED: CDD8D5  		call	dmaset
D9F0: 11DADB  		ld	de,fcb		;write out this sector now.
D9F3: CD04D5  		call	wrtrec
D9F6: D1      		pop	de		;reset (de) to the start of the last sector.
D9F7: E1      		pop	hl		;restore sector count.
D9F8: C208DA  		jp	nz,save3	;write error?
D9FB: C3E1D9  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
D9FE: 11DADB  	save2:	ld	de,fcb		;now close the file.
DA01: CDDAD4  		call	close
DA04: 3C      		inc	a		;did it close ok?
DA05: C20EDA  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
DA08: 0114DA  	save3:	ld	bc,nospace
DA0B: CDA7D4  		call	pline
DA0E: CDD5D5  	save4:	call	stddma		;reset the standard dma address.
DA11: C393DB  		jp	getback
DA14: 6E6F2073	nospace:defb	'no space',0
DA18: 70616365	
DA1C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DA1D: CD5ED6  	rename:	call	convfst		;convert first file name.
DA20: C209D6  		jp	nz,synerr	;wild cards not allowed.
DA23: 3AFDDB  		ld	a,(chgdrv)	;remember any change in drives specified.
DA26: F5      		push	af
DA27: CD61D8  		call	dselect		;and select this drive.
DA2A: CDE9D4  		call	srchfcb		;is this file present?
DA2D: C286DA  		jp	nz,rename6	;yes, print error message.
DA30: 21DADB  		ld	hl,fcb		;yes, move this name into second slot.
DA33: 11EADB  		ld	de,fcb+16
DA36: 0610    		ld	b,16
DA38: CD4FD8  		call	hl2de
DA3B: 2A88D4  		ld	hl,(inpoint)	;get input pointer.
DA3E: EB      		ex	de,hl
DA3F: CD4FD6  		call	nonblank	;get next non blank character.
DA42: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
DA44: CA4CDA  		jp	z,rename1
DA47: FE5F    		cp	'_'
DA49: C280DA  		jp	nz,rename5
DA4C: EB      	rename1:ex	de,hl
DA4D: 23      		inc	hl		;ok, skip seperator.
DA4E: 2288D4  		ld	(inpoint),hl	;save input line pointer.
DA51: CD5ED6  		call	convfst		;convert this second file name now.
DA54: C280DA  		jp	nz,rename5	;again, no wild cards.
DA57: F1      		pop	af		;if a drive was specified, then it
DA58: 47      		ld	b,a		;must be the same as before.
DA59: 21FDDB  		ld	hl,chgdrv
DA5C: 7E      		ld	a,(hl)
DA5D: B7      		or	a
DA5E: CA66DA  		jp	z,rename2
DA61: B8      		cp	b
DA62: 70      		ld	(hl),b
DA63: C280DA  		jp	nz,rename5	;they were different, error.
DA66: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
DA67: AF      		xor	a
DA68: 32DADB  		ld	(fcb),a		;clear the drive byte of the fcb.
DA6B: CDE9D4  	rename3:call	srchfcb		;and go look for second file.
DA6E: CA7ADA  		jp	z,rename4	;doesn't exist?
DA71: 11DADB  		ld	de,fcb
DA74: CD0ED5  		call	renam		;ok, rename the file.
DA77: C393DB  		jp	getback
              	;
              	;   process rename errors here.
              	;
DA7A: CDF7D7  	rename4:call	none		;file not there.
DA7D: C393DB  		jp	getback
DA80: CD73D8  	rename5:call	resetdr		;bad command format.
DA83: C309D6  		jp	synerr
DA86: 018FDA  	rename6:ld	bc,exists	;destination file already exists.
DA89: CDA7D4  		call	pline
DA8C: C393DB  		jp	getback
DA8F: 66696C65	exists:	defb	'file exists',0
DA93: 20657869	
DA97: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
DA9B: CD05D8  	user:	call	decode		;get numeric value following command.
DA9E: FE10    		cp	16		;legal user number?
DAA0: D209D6  		jp	nc,synerr
DAA3: 5F      		ld	e,a		;yes but is there anything else?
DAA4: 3ADBDB  		ld	a,(fcb+1)
DAA7: FE20    		cp	' '
DAA9: CA09D6  		jp	z,synerr	;yes, that is not allowed.
DAAC: CD15D5  		call	getsetuc	;ok, set user code.
DAAF: C396DB  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
DAB2: CDF5D5  	unknown:call	verify		;check for valid system (why?).
DAB5: 3ADBDB  		ld	a,(fcb+1)	;anything to execute?
DAB8: FE20    		cp	' '
DABA: C2D1DA  		jp	nz,unkwn1
DABD: 3AFDDB  		ld	a,(chgdrv)	;nope, only a drive change?
DAC0: B7      		or	a
DAC1: CA96DB  		jp	z,getback1	;neither???
DAC4: 3D      		dec	a
DAC5: 32FCDB  		ld	(cdrive),a	;ok, store new drive.
DAC8: CD29D5  		call	movecd		;set (tdrive) also.
DACB: CDBDD4  		call	dsksel		;and select this drive.
DACE: C396DB  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
DAD1: 11E3DB  	unkwn1:	ld	de,fcb+9	;an extension specified?
DAD4: 1A      		ld	a,(de)
DAD5: FE20    		cp	' '
DAD7: C209D6  		jp	nz,synerr	;yes, not allowed.
DADA: D5      	unkwn2:	push	de
DADB: CD61D8  		call	dselect		;select specified drive.
DADE: D1      		pop	de
DADF: 2190DB  		ld	hl,comfile	;set the extension to 'com'.
DAE2: CD4DD8  		call	move3
DAE5: CDD0D4  		call	openfcb		;and open this file.
DAE8: CA78DB  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
DAEB: 210001  		ld	hl,tbase	;store the program starting here.
DAEE: E5      	unkwn3:	push	hl
DAEF: EB      		ex	de,hl
DAF0: CDD8D5  		call	dmaset		;set transfer address.
DAF3: 11DADB  		ld	de,fcb		;and read the next record.
DAF6: CDF9D4  		call	rdrec
DAF9: C20EDB  		jp	nz,unkwn4	;end of file or read error?
DAFC: E1      		pop	hl		;nope, bump pointer for next sector.
DAFD: 118000  		ld	de,128
DB00: 19      		add	hl,de
DB01: 1100D4  		ld	de,cbase	;enough room for the whole file?
DB04: 7D      		ld	a,l
DB05: 93      		sub	e
DB06: 7C      		ld	a,h
DB07: 9A      		sbc	a,d
DB08: D27EDB  		jp	nc,unkwn0	;no, it can't fit.
DB0B: C3EEDA  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
DB0E: E1      	unkwn4:	pop	hl
DB0F: 3D      		dec	a		;normal end of file?
DB10: C27EDB  		jp	nz,unkwn0
DB13: CD73D8  		call	resetdr		;yes, reset previous drive.
DB16: CD5ED6  		call	convfst		;convert the first file name that follows
DB19: 21FDDB  		ld	hl,chgdrv	;command name.
DB1C: E5      		push	hl
DB1D: 7E      		ld	a,(hl)		;set drive code in default fcb.
DB1E: 32DADB  		ld	(fcb),a
DB21: 3E10    		ld	a,16		;put second name 16 bytes later.
DB23: CD60D6  		call	convert		;convert second file name.
DB26: E1      		pop	hl
DB27: 7E      		ld	a,(hl)		;and set the drive for this second file.
DB28: 32EADB  		ld	(fcb+16),a
DB2B: AF      		xor	a		;clear record byte in fcb.
DB2C: 32FADB  		ld	(fcb+32),a
DB2F: 115C00  		ld	de,tfcb		;move it into place at(005ch).
DB32: 21DADB  		ld	hl,fcb
DB35: 0621    		ld	b,33
DB37: CD4FD8  		call	hl2de
DB3A: 2108D4  		ld	hl,inbuff+2	;now move the remainder of the input
DB3D: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
DB3E: B7      		or	a		;or a null.
DB3F: CA4BDB  		jp	z,unkwn6
DB42: FE20    		cp	' '
DB44: CA4BDB  		jp	z,unkwn6
DB47: 23      		inc	hl
DB48: C33DDB  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
DB4B: 0600    	unkwn6:	ld	b,0		;keep a character count.
DB4D: 118100  		ld	de,tbuff+1	;data gets put here.
DB50: 7E      	unkwn7:	ld	a,(hl)		;move it now.
DB51: 12      		ld	(de),a
DB52: B7      		or	a
DB53: CA5CDB  		jp	z,unkwn8
DB56: 04      		inc	b
DB57: 23      		inc	hl
DB58: 13      		inc	de
DB59: C350DB  		jp	unkwn7
DB5C: 78      	unkwn8:	ld	a,b		;now store the character count.
DB5D: 328000  		ld	(tbuff),a
DB60: CD98D4  		call	crlf		;clean up the screen.
DB63: CDD5D5  		call	stddma		;set standard transfer address.
DB66: CD1AD5  		call	setcdrv		;reset current drive.
DB69: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
DB6C: 31B8DB  		ld	sp,batch	;set stack first off.
DB6F: CD29D5  		call	movecd		;move current drive into place (tdrive).
DB72: CDBDD4  		call	dsksel		;and reselect it.
DB75: C382D7  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
DB78: CD73D8  	unkwn9:	call	resetdr		;inproper format.
DB7B: C309D6  		jp	synerr
DB7E: 0187DB  	unkwn0:	ld	bc,badload	;read error or won't fit.
DB81: CDA7D4  		call	pline
DB84: C393DB  		jp	getback
DB87: 42616420	badload:defb	'Bad load',0
DB8B: 6C6F6164	
DB8F: 00      	
DB90: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
DB93: CD73D8  	getback:call	resetdr		;reset previous drive.
DB96: CD5ED6  	getback1: call	convfst		;convert first name in (fcb).
DB99: 3ADBDB  		ld	a,(fcb+1)	;if this was just a drive change request,
DB9C: D620    		sub	' '		;make sure it was valid.
DB9E: 21FDDB  		ld	hl,chgdrv
DBA1: B6      		or	(hl)
DBA2: C209D6  		jp	nz,synerr
DBA5: C382D7  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
DBA8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DBAC: 00...   	
DBB8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
DBB8: 00      	batch:	defb	0		;batch mode flag (0=not active).
DBB9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DBBD: 20202020	
DBC1: 20535542	
DBC5: 00000000	
DBC9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
DBDA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
DBDE: 20202020	
DBE2: 20202020	
DBE6: 00000000	
DBEA: 00202020	
DBEE: 20202020	
DBF2: 20202020	
DBF6: 00000000	
DBFA: 00      	
DBFB: 00      	rtncode:defb	0		;status returned from bdos call.
DBFC: 00      	cdrive:	defb	0		;currently active drive.
DBFD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
DBFE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
DC00: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
DC04: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
DC06: C314DC  	fbase:	jp	fbase1
DC09: C345EA  		jp	boot
              	;
              	;   bdos error table.
              	;
DC0C: 9FDC    	badsctr:defw	error1		;bad sector on read or write.
DC0E: ABDC    	badslct:defw	error2		;bad disk select.
DC10: B1DC    	rodisk:	defw	error3		;disk is read only.
DC12: B7DC    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
DC14: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
DC15: 2249DF  		ld	(params),hl
DC18: EB      		ex	de,hl
DC19: 7B      		ld	a,e		;and save register (e) in particular.
DC1A: 32DCE9  		ld	(eparam),a
DC1D: 210000  		ld	hl,0
DC20: 224BDF  		ld	(status),hl	;clear return status.
DC23: 39      		add	hl,sp
DC24: 2215DF  		ld	(usrstack),hl	;save users stack pointer.
DC27: 3147DF  		ld	sp,stkarea	;and set our own.
DC2A: AF      		xor	a		;clear auto select storage space.
DC2B: 32E6E9  		ld	(autoflag),a
DC2E: 32E4E9  		ld	(auto),a
DC31: 217AE9  		ld	hl,goback	;set return address.
DC34: E5      		push	hl
DC35: CD6DEB  		call	syshook		; see if anyone wants to intercept the call
DC38: 79      		ld	a,c		;get function number.
DC39: FE29    		cp	nfuncts		;valid function number?
DC3B: D0      		ret	nc
DC3C: 4B      		ld	c,e		;keep single register function here.
DC3D: 214DDC  		ld	hl,functns	;now look thru the function table.
DC40: 5F      		ld	e,a
DC41: 1600    		ld	d,0		;(de)=function number.
DC43: 19      		add	hl,de
DC44: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
DC45: 5E      		ld	e,(hl)
DC46: 23      		inc	hl
DC47: 56      		ld	d,(hl)		;now (de)=address for this function.
DC48: 2A49DF  		ld	hl,(params)	;retrieve parameters.
DC4B: EB      		ex	de,hl		;now (de) has the original parameters.
DC4C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
DC4D: 53EACEDE	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
DC51: 96DDD4DE	
DC55: CBEAC7EA	
DC59: DADEF3DE	
DC5D: F9DEFEDE		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
DC61: E7DD04DF	
DC65: 84E889E8	
DC69: 4BE8A2E8	
DC6D: ABE8B1E8		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
DC71: CEE8DDE8	
DC75: E6E8ECE8	
DC79: F2E8    	
DC7B: FBE804E9		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
DC7F: 0AE910E9	
DC83: 17E932E1	
DC87: 1DE923E9	
DC8B: 2CE933E9		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
DC8F: 47E94DE9	
DC93: 53E914E8	
DC97: 59E90ADF	
DC9B: 0ADFA1E9		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
DC9F: 21D0DC  	error1:	ld	hl,badsec	;bad sector message.
DCA2: CDEBDC  		call	prterr		;print it and get a 1 char responce.
DCA5: FE03    		cp	cntrlc		;re-boot request (control-c)?
DCA7: CA0000  		jp	z,0		;yes.
DCAA: C9      		ret			;no, return to retry i/o function.
              	;
DCAB: 21DBDC  	error2:	ld	hl,badsel	;bad drive selected.
DCAE: C3BADC  		jp	error5
              	;
DCB1: 21E7DC  	error3:	ld	hl,diskro	;disk is read only.
DCB4: C3BADC  		jp	error5
              	;
DCB7: 21E2DC  	error4:	ld	hl,filero	;file is read only.
              	;
DCBA: CDEBDC  	error5:	call	prterr
DCBD: C30000  		jp	0		;always reboot on these errors.
              	;
DCC0: 42646F73	bdoserr:defb	'Bdos Err on '
DCC4: 20457272	
DCC8: 206F6E20	
DCCC: 203A2024	bdosdrv:defb	' : $'
DCD0: 42616420	badsec:	defb	'Bad Sector$'
DCD4: 53656374	
DCD8: 6F7224  	
DCDB: 53656C65	badsel:	defb	'Select$'
DCDF: 637424  	
DCE2: 46696C65	filero:	defb	'File '
DCE6: 20      	
DCE7: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
DCEB: E5      	prterr:	push	hl		;save second message pointer.
DCEC: CDCFDD  		call	outcrlf		;send (cr)(lf).
DCEF: 3A48DF  		ld	a,(active)	;get active drive.
DCF2: C641    		add	a,'A'		;make ascii.
DCF4: 32CCDC  		ld	(bdosdrv),a	;and put in message.
DCF7: 01C0DC  		ld	bc,bdoserr	;and print it.
DCFA: CDD9DD  		call	prtmesg
DCFD: C1      		pop	bc		;print second message line now.
DCFE: CDD9DD  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
DD01: 2114DF  	getchar:ld	hl,charbuf	;check character buffer.
DD04: 7E      		ld	a,(hl)		;anything present already?
DD05: 3600    		ld	(hl),0		;...either case clear it.
DD07: B7      		or	a
DD08: C0      		ret	nz		;yes, use it.
DD09: C3AFEA  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
DD0C: CD01DD  	getecho:call	getchar		;input a character.
DD0F: CD1ADD  		call	chkchar		;carriage control?
DD12: D8      		ret	c		;no, a regular control char so don't echo.
DD13: F5      		push	af		;ok, save character now.
DD14: 4F      		ld	c,a
DD15: CD96DD  		call	outcon		;and echo it.
DD18: F1      		pop	af		;get character and return.
DD19: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
DD1A: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
DD1C: C8      		ret	z		;or a tab.
DD1D: FE0A    		cp	lf
DD1F: C8      		ret	z
DD20: FE09    		cp	tab
DD22: C8      		ret	z
DD23: FE08    		cp	bs
DD25: C8      		ret	z
DD26: FE20    		cp	' '		;other control char? set carry flag.
DD28: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
DD29: 3A14DF  	ckconsol: ld	a,(charbuf)	;check buffer.
DD2C: B7      		or	a		;if anything, just return without checking.
DD2D: C24BDD  		jp	nz,ckcon2
DD30: CDA4EA  		call	const		;nothing in buffer. check console.
DD33: E601    		and	01h		;look at bit 0.
DD35: C8      		ret	z		;return if nothing.
DD36: CDAFEA  		call	conin		;ok, get it.
DD39: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
DD3B: C248DD  		jp	nz,ckcon1
DD3E: CDAFEA  		call	conin		;halt processing until another char
DD41: FE03    		cp	cntrlc		;is typed. control-c?
DD43: CA0000  		jp	z,0		;yes, reboot now.
DD46: AF      		xor	a		;no, just pretend nothing was ever ready.
DD47: C9      		ret	
DD48: 3214DF  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
DD4B: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
DD4D: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
DD4E: 3A10DF  	outchar:ld	a,(outflag)	;check output flag.
DD51: B7      		or	a		;anything and we won't generate output.
DD52: C268DD  		jp	nz,outchr1
DD55: C5      		push	bc
DD56: CD29DD  		call	ckconsol	;check console (we don't care whats there).
DD59: C1      		pop	bc
DD5A: C5      		push	bc
DD5B: CDBBEA  		call	conout		;output (c) to the screen.
DD5E: C1      		pop	bc
DD5F: C5      		push	bc
DD60: 3A13DF  		ld	a,(prtflag)	;check printer flip-flop flag.
DD63: B7      		or	a
DD64: C4C7EA  		call	nz,list		;print it also if non-zero.
DD67: C1      		pop	bc
DD68: 79      	outchr1:ld	a,c		;update cursors position.
DD69: 2112DF  		ld	hl,curpos
DD6C: FE7F    		cp	del		;rubouts don't do anything here.
DD6E: C8      		ret	z
DD6F: 34      		inc	(hl)		;bump line pointer.
DD70: FE20    		cp	' '		;and return if a normal character.
DD72: D0      		ret	nc
DD73: 35      		dec	(hl)		;restore and check for the start of the line.
DD74: 7E      		ld	a,(hl)
DD75: B7      		or	a
DD76: C8      		ret	z		;ingnore control characters at the start of the line.
DD77: 79      		ld	a,c
DD78: FE08    		cp	bs		;is it a backspace?
DD7A: C27FDD  		jp	nz,outchr2
DD7D: 35      		dec	(hl)		;yes, backup pointer.
DD7E: C9      		ret	
DD7F: FE0A    	outchr2:cp	lf		;is it a line feed?
DD81: C0      		ret	nz		;ignore anything else.
DD82: 3600    		ld	(hl),0		;reset pointer to start of line.
DD84: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
DD85: 79      	showit:	ld	a,c
DD86: CD1ADD  		call	chkchar		;check character.
DD89: D296DD  		jp	nc,outcon	;not a control, use normal output.
DD8C: F5      		push	af
DD8D: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
DD8F: CD4EDD  		call	outchar
DD92: F1      		pop	af
DD93: F640    		or	'@'		;and then use the letter equivelant.
DD95: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
DD96: 79      	outcon:	ld	a,c
DD97: FE09    		cp	tab		;is it a tab?
DD99: C24EDD  		jp	nz,outchar	;use regular output.
DD9C: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
DD9E: CD4EDD  		call	outchar
DDA1: 3A12DF  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
DDA4: E607    		and	07h		;position.
DDA6: C29CDD  		jp	nz,outcon1
DDA9: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
DDAA: CDB2DD  	backup:	call	backup1		;backup the screen 1 place.
DDAD: 0E20    		ld	c,' '		;then blank that character.
DDAF: CDBBEA  		call	conout
DDB2: 0E08    	backup1:ld	c,bs		;then back space once more.
DDB4: C3BBEA  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
DDB7: 0E23    	newline:ld	c,'#'
DDB9: CD4EDD  		call	outchar		;print this.
DDBC: CDCFDD  		call	outcrlf		;start new line.
DDBF: 3A12DF  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
DDC2: 2111DF  		ld	hl,starting
DDC5: BE      		cp	(hl)
DDC6: D0      		ret	nc		;there yet?
DDC7: 0E20    		ld	c,' '
DDC9: CD4EDD  		call	outchar		;nope, keep going.
DDCC: C3BFDD  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
DDCF: 0E0D    	outcrlf:ld	c,cr
DDD1: CD4EDD  		call	outchar
DDD4: 0E0A    		ld	c,lf
DDD6: C34EDD  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
DDD9: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
DDDA: FE24    		cp	'$'
DDDC: C8      		ret	z
DDDD: 03      		inc	bc
DDDE: C5      		push	bc		;otherwise, bump pointer and print it.
DDDF: 4F      		ld	c,a
DDE0: CD96DD  		call	outcon
DDE3: C1      		pop	bc
DDE4: C3D9DD  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
DDE7: 3A12DF  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
DDEA: 3211DF  		ld	(starting),a
DDED: 2A49DF  		ld	hl,(params)	;get the maximum buffer space.
DDF0: 4E      		ld	c,(hl)
DDF1: 23      		inc	hl		;point to first available space.
DDF2: E5      		push	hl		;and save.
DDF3: 0600    		ld	b,0		;keep a character count.
DDF5: C5      	rdbuf1:	push	bc
DDF6: E5      		push	hl
DDF7: CD01DD  	rdbuf2:	call	getchar		;get the next input character.
DDFA: E67F    		and	7fh		;strip bit 7.
DDFC: E1      		pop	hl		;reset registers.
DDFD: C1      		pop	bc
DDFE: FE0D    		cp	cr		;en of the line?
DE00: CAC7DE  		jp	z,rdbuf17
DE03: FE0A    		cp	lf
DE05: CAC7DE  		jp	z,rdbuf17
DE08: FE08    		cp	bs		;how about a backspace?
DE0A: C21CDE  		jp	nz,rdbuf3
DE0D: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
DE0E: B7      		or	a
DE0F: CAF5DD  		jp	z,rdbuf1
DE12: 05      		dec	b		;ok, update counter.
DE13: 3A12DF  		ld	a,(curpos)	;if we backspace to the start of the line,
DE16: 3210DF  		ld	(outflag),a	;treat as a cancel (control-x).
DE19: C376DE  		jp	rdbuf10
DE1C: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
DE1E: C22CDE  		jp	nz,rdbuf4
DE21: 78      		ld	a,b		;ignore at the start of the line.
DE22: B7      		or	a
DE23: CAF5DD  		jp	z,rdbuf1
DE26: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
DE27: 05      		dec	b		;and reset pointers (counters).
DE28: 2B      		dec	hl
DE29: C3AFDE  		jp	rdbuf15
DE2C: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
DE2E: C23DDE  		jp	nz,rdbuf5
DE31: C5      		push	bc		;yes, do it.
DE32: E5      		push	hl
DE33: CDCFDD  		call	outcrlf
DE36: AF      		xor	a		;and update starting position.
DE37: 3211DF  		ld	(starting),a
DE3A: C3F7DD  		jp	rdbuf2
DE3D: FE10    	rdbuf5:	cp	cntrlp		;control-p?
DE3F: C24EDE  		jp	nz,rdbuf6
DE42: E5      		push	hl		;yes, flip the print flag filp-flop byte.
DE43: 2113DF  		ld	hl,prtflag
DE46: 3E01    		ld	a,1		;prtflag=1-prtflag
DE48: 96      		sub	(hl)
DE49: 77      		ld	(hl),a
DE4A: E1      		pop	hl
DE4B: C3F5DD  		jp	rdbuf1
DE4E: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
DE50: C265DE  		jp	nz,rdbuf8
DE53: E1      		pop	hl
DE54: 3A11DF  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
DE57: 2112DF  		ld	hl,curpos
DE5A: BE      		cp	(hl)
DE5B: D2E7DD  		jp	nc,rdbuff	;done yet?
DE5E: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
DE5F: CDAADD  		call	backup
DE62: C354DE  		jp	rdbuf7
DE65: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
DE67: C271DE  		jp	nz,rdbuf9
DE6A: CDB7DD  		call	newline		;start a new line.
DE6D: E1      		pop	hl
DE6E: C3E7DD  		jp	rdbuff
DE71: FE12    	rdbuf9:	cp	cntrlr		;control-r?
DE73: C2ACDE  		jp	nz,rdbuf14
DE76: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
DE77: CDB7DD  		call	newline
DE7A: C1      		pop	bc
DE7B: E1      		pop	hl
DE7C: E5      		push	hl
DE7D: C5      		push	bc
DE7E: 78      	rdbuf11:ld	a,b		;done whole line yet?
DE7F: B7      		or	a
DE80: CA90DE  		jp	z,rdbuf12
DE83: 23      		inc	hl		;nope, get next character.
DE84: 4E      		ld	c,(hl)
DE85: 05      		dec	b		;count it.
DE86: C5      		push	bc
DE87: E5      		push	hl
DE88: CD85DD  		call	showit		;and display it.
DE8B: E1      		pop	hl
DE8C: C1      		pop	bc
DE8D: C37EDE  		jp	rdbuf11
DE90: E5      	rdbuf12:push	hl		;done with line. if we were displaying
DE91: 3A10DF  		ld	a,(outflag)	;then update cursor position.
DE94: B7      		or	a
DE95: CAF7DD  		jp	z,rdbuf2
DE98: 2112DF  		ld	hl,curpos	;because this line is shorter, we must
DE9B: 96      		sub	(hl)		;back up the cursor (not the screen however)
DE9C: 3210DF  		ld	(outflag),a	;some number of positions.
DE9F: CDAADD  	rdbuf13:call	backup		;note that as long as (outflag) is non
DEA2: 2110DF  		ld	hl,outflag	;zero, the screen will not be changed.
DEA5: 35      		dec	(hl)
DEA6: C29FDE  		jp	nz,rdbuf13
DEA9: C3F7DD  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
DEAC: 23      	rdbuf14:inc	hl
DEAD: 77      		ld	(hl),a		;store character.
DEAE: 04      		inc	b		;and count it.
DEAF: C5      	rdbuf15:push	bc
DEB0: E5      		push	hl
DEB1: 4F      		ld	c,a		;echo it now.
DEB2: CD85DD  		call	showit
DEB5: E1      		pop	hl
DEB6: C1      		pop	bc
DEB7: 7E      		ld	a,(hl)		;was it an abort request?
DEB8: FE03    		cp	cntrlc		;control-c abort?
DEBA: 78      		ld	a,b
DEBB: C2C3DE  		jp	nz,rdbuf16
DEBE: FE01    		cp	1		;only if at start of line.
DEC0: CA0000  		jp	z,0
DEC3: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
DEC4: DAF5DD  		jp	c,rdbuf1
DEC7: E1      	rdbuf17:pop	hl		;yes end the line and return.
DEC8: 70      		ld	(hl),b
DEC9: 0E0D    		ld	c,cr
DECB: C34EDD  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
DECE: CD0CDD  	getcon:	call	getecho		;get and echo.
DED1: C307DF  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
DED4: CDCFEA  	getrdr:	call	reader		;get a character from reader, set status and return.
DED7: C307DF  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
DEDA: 79      	dircio:	ld	a,c		;test for (ff).
DEDB: 3C      		inc	a
DEDC: CAE6DE  		jp	z,dirc1
DEDF: 3C      		inc	a		;test for (fe).
DEE0: CAA4EA  		jp	z,const
DEE3: C3BBEA  		jp	conout		;just output (c).
DEE6: CDA4EA  	dirc1:	call	const		;this is an input request.
DEE9: B7      		or	a
DEEA: CA97E9  		jp	z,goback1	;not ready? just return (directly).
DEED: CDAFEA  		call	conin		;yes, get character.
DEF0: C307DF  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
DEF3: 3A0300  	getiob:	ld	a,(iobyte)
DEF6: C307DF  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
DEF9: 210300  	setiob:	ld	hl,iobyte
DEFC: 71      		ld	(hl),c
DEFD: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
DEFE: EB      	prtstr:	ex	de,hl
DEFF: 4D      		ld	c,l
DF00: 44      		ld	b,h		;now (bc) points to it.
DF01: C3D9DD  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
DF04: CD29DD  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
DF07: 324BDF  	setstat:ld	(status),a
DF0A: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
DF0B: 3E01    	ioerr1:	ld	a,1
DF0D: C307DF  		jp	setstat
              	;
DF10: 00      	outflag:defb	0		;output flag (non zero means no output).
DF11: 02      	starting: defb	2		;starting position for cursor.
DF12: 00      	curpos:	defb	0		;cursor position (0=start of line).
DF13: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
DF14: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
DF15: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
DF17: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF1B: 00...   	
DF2F: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF33: 00...   	
DF47:         	stkarea equ	$		;end of stack area.
              	;
DF47: 00      	userno:	defb	0		;current user number.
DF48: 00      	active:	defb	0		;currently active drive.
DF49: 0000    	params:	defw	0		;save (de) parameters here on entry.
DF4B: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
DF4D: 210EDC  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
DF50: 5E      	jumphl:	ld	e,(hl)
DF51: 23      		inc	hl
DF52: 56      		ld	d,(hl)		;now (de) contain the desired address.
DF53: EB      		ex	de,hl
DF54: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
DF55: 0C      	de2hl:	inc	c		;is count down to zero?
DF56: 0D      	de2hl1:	dec	c
DF57: C8      		ret	z		;yes, we are done.
DF58: 1A      		ld	a,(de)		;no, move one more byte.
DF59: 77      		ld	(hl),a
DF5A: 13      		inc	de
DF5B: 23      		inc	hl
DF5C: C356DF  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
DF5F: 3A48DF  	select:	ld	a,(active)	;get active disk.
DF62: 4F      		ld	c,a
DF63: CDE2EA  		call	seldsk		;select it.
DF66: 7C      		ld	a,h		;valid drive?
DF67: B5      		or	l		;valid drive?
DF68: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
DF69: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
DF6A: 23      		inc	hl
DF6B: 56      		ld	d,(hl)
DF6C: 23      		inc	hl
DF6D: 22B9E9  		ld	(scratch1),hl	;save pointers to scratch areas.
DF70: 23      		inc	hl
DF71: 23      		inc	hl
DF72: 22BBE9  		ld	(scratch2),hl	;ditto.
DF75: 23      		inc	hl
DF76: 23      		inc	hl
DF77: 22BDE9  		ld	(scratch3),hl	;ditto.
DF7A: 23      		inc	hl
DF7B: 23      		inc	hl
DF7C: EB      		ex	de,hl		;now save the translation table address.
DF7D: 22D6E9  		ld	(xlate),hl
DF80: 21BFE9  		ld	hl,dirbuf	;put the next 8 bytes here.
DF83: 0E08    		ld	c,8		;they consist of the directory buffer
DF85: CD55DF  		call	de2hl		;pointer, parameter block pointer,
DF88: 2AC1E9  		ld	hl,(diskpb)	;check and allocation vectors.
DF8B: EB      		ex	de,hl
DF8C: 21C7E9  		ld	hl,sectors	;move parameter block into our ram.
DF8F: 0E0F    		ld	c,15		;it is 15 bytes long.
DF91: CD55DF  		call	de2hl
DF94: 2ACCE9  		ld	hl,(dsksize)	;check disk size.
DF97: 7C      		ld	a,h		;more than 256 blocks on this?
DF98: 21E3E9  		ld	hl,bigdisk
DF9B: 36FF    		ld	(hl),0ffh	;set to samll.
DF9D: B7      		or	a
DF9E: CAA3DF  		jp	z,select1
DFA1: 3600    		ld	(hl),0		;wrong, set to large.
DFA3: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
DFA5: B7      		or	a
DFA6: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
DFA7: CDDDEA  	homedrv:call	home		;home the head.
DFAA: AF      		xor	a
DFAB: 2ABBE9  		ld	hl,(scratch2)	;set our track pointer also.
DFAE: 77      		ld	(hl),a
DFAF: 23      		inc	hl
DFB0: 77      		ld	(hl),a
DFB1: 2ABDE9  		ld	hl,(scratch3)	;and our sector pointer.
DFB4: 77      		ld	(hl),a
DFB5: 23      		inc	hl
DFB6: 77      		ld	(hl),a
DFB7: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
DFB8: CD0EEB  	doread:	call	read
DFBB: C3C1DF  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
DFBE: CD12EB  	dowrite:call	write
DFC1: B7      	ioret:	or	a
DFC2: C8      		ret	z		;return unless an error occured.
DFC3: 210CDC  		ld	hl,badsctr	;bad read/write on this sector.
DFC6: C350DF  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
DFC9: 2AF0E9  	trksec:	ld	hl,(filepos)	;get position of last accessed file
DFCC: 0E02    		ld	c,2		;in directory and compute sector #.
DFCE: CDF0E0  		call	shiftr		;sector #=file-position/4.
DFD1: 22EBE9  		ld	(blknmbr),hl	;save this as the block number of interest.
DFD4: 22F2E9  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
DFD7: 21EBE9  	trksec1:ld	hl,blknmbr
DFDA: 4E      		ld	c,(hl)		;move sector number into (bc).
DFDB: 23      		inc	hl
DFDC: 46      		ld	b,(hl)
DFDD: 2ABDE9  		ld	hl,(scratch3)	;get current sector number and
DFE0: 5E      		ld	e,(hl)		;move this into (de).
DFE1: 23      		inc	hl
DFE2: 56      		ld	d,(hl)
DFE3: 2ABBE9  		ld	hl,(scratch2)	;get current track number.
DFE6: 7E      		ld	a,(hl)		;and this into (hl).
DFE7: 23      		inc	hl
DFE8: 66      		ld	h,(hl)
DFE9: 6F      		ld	l,a
DFEA: 79      	trksec2:ld	a,c		;is desired sector before current one?
DFEB: 93      		sub	e
DFEC: 78      		ld	a,b
DFED: 9A      		sbc	a,d
DFEE: D200E0  		jp	nc,trksec3
DFF1: E5      		push	hl		;yes, decrement sectors by one track.
DFF2: 2AC7E9  		ld	hl,(sectors)	;get sectors per track.
DFF5: 7B      		ld	a,e
DFF6: 95      		sub	l
DFF7: 5F      		ld	e,a
DFF8: 7A      		ld	a,d
DFF9: 9C      		sbc	a,h
DFFA: 57      		ld	d,a		;now we have backed up one full track.
DFFB: E1      		pop	hl
DFFC: 2B      		dec	hl		;adjust track counter.
DFFD: C3EADF  		jp	trksec2
E000: E5      	trksec3:push	hl		;desired sector is after current one.
E001: 2AC7E9  		ld	hl,(sectors)	;get sectors per track.
E004: 19      		add	hl,de		;bump sector pointer to next track.
E005: DA15E0  		jp	c,trksec4
E008: 79      		ld	a,c		;is desired sector now before current one?
E009: 95      		sub	l
E00A: 78      		ld	a,b
E00B: 9C      		sbc	a,h
E00C: DA15E0  		jp	c,trksec4
E00F: EB      		ex	de,hl		;not yes, increment track counter
E010: E1      		pop	hl		;and continue until it is.
E011: 23      		inc	hl
E012: C300E0  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E015: E1      	trksec4:pop	hl		;get track number (hl).
E016: C5      		push	bc
E017: D5      		push	de
E018: E5      		push	hl
E019: EB      		ex	de,hl
E01A: 2AD4E9  		ld	hl,(offset)	;adjust for first track offset.
E01D: 19      		add	hl,de
E01E: 44      		ld	b,h
E01F: 4D      		ld	c,l
E020: CD00EB  		call	settrk		;select this track.
E023: D1      		pop	de		;reset current track pointer.
E024: 2ABBE9  		ld	hl,(scratch2)
E027: 73      		ld	(hl),e
E028: 23      		inc	hl
E029: 72      		ld	(hl),d
E02A: D1      		pop	de
E02B: 2ABDE9  		ld	hl,(scratch3)	;reset the first sector on this track.
E02E: 73      		ld	(hl),e
E02F: 23      		inc	hl
E030: 72      		ld	(hl),d
E031: C1      		pop	bc
E032: 79      		ld	a,c		;now subtract the desired one.
E033: 93      		sub	e		;to make it relative (1-# sectors/track).
E034: 4F      		ld	c,a
E035: 78      		ld	a,b
E036: 9A      		sbc	a,d
E037: 47      		ld	b,a
E038: 2AD6E9  		ld	hl,(xlate)	;translate this sector according to this table.
E03B: EB      		ex	de,hl
E03C: CD19EB  		call	sectrn		;let the bios translate it.
E03F: 4D      		ld	c,l
E040: 44      		ld	b,h
E041: C304EB  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E044: 21C9E9  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E047: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E048: 3AE9E9  		ld	a,(savnrec)	;get record number.
E04B: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E04C: 1F      		rra	
E04D: 0D      		dec	c
E04E: C24BE0  		jp	nz,getblk1
E051: 47      		ld	b,a		;save result in (b).
E052: 3E08    		ld	a,8
E054: 96      		sub	(hl)
E055: 4F      		ld	c,a		;compute (c)=8-blkshft.
E056: 3AE8E9  		ld	a,(savext)
E059: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E05A: CA62E0  		jp	z,getblk3
E05D: B7      		or	a
E05E: 17      		rla	
E05F: C359E0  		jp	getblk2
E062: 80      	getblk3:add	a,b
E063: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E064: 2A49DF  	extblk:	ld	hl,(params)	;get fcb address.
E067: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E06A: 19      		add	hl,de
E06B: 09      		add	hl,bc
E06C: 3AE3E9  		ld	a,(bigdisk)	;are we using a big-disk?
E06F: B7      		or	a
E070: CA77E0  		jp	z,extblk1
E073: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E074: 2600    		ld	h,0
E076: C9      		ret	
E077: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E078: 5E      		ld	e,(hl)
E079: 23      		inc	hl
E07A: 56      		ld	d,(hl)
E07B: EB      		ex	de,hl		;return in (hl).
E07C: C9      		ret	
              	;
              	;   compute block number.
              	;
E07D: CD44E0  	comblk:	call	getblock
E080: 4F      		ld	c,a
E081: 0600    		ld	b,0
E083: CD64E0  		call	extblk
E086: 22EBE9  		ld	(blknmbr),hl
E089: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E08A: 2AEBE9  	chkblk:	ld	hl,(blknmbr)
E08D: 7D      		ld	a,l		;is it zero?
E08E: B4      		or	h
E08F: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E090: 3AC9E9  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E093: 2AEBE9  		ld	hl,(blknmbr)	;get physical sector desired.
E096: 29      	logicl1:add	hl,hl		;compute logical sector number.
E097: 3D      		dec	a		;note logical sectors are 128 bytes long.
E098: C296E0  		jp	nz,logicl1
E09B: 22EDE9  		ld	(logsect),hl	;save logical sector.
E09E: 3ACAE9  		ld	a,(blkmask)	;get block mask.
E0A1: 4F      		ld	c,a
E0A2: 3AE9E9  		ld	a,(savnrec)	;get next sector to access.
E0A5: A1      		and	c		;extract the relative position within physical block.
E0A6: B5      		or	l		;and add it too logical sector.
E0A7: 6F      		ld	l,a
E0A8: 22EBE9  		ld	(blknmbr),hl	;and store.
E0AB: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E0AC: 2A49DF  	setext:	ld	hl,(params)
E0AF: 110C00  		ld	de,12		;it is the twelth byte.
E0B2: 19      		add	hl,de
E0B3: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E0B4: 2A49DF  	sethlde:ld	hl,(params)
E0B7: 110F00  		ld	de,15		;record count byte (#15).
E0BA: 19      		add	hl,de
E0BB: EB      		ex	de,hl
E0BC: 211100  		ld	hl,17		;next record number (#32).
E0BF: 19      		add	hl,de
E0C0: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E0C1: CDB4E0  	strdata:call	sethlde
E0C4: 7E      		ld	a,(hl)		;get and store record count byte.
E0C5: 32E9E9  		ld	(savnrec),a
E0C8: EB      		ex	de,hl
E0C9: 7E      		ld	a,(hl)		;get and store next record number byte.
E0CA: 32E7E9  		ld	(savnxt),a
E0CD: CDACE0  		call	setext		;point to extent byte.
E0D0: 3ACBE9  		ld	a,(extmask)	;get extent mask.
E0D3: A6      		and	(hl)
E0D4: 32E8E9  		ld	(savext),a	;and save extent here.
E0D7: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E0D8: CDB4E0  	setnrec:call	sethlde
E0DB: 3ADBE9  		ld	a,(mode)	;get sequential flag (=1).
E0DE: FE02    		cp	2		;a 2 indicates that no adder is needed.
E0E0: C2E4E0  		jp	nz,stnrec1
E0E3: AF      		xor	a		;clear adder (random access?).
E0E4: 4F      	stnrec1:ld	c,a
E0E5: 3AE9E9  		ld	a,(savnrec)	;get last record number.
E0E8: 81      		add	a,c		;increment record count.
E0E9: 77      		ld	(hl),a		;and set fcb's next record byte.
E0EA: EB      		ex	de,hl
E0EB: 3AE7E9  		ld	a,(savnxt)	;get next record byte from storage.
E0EE: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E0EF: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E0F0: 0C      	shiftr:	inc	c
E0F1: 0D      	shiftr1:dec	c
E0F2: C8      		ret	z
E0F3: 7C      		ld	a,h
E0F4: B7      		or	a
E0F5: 1F      		rra	
E0F6: 67      		ld	h,a
E0F7: 7D      		ld	a,l
E0F8: 1F      		rra	
E0F9: 6F      		ld	l,a
E0FA: C3F1E0  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E0FD: 0E80    	checksum: ld	c,128		;length of buffer.
E0FF: 2ABFE9  		ld	hl,(dirbuf)	;get its location.
E102: AF      		xor	a		;clear summation byte.
E103: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E104: 23      		inc	hl
E105: 0D      		dec	c
E106: C203E1  		jp	nz,chksum1
E109: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E10A: 0C      	shiftl:	inc	c
E10B: 0D      	shiftl1:dec	c
E10C: C8      		ret	z
E10D: 29      		add	hl,hl		;shift left 1 bit.
E10E: C30BE1  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E111: C5      	setbit:	push	bc		;save 16 bit word.
E112: 3A48DF  		ld	a,(active)	;get active drive.
E115: 4F      		ld	c,a
E116: 210100  		ld	hl,1
E119: CD0AE1  		call	shiftl		;shift bit 0 into place.
E11C: C1      		pop	bc		;now 'or' this with the original word.
E11D: 79      		ld	a,c
E11E: B5      		or	l
E11F: 6F      		ld	l,a		;low byte done, do high byte.
E120: 78      		ld	a,b
E121: B4      		or	h
E122: 67      		ld	h,a
E123: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E124: 2AB3E9  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E127: 3A48DF  		ld	a,(active)	;which drive is current?
E12A: 4F      		ld	c,a
E12B: CDF0E0  		call	shiftr		;shift status such that bit 0 is the
E12E: 7D      		ld	a,l		;one of interest for this drive.
E12F: E601    		and	01h		;and isolate it.
E131: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E132: 21B3E9  	wrtprtd:ld	hl,wrtprt	;point to status word.
E135: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E136: 23      		inc	hl
E137: 46      		ld	b,(hl)
E138: CD11E1  		call	setbit		;and set this bit according to current drive.
E13B: 22B3E9  		ld	(wrtprt),hl	;then save.
E13E: 2ACEE9  		ld	hl,(dirsize)	;now save directory size limit.
E141: 23      		inc	hl		;remember the last one.
E142: EB      		ex	de,hl
E143: 2AB9E9  		ld	hl,(scratch1)	;and store it here.
E146: 73      		ld	(hl),e		;put low byte.
E147: 23      		inc	hl
E148: 72      		ld	(hl),d		;then high byte.
E149: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E14A: CD64E1  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E14D: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E150: 19      		add	hl,de
E151: 7E      		ld	a,(hl)
E152: 17      		rla	
E153: D0      		ret	nc		;return if ok.
E154: 2112DC  		ld	hl,rofile	;else, print error message and terminate.
E157: C350DF  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E15A: CD24E1  	chkwprt:call	getwprt
E15D: C8      		ret	z		;return if ok.
E15E: 2110DC  		ld	hl,rodisk	;else print message and terminate.
E161: C350DF  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E164: 2ABFE9  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E167: 3AEFE9  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E16A: 85      	adda2hl:add	a,l
E16B: 6F      		ld	l,a
E16C: D0      		ret	nc
E16D: 24      		inc	h		;take care of any carry.
E16E: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E16F: 2A49DF  	gets2:	ld	hl,(params)	;get address of fcb.
E172: 110E00  		ld	de,14		;relative position of 's2'.
E175: 19      		add	hl,de
E176: 7E      		ld	a,(hl)		;extract this byte.
E177: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E178: CD6FE1  	clears2:call	gets2		;this sets (hl) pointing to it.
E17B: 3600    		ld	(hl),0		;now clear it.
E17D: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E17E: CD6FE1  	sets2b7:call	gets2		;get the byte.
E181: F680    		or	80h		;and set bit 7.
E183: 77      		ld	(hl),a		;then store.
E184: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E185: 2AF0E9  	morefls:ld	hl,(filepos)	;we are here.
E188: EB      		ex	de,hl
E189: 2AB9E9  		ld	hl,(scratch1)	;and don't go past here.
E18C: 7B      		ld	a,e		;compute difference but don't keep.
E18D: 96      		sub	(hl)
E18E: 23      		inc	hl
E18F: 7A      		ld	a,d
E190: 9E      		sbc	a,(hl)		;set carry if no more names.
E191: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E192: CD85E1  	chknmbr:call	morefls		;scratch1 too big?
E195: D8      		ret	c
E196: 13      		inc	de		;yes, reset it to (filepos).
E197: 72      		ld	(hl),d
E198: 2B      		dec	hl
E199: 73      		ld	(hl),e
E19A: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E19B: 7B      	subhl:	ld	a,e		;compute difference.
E19C: 95      		sub	l
E19D: 6F      		ld	l,a		;store low byte.
E19E: 7A      		ld	a,d
E19F: 9C      		sbc	a,h
E1A0: 67      		ld	h,a		;and then high byte.
E1A1: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E1A2: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E1A4: 2AF2E9  	checkdir: ld	hl,(cksumtbl)
E1A7: EB      		ex	de,hl
E1A8: 2AD2E9  		ld	hl,(alloc1)
E1AB: CD9BE1  		call	subhl
E1AE: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E1AF: C5      		push	bc
E1B0: CDFDE0  		call	checksum	;else compute checksum.
E1B3: 2AC3E9  		ld	hl,(chkvect)	;get address of checksum table.
E1B6: EB      		ex	de,hl
E1B7: 2AF2E9  		ld	hl,(cksumtbl)
E1BA: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E1BB: C1      		pop	bc
E1BC: 0C      		inc	c		;set or check ?
E1BD: CACAE1  		jp	z,chkdir1
E1C0: BE      		cp	(hl)		;check them.
E1C1: C8      		ret	z		;return if they are the same.
E1C2: CD85E1  		call	morefls		;not the same, do we care?
E1C5: D0      		ret	nc
E1C6: CD32E1  		call	wrtprtd		;yes, mark this as write protected.
E1C9: C9      		ret	
E1CA: 77      	chkdir1:ld	(hl),a		;just set the byte.
E1CB: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E1CC: CDA2E1  	dirwrite: call	setdir		;set checksum byte.
E1CF: CDE6E1  		call	dirdma		;set directory dma address.
E1D2: 0E01    		ld	c,1		;tell the bios to actually write.
E1D4: CDBEDF  		call	dowrite		;then do the write.
E1D7: C3E0E1  		jp	defdma
              	;
              	;   read from the directory.
              	;
E1DA: CDE6E1  	dirread:call	dirdma		;set the directory dma address.
E1DD: CDB8DF  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E1E0: 21B7E9  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E1E3: C3E9E1  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E1E6: 21BFE9  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E1E9: 4E      	dirdma1:ld	c,(hl)
E1EA: 23      		inc	hl
E1EB: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E1EC: C308EB  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E1EF: 2ABFE9  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E1F2: EB      		ex	de,hl
E1F3: 2AB7E9  		ld	hl,(userdma)	; put it here.
E1F6: 0E80    		ld	c,128		;this is its length.
E1F8: C355DF  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E1FB: 21F0E9  	ckfilpos: ld	hl,filepos
E1FE: 7E      		ld	a,(hl)
E1FF: 23      		inc	hl
E200: BE      		cp	(hl)		;are both bytes the same?
E201: C0      		ret	nz
E202: 3C      		inc	a		;yes, but are they each 0ffh?
E203: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E204: 21FFFF  	stfilpos: ld	hl,0ffffh
E207: 22F0E9  		ld	(filepos),hl
E20A: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
E20B: 2ACEE9  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
E20E: EB      		ex	de,hl
E20F: 2AF0E9  		ld	hl,(filepos)	;get current count.
E212: 23      		inc	hl		;go on to the next one.
E213: 22F0E9  		ld	(filepos),hl
E216: CD9BE1  		call	subhl		;(hl)=(dirsize)-(filepos)
E219: D21FE2  		jp	nc,nxent1	;is there more room left?
E21C: C304E2  		jp	stfilpos	;no. set this flag and return.
E21F: 3AF0E9  	nxent1:	ld	a,(filepos)	;get file position within directory.
E222: E603    		and	03h		;only look within this sector (only 4 entries fit).
E224: 0605    		ld	b,5		;convert to relative position (32 bytes each).
E226: 87      	nxent2:	add	a,a		;note that this is not efficient code.
E227: 05      		dec	b		;5 'add a's would be better.
E228: C226E2  		jp	nz,nxent2
E22B: 32EFE9  		ld	(fcbpos),a	;save it as position of fcb.
E22E: B7      		or	a
E22F: C0      		ret	nz		;return if we are within buffer.
E230: C5      		push	bc
E231: CDC9DF  		call	trksec		;we need the next directory sector.
E234: CDDAE1  		call	dirread
E237: C1      		pop	bc
E238: C3A4E1  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
E23B: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
E23C: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
E23E: 3C      		inc	a
E23F: 5F      		ld	e,a		;save particular bit number.
E240: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
E241: 79      		ld	a,c
E242: 0F      		rrca			;now shift right 3 bits.
E243: 0F      		rrca	
E244: 0F      		rrca	
E245: E61F    		and	1fh		;and clear bits 7,6,5.
E247: 4F      		ld	c,a
E248: 78      		ld	a,b
E249: 87      		add	a,a		;now shift (b) into bits 7,6,5.
E24A: 87      		add	a,a
E24B: 87      		add	a,a
E24C: 87      		add	a,a
E24D: 87      		add	a,a
E24E: B1      		or	c		;and add in (c).
E24F: 4F      		ld	c,a		;ok, (c) ha been completed.
E250: 78      		ld	a,b		;is there a better way of doing this?
E251: 0F      		rrca	
E252: 0F      		rrca	
E253: 0F      		rrca	
E254: E61F    		and	1fh
E256: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
E257: 2AC5E9  		ld	hl,(alocvect)
E25A: 09      		add	hl,bc
E25B: 7E      		ld	a,(hl)		;now get correct byte.
E25C: 07      	ckbmap1:rlca			;get correct bit into position 0.
E25D: 1D      		dec	e
E25E: C25CE2  		jp	nz,ckbmap1
E261: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
E262: D5      	stbitmap: push	de
E263: CD3BE2  		call	ckbitmap	;get the byte of interest.
E266: E6FE    		and	0feh		;clear the affected bit.
E268: C1      		pop	bc
E269: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
E26A: 0F      	stbmap1:rrca			;restore original bit position.
E26B: 15      		dec	d
E26C: C26AE2  		jp	nz,stbmap1
E26F: 77      		ld	(hl),a		;and stor byte in table.
E270: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
E271: CD64E1  	setfile:call	fcb2hl		;get address of fcb
E274: 111000  		ld	de,16
E277: 19      		add	hl,de		;get to block number bytes.
E278: C5      		push	bc
E279: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
E27B: D1      	setfl1:	pop	de
E27C: 0D      		dec	c		;done all bytes yet?
E27D: C8      		ret	z
E27E: D5      		push	de
E27F: 3AE3E9  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
E282: B7      		or	a
E283: CA8EE2  		jp	z,setfl2
E286: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
E287: E5      		push	hl
E288: 4E      		ld	c,(hl)		;get low byte from table, always
E289: 0600    		ld	b,0		;set high byte to zero.
E28B: C394E2  		jp	setfl3
E28E: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
E28F: C5      		push	bc
E290: 4E      		ld	c,(hl)		;now get both the low and high bytes.
E291: 23      		inc	hl
E292: 46      		ld	b,(hl)
E293: E5      		push	hl
E294: 79      	setfl3:	ld	a,c		;block used?
E295: B0      		or	b
E296: CAA3E2  		jp	z,setfl4
E299: 2ACCE9  		ld	hl,(dsksize)	;is this block number within the
E29C: 7D      		ld	a,l		;space on the disk?
E29D: 91      		sub	c
E29E: 7C      		ld	a,h
E29F: 98      		sbc	a,b
E2A0: D462E2  		call	nc,stbitmap	;yes, set the proper bit.
E2A3: E1      	setfl4:	pop	hl		;point to next block number in fcb.
E2A4: 23      		inc	hl
E2A5: C1      		pop	bc
E2A6: C37BE2  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
E2A9: 2ACCE9  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
E2AC: 0E03    		ld	c,3
E2AE: CDF0E0  		call	shiftr		;(hl)=(hl)/8.
E2B1: 23      		inc	hl		;at lease 1 byte.
E2B2: 44      		ld	b,h
E2B3: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
E2B4: 2AC5E9  		ld	hl,(alocvect)	;now zero out the table now.
E2B7: 3600    	bitmap1:ld	(hl),0
E2B9: 23      		inc	hl
E2BA: 0B      		dec	bc
E2BB: 78      		ld	a,b
E2BC: B1      		or	c
E2BD: C2B7E2  		jp	nz,bitmap1
E2C0: 2AD0E9  		ld	hl,(alloc0)	;get initial space used by directory.
E2C3: EB      		ex	de,hl
E2C4: 2AC5E9  		ld	hl,(alocvect)	;and put this into map.
E2C7: 73      		ld	(hl),e
E2C8: 23      		inc	hl
E2C9: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
E2CA: CDA7DF  		call	homedrv		;now home the drive.
E2CD: 2AB9E9  		ld	hl,(scratch1)
E2D0: 3603    		ld	(hl),3		;force next directory request to read
E2D2: 23      		inc	hl		;in a sector.
E2D3: 3600    		ld	(hl),0
E2D5: CD04E2  		call	stfilpos	;clear initial file position also.
E2D8: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
E2DA: CD0BE2  		call	nxentry		;and set checksum byte.
E2DD: CDFBE1  		call	ckfilpos	;is there another file?
E2E0: C8      		ret	z
E2E1: CD64E1  		call	fcb2hl		;yes, get its address.
E2E4: 3EE5    		ld	a,0e5h
E2E6: BE      		cp	(hl)		;empty file entry?
E2E7: CAD8E2  		jp	z,bitmap2
E2EA: 3A47DF  		ld	a,(userno)	;no, correct user number?
E2ED: BE      		cp	(hl)
E2EE: C2FCE2  		jp	nz,bitmap3
E2F1: 23      		inc	hl
E2F2: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
E2F3: D624    		sub	'$'
E2F5: C2FCE2  		jp	nz,bitmap3
E2F8: 3D      		dec	a		;yes, set atatus to minus one.
E2F9: 324BDF  		ld	(status),a
E2FC: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
E2FE: CD71E2  		call	setfile
E301: CD92E1  		call	chknmbr		;keep (scratch1) in bounds.
E304: C3D8E2  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
E307: 3ADAE9  	ststatus: ld	a,(fndstat)
E30A: C307DF  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
E30D: C5      	samext:	push	bc
E30E: F5      		push	af
E30F: 3ACBE9  		ld	a,(extmask)	;get extent mask and use it to
E312: 2F      		cpl			;to compare both extent numbers.
E313: 47      		ld	b,a		;save resulting mask here.
E314: 79      		ld	a,c		;mask first extent and save in (c).
E315: A0      		and	b
E316: 4F      		ld	c,a
E317: F1      		pop	af		;now mask second extent and compare
E318: A0      		and	b		;with the first one.
E319: 91      		sub	c
E31A: E61F    		and	1fh		;(* only check buts 0-4 *)
E31C: C1      		pop	bc		;the zero flag is set if they are the same.
E31D: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
E31E: 3EFF    	findfst:ld	a,0ffh
E320: 32DAE9  		ld	(fndstat),a
E323: 21DEE9  		ld	hl,counter	;save character count.
E326: 71      		ld	(hl),c
E327: 2A49DF  		ld	hl,(params)	;get filename to match.
E32A: 22DFE9  		ld	(savefcb),hl	;and save.
E32D: CD04E2  		call	stfilpos	;clear initial file position (set to 0ffffh).
E330: CDA7DF  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
E333: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
E335: CD0BE2  		call	nxentry		;get next filename entry in directory.
E338: CDFBE1  		call	ckfilpos	;is file position = 0ffffh?
E33B: CA9AE3  		jp	z,fndnxt6	;yes, exit now then.
E33E: 2ADFE9  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
E341: EB      		ex	de,hl
E342: 1A      		ld	a,(de)
E343: FEE5    		cp	0e5h		;empty directory entry?
E345: CA50E3  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
E348: D5      		push	de
E349: CD85E1  		call	morefls		;more files in directory?
E34C: D1      		pop	de
E34D: D29AE3  		jp	nc,fndnxt6	;no more. exit now.
E350: CD64E1  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
E353: 3ADEE9  		ld	a,(counter)	;get number of bytes (characters) to check.
E356: 4F      		ld	c,a
E357: 0600    		ld	b,0		;initialize byte position counter.
E359: 79      	fndnxt2:ld	a,c		;are we done with the compare?
E35A: B7      		or	a
E35B: CA89E3  		jp	z,fndnxt5
E35E: 1A      		ld	a,(de)		;no, check next byte.
E35F: FE3F    		cp	'?'		;don't care about this character?
E361: CA82E3  		jp	z,fndnxt4
E364: 78      		ld	a,b		;get bytes position in fcb.
E365: FE0D    		cp	13		;don't care about the thirteenth byte either.
E367: CA82E3  		jp	z,fndnxt4
E36A: FE0C    		cp	12		;extent byte?
E36C: 1A      		ld	a,(de)
E36D: CA79E3  		jp	z,fndnxt3
E370: 96      		sub	(hl)		;otherwise compare characters.
E371: E67F    		and	7fh
E373: C233E3  		jp	nz,findnxt	;not the same, check next entry.
E376: C382E3  		jp	fndnxt4		;so far so good, keep checking.
E379: C5      	fndnxt3:push	bc		;check the extent byte here.
E37A: 4E      		ld	c,(hl)
E37B: CD0DE3  		call	samext
E37E: C1      		pop	bc
E37F: C233E3  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
E382: 13      	fndnxt4:inc	de		;bump pointers.
E383: 23      		inc	hl
E384: 04      		inc	b
E385: 0D      		dec	c		;adjust character counter.
E386: C359E3  		jp	fndnxt2
E389: 3AF0E9  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
E38C: E603    		and	03h
E38E: 324BDF  		ld	(status),a
E391: 21DAE9  		ld	hl,fndstat
E394: 7E      		ld	a,(hl)
E395: 17      		rla	
E396: D0      		ret	nc
E397: AF      		xor	a
E398: 77      		ld	(hl),a
E399: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
E39A: CD04E2  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
E39D: 3EFF    		ld	a,0ffh		;say not located.
E39F: C307DF  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
E3A2: CD5AE1  	erafile:call	chkwprt		;is disk write protected?
E3A5: 0E0C    		ld	c,12		;only compare file names.
E3A7: CD1EE3  		call	findfst		;get first file name.
E3AA: CDFBE1  	erafil1:call	ckfilpos	;any found?
E3AD: C8      		ret	z		;nope, we must be done.
E3AE: CD4AE1  		call	chkrofl		;is file read only?
E3B1: CD64E1  		call	fcb2hl		;nope, get address of fcb and
E3B4: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
E3B6: 0E00    		ld	c,0		;clear the space from the bit map.
E3B8: CD71E2  		call	setfile
E3BB: CDCCE1  		call	dirwrite	;now write the directory sector back out.
E3BE: CD33E3  		call	findnxt		;find the next file name.
E3C1: C3AAE3  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
E3C4: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
E3C5: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
E3C6: 79      	fndspa1:ld	a,c		;is block 0 specified?
E3C7: B0      		or	b
E3C8: CAD7E3  		jp	z,fndspa2
E3CB: 0B      		dec	bc		;nope, check previous block.
E3CC: D5      		push	de
E3CD: C5      		push	bc
E3CE: CD3BE2  		call	ckbitmap
E3D1: 1F      		rra			;is this block empty?
E3D2: D2F2E3  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
E3D5: C1      		pop	bc		;nope, check some more.
E3D6: D1      		pop	de
              	;
              	;   now look after target block.
              	;
E3D7: 2ACCE9  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
E3DA: 7B      		ld	a,e
E3DB: 95      		sub	l
E3DC: 7A      		ld	a,d
E3DD: 9C      		sbc	a,h
E3DE: D2FAE3  		jp	nc,fndspa4
E3E1: 13      		inc	de		;yes, move on to next one.
E3E2: C5      		push	bc
E3E3: D5      		push	de
E3E4: 42      		ld	b,d
E3E5: 4B      		ld	c,e
E3E6: CD3BE2  		call	ckbitmap	;check it.
E3E9: 1F      		rra			;empty?
E3EA: D2F2E3  		jp	nc,fndspa3
E3ED: D1      		pop	de		;nope, continue searching.
E3EE: C1      		pop	bc
E3EF: C3C6E3  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
E3F2: 17      	fndspa3:rla			;reset byte.
E3F3: 3C      		inc	a		;and set bit 0.
E3F4: CD6AE2  		call	stbmap1		;update bit map.
E3F7: E1      		pop	hl		;set return registers.
E3F8: D1      		pop	de
E3F9: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
E3FA: 79      	fndspa4:ld	a,c
E3FB: B0      		or	b
E3FC: C2C6E3  		jp	nz,fndspa1
E3FF: 210000  		ld	hl,0		;set 'not found' status.
E402: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
E403: 0E00    	fcbset:	ld	c,0
E405: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
E407: D5      	update:	push	de
E408: 0600    		ld	b,0		;set (bc) to relative byte position.
E40A: 2A49DF  		ld	hl,(params)	;get address of fcb.
E40D: 09      		add	hl,bc		;compute starting byte.
E40E: EB      		ex	de,hl
E40F: CD64E1  		call	fcb2hl		;get address of fcb to update in directory.
E412: C1      		pop	bc		;set (c) to number of bytes to change.
E413: CD55DF  		call	de2hl
E416: CDC9DF  	update1:call	trksec		;determine the track and sector affected.
E419: C3CCE1  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
E41C: CD5AE1  	chgnames: call	chkwprt		;check for a write protected disk.
E41F: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
E421: CD1EE3  		call	findfst		;get first name.
E424: 2A49DF  		ld	hl,(params)	;get address of fcb.
E427: 7E      		ld	a,(hl)		;get user number.
E428: 111000  		ld	de,16		;move over to desired name.
E42B: 19      		add	hl,de
E42C: 77      		ld	(hl),a		;keep same user number.
E42D: CDFBE1  	chgnam1:call	ckfilpos	;any matching file found?
E430: C8      		ret	z		;no, we must be done.
E431: CD4AE1  		call	chkrofl		;check for read only file.
E434: 0E10    		ld	c,16		;start 16 bytes into fcb.
E436: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
E438: CD07E4  		call	update
E43B: CD33E3  		call	findnxt		;get te next file name.
E43E: C32DE4  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
E441: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
E443: CD1EE3  		call	findfst		;look for first filename.
E446: CDFBE1  	savatr1:call	ckfilpos	;was one found?
E449: C8      		ret	z		;nope, we must be done.
E44A: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
E44C: 1E0C    		ld	e,12
E44E: CD07E4  		call	update		;update filename and write directory.
E451: CD33E3  		call	findnxt		;and get the next file.
E454: C346E4  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
E457: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
E459: CD1EE3  		call	findfst		;get the first one in directory.
E45C: CDFBE1  		call	ckfilpos	;any at all?
E45F: C8      		ret	z
E460: CDACE0  	openit1:call	setext		;point to extent byte within users fcb.
E463: 7E      		ld	a,(hl)		;and get it.
E464: F5      		push	af		;save it and address.
E465: E5      		push	hl
E466: CD64E1  		call	fcb2hl		;point to fcb in directory.
E469: EB      		ex	de,hl
E46A: 2A49DF  		ld	hl,(params)	;this is the users copy.
E46D: 0E20    		ld	c,32		;move it into users space.
E46F: D5      		push	de
E470: CD55DF  		call	de2hl
E473: CD7EE1  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
E476: D1      		pop	de		;now get the extent byte from this fcb.
E477: 210C00  		ld	hl,12
E47A: 19      		add	hl,de
E47B: 4E      		ld	c,(hl)		;into (c).
E47C: 210F00  		ld	hl,15		;now get the record count byte into (b).
E47F: 19      		add	hl,de
E480: 46      		ld	b,(hl)
E481: E1      		pop	hl		;keep the same extent as the user had originally.
E482: F1      		pop	af
E483: 77      		ld	(hl),a
E484: 79      		ld	a,c		;is it the same as in the directory fcb?
E485: BE      		cp	(hl)
E486: 78      		ld	a,b		;if yes, then use the same record count.
E487: CA91E4  		jp	z,openit2
E48A: 3E00    		ld	a,0		;if the user specified an extent greater than
E48C: DA91E4  		jp	c,openit2	;the one in the directory, then set record count to 0.
E48F: 3E80    		ld	a,128		;otherwise set to maximum.
E491: 2A49DF  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
E494: 110F00  		ld	de,15
E497: 19      		add	hl,de		;compute relative position.
E498: 77      		ld	(hl),a		;and set the record count.
E499: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
E49A: 7E      	moveword: ld	a,(hl)		;check for a zero word.
E49B: 23      		inc	hl
E49C: B6      		or	(hl)		;both bytes zero?
E49D: 2B      		dec	hl
E49E: C0      		ret	nz		;nope, just return.
E49F: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
E4A0: 77      		ld	(hl),a		;this zero space.
E4A1: 13      		inc	de
E4A2: 23      		inc	hl
E4A3: 1A      		ld	a,(de)
E4A4: 77      		ld	(hl),a
E4A5: 1B      		dec	de		;don't disturb these registers.
E4A6: 2B      		dec	hl
E4A7: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
E4A8: AF      	closeit:xor	a		;clear status and file position bytes.
E4A9: 324BDF  		ld	(status),a
E4AC: 32F0E9  		ld	(filepos),a
E4AF: 32F1E9  		ld	(filepos+1),a
E4B2: CD24E1  		call	getwprt		;get write protect bit for this drive.
E4B5: C0      		ret	nz		;just return if it is set.
E4B6: CD6FE1  		call	gets2		;else get the 's2' byte.
E4B9: E680    		and	80h		;and look at bit 7 (file unmodified?).
E4BB: C0      		ret	nz		;just return if set.
E4BC: 0E0F    		ld	c,15		;else look up this file in directory.
E4BE: CD1EE3  		call	findfst
E4C1: CDFBE1  		call	ckfilpos	;was it found?
E4C4: C8      		ret	z		;just return if not.
E4C5: 011000  		ld	bc,16		;set (hl) pointing to records used section.
E4C8: CD64E1  		call	fcb2hl
E4CB: 09      		add	hl,bc
E4CC: EB      		ex	de,hl
E4CD: 2A49DF  		ld	hl,(params)	;do the same for users specified fcb.
E4D0: 09      		add	hl,bc
E4D1: 0E10    		ld	c,16		;this many bytes are present in this extent.
E4D3: 3AE3E9  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
E4D6: B7      		or	a
E4D7: CAEEE4  		jp	z,closeit4
E4DA: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
E4DB: B7      		or	a
E4DC: 1A      		ld	a,(de)		;now get one from directory fcb.
E4DD: C2E1E4  		jp	nz,closeit2
E4E0: 77      		ld	(hl),a		;users byte was zero. update from directory.
E4E1: B7      	closeit2: or	a
E4E2: C2E7E4  		jp	nz,closeit3
E4E5: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
E4E6: 12      		ld	(de),a
E4E7: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
E4E8: C225E5  		jp	nz,closeit7	;then close error if they are not the same.
E4EB: C303E5  		jp	closeit5	;ok so far, get to next byte in fcbs.
E4EE: CD9AE4  	closeit4: call	moveword	;update users fcb if it is zero.
E4F1: EB      		ex	de,hl
E4F2: CD9AE4  		call	moveword	;update directories fcb if it is zero.
E4F5: EB      		ex	de,hl
E4F6: 1A      		ld	a,(de)		;if these two values are no different,
E4F7: BE      		cp	(hl)		;then a close error occured.
E4F8: C225E5  		jp	nz,closeit7
E4FB: 13      		inc	de		;check second byte.
E4FC: 23      		inc	hl
E4FD: 1A      		ld	a,(de)
E4FE: BE      		cp	(hl)
E4FF: C225E5  		jp	nz,closeit7
E502: 0D      		dec	c		;remember 16 bit values.
E503: 13      	closeit5: inc	de		;bump to next item in table.
E504: 23      		inc	hl
E505: 0D      		dec	c		;there are 16 entries only.
E506: C2D3E4  		jp	nz,closeit1	;continue if more to do.
E509: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
E50C: 09      		add	hl,bc
E50D: EB      		ex	de,hl
E50E: 09      		add	hl,bc
E50F: 1A      		ld	a,(de)
E510: BE      		cp	(hl)		;directory's extent already greater than the
E511: DA1DE5  		jp	c,closeit6	;users extent?
E514: 77      		ld	(hl),a		;no, update directory extent.
E515: 010300  		ld	bc,3		;and update the record count byte in
E518: 09      		add	hl,bc		;directories fcb.
E519: EB      		ex	de,hl
E51A: 09      		add	hl,bc
E51B: 7E      		ld	a,(hl)		;get from user.
E51C: 12      		ld	(de),a		;and put in directory.
E51D: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
E51F: 32D8E9  		ld	(closeflg),a
E522: C316E4  		jp	update1		;update the directory now.
E525: 214BDF  	closeit7: ld	hl,status	;set return status and then return.
E528: 35      		dec	(hl)
E529: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
E52A: CD5AE1  	getempty: call	chkwprt		;make sure disk is not write protected.
E52D: 2A49DF  		ld	hl,(params)	;save current parameters (fcb).
E530: E5      		push	hl
E531: 21B2E9  		ld	hl,emptyfcb	;use special one for empty space.
E534: 2249DF  		ld	(params),hl
E537: 0E01    		ld	c,1		;search for first empty spot in directory.
E539: CD1EE3  		call	findfst		;(* only check first byte *)
E53C: CDFBE1  		call	ckfilpos	;none?
E53F: E1      		pop	hl
E540: 2249DF  		ld	(params),hl	;restore original fcb address.
E543: C8      		ret	z		;return if no more space.
E544: EB      		ex	de,hl
E545: 210F00  		ld	hl,15		;point to number of records for this file.
E548: 19      		add	hl,de
E549: 0E11    		ld	c,17		;and clear all of this space.
E54B: AF      		xor	a
E54C: 77      	getmt1:	ld	(hl),a
E54D: 23      		inc	hl
E54E: 0D      		dec	c
E54F: C24CE5  		jp	nz,getmt1
E552: 210D00  		ld	hl,13		;clear the 's1' byte also.
E555: 19      		add	hl,de
E556: 77      		ld	(hl),a
E557: CD92E1  		call	chknmbr		;keep (scratch1) within bounds.
E55A: CD03E4  		call	fcbset		;write out this fcb entry to directory.
E55D: C37EE1  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
E560: AF      	getnext:xor	a
E561: 32D8E9  		ld	(closeflg),a	;clear close flag.
E564: CDA8E4  		call	closeit		;close this extent.
E567: CDFBE1  		call	ckfilpos
E56A: C8      		ret	z		;not there???
E56B: 2A49DF  		ld	hl,(params)	;get extent byte.
E56E: 010C00  		ld	bc,12
E571: 09      		add	hl,bc
E572: 7E      		ld	a,(hl)		;and increment it.
E573: 3C      		inc	a
E574: E61F    		and	1fh		;keep within range 0-31.
E576: 77      		ld	(hl),a
E577: CA89E5  		jp	z,gtnext1	;overflow?
E57A: 47      		ld	b,a		;mask extent byte.
E57B: 3ACBE9  		ld	a,(extmask)
E57E: A0      		and	b
E57F: 21D8E9  		ld	hl,closeflg	;check close flag (0ffh is ok).
E582: A6      		and	(hl)
E583: CA94E5  		jp	z,gtnext2	;if zero, we must read in next extent.
E586: C3B2E5  		jp	gtnext3		;else, it is already in memory.
E589: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
E58C: 09      		add	hl,bc
E58D: 34      		inc	(hl)		;and bump it.
E58E: 7E      		ld	a,(hl)		;too many extents?
E58F: E60F    		and	0fh
E591: CABCE5  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
E594: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
E596: CD1EE3  		call	findfst		;find the first one.
E599: CDFBE1  		call	ckfilpos	;none available?
E59C: C2B2E5  		jp	nz,gtnext3
E59F: 3AD9E9  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
E5A2: 3C      		inc	a		;0ffh means reading (so not possible).
E5A3: CABCE5  		jp	z,gtnext5	;or an error.
E5A6: CD2AE5  		call	getempty	;we are writing, get an empty entry.
E5A9: CDFBE1  		call	ckfilpos	;none?
E5AC: CABCE5  		jp	z,gtnext5	;error if true.
E5AF: C3B5E5  		jp	gtnext4		;else we are almost done.
E5B2: CD60E4  	gtnext3:call	openit1		;open this extent.
E5B5: CDC1E0  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
E5B8: AF      		xor	a		;clear status and return.
E5B9: C307DF  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
E5BC: CD0BDF  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
E5BF: C37EE1  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
E5C2: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
E5C4: 32DBE9  		ld	(mode),a
E5C7: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
E5C9: 32D9E9  		ld	(rdwrtflg),a
E5CC: CDC1E0  		call	strdata		;put rec# and ext# into fcb.
E5CF: 3AE9E9  		ld	a,(savnrec)	;get next record to read.
E5D2: 21E7E9  		ld	hl,savnxt	;get number of records in extent.
E5D5: BE      		cp	(hl)		;within this extent?
E5D6: DAECE5  		jp	c,rdseq2
E5D9: FE80    		cp	128		;no. is this extent fully used?
E5DB: C201E6  		jp	nz,rdseq3	;no. end-of-file.
E5DE: CD60E5  		call	getnext		;yes, open the next one.
E5E1: AF      		xor	a		;reset next record to read.
E5E2: 32E9E9  		ld	(savnrec),a
E5E5: 3A4BDF  		ld	a,(status)	;check on open, successful?
E5E8: B7      		or	a
E5E9: C201E6  		jp	nz,rdseq3	;no, error.
E5EC: CD7DE0  	rdseq2:	call	comblk		;ok. compute block number to read.
E5EF: CD8AE0  		call	chkblk		;check it. within bounds?
E5F2: CA01E6  		jp	z,rdseq3	;no, error.
E5F5: CD90E0  		call	logical		;convert (blknmbr) to logical sector (128 byte).
E5F8: CDD7DF  		call	trksec1		;set the track and sector for this block #.
E5FB: CDB8DF  		call	doread		;and read it.
E5FE: C3D8E0  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
E601: C30BDF  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
E604: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
E606: 32DBE9  		ld	(mode),a
E609: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
E60B: 32D9E9  		ld	(rdwrtflg),a
E60E: CD5AE1  		call	chkwprt		;check write protect status.
E611: 2A49DF  		ld	hl,(params)
E614: CD4DE1  		call	ckrof1		;check for read only file, (hl) already set to fcb.
E617: CDC1E0  		call	strdata		;put updated data into fcb.
E61A: 3AE9E9  		ld	a,(savnrec)	;get record number to write.
E61D: FE80    		cp	128		;within range?
E61F: D20BDF  		jp	nc,ioerr1	;no, error(?).
E622: CD7DE0  		call	comblk		;compute block number.
E625: CD8AE0  		call	chkblk		;check number.
E628: 0E00    		ld	c,0		;is there one to write to?
E62A: C274E6  		jp	nz,wtseq6	;yes, go do it.
E62D: CD44E0  		call	getblock	;get next block number within fcb to use.
E630: 32DDE9  		ld	(relblock),a	;and save.
E633: 010000  		ld	bc,0		;start looking for space from the start
E636: B7      		or	a		;if none allocated as yet.
E637: CA41E6  		jp	z,wtseq2
E63A: 4F      		ld	c,a		;extract previous block number from fcb
E63B: 0B      		dec	bc		;so we can be closest to it.
E63C: CD64E0  		call	extblk
E63F: 44      		ld	b,h
E640: 4D      		ld	c,l
E641: CDC4E3  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
E644: 7D      		ld	a,l		;check for a zero number.
E645: B4      		or	h
E646: C24EE6  		jp	nz,wtseq3
E649: 3E02    		ld	a,2		;no more space?
E64B: C307DF  		jp	setstat
E64E: 22EBE9  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
E651: EB      		ex	de,hl		;put block number into (de).
E652: 2A49DF  		ld	hl,(params)	;now we must update the fcb for this
E655: 011000  		ld	bc,16		;newly allocated block.
E658: 09      		add	hl,bc
E659: 3AE3E9  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
E65C: B7      		or	a
E65D: 3ADDE9  		ld	a,(relblock)	;(* update this entry *)
E660: CA6AE6  		jp	z,wtseq4	;zero means 16 bit ones.
E663: CD6AE1  		call	adda2hl		;(hl)=(hl)+(a)
E666: 73      		ld	(hl),e		;store new block number.
E667: C372E6  		jp	wtseq5
E66A: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
E66B: 0600    		ld	b,0
E66D: 09      		add	hl,bc
E66E: 09      		add	hl,bc
E66F: 73      		ld	(hl),e		;stuff block number (de) there.
E670: 23      		inc	hl
E671: 72      		ld	(hl),d
E672: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
E674: 3A4BDF  	wtseq6:	ld	a,(status)	;are we ok so far?
E677: B7      		or	a
E678: C0      		ret	nz
E679: C5      		push	bc		;yes, save write flag for bios (register c).
E67A: CD90E0  		call	logical		;convert (blknmbr) over to loical sectors.
E67D: 3ADBE9  		ld	a,(mode)	;get access mode flag (1=sequential,
E680: 3D      		dec	a		;0=random, 2=special?).
E681: 3D      		dec	a
E682: C2C1E6  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
E685: C1      		pop	bc
E686: C5      		push	bc
E687: 79      		ld	a,c		;get write status flag (2=writing unused space).
E688: 3D      		dec	a
E689: 3D      		dec	a
E68A: C2C1E6  		jp	nz,wtseq9
E68D: E5      		push	hl
E68E: 2ABFE9  		ld	hl,(dirbuf)	;zero out the directory buffer.
E691: 57      		ld	d,a		;note that (a) is zero here.
E692: 77      	wtseq7:	ld	(hl),a
E693: 23      		inc	hl
E694: 14      		inc	d		;do 128 bytes.
E695: F292E6  		jp	p,wtseq7
E698: CDE6E1  		call	dirdma		;tell the bios the dma address for directory access.
E69B: 2AEDE9  		ld	hl,(logsect)	;get sector that starts current block.
E69E: 0E02    		ld	c,2		;set 'writing to unused space' flag.
E6A0: 22EBE9  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
E6A3: C5      		push	bc
E6A4: CDD7DF  		call	trksec1		;determine its track and sector numbers.
E6A7: C1      		pop	bc
E6A8: CDBEDF  		call	dowrite		;now write out 128 bytes of zeros.
E6AB: 2AEBE9  		ld	hl,(blknmbr)	;get sector number.
E6AE: 0E00    		ld	c,0		;set normal write flag.
E6B0: 3ACAE9  		ld	a,(blkmask)	;determine if we have written the entire
E6B3: 47      		ld	b,a		;physical block.
E6B4: A5      		and	l
E6B5: B8      		cp	b
E6B6: 23      		inc	hl		;prepare for the next one.
E6B7: C2A0E6  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
E6BA: E1      		pop	hl		;reset next sector number.
E6BB: 22EBE9  		ld	(blknmbr),hl
E6BE: CDE0E1  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
E6C1: CDD7DF  	wtseq9:	call	trksec1		;determine track and sector for this write.
E6C4: C1      		pop	bc		;get write status flag.
E6C5: C5      		push	bc
E6C6: CDBEDF  		call	dowrite		;and write this out.
E6C9: C1      		pop	bc
E6CA: 3AE9E9  		ld	a,(savnrec)	;get number of records in file.
E6CD: 21E7E9  		ld	hl,savnxt	;get last record written.
E6D0: BE      		cp	(hl)
E6D1: DAD8E6  		jp	c,wtseq10
E6D4: 77      		ld	(hl),a		;we have to update record count.
E6D5: 34      		inc	(hl)
E6D6: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
E6D8: 00      	wtseq10:nop			;was 'dcr c'
E6D9: 00      		nop			;was 'dcr c'
E6DA: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
E6DD: F5      		push	af
E6DE: CD6FE1  		call	gets2		;set 'extent written to' flag.
E6E1: E67F    		and	7fh		;(* clear bit 7 *)
E6E3: 77      		ld	(hl),a
E6E4: F1      		pop	af		;get record count for this extent.
E6E5: FE7F    	wtseq99:cp	127		;is it full?
E6E7: C206E7  		jp	nz,wtseq12
E6EA: 3ADBE9  		ld	a,(mode)	;yes, are we in sequential mode?
E6ED: FE01    		cp	1
E6EF: C206E7  		jp	nz,wtseq12
E6F2: CDD8E0  		call	setnrec		;yes, set next record number.
E6F5: CD60E5  		call	getnext		;and get next empty space in directory.
E6F8: 214BDF  		ld	hl,status	;ok?
E6FB: 7E      		ld	a,(hl)
E6FC: B7      		or	a
E6FD: C204E7  		jp	nz,wtseq11
E700: 3D      		dec	a		;yes, set record count to -1.
E701: 32E9E9  		ld	(savnrec),a
E704: 3600    	wtseq11:ld	(hl),0		;clear status.
E706: C3D8E0  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
E709: AF      	position: xor	a		;set random i/o flag.
E70A: 32DBE9  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
E70D: C5      	positn1:push	bc		;save read/write flag.
E70E: 2A49DF  		ld	hl,(params)	;get address of fcb.
E711: EB      		ex	de,hl
E712: 212100  		ld	hl,33		;now get byte 'r0'.
E715: 19      		add	hl,de
E716: 7E      		ld	a,(hl)
E717: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
E719: F5      		push	af
E71A: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
E71B: 17      		rla	
E71C: 23      		inc	hl
E71D: 7E      		ld	a,(hl)
E71E: 17      		rla	
E71F: E61F    		and	1fh		;and save this in bits 0-4 of (c).
E721: 4F      		ld	c,a		;this is the extent byte.
E722: 7E      		ld	a,(hl)		;now get the extra extent byte.
E723: 1F      		rra	
E724: 1F      		rra	
E725: 1F      		rra	
E726: 1F      		rra	
E727: E60F    		and	0fh
E729: 47      		ld	b,a		;and save it in (b).
E72A: F1      		pop	af		;get record number back to (a).
E72B: 23      		inc	hl		;check overflow byte 'r2'.
E72C: 6E      		ld	l,(hl)
E72D: 2C      		inc	l
E72E: 2D      		dec	l
E72F: 2E06    		ld	l,6		;prepare for error.
E731: C291E7  		jp	nz,positn5	;out of disk space error.
E734: 212000  		ld	hl,32		;store record number into fcb.
E737: 19      		add	hl,de
E738: 77      		ld	(hl),a
E739: 210C00  		ld	hl,12		;and now check the extent byte.
E73C: 19      		add	hl,de
E73D: 79      		ld	a,c
E73E: 96      		sub	(hl)		;same extent as before?
E73F: C24DE7  		jp	nz,positn2
E742: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
E745: 19      		add	hl,de
E746: 78      		ld	a,b
E747: 96      		sub	(hl)
E748: E67F    		and	7fh
E74A: CA85E7  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
E74D: C5      	positn2:push	bc
E74E: D5      		push	de
E74F: CDA8E4  		call	closeit		;close current extent.
E752: D1      		pop	de
E753: C1      		pop	bc
E754: 2E03    		ld	l,3		;prepare for error.
E756: 3A4BDF  		ld	a,(status)
E759: 3C      		inc	a
E75A: CA8AE7  		jp	z,positn4	;close error.
E75D: 210C00  		ld	hl,12		;put desired extent into fcb now.
E760: 19      		add	hl,de
E761: 71      		ld	(hl),c
E762: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
E765: 19      		add	hl,de
E766: 70      		ld	(hl),b
E767: CD57E4  		call	openit		;try and get this extent.
E76A: 3A4BDF  		ld	a,(status)	;was it there?
E76D: 3C      		inc	a
E76E: C285E7  		jp	nz,positn3
E771: C1      		pop	bc		;no. can we create a new one (writing?).
E772: C5      		push	bc
E773: 2E04    		ld	l,4		;prepare for error.
E775: 0C      		inc	c
E776: CA8AE7  		jp	z,positn4	;nope, reading unwritten space error.
E779: CD2AE5  		call	getempty	;yes we can, try to find space.
E77C: 2E05    		ld	l,5		;prepare for error.
E77E: 3A4BDF  		ld	a,(status)
E781: 3C      		inc	a
E782: CA8AE7  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
E785: C1      	positn3:pop	bc		;restore stack.
E786: AF      		xor	a		;and clear error code byte.
E787: C307DF  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
E78A: E5      	positn4:push	hl
E78B: CD6FE1  		call	gets2
E78E: 36C0    		ld	(hl),0c0h
E790: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
E791: C1      	positn5:pop	bc
E792: 7D      		ld	a,l		;get error code.
E793: 324BDF  		ld	(status),a
E796: C37EE1  		jp	sets2b7
              	;
              	;   read a random record.
              	;
E799: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
E79B: CD09E7  		call	position	;position the file to proper record.
E79E: CCC7E5  		call	z,rdseq1	;and read it as usual (if no errors).
E7A1: C9      		ret	
              	;
              	;   write to a random record.
              	;
E7A2: 0E00    	writeran: ld	c,0		;set 'writing' flag.
E7A4: CD09E7  		call	position	;position the file to proper record.
E7A7: CC09E6  		call	z,wtseq1	;and write as usual (if no errors).
E7AA: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
E7AB: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
E7AC: 19      		add	hl,de		;compute relative position of record #.
E7AD: 4E      		ld	c,(hl)		;get record number into (bc).
E7AE: 0600    		ld	b,0
E7B0: 210C00  		ld	hl,12		;now get extent.
E7B3: 19      		add	hl,de
E7B4: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
E7B5: 0F      		rrca			;move lower bit into bit 7.
E7B6: E680    		and	80h		;and ignore all other bits.
E7B8: 81      		add	a,c		;add to our record number.
E7B9: 4F      		ld	c,a
E7BA: 3E00    		ld	a,0		;take care of any carry.
E7BC: 88      		adc	a,b
E7BD: 47      		ld	b,a
E7BE: 7E      		ld	a,(hl)		;now get the upper bits of extent into
E7BF: 0F      		rrca			;bit positions 0-3.
E7C0: E60F    		and	0fh		;and ignore all others.
E7C2: 80      		add	a,b		;add this in to 'r1' byte.
E7C3: 47      		ld	b,a
E7C4: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
E7C7: 19      		add	hl,de
E7C8: 7E      		ld	a,(hl)
E7C9: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
E7CA: 87      		add	a,a
E7CB: 87      		add	a,a
E7CC: 87      		add	a,a
E7CD: F5      		push	af		;save carry flag (bit 0 of flag byte).
E7CE: 80      		add	a,b		;now add extra extent into 'r1'.
E7CF: 47      		ld	b,a
E7D0: F5      		push	af		;and save carry (overflow byte 'r2').
E7D1: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
E7D2: 7D      		ld	a,l
E7D3: E1      		pop	hl		;and same for first carry flag.
E7D4: B5      		or	l		;either one of these set?
E7D5: E601    		and	01h		;only check the carry flags.
E7D7: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
E7D8: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
E7DA: CD1EE3  		call	findfst		;this name.
E7DD: 2A49DF  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
E7E0: 112100  		ld	de,33
E7E3: 19      		add	hl,de
E7E4: E5      		push	hl
E7E5: 72      		ld	(hl),d		;note that (d)=0.
E7E6: 23      		inc	hl
E7E7: 72      		ld	(hl),d
E7E8: 23      		inc	hl
E7E9: 72      		ld	(hl),d
E7EA: CDFBE1  	ransiz1:call	ckfilpos	;is there an extent to process?
E7ED: CA12E8  		jp	z,ransiz3	;no, we are done.
E7F0: CD64E1  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
E7F3: 110F00  		ld	de,15		;point to last record in extent.
E7F6: CDABE7  		call	comprand	;and compute random parameters.
E7F9: E1      		pop	hl
E7FA: E5      		push	hl		;now check these values against those
E7FB: 5F      		ld	e,a		;already in fcb.
E7FC: 79      		ld	a,c		;the carry flag will be set if those
E7FD: 96      		sub	(hl)		;in the fcb represent a larger size than
E7FE: 23      		inc	hl		;this extent does.
E7FF: 78      		ld	a,b
E800: 9E      		sbc	a,(hl)
E801: 23      		inc	hl
E802: 7B      		ld	a,e
E803: 9E      		sbc	a,(hl)
E804: DA0CE8  		jp	c,ransiz2
E807: 73      		ld	(hl),e		;we found a larger (in size) extent.
E808: 2B      		dec	hl		;stuff these values into fcb.
E809: 70      		ld	(hl),b
E80A: 2B      		dec	hl
E80B: 71      		ld	(hl),c
E80C: CD33E3  	ransiz2:call	findnxt		;now get the next extent.
E80F: C3EAE7  		jp	ransiz1		;continue til all done.
E812: E1      	ransiz3:pop	hl		;we are done, restore the stack and
E813: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
E814: 2A49DF  	setran:	ld	hl,(params)	;point to fcb.
E817: 112000  		ld	de,32		;and to last used record.
E81A: CDABE7  		call	comprand	;compute random position.
E81D: 212100  		ld	hl,33		;now stuff these values into fcb.
E820: 19      		add	hl,de
E821: 71      		ld	(hl),c		;move 'r0'.
E822: 23      		inc	hl
E823: 70      		ld	(hl),b		;and 'r1'.
E824: 23      		inc	hl
E825: 77      		ld	(hl),a		;and lastly 'r2'.
E826: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
E827: 2AB5E9  	logindrv: ld	hl,(login)	;get the login vector.
E82A: 3A48DF  		ld	a,(active)	;get the default drive.
E82D: 4F      		ld	c,a
E82E: CDF0E0  		call	shiftr		;position active bit for this drive
E831: E5      		push	hl		;into bit 0.
E832: EB      		ex	de,hl
E833: CD5FDF  		call	select		;select this drive.
E836: E1      		pop	hl
E837: CC4DDF  		call	z,slcterr	;valid drive?
E83A: 7D      		ld	a,l		;is this a newly activated drive?
E83B: 1F      		rra	
E83C: D8      		ret	c
E83D: 2AB5E9  		ld	hl,(login)	;yes, update the login vector.
E840: 4D      		ld	c,l
E841: 44      		ld	b,h
E842: CD11E1  		call	setbit
E845: 22B5E9  		ld	(login),hl	;and save.
E848: C3A9E2  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
E84B: 3ADCE9  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
E84E: 2148DF  		ld	hl,active	;represents a change in drives.
E851: BE      		cp	(hl)
E852: C8      		ret	z
E853: 77      		ld	(hl),a		;yes it does, log it in.
E854: C327E8  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
E857: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
E859: 32E4E9  		ld	(auto),a
E85C: 2A49DF  		ld	hl,(params)	;get drive specified.
E85F: 7E      		ld	a,(hl)
E860: E61F    		and	1fh		;look at lower 5 bits.
E862: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
E863: 32DCE9  		ld	(eparam),a	;and save for the select routine.
E866: FE1E    		cp	1eh		;check for 'no change' condition.
E868: D27BE8  		jp	nc,autosl1	;yes, don't change.
E86B: 3A48DF  		ld	a,(active)	;we must change, save currently active
E86E: 32E5E9  		ld	(olddrv),a	;drive.
E871: 7E      		ld	a,(hl)		;and save first byte of fcb also.
E872: 32E6E9  		ld	(autoflag),a	;this must be non-zero.
E875: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
E877: 77      		ld	(hl),a		;something)?
E878: CD4BE8  		call	setdsk		;select and log in this drive.
E87B: 3A47DF  	autosl1:ld	a,(userno)	;move user number into fcb.
E87E: 2A49DF  		ld	hl,(params)	;(* upper half of first byte *)
E881: B6      		or	(hl)
E882: 77      		ld	(hl),a
E883: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
E884: 3E22    	getver:	ld	a,022h		;version 2.2
E886: C307DF  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
E889: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
E88C: 22B3E9  		ld	(wrtprt),hl	;in vector.
E88F: 22B5E9  		ld	(login),hl
E892: AF      		xor	a		;select drive 'a'.
E893: 3248DF  		ld	(active),a
E896: 218000  		ld	hl,tbuff	;setup default dma address.
E899: 22B7E9  		ld	(userdma),hl
E89C: CDE0E1  		call	defdma
E89F: C327E8  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
E8A2: CD78E1  	openfil:call	clears2		;clear 's2' byte.
E8A5: CD57E8  		call	autosel		;select proper disk.
E8A8: C357E4  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
E8AB: CD57E8  	closefil: call	autosel		;select proper disk.
E8AE: C3A8E4  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
E8B1: 0E00    	getfst:	ld	c,0		;prepare for special search.
E8B3: EB      		ex	de,hl
E8B4: 7E      		ld	a,(hl)		;is first byte a '?'?
E8B5: FE3F    		cp	'?'
E8B7: CAC8E8  		jp	z,getfst1	;yes, just get very first entry (zero length match).
E8BA: CDACE0  		call	setext		;get the extension byte from fcb.
E8BD: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
E8BE: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
E8C0: C478E1  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
E8C3: CD57E8  		call	autosel		;select proper drive.
E8C6: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
E8C8: CD1EE3  	getfst1:call	findfst		;find an entry and then move it into
E8CB: C3EFE1  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
E8CE: 2ADFE9  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
E8D1: 2249DF  		ld	(params),hl	;other dbos calls are allowed.
E8D4: CD57E8  		call	autosel		;no error will be returned, but the
E8D7: CD33E3  		call	findnxt		;results will be wrong.
E8DA: C3EFE1  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
E8DD: CD57E8  	delfile:call	autosel		;select proper drive.
E8E0: CDA2E3  		call	erafile		;erase the file.
E8E3: C307E3  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
E8E6: CD57E8  	readseq:call	autosel		;select proper drive then read.
E8E9: C3C2E5  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
E8EC: CD57E8  	wrtseq:	call	autosel		;select proper drive then write.
E8EF: C304E6  		jp	wtseq
              	;
              	;   create a file function.
              	;
E8F2: CD78E1  	fcreate:call	clears2		;clear the 's2' byte on all creates.
E8F5: CD57E8  		call	autosel		;select proper drive and get the next
E8F8: C32AE5  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
E8FB: CD57E8  	renfile:call	autosel		;select proper drive and then switch
E8FE: CD1CE4  		call	chgnames	;file names.
E901: C307E3  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
E904: 2AB5E9  	getlog:	ld	hl,(login)
E907: C32FE9  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
E90A: 3A48DF  	getcrnt:ld	a,(active)
E90D: C307DF  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
E910: EB      	putdma:	ex	de,hl
E911: 22B7E9  		ld	(userdma),hl	;save in our space and then get to
E914: C3E0E1  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
E917: 2AC5E9  	getaloc:ld	hl,(alocvect)
E91A: C32FE9  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
E91D: 2AB3E9  	getrov:	ld	hl,(wrtprt)
E920: C32FE9  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
E923: CD57E8  	setattr:call	autosel		;select proper drive then save attributes.
E926: CD41E4  		call	saveattr
E929: C307E3  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
E92C: 2AC1E9  	getparm:ld	hl,(diskpb)
E92F: 224BDF  	getprm1:ld	(status),hl
E932: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
E933: 3ADCE9  	getuser:ld	a,(eparam)	;get parameter.
E936: FEFF    		cp	0ffh		;get user number?
E938: C241E9  		jp	nz,setuser
E93B: 3A47DF  		ld	a,(userno)	;yes, just do it.
E93E: C307DF  		jp	setstat
E941: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
E943: 3247DF  		ld	(userno),a	;bits (0-4) only.
E946: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
E947: CD57E8  	rdrandom: call	autosel		;select proper drive and read.
E94A: C399E7  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
E94D: CD57E8  	wtrandom: call	autosel		;select proper drive and write.
E950: C3A2E7  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
E953: CD57E8  	filesize: call	autosel		;select proper drive and check file length
E956: C3D8E7  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
E959: 2A49DF  	logoff:	ld	hl,(params)	;get drives to log off.
E95C: 7D      		ld	a,l		;for each bit that is set, we want
E95D: 2F      		cpl			;to clear that bit in (login)
E95E: 5F      		ld	e,a		;and (wrtprt).
E95F: 7C      		ld	a,h
E960: 2F      		cpl	
E961: 2AB5E9  		ld	hl,(login)	;reset the login vector.
E964: A4      		and	h
E965: 57      		ld	d,a
E966: 7D      		ld	a,l
E967: A3      		and	e
E968: 5F      		ld	e,a
E969: 2AB3E9  		ld	hl,(wrtprt)
E96C: EB      		ex	de,hl
E96D: 22B5E9  		ld	(login),hl	;and save.
E970: 7D      		ld	a,l		;now do the write protect vector.
E971: A3      		and	e
E972: 6F      		ld	l,a
E973: 7C      		ld	a,h
E974: A2      		and	d
E975: 67      		ld	h,a
E976: 22B3E9  		ld	(wrtprt),hl	;and save. all done.
E979: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
E97A: 3AE4E9  	goback:	ld	a,(auto)	;was auto select activated?
E97D: B7      		or	a
E97E: CA97E9  		jp	z,goback1
E981: 2A49DF  		ld	hl,(params)	;yes, but was a change made?
E984: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
E986: 3AE6E9  		ld	a,(autoflag)
E989: B7      		or	a
E98A: CA97E9  		jp	z,goback1
E98D: 77      		ld	(hl),a		;yes, reset first byte properly.
E98E: 3AE5E9  		ld	a,(olddrv)	;and get the old drive and select it.
E991: 32DCE9  		ld	(eparam),a
E994: CD4BE8  		call	setdsk
E997: 2A15DF  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
E99A: F9      		ld	sp,hl
E99B: 2A4BDF  		ld	hl,(status)	;get return status.
E99E: 7D      		ld	a,l		;force version 1.4 compatability.
E99F: 44      		ld	b,h
E9A0: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
E9A1: CD57E8  	wtspecl:call	autosel		;select proper drive.
E9A4: 3E02    		ld	a,2		;use special write mode.
E9A6: 32DBE9  		ld	(mode),a
E9A9: 0E00    		ld	c,0		;set write indicator.
E9AB: CD0DE7  		call	positn1		;position the file.
E9AE: CC09E6  		call	z,wtseq1	;and write (if no errors).
E9B1: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
E9B2: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
E9B3: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
E9B5: 0000    	login:	defw	0		;drive active word (1 bit per drive).
E9B7: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
E9B9: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
E9BB: 0000    	scratch2: defw	0		;last selected track number.
E9BD: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
E9BF: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
E9C1: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
E9C3: 0000    	chkvect:defw	0		;address of check vector.
E9C5: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
E9C7: 0000    	sectors:defw	0		;sectors per track from bios.
E9C9: 00      	blkshft:defb	0		;block shift.
E9CA: 00      	blkmask:defb	0		;block mask.
E9CB: 00      	extmask:defb	0		;extent mask.
E9CC: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
E9CE: 0000    	dirsize:defw	0		;directory size.
E9D0: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
E9D2: 0000    	alloc1:	defw	0
E9D4: 0000    	offset:	defw	0		;first usable track number.
E9D6: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
E9D8: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
E9D9: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
E9DA: 00      	fndstat:defb	0		;filename found status (0=found first entry).
E9DB: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
E9DC: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
E9DD: 00      	relblock: defb	0		;relative position within fcb of block number written.
E9DE: 00      	counter:defb	0		;byte counter for directory name searches.
E9DF: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
E9E3: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
E9E4: 00      	auto:	defb	0		;if non-zero, then auto select activated.
E9E5: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
E9E6: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
E9E7: 00      	savnxt:	defb	0		;storage for next record number to access.
E9E8: 00      	savext:	defb	0		;storage for extent number of file.
E9E9: 0000    	savnrec:defw	0		;storage for number of records in file.
E9EB: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
E9ED: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
E9EF: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
E9F0: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
E9F2: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E9F6: 00...   	
              		
              	; Small routine to print a decimal 0-19
EA02: FE3A    	printdc:cp	':'
EA04: DA8CD4  		jp	c,print
EA07: D60A    		sub	10
EA09: F5      		push	af
EA0A: 3E31    		ld	a,'1'
EA0C: CD8CD4  		call	print
EA0F: F1      		pop	af
EA10: 18F0    		jr	printdc
              	
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS. 
              	;*
              	;**************************************************************
              	;
EA12: C345EA  		jp	boot
EA15: C353EA  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
EA18: C3A4EA  		jp	const
EA1B: C3AFEA  		jp	conin
EA1E: C3BBEA  		jp	conout
EA21: C3C7EA  		jp	list
EA24: C3CBEA  		jp	punch
EA27: C3CFEA  		jp	reader
EA2A: C3DDEA  		jp	home
EA2D: C3E2EA  		jp	seldsk
EA30: C300EB  		jp	settrk
EA33: C304EB  		jp	setsec
EA36: C308EB  		jp	setdma
EA39: C30EEB  		jp	read
EA3C: C312EB  		jp	write
EA3F: C316EB  		jp	prstat
EA42: C319EB  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
EA45: 3100D4  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
EA48: CD66EA  		call	wbootr
              		
              		; Special conditions for a cold boot
EA4B: CD64EB  		call	cbinit
              	
              		; Jump to CP/M
EA4E: 0E00    		ld	c,default
EA50: C300D4  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
EA53: 3100D4  	wboot:	ld	sp,cbase
              	
              		; Save IOBYTE
EA56: 3A0300  		ld	a,(iobyte)
EA59: F5      		push	af
              	
              		; Warm boot
EA5A: CD66EA  		call	wbootr
              		
              		; Restore IOBYTE
EA5D: F1      		pop	af
EA5E: 320300  		ld	(iobyte),a
              		
EA61: 0E00    		ld	c,default
EA63: C300D4  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
EA66: F3      	wbootr:	di
              		
              		; Zero out BSS
EA67: AF      		xor	a
EA68: 21D9F7  		ld	hl,_TEXT_end
EA6B: 77      		ld	(hl),a
EA6C: 11DAF7  		ld	de,_TEXT_end+1
EA6F: 012608  		ld	bc,0xFFFF-_TEXT_end
EA72: EDB0    		ldir
              	
              		; Send init signals to all devices
EA74: 0600    		ld	b,0
EA76: C5      	wboot0:	push	bc
EA77: 2176EB  		ld	hl,bdevsw
EA7A: 78      		ld	a,b
EA7B: CD2BEB  		call	swindir
EA7E: AF      		xor	a
EA7F: 14      		inc	d
EA80: CC48EB  		call	z,callmj
EA83: C1      		pop	bc
EA84: 04      		inc	b
EA85: 3E14    		ld	a,20
EA87: B8      		cp	b
EA88: 20EC    		jr	nz,wboot0
              	
              		; Call config init
EA8A: CD4DEB  		call	wbinit
              	
              		; Load the CCP
EA8D: CD70EB  		call	resccp
              	
              		
              		; Set up lower memory
EA90: 219CEA  		ld	hl,cpmlow
EA93: 110000  		ld	de,0
EA96: 010800  		ld	bc,8
EA99: EDB0    		ldir
              	
              		; Return
EA9B: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
EA9C: C315EA  	cpmlow:	jp	wbootin	; Call jump table version instead
EA9F: 81      		defb	0x81	; Default IOBYTE
EAA0: 00      		defb	0	; Default drive
EAA1: C302DC  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
EAA4: 0600    	const:	ld	b,0
EAA6: CD1CEB  		call	cdindir
EAA9: 14      		inc	d
EAAA: C0      		ret	nz
EAAB: 3C      		inc	a
EAAC: C348EB  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
EAAF: 0600    	conin:	ld	b,0
EAB1: CD1CEB  		call	cdindir
EAB4: 14      		inc	d
EAB5: C0      		ret	nz
EAB6: 3E02    		ld	a,2
EAB8: C348EB  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
EABB: 0600    	conout:	ld	b,0
EABD: CD1CEB  	chrout:	call	cdindir
EAC0: 14      		inc	d
EAC1: C0      		ret	nz
EAC2: 3E03    		ld	a,3
EAC4: C348EB  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
EAC7: 0606    	list:	ld	b,6
EAC9: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
EACB: 0604    	punch:	ld	b,4
EACD: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
EACF: 0602    	reader:	ld	b,2
EAD1: CD1CEB  		call	cdindir
EAD4: 14      		inc	d
EAD5: 3E1A    		ld	a,0x1A
EAD7: C0      		ret	nz
EAD8: 3E02    		ld	a,2
EADA: C348EB  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
EADD: 3E01    	home:	ld	a,1
EADF: C3FAEA  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
EAE2: 79      	seldsk:	ld	a,c
EAE3: 43      		ld	b,e
EAE4: 2176EB  		ld	hl,bdevsw
EAE7: CD2BEB  		call	swindir
EAEA: 22FBEA  		ld	(callbd+1),hl
EAED: 210000  		ld	hl,0
EAF0: 14      		inc	d
EAF1: C0      		ret	nz
EAF2: 2A49EB  		ld	hl,(callmj+1)
EAF5: 22FEEA  		ld	(callbd+4),hl
EAF8: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
EAFA: 21      	callbd:	defb	0x21
EAFB: 0000    		defw	0
EAFD: C3      		defb	0xC3
EAFE: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
EB00: 3E03    	settrk:	ld	a,3
EB02: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
EB04: 3E04    	setsec:	ld	a,4
EB06: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
EB08: 60      	setdma:	ld	h,b
EB09: 69      		ld	l,c
EB0A: 224BEB  		ld	(biodma),hl
EB0D: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
EB0E: 3E05    	read:	ld	a,5
EB10: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
EB12: 3E06    	write:	ld	a,6
EB14: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
EB16: 3EFF    	prstat:	ld	a,0xFF
EB18: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
EB19: 60      	sectrn:	ld	h,b
EB1A: 69      		ld	l,c
EB1B: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
EB1C: 04      	cdindir:inc	b
EB1D: 3A0300  		ld	a,(iobyte)
EB20: 05      	cdindi0:dec	b
EB21: 2803    		jr	z,cdindi1
EB23: 1F      		rra
EB24: 18FA    		jr	cdindi0
EB26: E603    	cdindi1:and	0x03
EB28: 21B6EB  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
EB2B: 110400  	swindir:ld	de,4
EB2E: B7      		or	a
EB2F: 2804    	swindi0:jr	z,swindi1
EB31: 19      		add	hl,de
EB32: 3D      		dec	a
EB33: 18FA    		jr	swindi0
EB35: 7E      	swindi1:ld	a,(hl)
EB36: 3249EB  		ld	(callmj+1),a
EB39: 23      		inc	hl
EB3A: B6      		or	(hl)
EB3B: C8      		ret	z
EB3C: 7E      		ld	a,(hl)
EB3D: 324AEB  		ld	(callmj+2),a
EB40: 23      		inc	hl
EB41: 7E      		ld	a,(hl)
EB42: 23      		inc	hl
EB43: 66      		ld	h,(hl)
EB44: 6F      		ld	l,a
EB45: 16FF    		ld	d,255
EB47: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
EB48: C3      	callmj: defb	0xC3
EB49: 0000    		defw	0
              	
              	
              	
              	; Variables
EB4B: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
EB4D: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
EB4F: D300    		out	(0x00),a
              		
EB51: 3EC3    		ld	a,0xC3		; Set up IRQ handler
EB53: 323800  		ld	(0x38),a	
EB56: 216AEB  		ld	hl,cfirq
EB59: 223900  		ld	(0x39),hl
              		
EB5C: 3E0E    		ld	a,0x0E		; Enable clock
              		;out	(0x41),a
EB5E: 3E00    		ld	a,0x00
              		;out	(0x40),a
              		
              		
EB60: ED56    		im	1		; Start interrupts
EB62: F3      		di
EB63: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
EB64: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
EB66: 3207D4  		ld	(inbuff+1),a
EB69: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
EB6A: FB      	cfirq:	ei
EB6B: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
EB6D: C321EF  	syshook:jp	ns_sysh
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
EB70: C3FBEE  	resccp:	jp	ns_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
EB73: C300EF  	resgrb:	jp	ns_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EB76: BDEE0000	bdevsw:	defw	nfsdev,	0	; 'A'
EB7A: BDEE0100		defw	nfsdev,	1	; 'B'
EB7E: BAF50000		defw	nfddev,	0	; 'C'
EB82: BAF50100		defw	nfddev,	1	; 'D'
EB86: BDEE0400		defw	nfsdev,	4	; 'E'
EB8A: BDEE0500		defw	nfsdev,	5	; 'F'
EB8E: BDEE0600		defw	nfsdev,	6	; 'G'
EB92: BDEE0700		defw	nfsdev,	7	; 'H'
EB96: BDEE0800		defw	nfsdev,	8	; 'I'
EB9A: BDEE0900		defw	nfsdev,	9	; 'J'
EB9E: BDEE0A00		defw	nfsdev,	10	; 'K'
EBA2: BDEE0B00		defw	nfsdev,	11	; 'L'
EBA6: BDEE0C00		defw	nfsdev,	12	; 'M'
EBAA: BDEE0D00		defw	nfsdev,	13	; 'N'
EBAE: BDEE0E00		defw	nfsdev,	14	; 'O'
EBB2: BDEE0F00		defw	nfsdev,	15	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EBB6: FDF40000	cdevsw:	defw	siodev,	0	; TTY device
EBBA: C6EB0000		defw	vdpdev,	0	; Console device
EBBE: D3F40000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
EBC2: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F859: 00      	tm_curx:defs	1	; Cursor X
F85A: 00      	tm_cury:defs	1	; Cursor Y
F85B: 00      	tm_outc:defs	1	; Output character
F85C: 00      	tm_scro:defs	1	; Scroll width
F85D: 00      	tm_escs:defs	1	; Escape state
F85E: 00      	tm_last:defs	1	; Last character read
F85F: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
F863: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
              	; Driver jump table
EBC6: B7      	vdpdev:	or	a
EBC7: 2839    		jr	z,tm_init
EBC9: 3D      		dec	a
EBCA: 2819    		jr	z,tm_stat
EBCC: 3D      		dec	a
EBCD: CA6BEC  		jp	z,tm_read
EBD0: C3BDEC  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBD3: F5      	tm_otir:push	af
EBD4: 7E      	tm_oti0:ld	a,(hl)
EBD5: ED79    		out	(c),a
EBD7: 23      		inc	hl
EBD8: 10FA    		djnz	tm_oti0
EBDA: F1      		pop	af
EBDB: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBDC: F5      	tm_inir:push	af
EBDD: ED78    	tm_inr0:in	a,(c)
EBDF: 77      		ld	(hl),a
EBE0: 23      		inc	hl
EBE1: 10FA    		djnz	tm_inr0
EBE3: F1      		pop	af
EBE4: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
EBE5: 3A5EF8  	tm_stat:ld	a,(tm_last)
EBE8: FEE4    		cp	0xE4
EBEA: 2843    		jr	z,tm_scri
EBEC: FEE5    		cp	0xE5
EBEE: 2851    		jr	z,tm_sclf
EBF0: 3A5BF8  	tm_sta0:ld	a,(tm_outc)
EBF3: 3C      		inc	a
EBF4: 3EFF    		ld	a,0xFF
EBF6: C0      		ret	nz
EBF7: CDD6ED  		call	tm_getc
EBFA: 325BF8  		ld	(tm_outc),a
EBFD: 3C      		inc	a
EBFE: C8      		ret	z
EBFF: 3EFF    		ld	a,0xFF
EC01: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
EC02: CD73EB  	tm_init:call	resgrb
              	
              		; Set up registers
EC05: CD4BEC  		call	tm_setp
              		
              		; Set TMS pattern generator block to 0
EC08: DBA1    		in	a,(tm_latc)
EC0A: AF      		xor	a
EC0B: D3A1    		out	(tm_latc),a
EC0D: 3E84    		ld	a,0x84
EC0F: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
EC11: 010040  		ld	bc,0x4000
EC14: CD90EE  		call	tm_addr
EC17: 2100D4  		ld	hl,cbase
EC1A: 0EA0    		ld	c,tm_data
EC1C: 3E08    		ld	a,8	; Transfer 8*256 = 2048
EC1E: 0600    	tm_ini0:ld	b,0
EC20: CDD3EB  		call	tm_otir
EC23: 3D      		dec	a
EC24: 20F8    		jr	nz,tm_ini0
              		
              		; Clear the terminal
EC26: CD7DEE  		call	tm_cls
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
EC29: 3EFF    	tm_cloc:ld	a,0xFF
EC2B: 325BF8  		ld	(tm_outc),a
              	
EC2E: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
EC2F: 3A5CF8  	tm_scri:ld	a,(tm_scro)
EC32: B7      		or	a
EC33: FE28    		cp	40
EC35: 2808    		jr	z,tm_scr1
EC37: C604    		add	a,4
EC39: 325CF8  	tm_scr0:ld	(tm_scro),a
EC3C: CD5AEE  		call	tm_usco
EC3F: 18AF    	tm_scr1:jr	tm_sta0
EC41: 3A5CF8  	tm_sclf:ld	a,(tm_scro)
EC44: B7      		or	a
EC45: 28F8    		jr	z,tm_scr1
EC47: D604    		sub	4
EC49: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
EC4B: 2A9BEE  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
EC4E: DBA1    		in	a,(tm_latc)
EC50: 7C      		ld	a,h
EC51: D3A1    		out	(tm_latc),a
EC53: 3E80    		ld	a,0x80
EC55: D3A1    		out	(tm_latc),a
EC57: DBA1    		in	a,(tm_latc)
EC59: 3EF0    		ld	a,0xF0
EC5B: D3A1    		out	(tm_latc),a
EC5D: 3E81    		ld	a,0x81
EC5F: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
EC61: DBA1    		in	a,(tm_latc)
EC63: 7D      		ld	a,l
EC64: D3A1    		out	(tm_latc),a
EC66: 3E82    		ld	a,0x82
EC68: D3A1    		out	(tm_latc),a
EC6A: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
EC6B: 3A59F8  	tm_read:ld	a,(tm_curx)
EC6E: 4F      		ld	c,a
EC6F: 3A5AF8  		ld	a,(tm_cury)
EC72: 57      		ld	d,a
EC73: 210010  		ld	hl,0x1000
EC76: 3E50    		ld	a,80
EC78: CD36EE  		call	tm_chat
EC7B: DBA0    		in	a,(tm_data)	; char is in A
EC7D: 57      		ld	d,a		; char key
EC7E: 5F      		ld	e,a		; blinking char
EC7F: 0601    		ld	b,1
              		
EC81: D5      	tm_rea0:push	de
EC82: CDE5EB  		call	tm_stat
EC85: D1      		pop	de
EC86: 3C      		inc	a
EC87: 200D    		jr	nz,tm_rea1
EC89: 5A      		ld	e,d
EC8A: CDA6EC  		call	tm_rea2
EC8D: 3A5BF8  		ld	a,(tm_outc)
EC90: 47      		ld	b,a
EC91: CD29EC  		call	tm_cloc
EC94: 78      		ld	a,b
EC95: C9      		ret
              		
EC96: CDB4EC  	tm_rea1:call	tm_stal
EC99: 10E6    		djnz	tm_rea0
EC9B: 3E80    		ld	a,0x80
EC9D: AB      		xor	e
EC9E: 5F      		ld	e,a
EC9F: CDA6EC  		call	tm_rea2
ECA2: 06BE    		ld	b,190
ECA4: 18DB    		jr	tm_rea0
              	
              	
ECA6: D5      	tm_rea2:push	de
ECA7: 3A59F8  		ld	a,(tm_curx)
ECAA: 4F      		ld	c,a
ECAB: 3A5AF8  		ld	a,(tm_cury)
ECAE: 57      		ld	d,a
ECAF: CD12EE  		call	tm_putc
ECB2: D1      		pop	de
ECB3: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
ECB4: C5      	tm_stal:push	bc
ECB5: 06FF    		ld	b,255
ECB7: C5      	tm_sta1:push	bc
ECB8: C1      		pop	bc
ECB9: 10FC    		djnz	tm_sta1
ECBB: C1      		pop	bc
ECBC: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
ECBD: 59      	tm_writ:ld	e,c
ECBE: 3A59F8  		ld	a,(tm_curx)
ECC1: 4F      		ld	c,a
ECC2: 3A5AF8  		ld	a,(tm_cury)
ECC5: 57      		ld	d,a
ECC6: CDD2EC  		call	tm_wri0
ECC9: 78      		ld	a,b
ECCA: 325AF8  		ld	(tm_cury),a
ECCD: 79      		ld	a,c
ECCE: 3259F8  		ld	(tm_curx),a
ECD1: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
ECD2: 42      	tm_wri0:ld	b,d		; c = X, b = Y
ECD3: 3A5DF8  		ld	a,(tm_escs)
ECD6: B7      		or	a		; Process escape code
ECD7: C23FED  		jp	nz,tm_esc
ECDA: 3E1F    		ld	a,0x1F
ECDC: BB      		cp	e
ECDD: D211ED  		jp	nc,tm_wri1	; Process control code
ECE0: C5      		push	bc
ECE1: CD12EE  		call	tm_putc		; Write character
ECE4: C1      		pop	bc
              		
              		; Increment character
ECE5: 0C      	tm_ri	inc	c
ECE6: 3E50    		ld	a,80
ECE8: B9      		cp	c
ECE9: C0      		ret	nz
ECEA: AF      		xor	a
ECEB: 4F      		ld	c,a
ECEC: 04      	tm_lf:  inc	b	; Line feed
ECED: 3E18    		ld	a,24
ECEF: B8      		cp	b
ECF0: C0      		ret	nz
ECF1: C5      		push	bc
ECF2: CDB0ED  		call	tm_dsco
ECF5: C1      		pop	bc
ECF6: 05      		dec	b
ECF7: C9      		ret
ECF8: AF      	tm_cr:	xor	a	; Carriage return
ECF9: 4F      		ld	c,a
ECFA: C9      		ret
ECFB: 0D      	tm_bs:	dec	c	; Backspace 
ECFC: F0      		ret	p
ECFD: 0E4F    		ld	c,79
ECFF: 05      		dec	b
ED00: F0      		ret	p
ED01: AF      		xor	a
ED02: 47      		ld	b,a
ED03: 4F      		ld	c,a
ED04: C9      		ret
ED05: AF      	tm_up:	xor	a	; Move up
ED06: B8      		cp	b
ED07: C8      		ret	z
ED08: 05      		dec	b
ED09: C9      		ret
ED0A: CD7DEE  	tm_cshm:call	tm_cls
ED0D: AF      	tm_home:xor	a
ED0E: 47      		ld	b,a
ED0F: 4F      		ld	c,a
ED10: C9      		ret
              	
ED11: 7B      	tm_wri1:ld	a,e
ED12: FE08    		cp	0x08	; '\b' (Cursor left)
ED14: 28E5    		jr	z,tm_bs
ED16: FE12    		cp	0x12	; Cursor right
ED18: 28CB    		jr	z,tm_ri
ED1A: FE0A    		cp	0x0A	; '\n' (Cursor down)
ED1C: 28CE    		jr	z,tm_lf
ED1E: FE0B    		cp	0x0B	; Cursor up
ED20: 28E3    		jr	z,tm_up
ED22: FE0D    		cp	0x0D	; '\r' 
ED24: 28D2    		jr	z,tm_cr
ED26: FE17    		cp	0x17	; Clear end of screen
ED28: 284E    		jr	z,tm_cles
ED2A: FE18    		cp	0x18	; Clear end of line
ED2C: 284C    		jr	z,tm_clea
ED2E: FE1A    		cp	0x1A	; Clear screen, home cursor
ED30: 28D8    		jr	z,tm_cshm
ED32: FE1E    		cp	0x1E	; Home cursor
ED34: 28D7    		jr	z,tm_home
ED36: FE1B    		cp	0x1B	; Escape
ED38: C0      		ret	nz
ED39: 3E01    		ld	a,1
ED3B: 325DF8  		ld	(tm_escs),a
ED3E: C9      		ret
              		
              		; Handle escape sequence
ED3F: 3D      	tm_esc:	dec	a
ED40: 280B    		jr	z,tm_esc0
ED42: 3D      		dec	a
ED43: 281D    		jr	z,tm_esc1
ED45: 3D      		dec	a
ED46: 2825    		jr	z,tm_esc2
ED48: AF      	tm_escd:xor	a	; Escape done
ED49: 325DF8  	tm_escr:ld	(tm_escs),a
ED4C: C9      		ret
ED4D: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
ED4F: BB      		cp	e
ED50: 284B    		jr	z,tm_40c
ED52: 3EFE    		ld	a,0xFE	; Do 80-col
ED54: BB      		cp	e
ED55: 2853    		jr	z,tm_80c
ED57: 3E3D    		ld	a,0x3D	; '='
ED59: BB      		cp	e
ED5A: 20EC    		jr	nz,tm_escd
ED5C: 3A5DF8  	tm_esci:ld	a,(tm_escs)
ED5F: 3C      		inc	a
ED60: 18E7    		jr	tm_escr
ED62: 7B      	tm_esc1:ld	a,e
ED63: 1E20    		ld	e,0x20
ED65: 93      		sub	e
ED66: FE18    		cp	24
ED68: 30DE    		jr	nc,tm_escd
ED6A: 47      		ld	b,a
ED6B: 18EF    		jr	tm_esci
ED6D: 7B      	tm_esc2:ld	a,e
ED6E: 1E20    		ld	e,0x20
ED70: 93      		sub	e
ED71: FE50    		cp	80
ED73: 30D3    		jr	nc,tm_escd
ED75: 4F      		ld	c,a
ED76: 18D0    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
ED78: 0617    	tm_cles:ld	b,23
ED7A: 04      	tm_clea:inc	b
ED7B: 1E00    		ld	e,0
ED7D: C5      		push	bc
ED7E: D5      		push	de
ED7F: 3E50    		ld	a,80
ED81: 210050  		ld	hl,0x5000
ED84: CD36EE  		call	tm_chat
ED87: D1      		pop	de
ED88: C1      		pop	bc
ED89: AF      	tm_cle0:xor	a
ED8A: D3A0    		out	(tm_data),a
ED8C: 0C      		inc	c
ED8D: 3E50    		ld	a,80
ED8F: B9      		cp	c
ED90: 20F7    		jr	nz,tm_cle0
ED92: 14      		inc	d
ED93: AF      		xor	a
ED94: 4F      		ld	c,a
ED95: 7A      		ld	a,d
ED96: B8      		cp	b
ED97: 20F0    		jr	nz,tm_cle0
ED99: D1      		pop	de	; Do not update character
ED9A: C35AEE  		jp	tm_usco
              		
ED9D: E5      	tm_40c:	push	hl
ED9E: 210200  		ld	hl,0x0002
EDA1: 229BEE  	tm_cupd:ld	(tm_mode),hl
EDA4: CD4BEC  		call	tm_setp
EDA7: E1      		pop	hl
EDA8: 189E    		jr	tm_escd
              		
EDAA: E5      	tm_80c:	push	hl
EDAB: 210704  		ld	hl,0x0407
EDAE: 18F1    		jr	tm_cupd
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
EDB0: 212808  	tm_dsco:ld	hl,0x0800+40
EDB3: 110048  		ld	de,0x4800
EDB6: 0618    		ld	b,24
EDB8: CDC3ED  		call	tm_dsc0
EDBB: 215010  		ld	hl,0x1000+80
EDBE: 110050  		ld	de,0x5000
EDC1: 0630    		ld	b,48
EDC3: C5      	tm_dsc0:push	bc
EDC4: D5      		push	de
EDC5: E5      		push	hl
EDC6: CD42EE  		call	tm_vcpy
EDC9: E1      		pop	hl
EDCA: D1      		pop	de
EDCB: 012800  		ld	bc,40
EDCE: 09      		add	hl,bc
EDCF: EB      		ex	de,hl
EDD0: 09      		add	hl,bc
EDD1: EB      		ex	de,hl
EDD2: C1      		pop	bc
EDD3: 10EE    		djnz	tm_dsc0
EDD5: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
EDD6: DB91    	tm_getc:in	a,(tm_keys)
EDD8: E602    		and	2
EDDA: 3D      		dec	a
EDDB: F8      		ret	m
              		
              		; Grab the key
EDDC: DB90    		in	a,(tm_keyd)
EDDE: 325EF8  		ld	(tm_last),a
EDE1: CDE6ED  		call	tm_map
EDE4: 79      		ld	a,c
EDE5: C9      		ret
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
EDE6: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
EDE7: 21FDED  		ld	hl,tm_mapt
EDEA: 7E      	tm_map0:ld	a,(hl)
EDEB: B7      		or	a
EDEC: 2808    		jr	z,tm_map2
EDEE: B9      		cp	c
EDEF: 23      		inc	hl
EDF0: 7E      		ld	a,(hl)
EDF1: 23      		inc	hl
EDF2: 20F6    		jr	nz,tm_map0
EDF4: 4F      		ld	c,a
EDF5: C9      		ret
              		
              		
              		; Filter non-ASCII
EDF6: 79      	tm_map2:ld	a,c
EDF7: E680    		and	0x80	
EDF9: C8      		ret	z
EDFA: 0EFF    		ld	c,0xFF
EDFC: C9      		ret
              		
              	; Map table
EDFD: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
EDFF: E108    		defb	0xE1,0x08	; '<-' -> BS
EE01: EA7F    		defb	0xEA,0x7F	; TV -> DEL
EE03: E00C    		defb	0xE0,0x0C	; '->' -> Right
EE05: E20B    		defb	0xE2,0x0B	; '/\' -> Up
EE07: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
EE09: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
EE0B: E860    		defb	0xE8,0x60	; SYM -> '@'
EE0D: E67C    		defb	0xE6,0x7C	; NO -> '|'
EE0F: E77E    		defb	0xE7,0x7E	; YES -> '~'
EE11: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
EE12: 210050  	tm_putc:ld	hl,0x5000
EE15: 3E50    		ld	a,80
EE17: C5      		push	bc
EE18: D5      		push	de
EE19: CD36EE  		call	tm_chat	; Place it in the 80 col buffer
EE1C: ED59    		out	(c),e
EE1E: D1      		pop	de
EE1F: C1      		pop	bc
EE20: 3A5CF8  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
EE23: 47      		ld	b,a
EE24: 79      		ld	a,c
EE25: 90      		sub	b	; If character is less than scroll...
EE26: 4F      		ld	c,a
EE27: F8      		ret	m
EE28: FE28    		cp	40	; If desired position is 40 or more
EE2A: D0      		ret	nc
EE2B: 210048  		ld	hl,0x4800
EE2E: 3E28    		ld	a,40
EE30: CD36EE  		call	tm_chat	; Place it in the 40 col screen buffer
EE33: ED59    		out	(c),e
EE35: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
EE36: 0600    	tm_chat:ld	b,0
EE38: 09      		add	hl,bc
EE39: 4F      		ld	c,a
EE3A: AF      		xor	a
EE3B: BA      		cp	d
EE3C: 2850    	tm_cha0:jr	z,tm_addh
EE3E: 09      		add	hl,bc
EE3F: 15      		dec	d
EE40: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
EE42: CD8EEE  	tm_vcpy:call	tm_addh
EE45: 0628    		ld	b,40
EE47: 215FF8  		ld	hl,tm_cbuf
EE4A: CDDCEB  		call	tm_inir
EE4D: EB      		ex	de,hl
EE4E: CD8EEE  		call	tm_addh
EE51: 0628    		ld	b,40
EE53: 215FF8  		ld	hl,tm_cbuf
EE56: CDD3EB  		call	tm_otir
EE59: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
EE5A: 210010  	tm_usco:ld	hl,0x1000
EE5D: 110048  		ld	de,0x4800
EE60: 3A5CF8  		ld	a,(tm_scro)
EE63: 0600    		ld	b,0
EE65: 4F      		ld	c,a
EE66: 09      		add	hl,bc
EE67: 0618    		ld	b,24
EE69: C5      	tm_usc0:push	bc
EE6A: D5      		push	de
EE6B: E5      		push	hl
EE6C: CD42EE  		call	tm_vcpy
EE6F: E1      		pop	hl
EE70: D1      		pop	de
EE71: 0E50    		ld	c,80
EE73: 09      		add	hl,bc
EE74: EB      		ex	de,hl
EE75: 0E28    		ld	c,40
EE77: 09      		add	hl,bc
EE78: EB      		ex	de,hl
EE79: C1      		pop	bc
EE7A: 10ED    		djnz	tm_usc0
EE7C: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
EE7D: 010048  	tm_cls:	ld	bc,0x4800
EE80: 110010  		ld	de,0x1000
EE83: CD90EE  		call	tm_addr
EE86: ED71    	tm_cls0:out	(c),0
EE88: 1B      		dec	de
EE89: 7A      		ld	a,d
EE8A: B3      		or	e
EE8B: 20F9    		jr	nz,tm_cls0
EE8D: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; uses: af, bc
EE8E: 44      	tm_addh:ld	b,h		; Does HL instead of BC
EE8F: 4D      		ld	c,l
EE90: DBA1    	tm_addr:in	a,(tm_latc)
EE92: 79      		ld	a,c
EE93: D3A1    		out	(tm_latc),a
EE95: 78      		ld	a,b
EE96: D3A1    		out	(tm_latc),a
EE98: 0EA0    		ld	c,tm_data
EE9A: C9      		ret
              		
              	; Variables
EE9B: 0200    	tm_mode:defw	0x0002
              	#include "dev/nabu_nfs.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   F I L E   S Y S T E M
              	;*
              	;*    Unlike a standard block device, the NFS driver provides
              	;*    a CP/M filesystem by directly intercepting system calls.
              	;*    By doing this, it can access provide access to an external
              	;*    filesystem via NHACP.
              	;*
              	;*    Virtual filesystems are directories labelled "A", "B",
              	;*    "C", etc... on the host system. That are converted to
              	;*    minor numbers 0, 1, 2, etc... when the driver is being
              	;*    added to the block device switch  
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F887: 00000000	ns_buff:defs	48	; Buffer (48b)
F88B: 00...   	
F8B7: 00000000	ns_ptrn:defs	11	; Pattern buffer (11b)
F8BB: 00...   	
F8C2: 00000000	ns_name:defs	11	; Name bufffer (11b)
F8C6: 00...   	
F8CD: 0000    	ns_mask:defs	2	; Ownership mask (2b)
F8CF: 0000    	ns_cfcb:defs	2	; Current FCB (2b)
F8D1: 00      	ns_dore:defs	1	; Do reopen? (1b)
F8D2: 00      	ns_isls:defs	1	; Is listing dir? (1b)
F8D3: 00      	ns_tran:defs	1	; Number of bytes in transfer (1b)
              	.area	_TEXT
              	
0040:         	ns_ayda	equ	0x40		; AY-3-8910 data port
0041:         	ns_atla	equ	0x41		; AY-3-8910 latch port
0080:         	ns_hcca	equ	0x80		; Modem data port
0000:         	ns_nctl	equ	0x00		; NABU control port
              	
0080:         	ns_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D U M M Y   D I S K   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Dummy DPH
EE9D: 00000000	ns_dph:	defw	0,0,0,0
EEA1: 00000000	
EEA5: D9F7    		defw	dircbuf	; DIRBUF
EEA7: ADEE    		defw	ns_dpb	; DPB
EEA9: 0000    		defw	0	; CSV
EEAB: BCEE    		defw	ns_alv	; ALV 
              		
              		
              	; Dummy format
EEAD: 4000    	ns_dpb:	defw	64	; # sectors per track
EEAF: 03      		defb	3	; BSH
EEB0: 07      		defb	7	; BLM
EEB1: 00      		defb	0	; EXM
EEB2: 0100    		defw	1	; DSM
EEB4: 0000    		defw	0	; DRM
EEB6: 00      		defb	0	; AL0
EEB7: 00      		defb	0	; AL1
EEB8: 0000    		defw	0	; Size of directory check vector
EEBA: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              		
              	; Dummy ALV
EEBC: 00      	ns_alv: defb	0
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
EEBD: B7      	nfsdev:	or	a
EEBE: 2807    		jr	z,ns_init
EEC0: 3D      		dec	a
EEC1: 3D      		dec	a
EEC2: 2814    		jr	z,ns_sel
EEC4: 3E01    		ld	a,1
EEC6: C9      		ret
              	
              	; Inits the device
              	; Figures out which devices that the NFS driver "owns"
              	; b = Logical CP/M device #
              	; hl = Call argument
              	;
              	; uses: does not matter
EEC7: 78      	ns_init:ld	a,b
EEC8: CDA1F2  		call	ns_domk
EECB: 2ACDF8  		ld	hl,(ns_mask)
EECE: 7C      		ld	a,h
EECF: B0      		or	b
EED0: 67      		ld	h,a
EED1: 7D      		ld	a,l
EED2: B1      		or	c
EED3: 6F      		ld	l,a
EED4: 22CDF8  		ld	(ns_mask),hl
EED7: C9      		ret
              	
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
EED8: 11BFE9  	ns_sel:	ld	de,dirbuf
EEDB: 21A5EE  		ld	hl,ns_dph+8
EEDE: 010800  		ld	bc,8
EEE1: EDB0    		ldir
EEE3: C37AE9  		jp	goback
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a
EEE6: 3E07    	ns_hini:ld	a,0x07
EEE8: D341    		out	(ns_atla),a	; AY register = 7
EEEA: 3E7F    		ld	a,0x7F
EEEC: D340    		out	(ns_ayda),a	; Configure AY port I/O
              		
EEEE: 3E0E    		ld	a,0x0E
EEF0: D341    		out	(ns_atla),a	; AY register = 14
EEF2: 3EC0    		ld	a,0xC0
EEF4: D340    		out	(ns_ayda),a	; Enable HCCA receive and send
              		
EEF6: 3E0F    		ld	a,0x0F
EEF8: D341    		out	(ns_atla),a	; AY register = 15
EEFA: C9      		ret
              	
              	; Loads the CCP into the CCP space
EEFB: 2128F4  	ns_ccp:	ld	hl,ns_p0
EEFE: 1803    		jr	ns_grb0
              		
              	; Loads the GRB into the CCP space
EF00: 2135F4  	ns_grb:	ld	hl,ns_p1
EF03: 114BF4  	ns_grb0:ld	de,ns_m0na
EF06: 010D00  		ld	bc,13
EF09: EDB0    		ldir			; Copy name to file open
EF0B: CDE6EE  		call	ns_hini		; Go to HCCA mode
EF0E: CDDFF2  		call	ns_open		; Open the file
EF11: 110000  		ld	de,0
EF14: 2100D4  		ld	hl,cbase
EF17: CD01F3  	ns_grb1:call	ns_getb
EF1A: 1C      		inc	e
EF1B: 3E10    		ld	a,16
EF1D: BB      		cp	e
EF1E: 20F7    		jr	nz,ns_grb1
EF20: C9      		ret
              		
              	; CP/M system hook
              	; Used to intercept certain syscalls
              	;
              	; uses: af if not hooked, all otherwise
EF21: 79      	ns_sysh:ld	a,c
EF22: D60F    		sub	15
EF24: D8      		ret	c		; No syscalls lower than 15
EF25: 2841    		jr	z,ns_fopn	; Open file
EF27: 3D      		dec	a
EF28: CAA1EF  		jp	z,ns_fcls	; Close file
EF2B: 3D      		dec	a
EF2C: CA52F0  		jp	z,ns_sfir	; Search for first 
EF2F: 3D      		dec	a
EF30: CA77F0  		jp	z,ns_snxt	; Search for next 
EF33: 3D      		dec	a
EF34: CAC7F0  		jp	z,ns_dele	; Delete file
EF37: 3D      		dec	a
EF38: CA80F1  		jp	z,ns_frea	; File read next record
EF3B: 3D      		dec	a
EF3C: CAACF1  		jp	z,ns_fwri	; File write next record
EF3F: 3D      		dec	a
EF40: CAFFF1  		jp	z,ns_fmak	; Create file
EF43: 3D      		dec	a
EF44: CA33F2  		jp	z,ns_frnm	; Rename file
EF47: D607    		sub	7
EF49: 2817    		jr	z,ns_stmp	; Set file attributes (stump)
EF4B: D603    		sub	3
EF4D: CAC6F1  		jp	z,ns_rrea	; File read random
EF50: 3D      		dec	a
EF51: CAD5F1  		jp	z,ns_rwri	; File write random
EF54: 3D      		dec	a
EF55: CA77F2  		jp	z,ns_size	; Compute file size
EF58: 3D      		dec	a
EF59: CAE4F1  		jp	z,ns_rrec	; Update random access pointer
EF5C: D604    		sub	4
EF5E: CAD5F1  		jp	z,ns_rwri	; FIle write random (we will ignore the zero part)
EF61: C9      		ret
              		
              	; Stump, do nothing if FCB is owned
              	; de = Address to FCB
              	;
              	; uses: does not matter
EF62: CDADF2  	ns_stmp:call	ns_ownr
              	
EF65: C37AE9  		jp	goback
              		
              	; Parses the current FCB, and searches for a file that matches
              	; the pattern.
              	; The point here is to insert the "true" name of the file into
              	; the FCB so it can be accessed later
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
EF68: CDADF2  	ns_fopn:call	ns_ownr
              	
              		; Go find the file
EF6B: D5      		push	de
EF6C: CDF7EF  		call	ns_find
              		
              		; Update status
EF6F: 210000  		ld	hl,0
EF72: 224BDF  		ld	(status),hl
              		
              		; Copy over false CP/M filename to the FCP
EF75: D1      		pop	de
EF76: D5      		push	de
EF77: 13      		inc	de
EF78: 21C2F8  		ld	hl,ns_name
EF7B: 010B00  		ld	bc,11
EF7E: EDB0    		ldir
              		
              		; Set open flag
EF80: 13      		inc	de
EF81: 3EE7    		ld	a,0xE7
EF83: 12      		ld	(de),a
EF84: 13      		inc	de
EF85: AF      		xor	a
EF86: 12      		ld	(de),a
EF87: 13      		inc	de
EF88: 13      		inc	de
              		
              		; Copy over the real filename to the FCB
EF89: 011000  		ld	bc,16
EF8C: 219DF8  		ld	hl,ns_buff+22
EF8F: EDB0    		ldir
              		
              	
              		; Check if current
EF91: D1      		pop	de
EF92: 2ACFF8  		ld	hl,(ns_cfcb)
EF95: ED52    		sbc	hl,de
EF97: 2005    		jr	nz,ns_fop0
              	
              		; Set the reopen flag
EF99: 3E01    		ld	a,1
EF9B: 32D1F8  		ld	(ns_dore),a
              		
EF9E: C37AE9  	ns_fop0:jp	goback
              		
              	; Close the file
              	; Main purpose is to ensure that a close on this device is deferred
              	; Also resets the open flag
              	; de = Address of DPH
              	;
              	; uses: does not matter
EFA1: CDADF2  	ns_fcls:call	ns_ownr
              	
              		; Reset open flag
EFA4: 210D00  		ld	hl,13
EFA7: 19      		add	hl,de
EFA8: 3600    		ld	(hl),0x00
              		
              		; Set flag
EFAA: 210000  		ld	hl,0
EFAD: 224BDF  		ld	(status),hl
              	
EFB0: C37AE9  		jp	goback
              		
              	; Function call to start a list-dir operation
              	; Must be called before a file search
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
EFB3: D5      	ns_slst:push	de		; Save de
EFB4: 214BF4  		ld	hl,ns_m0na
EFB7: EB      		ex	de,hl
EFB8: CD0AF4  		call	ns_sdir 
EFBB: AF      		xor	a
EFBC: 12      		ld	(de),a		; Zero terminate string
EFBD: 3E01    		ld	a,1
EFBF: 32D1F8  		ld	(ns_dore),a	; The existing file will be closed unconditionally
EFC2: 210800  		ld	hl,0x0008	; Set flag type to directory
EFC5: CDE2F2  		call	ns_opef		; Call ns_open, but don't set flag
EFC8: 21FF00  		ld	hl,0x00FF
EFCB: 224BDF  		ld	(status),hl	; Set status
EFCE: C27AE9  		jp	nz,goback	; Error if cannot open file
              		
              		; Send LIST-DIR
EFD1: 217DF4  		ld	hl,ns_m4
EFD4: 0607    		ld	b,7
EFD6: CD79F3  		call	ns_send		; Start list-dir command
EFD9: 2187F8  		ld	hl,ns_buff
EFDC: CD64F3  		call	ns_rece
EFDF: 3A87F8  		ld	a,(ns_buff)	; Check for errors
EFE2: FE81    		cp	0x81
EFE4: C27AE9  		jp	nz,goback
              		
              		; Copy the file pattern to the pattern buffer
EFE7: E1      		pop	hl		; Get the FCB back
EFE8: 23      		inc	hl
EFE9: 11B7F8  		ld	de,ns_ptrn
EFEC: 060B    		ld	b,11
EFEE: 7E      	ns_sls0:ld	a,(hl)
EFEF: E67F    		and	0x7F		; Fix for CP/M stupidness
EFF1: 12      		ld	(de),a
EFF2: 13      		inc	de
EFF3: 23      		inc	hl
EFF4: 10F8    		djnz	ns_sls0
EFF6: C9      		ret
              	
              	; Does a complete find operation
              	; Calls ns_slst, and then falls to ns_find
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de ,hl
EFF7: CDB3EF  	ns_find:call	ns_slst		; Complete find operation
              		
              	; Put the next found file name into the name buffer
              	; If no more names are found, exit with status of 0x00FF
              	; ns_slst must have been run to set up state, no more disk operations
              	; should be been run in the meantime.
              	; enter into ns_lis0 to avoid setting status
              	;
              	; uses: af, bc, de, hl
              	
EFFA: 21FF00  	ns_list:ld	hl,0x00FF
EFFD: 224BDF  		ld	(status),hl	; Set status
              	
              		
F000: 2187F8  	ns_lis0:ld	hl,ns_buff	; Clear out the first 40 bytes of the buffer
F003: AF      		xor	a		; This is to emulate zero termination, due
F004: 77      		ld	(hl),a		; To the fact that NHACP does not zero-terminate
F005: 1188F8  		ld	de,ns_buff+1	; strings coming back from the adapter...
F008: 012800  		ld	bc,40		
F00B: EDB0    		ldir			
              	
              		; Lets read a directory now
F00D: 2184F4  		ld	hl,ns_m5	; Entry point from ns_sfir
F010: 0607    		ld	b,7
F012: CD79F3  		call	ns_send		; Get the next file
F015: 2187F8  		ld	hl,ns_buff
F018: CD64F3  		call	ns_rece	
F01B: 3A87F8  		ld	a,(ns_buff)	; Ensure we got FILE-INFO
F01E: FE86    		cp	0x86
F020: C27AE9  		jp	nz,goback
              		
              		; Ok, time to format a directory entry
F023: 219DF8  		ld	hl,ns_buff+22
F026: 11C2F8  		ld	de,ns_name
F029: 0608    		ld	b,8
              		
              		; Format first part of file
F02B: CD63F0  		call	ns_ffmt
              		
              		; Now we must skip till we either find a '.' or a '\0'
F02E: 7E      	ns_lis1:ld	a,(hl)
F02F: B7      		or	a
F030: 2805    		jr	z,ns_lis2
F032: 23      		inc	hl
F033: FE2E    		cp	'.'
F035: 20F7    		jr	nz,ns_lis1
              		
              		; Now the last part
F037: 0603    	ns_lis2:ld	b,3
F039: CD63F0  		call	ns_ffmt
              		
              		; Back dir entry against pattern
F03C: 11B7F8  		ld	de,ns_ptrn
F03F: 21C2F8  		ld	hl,ns_name
F042: 060B    		ld	b,11
              	
F044: 1A      	ns_lis3:ld	a,(de)
F045: 4E      		ld	c,(hl)
F046: 23      		inc	hl
F047: 13      		inc	de
F048: FE3F    		cp	'?'
F04A: 2803    		jr	z,ns_lis4
F04C: B9      		cp	c
F04D: 20B1    		jr	nz,ns_lis0
F04F: 10F3    	ns_lis4:djnz	ns_lis3
F051: C9      		ret
              		
              	; Search for first file
              	; Opens up a directory, then skips to routines that read the first dir entry
              	; de = Address of FCB
              	;
              	; uses: all
F052: AF      	ns_sfir:xor	a
F053: 32D2F8  		ld	(ns_isls),a	; Clear "isls" flag
F056: CDADF2  		call	ns_ownr
              		
              		; Start the list-dir function
F059: CDB3EF  		call	ns_slst
              		
              		; Set isls flag
F05C: 3E01    		ld	a,1
F05E: 32D2F8  		ld	(ns_isls),a
              		
              		; Move into ns_snxt
F061: 181C    		jr	ns_snx0
              		
              	; Format incoming files into a dir entry
              	; Will copy over characters until a '.' or '\0' is reached
              	; Any remaining characters will be filled out with spaces
              	; b = Number of characters
              	; de = Destination of data
              	; hl = Source of data
              	;
              	; uses: af, b, de, hl
F063: 7E      	ns_ffmt:ld	a,(hl)
F064: CD1DF4  		call	ns_ltou
F067: B7      		or	a
F068: 2804    		jr	z,ns_ffm0
F06A: FE2E    		cp	'.'
F06C: 2003    		jr	nz,ns_ffm1
F06E: 2B      	ns_ffm0:dec	hl
F06F: 3E20    		ld	a,' '		; Turn it into a space
F071: 23      	ns_ffm1:inc	hl
F072: 12      		ld	(de),a
F073: 13      		inc	de
F074: 10ED    		djnz	ns_ffmt
F076: C9      		ret
              		
              	; Search for next file
              	; Takes the open directory and gets the next file
              	;
              	; uses: all
F077: 3AD2F8  	ns_snxt:ld	a,(ns_isls)
F07A: B7      		or	a
F07B: C8      		ret	z
              		
              		; Set up the HCCA
F07C: CDE6EE  		call	ns_hini	
              		
              		; Find the next entry
F07F: CDFAEF  	ns_snx0:call	ns_list
              		
              		; Copy to directory entry
F082: ED5B4BEB		ld	de,(biodma)
F086: 3A47DF  		ld	a,(userno)
F089: 12      		ld	(de),a
F08A: 13      		inc	de
F08B: 21C2F8  		ld	hl,ns_name
F08E: 010B00  		ld	bc,11
F091: EDB0    		ldir
              		
              		; Get file size
F093: CD8FF2  		call	ns_nblk
              		
F096: AF      		xor	a
F097: B8      		cp	b
F098: 0610    		ld	b,16
F09A: 200F    		jr	nz,ns_snx1
F09C: AF      		xor	a
F09D: CB39    		srl	c
F09F: 17      		rla
F0A0: CB39    		srl	c
F0A2: 17      		rla
F0A3: CB39    		srl	c
F0A5: 17      		rla
F0A6: B7      		or	a
F0A7: 41      		ld	b,c
F0A8: 2801    		jr	z,ns_snx1
F0AA: 04      		inc	b
              		
              		
              		; Set the records to 0
F0AB: 48      	ns_snx1:ld	c,b
F0AC: 0604    		ld	b,4
F0AE: AF      		xor	a
F0AF: 12      	ns_snx2:ld	(de),a
F0B0: 13      		inc	de
F0B1: 10FC    		djnz	ns_snx2
              		
              		; Spoof file size 1-16KB
F0B3: 0610    		ld	b,16
F0B5: 79      		ld	a,c
F0B6: 12      	ns_snx3:ld	(de),a
F0B7: 13      		inc	de
F0B8: B7      		or	a
F0B9: 2801    		jr	z,ns_snx4
F0BB: 3D      		dec	a
F0BC: 10F8    	ns_snx4:djnz	ns_snx3
              		
              		; Set status to 0 and return
F0BE: 210000  		ld	hl,0
F0C1: 224BDF  		ld	(status),hl
F0C4: C37AE9  		jp	goback
              		
              	; Delete files based on pattern
              	; Will return error if less than 1 file is found
              	; de = Address to FCB
              	;
              	; uses: all
F0C7: CDADF2  	ns_dele:call	ns_ownr
              	
              		; Set first part of remove message prototype
F0CA: F5      		push	af
F0CB: EB      		ex	de,hl
F0CC: 1193F4  		ld	de,ns_m6na
F0CF: CD0AF4  		call	ns_sdir
F0D2: 3E2F    		ld	a,'/'
F0D4: 12      		ld	(de),a
F0D5: EB      		ex	de,hl
F0D6: F1      		pop	af
              	
              		; Start the list-dir function
F0D7: CDB3EF  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F0DA: CD00F0  	ns_del0:call	ns_lis0
              	
              		; Copy over file name into message
F0DD: 1196F4  		ld	de,ns_m6na+3
F0E0: 219DF8  		ld	hl,ns_buff+22
F0E3: 011000  		ld	bc,16
F0E6: EDB0    		ldir
              		
              		; Send delete message
F0E8: 218BF4  		ld	hl,ns_m6
F0EB: 061B    		ld	b,27
F0ED: CD79F3  		call	ns_send
F0F0: 2187F8  		ld	hl,ns_buff
F0F3: CD64F3  		call	ns_rece
              		
              		; Set status to 0, and get next element
F0F6: 210000  		ld	hl,0
F0F9: 224BDF  		ld	(status),hl
F0FC: 18DC    		jr	ns_del0
              	
              		
              	; Prepare to access a file
              	; Checks the magic number to ensure that the file is in fact open
              	; Also checks ns_dore and ns_cfcb to see if a reopen is required
              	; If so, copy filename from FCB and do NHACP open
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, hl
F0FE: 4F      	ns_aces:ld	c,a
F0FF: 210D00  		ld	hl,13
F102: 19      		add	hl,de
F103: 7E      		ld	a,(hl)
F104: FEE7    		cp	0xE7
F106: 2809    		jr	z,ns_ace0
              		
              		; Return invalid FCB
F108: 210900  		ld	hl,9
F10B: 224BDF  		ld	(status),hl
F10E: C37AE9  		jp	goback
              		
              		; Check to see if it is currently being accessed
F111: 2ACFF8  	ns_ace0:ld	hl,(ns_cfcb)
F114: ED52    		sbc	hl,de
F116: 2005    		jr	nz,ns_ace1
              		
              		; See if a reopen is needed
F118: 3AD1F8  		ld	a,(ns_dore)
F11B: B7      		or	a
F11C: C8      		ret	z
              		
              		; A reopen is needed, do it!
F11D: 21FF00  	ns_ace1:ld	hl,0x00FF
F120: 224BDF  		ld	(status),hl
              		
              		; Set the current FCB to this one
F123: ED53CFF8		ld	(ns_cfcb),de
              		
              		; Clear ns_dore flag
F127: AF      		xor	a
F128: 32D1F8  		ld	(ns_dore),a
              		
              		; Copy over the true filename
F12B: 211000  		ld	hl,16
F12E: 19      		add	hl,de
F12F: D5      		push	de
F130: 114BF4  		ld	de,ns_m0na
F133: 79      		ld	a,c
F134: CD0AF4  		call	ns_sdir
F137: 3E2F    		ld	a,'/'
F139: 12      		ld	(de),a
F13A: 13      		inc	de
F13B: 011000  		ld	bc,16
F13E: EDB0    		ldir
              		
              		; Now open the file
F140: CDDFF2  		call	ns_open
F143: D1      		pop	de
F144: C9      		ret
              		
              	; Takes in a FCB, and returns the current record to access
              	; de = Address to FCB
              	;
              	; Returns record # in bc
              	; uses: af, bc, hl
F145: 210C00  	ns_gcre:ld	hl,0x0C
F148: 19      		add	hl,de
F149: 46      		ld	b,(hl)
F14A: 0E00    		ld	c,0
F14C: CB38    		srl	b
F14E: CB19    		rr	c
F150: 23      		inc	hl
F151: 23      		inc	hl
F152: 7E      		ld	a,(hl)
F153: 07      		rlca
F154: 07      		rlca
F155: 07      		rlca
F156: 07      		rlca
F157: B0      		or	b
F158: 47      		ld	b,a
F159: 212000  		ld	hl,0x20
F15C: 19      		add	hl,de
F15D: 7E      		ld	a,(hl)
F15E: B1      		or	c
F15F: 4F      		ld	c,a
F160: C9      		ret
              		
              	; Takes in a random record, and writes it to the FCB
              	; bc = Record #
              	; de = Address to FCB
              	;
              	; uses: af, bc, hl
F161: 212000  	ns_scre:ld	hl,0x20
F164: 19      		add	hl,de
F165: 79      		ld	a,c
F166: E67F    		and	0x7F
F168: 77      		ld	(hl),a
F169: 210E00  		ld	hl,0x0E
F16C: 19      		add	hl,de
F16D: 78      		ld	a,b
F16E: 0F      		rrca
F16F: 0F      		rrca
F170: 0F      		rrca
F171: 0F      		rrca
F172: E60F    		and	0x0F
F174: 77      		ld	(hl),a
F175: 2B      		dec	hl
F176: 2B      		dec	hl
F177: CB21    		sla	c
F179: CB10    		rl	b
F17B: 78      		ld	a,b
F17C: E60F    		and	0x0F
F17E: 77      		ld	(hl),a
F17F: C9      		ret
              			
              	; Read next record
              	; Reads the next 128 bytes in a file into the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F180: CDADF2  	ns_frea:call	ns_ownr
              	
              		; Set file up to access
F183: CDFEF0  		call	ns_aces
              		
              		; Get the record to read
F186: CD45F1  		call	ns_gcre
              		
              		; Set up and do read
F189: C5      		push	bc
F18A: D5      		push	de
F18B: 50      	ns_fre0:ld	d,b
F18C: 59      		ld	e,c
F18D: 2A4BEB  		ld	hl,(biodma)
F190: CD01F3  		call	ns_getb
              		
              		; Make sure there were no issues
F193: DA7AE9  	ns_fre1:jp	c,goback
              		
              		; Increment and writeback
F196: D1      		pop	de
F197: C1      		pop	bc
F198: 03      		inc	bc
F199: CD61F1  		call	ns_scre
              		
              		; Set return status
F19C: 210000  		ld	hl,0
F19F: 3AD3F8  		ld	a,(ns_tran)
F1A2: B7      		or	a
F1A3: 2001    		jr	nz,ns_fre2
F1A5: 23      		inc	hl
              		
F1A6: 224BDF  	ns_fre2:ld	(status),hl
F1A9: C37AE9  		jp	goback
              		
              	; Write next record
              	; Writes the next 128 bytes into a file from the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F1AC: CDADF2  	ns_fwri:call	ns_ownr
              	
              		; Set file up to access
F1AF: CDFEF0  		call	ns_aces
              		
              		; Get the record to write
F1B2: CD45F1  		call	ns_gcre
              		
              		; Set up and do write
F1B5: C5      		push	bc
F1B6: D5      		push	de
F1B7: 50      	ns_fwr0:ld	d,b
F1B8: 59      		ld	e,c
F1B9: 2A4BEB  		ld	hl,(biodma)
F1BC: CD3CF3  		call	ns_putb
              		
              		; Set amount transfered to 128
F1BF: 3E80    		ld	a,128
F1C1: 32D3F8  		ld	(ns_tran),a
              		
              		; Continue in read
F1C4: 18CD    		jr	ns_fre1
              		
              	; Read record random
              	; Takes the random address and read a sector from it
F1C6: CDADF2  	ns_rrea:call	ns_ownr
              	
              		; Set file up to access
F1C9: CDFEF0  		call	ns_aces
              		
              		; Decode random address
F1CC: CDF7F1  		call	ns_deco
F1CF: 0B      		dec	bc
F1D0: C5      		push	bc
F1D1: D5      		push	de
F1D2: 03      		inc	bc
F1D3: 18B6    		jr	ns_fre0
              		
              	; Write record random
              	; Takes the random address and write a sector to it
              	; de = Address to FCB
              	;
              	; uses: all
F1D5: CDADF2  	ns_rwri:call	ns_ownr
              	
              		; Set file up to access
F1D8: CDFEF0  		call	ns_aces
              		
              		; Decode random address
F1DB: CDF7F1  		call	ns_deco
F1DE: 0B      		dec	bc
F1DF: C5      		push	bc
F1E0: D5      		push	de
F1E1: 03      		inc	bc
F1E2: 18D3    		jr	ns_fwr0
              		
              	; Set random record
              	; de = Address to FCB
              	;
              	; uses: all
F1E4: CDADF2  	ns_rrec:call	ns_ownr
              		
              		; Get current address from FCB
F1E7: CD45F1  		call	ns_gcre
              		
              		; Set FCB random record
F1EA: 212100  		ld	hl,0x21
F1ED: 19      		add	hl,de
F1EE: 71      		ld	(hl),c
F1EF: 23      		inc	hl
F1F0: 70      		ld	(hl),b
F1F1: 23      		inc	hl
F1F2: 3600    		ld	(hl),0
              		
              		; Done
F1F4: C37AE9  		jp	goback
              		
              	; Decodes random address
              	; de = Address to FCB
              	;
              	; Returns block number in bc
              	; uses: af, bc, hl
F1F7: 212100  	ns_deco:ld	hl,0x21
F1FA: 19      		add	hl,de
F1FB: 4E      		ld	c,(hl)
F1FC: 23      		inc	hl
F1FD: 46      		ld	b,(hl)
F1FE: C9      		ret
              		
              	; Make new file
              	; Reboot the system if the file already exists
              	; de = Address to FCB
              	;
              	; uses: all
F1FF: CDADF2  	ns_fmak:call	ns_ownr
              	
              		; We either succeed or die trying
F202: 210000  		ld	hl,0
F205: 224BDF  		ld	(status),hl
              	
              		; Decode filename into open buffer
F208: 214BF4  		ld	hl,ns_m0na
F20B: D5      		push	de
F20C: EB      		ex	de,hl
F20D: 23      		inc	hl
F20E: CDD2F3  		call	ns_form
              		
              		; Set the flag and open
F211: 213000  		ld	hl,0x0030
F214: 2248F4  		ld	(ns_m0fl),hl
F217: CDE2F2  		call	ns_opef
              		
              		; Error? time to reboot!
F21A: C20000  		jp	nz,0
              		
              		; Nope? Activate FCB
F21D: D1      		pop	de
F21E: 210D00  		ld	hl,0x0D
F221: 19      		add	hl,de
F222: 36E7    		ld	(hl),0xE7	; Set magic number
F224: 23      		inc	hl
F225: 23      		inc	hl
F226: 23      		inc	hl
F227: EB      		ex	de,hl
F228: 214EF4  		ld	hl,ns_m0na+3
F22B: 011000  		ld	bc,16
F22E: EDB0    		ldir
              		
              		; All done
F230: C37AE9  		jp	goback
              		
              	; Rename file
              	; Similar to delete, wildcards are allowed
              	; de = Address to FCB
              	;
              	; uses: all
F233: CDADF2  	ns_frnm:call	ns_ownr
              	
              		; Set first part of rename message prototype
F236: F5      		push	af
F237: EB      		ex	de,hl
F238: 11ACF4  		ld	de,ns_m7n0
F23B: CD0AF4  		call	ns_sdir
F23E: 3E2F    		ld	a,'/'
F240: 12      		ld	(de),a
F241: F1      		pop	af
F242: F5      		push	af
F243: E5      		push	hl
F244: 111100  		ld	de,17
F247: 19      		add	hl,de
F248: 11C0F4  		ld	de,ns_m7n1
F24B: CDD2F3  		call	ns_form
F24E: D1      		pop	de
F24F: F1      		pop	af
              		
              	
              		; Start the list-dir function
F250: CDB3EF  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F253: CD00F0  	ns_frn0:call	ns_lis0
              	
              		; Copy over file name into message
F256: 11AFF4  		ld	de,ns_m7n0+3
F259: 219DF8  		ld	hl,ns_buff+22
F25C: 011000  		ld	bc,16
F25F: EDB0    		ldir
              		
              		; Send rename message
F261: 21A6F4  		ld	hl,ns_m7
F264: 062D    		ld	b,45
F266: CD79F3  		call	ns_send
F269: 2187F8  		ld	hl,ns_buff
F26C: CD64F3  		call	ns_rece
              		
              		; Set status to 0, and get next element
F26F: 210000  		ld	hl,0
F272: 224BDF  		ld	(status),hl
F275: 18DC    		jr	ns_frn0
              		
              	; Place size of file into FCB
              	; de = Address to FCB
              	;
              	; uses: all
F277: CDADF2  	ns_size:call	ns_ownr
              	
              		; Find file
F27A: D5      		push	de
F27B: CDF7EF  		call	ns_find
F27E: D1      		pop	de
              		
              		; Get number of blocks
F27F: CD8FF2  		call	ns_nblk
              		
              		; Set in FCB
F282: 212100  		ld	hl,0x21
F285: 19      		add	hl,de
F286: 71      		ld	(hl),c
F287: 23      		inc	hl
F288: 70      		ld	(hl),b
F289: 23      		inc	hl
F28A: 3600    		ld	(hl),0
              	
F28C: C37AE9  		jp	goback	
              		
              	; Use a FILE-INFO block in ns_buff to calculate
              	; the number of blocks in a file
              	;
              	; Returns number of blocks in bc
              	; uses: af, bc, hl
F28F: 219AF8  	ns_nblk:ld	hl,ns_buff+19
F292: 46      		ld	b,(hl)
F293: 2B      		dec	hl
F294: 4E      		ld	c,(hl)
F295: 2B      		dec	hl
F296: 7E      		ld	a,(hl)
F297: CB27    		sla	a
F299: CB11    		rl	c
F29B: CB10    		rl	b
F29D: B7      		or	a
F29E: C8      		ret	z
F29F: 03      		inc	bc
F2A0: C9      		ret
              		
              	; Set a 16 bit mask based on a number from 0-15
              	; a = Bit to set
              	;
              	; Returns bit mask in bc
              	; uses: af, bc
F2A1: 010100  	ns_domk:ld	bc,1
F2A4: B7      		or	a
F2A5: C8      	ns_dom0:ret	z
F2A6: CB21    		sla	c
F2A8: CB10    		rl	b
F2AA: 3D      		dec	a
F2AB: 18F8    		jr	ns_dom0
              		
              	; Check if driver owns device
              	; Bail if it does not
              	; If it does, get the logical NHACP device
              	; de = Address of FCB
              	;
              	; Returns logical device in a
              	; uses: af, hl
F2AD: C5      	ns_ownr:push	bc
F2AE: CDD8F2  		call	ns_getd		; Get FCB device
F2B1: CDA1F2  		call	ns_domk		; Create bitmask
F2B4: 2ACDF8  		ld	hl,(ns_mask)
F2B7: 7C      		ld	a,h
F2B8: A0      		and	b
F2B9: 2002    		jr	nz,ns_own0
F2BB: 7D      		ld	a,l
F2BC: A1      		and	c
F2BD: 2816    	ns_own0:jr	z,ns_exit	; Exit if does not own	
F2BF: 2178EB  		ld	hl,bdevsw+2
F2C2: CDD8F2  		call	ns_getd		; Get FCB device
F2C5: 010400  		ld	bc,4
F2C8: B7      		or	a
F2C9: 2804    	ns_own1:jr	z,ns_own2
F2CB: 09      		add	hl,bc
F2CC: 3D      		dec	a
F2CD: 18FA    		jr	ns_own1
F2CF: CDE6EE  	ns_own2:call	ns_hini		; We are commited at this point, init HCCA
F2D2: 7E      		ld	a,(hl)		; a = Logical NHACP device
F2D3: C1      		pop	bc
F2D4: C9      		ret
              	
              	; Exit, do not return to caller
F2D5: C1      	ns_exit:pop	bc
F2D6: F1      		pop	af		; Throw away caller address
F2D7: C9      		ret
              	
              	; Gets the logical device number from a FCB
              	; de = Address of FCB
              	; 
              	; Logical device returns in a
              	; uses: af
F2D8: 1A      	ns_getd:ld	a,(de)
F2D9: 3D      		dec	a
F2DA: F0      		ret	p
F2DB: 3A48DF  		ld	a,(active)
F2DE: C9      		ret
              	
              	; Open the prepared file
              	; Closes the existing file too
              	; ns_opef can be called to set custom flag
              	;
              	; Flag z cleared on error
              	; uses: af, b, hl
F2DF: 210100  	ns_open:ld	hl,0x0001	; Read/Write flag
F2E2: 2248F4  	ns_opef:ld	(ns_m0fl),hl
F2E5: 215FF4  		ld	hl,ns_m1
F2E8: 0606    		ld	b,6
F2EA: CD79F3  		call	ns_send
F2ED: 2142F4  		ld	hl,ns_m0
F2F0: 061C    		ld	b,28
F2F2: CD79F3  		call	ns_send
F2F5: 2187F8  		ld	hl,ns_buff
F2F8: CD64F3  		call	ns_rece
F2FB: 3A87F8  		ld	a,(ns_buff)
F2FE: FE83    		cp	0x83
F300: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F301: EB      	ns_getb:ex	de,hl
F302: 226BF4  		ld	(ns_m2bn),hl
F305: EB      		ex	de,hl
F306: E5      		push	hl
F307: 2165F4  		ld	hl,ns_m2
F30A: 060C    		ld	b,12
F30C: CD79F3  		call	ns_send
F30F: E1      		pop	hl
F310: D8      		ret	c
F311: CD82F3  		call	ns_hcrd
F314: CD85F3  		call	ns_hcre
F317: D8      		ret	c
F318: FE84    		cp	0x84
F31A: 37      		scf
F31B: 2017    		jr	nz,ns_get2
F31D: CD85F3  		call	ns_hcre
F320: 32D3F8  		ld	(ns_tran),a
F323: 47      		ld	b,a
F324: CD85F3  		call	ns_hcre
F327: 78      		ld	a,b
F328: B7      		or	a
F329: C8      		ret	z
F32A: CD85F3  	ns_get0:call	ns_hcre
F32D: D8      		ret	c
F32E: 77      		ld	(hl),a
F32F: 23      		inc	hl
F330: 10F8    		djnz	ns_get0
F332: B7      		or	a
F333: C9      		ret
F334: CD82F3  	ns_get2:call	ns_hcrd	; Read the error message and exit
F337: CD85F3  		call	ns_hcre
F33A: 37      		scf
F33B: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F33C: EB      	ns_putb:ex	de,hl
F33D: 2277F4  		ld	(ns_m3bn),hl
F340: EB      		ex	de,hl
F341: E5      		push	hl
F342: 2171F4  		ld	hl,ns_m3
F345: 060C    		ld	b,12
F347: CD79F3  		call	ns_send		; Send message precursor
F34A: E1      		pop	hl
F34B: D8      		ret	c
F34C: 0680    		ld	b,128
F34E: 7E      	ns_put0:ld	a,(hl)		; Send the block
F34F: CDAEF3  		call	ns_hcwr
F352: D8      		ret	c
F353: 23      		inc	hl
F354: 10F8    		djnz	ns_put0
F356: 2187F8  		ld	hl,ns_buff
F359: CD64F3  		call	ns_rece
F35C: 3A87F8  		ld	a,(ns_buff)
F35F: FE81    		cp	0x81
F361: C8      		ret	z
F362: 37      		scf
F363: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F364: CD85F3  	ns_rece:call	ns_hcre
F367: D8      		ret	c		; Existing error
F368: 47      		ld	b,a
F369: CD85F3  		call	ns_hcre
F36C: D8      		ret	c		; Existing error
F36D: 37      		scf
F36E: C0      		ret	nz		; Message too big!
F36F: CD85F3  	ns_rec0:call	ns_hcre
F372: D8      		ret	c		; Error!
F373: 77      		ld	(hl),a
F374: 23      		inc	hl
F375: 10F8    		djnz	ns_rec0
F377: B7      		or	a
F378: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F379: 7E      	ns_send:ld	a,(hl)
F37A: 23      		inc	hl
F37B: CDAEF3  		call	ns_hcwr
F37E: D8      		ret	c		; Error!
F37F: 10F8    		djnz	ns_send
F381: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns return in a
              	; Carry flag set on error
              	; Uses: af
F382: CD85F3  	ns_hcrd:call	ns_hcre
F385: D5      	ns_hcre:push	de
F386: 3E09    		ld	a,0x09
F388: D300    		out	(ns_nctl),a	; Turn on recv light
F38A: 11FFFF  		ld	de,0xFFFF
F38D: DB40    	ns_hcr0:in	a,(ns_ayda)
F38F: CB47    		bit	0,a
F391: 28FA    		jr	z,ns_hcr0	; Await an interrupt
F393: CB4F    		bit	1,a
F395: 280B    		jr	z,ns_hcr1
F397: 1B      		dec	de
F398: 7B      		ld	a,e
F399: B2      		or	d
F39A: 20F1    		jr	nz,ns_hcr0
F39C: 3E01    	ns_hcer:ld	a,0x01
F39E: D300    		out	(ns_nctl),a	; Turn off recv light
F3A0: 37      		scf
F3A1: C9      		ret			; Timed out waiting
F3A2: 3E01    	ns_hcr1:ld	a,0x01
F3A4: D300    		out	(ns_nctl),a	; Turn off recv light
F3A6: DB80    		in	a,(ns_hcca)
F3A8: D1      		pop	de
F3A9: B7      		or	a
F3AA: C9      		ret
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F3AB: CDAEF3  	ns_hcwd:call	ns_hcwr
F3AE: D5      	ns_hcwr:push	de
F3AF: F5      		push	af
F3B0: 11FFFF  		ld	de,0xFFFF
F3B3: 3E21    		ld	a,0x21
F3B5: D300    		out	(ns_nctl),a	; Turn on send light
F3B7: DB40    	ns_hcw0:in	a,(ns_ayda)
F3B9: CB47    		bit	0,a
F3BB: 28FA    		jr	z,ns_hcw0	; Await an interrupt
F3BD: CB4F    		bit	1,a
F3BF: 2007    		jr	nz,ns_hcw1
F3C1: 1B      		dec	de
F3C2: 7B      		ld	a,e
F3C3: B2      		or	d
F3C4: 20F1    		jr	nz,ns_hcw0
F3C6: 18D4    		jr	ns_hcer		; Timed out waiting
F3C8: 3E01    	ns_hcw1:ld	a,0x01
F3CA: D300    		out	(ns_nctl),a	; Turn off send light
F3CC: F1      		pop	af
F3CD: D380    		out	(ns_hcca),a
F3CF: D1      		pop	de
F3D0: B7      		or	a
F3D1: C9      		ret
              		
              	; Takes a FCB-style name and formats it to standard notation
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	; hl = Source FCB file name
              	;
              	; uses: all
F3D2: CD0AF4  	ns_form:call	ns_sdir
F3D5: 3E2F    		ld	a,'/'
F3D7: CD1AF4  		call	ns_wchd
F3DA: 0608    		ld	b,8		; Look at all 8 possible name chars
F3DC: 7E      	ns_for1:ld	a,(hl)
F3DD: E67F    		and	0x7F
F3DF: CD1DF4  		call	ns_ltou
F3E2: FE21    		cp	0x21
F3E4: 3806    		jr	c,ns_for2
F3E6: CD1AF4  		call	ns_wchd
F3E9: 23      		inc	hl
F3EA: 10F0    		djnz	ns_for1
F3EC: 3E2E    	ns_for2:ld	a,0x2E		; '.'
F3EE: CD1AF4  		call	ns_wchd
F3F1: 48      		ld	c,b
F3F2: 0600    		ld	b,0
F3F4: 09      		add	hl,bc		; Fast forward to extenstion
F3F5: 0603    		ld	b,3		; Copy over extension
F3F7: 7E      	ns_for3:ld	a,(hl)
F3F8: E67F    		and	0x7F
F3FA: CD1DF4  		call	ns_ltou
F3FD: FE21    		cp	0x21
F3FF: 3806    		jr	c,ns_for4
F401: CD1AF4  		call	ns_wchd
F404: 23      		inc	hl
F405: 10F0    		djnz	ns_for3
F407: AF      	ns_for4:xor	a		; Zero terminate
F408: 12      		ld	(de),a
F409: C9      		ret
              		
              	; Part of ns_form, but sometimes is called independently
              	; Sets the directory to access files from
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	;
              	; uses: af, de
F40A: C641    	ns_sdir:add	a,'A'
F40C: CD1AF4  		call	ns_wchd
F40F: 3A47DF  		ld	a,(userno)
F412: C630    		add	a,'0'
F414: FE3A    		cp	':'
F416: 3802    		jr	c,ns_wchd
F418: C607    		add	a,7
              		
              		; Fall to ns_wchd
              		
              	; Writes a byte to (de), then increments de
              	; a = Character to write
              	; de = Destination for character
              	;
              	; Returns de=de+1
              	; uses: af, de
F41A: 12      	ns_wchd:ld	(de),a
F41B: 13      		inc	de
F41C: C9      		ret
              	
              	; Converts lowercase to uppercase
              	; a = Character to convert
              	;
              	; Returns uppercase in A
              	; uses: af
F41D: E67F    	ns_ltou:and	0x7F
F41F: FE61    		cp	0x61		; 'a'
F421: D8      		ret	c
F422: FE7B    		cp	0x7B		; '{'
F424: D0      		ret	nc
F425: D620    		sub	0x20
F427: C9      		ret
              		
              	; Path to CP/M image
              	; Total length: 13 bytes
F428: 41302F43	ns_p0:	defb	'A0/CPM22.SYS',0
F42C: 504D3232	
F430: 2E535953	
F434: 00      	
              	
              	; Path to GRB image
              	; Total length: 13 bytes
F435: 41302F46	ns_p1:	defb	'A0/FONT.GRB',0,0
F439: 4F4E542E	
F43D: 47524200	
F441: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 28 bytes
F442: 8F00    	ns_m0:	defb	0x8F,0x00
F444: 1800    		defw	24		; Message length
F446: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F447: 80      		defb	ns_fild		; Default file descriptor
F448: 0000    	ns_m0fl:defw	0x0000		; Read/Write flags
F44A: 13      		defb	19		; File name length
F44B: 58585858	ns_m0na:defs	19,'X'		; File name field
F44F: 58...   	
F45E: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F45F: 8F00    	ns_m1:	defb	0x8F,0x00
F461: 0200    		defw	2		; Message length
F463: 05      		defb	0x05		; Cmd: FILE-CLOSE
F464: 80      		defb	ns_fild		; Default file descriptor
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F465: 8F00    	ns_m2:	defb	0x8F,0x00
F467: 0800    		defw	8		; Message length
F469: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F46A: 80      		defb	ns_fild		; Default file descritor
F46B: 00000000	ns_m2bn:defw	0x00,0x00	; Block number
F46F: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F471: 8F00    	ns_m3:	defb	0x8F,0x00
F473: 8800    		defw	136		; Message length
F475: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F476: 80      		defb	ns_fild		; Default file descritor
F477: 00000000	ns_m3bn:defw	0x00,0x00	; Block number
F47B: 8000    		defw	128		; Block length
              		
              	; Message prototype to start a list-dir
              	; Total length: 7 bytes
F47D: 8F00    	ns_m4:	defb	0x8F,0x00
F47F: 0300    		defw	3		; Message length
F481: 0E      		defb	0x0E		; Cmd: LIST-DIR
F482: 80      		defb	ns_fild		; Default file descriptor
F483: 00      		defb	0x00		; Null string
              		
              	; Message prototype to get the next dir entry
              	; Total length: 7 bytes
F484: 8F00    	ns_m5:	defb	0x8F,0x00
F486: 0300    		defw	3		; Message length
F488: 0F      		defb	0x0F		; Cmd: GET-DIR-ENTRY
F489: 80      		defb	ns_fild		; Default file descriptor
F48A: 10      		defb	16		; Max length of file
              		
              	; Message prototype to remove a file
              	; Total length: 27 bytes
F48B: 8F00    	ns_m6:	defb	0x8F,0x00
F48D: 1700    		defw	23		; Message length
F48F: 10      		defb	0x10		; Cmd: REMOVE
F490: 0000    		defw	0x0000		; Remove regular file
F492: 13      		defb	19		; File name length
F493: 58585858	ns_m6na:defs	19,'X'		; File name field
F497: 58...   	
              	
              	; Message prototype to rename a file
              	; Total length: 45 bytes
F4A6: 8F00    	ns_m7:	defb	0x8F,0x00
F4A8: 2900    		defw	41		; Message length
F4AA: 11      		defb	0x11		; Cmd: RENAME
F4AB: 13      		defb	19		; File name #1 length
F4AC: 58585858	ns_m7n0:defs	19,'X'		; File name #1 field
F4B0: 58...   	
F4BF: 13      		defb	19		; File name #2 length
F4C0: 58585858	ns_m7n1:defs	19,'X'		; File name #2 field
F4C4: 58...   	
              	#include "dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F4D3: B7      	prtdev:	or	a
F4D4: 2808    		jr	z,pr_init
F4D6: 3D      		dec	a
F4D7: 2806    		jr	z,pr_stat
F4D9: 3D      		dec	a
F4DA: 2805    		jr	z,pr_read
F4DC: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F4DE: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F4DF: AF      	pr_stat:xor	a
F4E0: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F4E1: AF      	pr_read:xor	a
F4E2: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F4E3: 3E0F    	pr_writ:ld	a,0x0F
F4E5: D341    		out	(pr_atla),a	; AY register = 15
              		
F4E7: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F4E9: E610    		and	0x10
F4EB: 20FA    		jr	nz,pr_wri0
              		
F4ED: 79      		ld	a,c
F4EE: D3B0    		out	(pr_prnt),a	; Write data
              		
F4F0: 3E05    		ld	a,0x05		; Strobe
F4F2: D300    		out	(pr_ctrl),a
              		
F4F4: 0620    		ld	b,32		
F4F6: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
F4F8: 3E01    		ld	a,0x01		; Strobe off
F4FA: D300    		out	(pr_ctrl),a
              		
F4FC: C9      		ret
              		
              	#include "dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
F4FD: B7      	siodev:	or	a
F4FE: 2808    		jr	z,so_init
F500: 3D      		dec	a
F501: 2833    		jr	z,so_stat
F503: 3D      		dec	a
F504: 2841    		jr	z,so_read
F506: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
F508: 116DF5  	so_init:ld	de,so_atab
F50B: 45      		ld	b,l
F50C: 04      		inc	b		; Slot 1,2,3,...
F50D: 19      		add	hl,de 		; Get address table entry
F50E: 0ECF    		ld	c,0xCF		; First slot
              		
F510: ED78    	so_ini0:in	a,(c)
F512: FE08    		cp	0x08
F514: 2807    		jr	z,so_ini2
              		
F516: 3E10    	so_ini1:ld	a,0x10
F518: 81      		add	c
F519: F0      		ret	p		; Can't find, failure
F51A: 4F      		ld	c,a
F51B: 18F3    		jr	so_ini0
              		
F51D: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
F51F: 79      		ld	a,c
F520: D60F    		sub	0x0F
F522: 4F      		ld	c,a
F523: 71      		ld	(hl),c
F524: 1171F5  		ld	de,so_conf
F527: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
F529: 1A      	so_ini3:ld	a,(de)
F52A: 13      		inc	de
F52B: 86      		add	a,(hl)
F52C: 4F      		ld	c,a
F52D: 1A      		ld	a,(de)
F52E: 13      		inc	de
F52F: ED79    		out	(c),a
F531: E5      		push	hl
F532: E1      		pop	hl	; Small delay
F533: 10F4    		djnz	so_ini3
F535: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F536: 116DF5  	so_stat:ld	de,so_atab
F539: 19      		add	hl,de
F53A: AF      		xor	a
F53B: BE      		cp	(hl)
F53C: C8      		ret	z	; No device, return 0
F53D: 4E      		ld	c,(hl)
F53E: 0C      		inc	c
F53F: ED78    	so_sta0:in	a,(c)	; Check status register
F541: E602    		and	0x02
F543: C8      		ret	z
F544: 3EFF    		ld	a,0xFF
F546: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
F547: 116DF5  	so_read:ld	de,so_atab
F54A: 19      		add	hl,de
F54B: AF      		xor	a
F54C: BE      		cp	(hl)
F54D: C8      		ret	z	; No device, return 0
F54E: 4E      		ld	c,(hl)
F54F: 0C      		inc	c
F550: CD3FF5  	so_rea0:call	so_sta0	; Wait for a character
F553: 28FB    		jr	z,so_rea0
F555: 0D      		dec	c
F556: ED78    		in	a,(c)
F558: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
F559: 41      	so_writ:ld	b,c
F55A: 116DF5  		ld	de,so_atab
F55D: 19      		add	hl,de
F55E: AF      		xor	a
F55F: BE      		cp	(hl)
F560: C8      		ret	z	; No device, return 0
F561: 4E      		ld	c,(hl)
F562: 0C      		inc	c
F563: ED78    	so_wri0:in	a,(c)
F565: E601    		and	0x01
F567: 28FA    		jr	z,so_wri0
F569: 0D      		dec	c
F56A: ED41    		out	(c),b
F56C: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
F56D: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
F571: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
F573: 0412    		defb	0x04,0x12
F575: 0400    		defb	0x04,0x00
F577: 0777    		defb	0x07,0x77	; Counter 2 setup
F579: 0512    		defb	0x05,0x12
F57B: 0500    		defb	0x05,0x00
              		
F57D: 0100    		defb	0x01,0x00	; 8251 setup
F57F: 0100    		defb	0x01,0x00
F581: 0100    		defb	0x01,0x00
F583: 0100    		defb	0x01,0x00
F585: 0140    		defb	0x01,0x40
F587: 014E    		defb	0x01,0x4E
F589: 0137    		defb	0x01,0x37
              	#include "dev/nabu_fdc.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F8D4: 00      	nf_io:	defs	1	; FDC address
F8D5: 00      	nf_r2ks:defs	1	; Temp storaged used in nf_r2k
              	
F8D6: 00      	nf_curd:defs	1	; Currently selected disk
F8D7: 00      	nf_subs:defs	1	; Current subsector
F8D8: 00      	nf_sync:defs	1	; Set if disk needs to be rehomed
F8D9: 00      	nf_inco:defs	1	; Set if sector is in core already
F8DA: 00      	nf_dirt:defs	1	; Set if cache is dirty
              	
F8DB: 00000000	nf_asva:defs	26	; Misc CP/M buffer
F8DF: 00...   	
F8F5: 00000000	nf_asvb:defs	26
F8F9: 00...   	
F90F: 00000000	nf_csva:defs	15
F913: 00...   	
F91E: 00000000	nf_csvb:defs	15
F922: 00...   	
              	
F92D: 00000000	nf_cach:defs	1024	; Sector cache
F931: 00...   	
              	.area	_TEXT
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F58B:         	nf_dpha:
F58B: 00000000		defw	0,0,0,0
F58F: 00000000	
F593: D9F7    		defw	dircbuf	; DIRBUF
F595: ABF5    		defw	nf_dpb	; DPB
F597: 0FF9    		defw	nf_csva	; CSV
F599: DBF8    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F59B:         	nf_dphb:
F59B: 00000000		defw	0,0,0,0
F59F: 00000000	
F5A3: D9F7    		defw	dircbuf	; DIRBUF
F5A5: ABF5    		defw	nf_dpb	; DPB
F5A7: 1EF9    		defw	nf_csvb	; CSV
F5A9: F5F8    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F5AB:         	nf_dpb:
F5AB: 2800    		defw	40	; # sectors per track
F5AD: 03      		defb	3	; BSH
F5AE: 07      		defb	7	; BLM
F5AF: 00      		defb	0	; EXM
F5B0: B800    		defw	184	; DSM
F5B2: 3F00    		defw	63	; DRM
F5B4: C0      		defb	0xC0	; AL0
F5B5: 00      		defb	0	; AL1
F5B6: 1000    		defw	16	; Size of directory check vector
F5B8: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F5BA: B7      	nfddev:	or	a
F5BB: 2815    		jr	z,nf_init
F5BD: 3D      		dec	a
F5BE: 283D    		jr	z,nf_home
F5C0: 3D      		dec	a
F5C1: 2852    		jr	z,nf_sel
F5C3: 3D      		dec	a
F5C4: CA69F6  		jp	z,nf_strk
F5C7: 3D      		dec	a
F5C8: CA9FF6  		jp	z,nf_ssec
F5CB: 3D      		dec	a
F5CC: CAF0F6  		jp	z,nf_read
F5CF: C3F8F6  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F5D2: AF      	nf_init:xor	a
F5D3: 32D4F8  		ld	(nf_io),a
              	
              		; Look for the FDC
F5D6: 0ECF    		ld	c,0xCF
F5D8: ED78    	nf_ini1:in	a,(c)
F5DA: FE10    		cp	0x10
F5DC: 2808    		jr	z,nf_ini2
F5DE: 0C      		inc	c
F5DF: C8      		ret	z	; Should not be possible!
F5E0: 3E0F    		ld	a,0x0F
F5E2: 81      		add	a,c
F5E3: 4F      		ld	c,a
F5E4: 18F2    		jr	nf_ini1
              		
              		; Get command register
F5E6: 79      	nf_ini2:ld	a,c
F5E7: D60F    		sub	15
F5E9: 4F      		ld	c,a
F5EA: 32D4F8  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F5ED: CB25    		sla	l
F5EF: 3E02    		ld	a,2
F5F1: 85      		add	l
F5F2: 32D6F8  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F5F5: 3ED0    		ld	a,0xD0
F5F7: ED79    		out	(c),a
              		
              		; Re-home drive
F5F9: CDFDF5  		call	nf_home
              		
              		; De-select drive
              		
F5FC: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F5FD: CD10F7  	nf_home:call	nf_wdef
F600: CDB7F7  		call	nf_dvsc
              	
F603: 3AD4F8  		ld	a,(nf_io)
F606: 4F      		ld	c,a
              		
              		; Restore to track 0
F607: 3E09    		ld	a,0x09
F609: ED79    		out	(c),a 
F60B: CDCEF7  		call	nf_busy
              		
              		; Reset sync flag
F60E: AF      		xor	a
F60F: 32D8F8  		ld	(nf_sync),a
              		
              		; De-select drive
F612: C3BCF7  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F615: 3AD4F8  	nf_sel:	ld	a,(nf_io)
F618: B7      		or	a
F619: FA20F6  		jp	m,nf_seld
              		
              		; no FDC card
F61C: 210000  		ld	hl,0
F61F: C9      		ret
              	
F620: 7D      	nf_seld:ld	a,l		; Select a disk
F621: 0602    		ld	b,2
F623: B7      		or	a
F624: 2809    		jr	z,nf_sel0
F626: 3D      		dec	a
F627: 0604    		ld	b,4
F629: 2804    		jr	z,nf_sel0
F62B: 210000  		ld	hl,0
F62E: C9      		ret
              	
              		; Move control of drive buffers
F62F: CD10F7  	nf_sel0:call	nf_wdef		; Write back if needed
F632: 3EFF    		ld	a,0xFF
F634: 32D8F8  		ld	(nf_sync),a	; Set sync flag
F637: 78      		ld	a,b
F638: 32D6F8  		ld	(nf_curd),a	; Set current drive
F63B: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F63C: 16FF    	nf_selc	ld	d,255
F63E: CDB7F7  		call	nf_dvsc
F641: 3AD4F8  		ld	a,(nf_io)
F644: 4F      		ld	c,a
F645: 3ED0    		ld	a,0xD0
F647: ED79    		out	(c),a		; Force FDC interrupt
F649: CDD4F7  	nf_sel1:call	nf_stal
F64C: ED78    		in	a,(c)
F64E: E602    		and	0x02
F650: 2009    		jr	nz,nf_sel2
F652: 15      		dec	d
F653: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F655: 210000  		ld	hl,0
F658: C3BCF7  		jp	nf_udsl
              		
              		
              		; Output DPH
F65B: CDBCF7  	nf_sel2:call	nf_udsl
F65E: 218BF5  		ld	hl,nf_dpha
F661: 3E02    		ld	a,2
F663: BB      		cp	e
F664: C8      		ret	z
F665: 219BF5  		ld	hl,nf_dphb
F668: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F669: 51      	nf_strk:ld	d,c		; Track = d
F66A: 3AD4F8  		ld	a,(nf_io)
F66D: 4F      		ld	c,a
F66E: 3AD8F8  		ld	a,(nf_sync)
F671: B7      		or	a
F672: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F674: CDB7F7  		call	nf_dvsc
              		
              		; Restore to track 0
F677: 3E09    		ld	a,0x09
F679: ED79    		out	(c),a 
F67B: CDCEF7  		call	nf_busy
              		
              		; Reset sync flag
F67E: AF      		xor	a
F67F: 32D8F8  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F682: 59      	nf_str0:ld	e,c
F683: 0C      		inc	c
F684: ED78    		in	a,(c)
F686: BA      		cp	d
F687: CABCF7  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F68A: CD10F7  		call	nf_wdef
              	
              		; Seek to track
F68D: CDB7F7  		call	nf_dvsc
F690: 0C      		inc	c
F691: 0C      		inc	c
F692: ED51    		out	(c),d
F694: 3E19    		ld	a,0x19
F696: 4B      		ld	c,e
F697: ED79    		out	(c),a 
F699: CDCEF7  		call	nf_busy	
              		
F69C: C3BCF7  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F69F: 79      	nf_ssec:ld	a,c
F6A0: E607    		and	0x07
F6A2: 32D7F8  		ld	(nf_subs),a
F6A5: 79      		ld	a,c
              		
              		; Compute physical sector
F6A6: CB3F    		srl	a
F6A8: CB3F    		srl	a
F6AA: CB3F    		srl	a
F6AC: 3C      		inc	a
F6AD: 47      		ld	b,a	; b = Physical sector
F6AE: 3AD4F8  		ld	a,(nf_io)
F6B1: 3C      		inc	a
F6B2: 3C      		inc	a
F6B3: 4F      		ld	c,a
F6B4: ED78    		in	a,(c)
F6B6: B8      		cp	b
F6B7: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F6B8: CD10F7  		call	nf_wdef
F6BB: ED41    		out	(c),b
F6BD: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F6BE: 3AD9F8  	nf_rdwr:ld	a,(nf_inco)
F6C1: B7      		or	a
F6C2: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F6C4: CDB7F7  		call	nf_dvsc
F6C7: 3AD4F8  		ld	a,(nf_io)
F6CA: 4F      		ld	c,a
F6CB: 212DF9  		ld	hl,nf_cach
F6CE: CD9BF7  		call	nf_rphy
F6D1: 47      		ld	b,a
F6D2: CDBCF7  		call	nf_udsl
F6D5: 78      		ld	a,b
              		
              		; Error checking
F6D6: B7      		or	a
F6D7: 3E01    		ld	a,1
F6D9: C0      		ret	nz
F6DA: 32D9F8  		ld	(nf_inco),a
              		
              		; DMA subsector
F6DD: 2A4BEB  	nf_rdw0:ld	hl,(biodma)
F6E0: EB      		ex	de,hl
              	
F6E1: 3AD7F8  		ld	a,(nf_subs)
F6E4: 21ADF8  		ld	hl,nf_cach-128
F6E7: 018000  		ld	bc,128
F6EA: 3C      		inc	a
F6EB: 09      	nf_rdw1:add	hl,bc
F6EC: 3D      		dec	a
F6ED: 20FC    		jr	nz,nf_rdw1
F6EF: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F6F0: CDBEF6  	nf_read:call	nf_rdwr
F6F3: B7      		or	a
F6F4: C0      		ret	nz
F6F5: EDB0    		ldir
F6F7: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F6F8: C5      	nf_writ:push	bc
F6F9: CDBEF6  		call	nf_rdwr
F6FC: B7      		or	a
F6FD: C1      		pop	bc
F6FE: C0      		ret	nz
F6FF: 3E01    		ld	a,1
F701: 32DAF8  		ld	(nf_dirt),a
F704: 79      		ld	a,c
F705: 018000  		ld	bc,128
F708: EB      		ex	de,hl
F709: EDB0    		ldir
F70B: FE01    		cp	1
F70D: 3E00    		ld	a,0
F70F: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F710: 3ADAF8  	nf_wdef:ld	a,(nf_dirt)
F713: B7      		or	a
F714: 2837    		jr	z,nf_wde4
              	
F716: C5      		push	bc
F717: D5      		push	de
F718: E5      		push	hl
              		
              		; Write physical sector
F719: CDB7F7  		call	nf_dvsc
F71C: 3AD4F8  		ld	a,(nf_io)
F71F: 4F      		ld	c,a
F720: C603    		add	a,3
F722: 57      		ld	d,a
F723: 59      		ld	e,c
F724: 3EA8    		ld	a,0xA8		; Write command
F726: ED79    		out	(c),a
F728: 212DF9  		ld	hl,nf_cach
F72B: ED78    	nf_wde1:in	a,(c)
F72D: 1F      		rra	
F72E: 3009    		jr	nc,nf_wde2
F730: 1F      		rra
F731: 30F8    		jr	nc,nf_wde1
F733: 4A      		ld	c,d
F734: EDA3    		outi 
F736: 4B      		ld	c,e
F737: 18F2    		jr	nf_wde1
F739: ED78    	nf_wde2:in	a,(c)
              		
              		; Deselect drive
F73B: 47      		ld	b,a
F73C: CDBCF7  		call	nf_udsl
F73F: 78      		ld	a,b
              		
F740: E1      		pop	hl
F741: D1      		pop	de
F742: C1      		pop	bc
              		
              		; Error checking
F743: E6FC    		and	0xFC
F745: 2803    		jr	z,nf_wde3
              		
F747: 3E01    		ld	a,1
F749: C9      		ret
              		
              		; Cache is no longer dirty
F74A: 32DAF8  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F74D: AF      	nf_wde4:xor	a
F74E: 32D9F8  		ld	(nf_inco),a
              		
F751: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F752: 3E02    	nf_grb:	ld	a,2
F754: 32D5F8  		ld	(nf_r2ks),a
F757: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F759: 3E04    	nf_ccp:	ld	a,4
F75B: 32D5F8  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F75E: 3E02    	nf_r2k: ld	a,nf_rdsk
F760: CDBDF7  		call	nf_dvsl
              		
              		; Restore to track 0
F763: 3AD4F8  		ld	a,(nf_io)
F766: 4F      		ld	c,a
F767: 3E09    		ld	a,0x09
F769: ED79    		out	(c),a 
F76B: CDCEF7  		call	nf_busy
              		
              		; Set sector # to 4
F76E: 3AD5F8  		ld	a,(nf_r2ks)
F771: 0C      		inc	c
F772: 0C      		inc	c
F773: ED79    		out	(c),a
F775: C5      		push	bc
F776: 0D      		dec	c
F777: 0D      		dec	c
              		
              		; Read into memory
F778: 2100D4  		ld	hl,cbase
F77B: CD9BF7  		call	nf_rphy
F77E: C1      		pop	bc
F77F: B7      		or	a
F780: 2805    		jr	z,nf_r2k0
F782: CDD2F5  		call	nf_init		; Error!
F785: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F787: ED78    	nf_r2k0:in	a,(c)
F789: 3C      		inc	a
F78A: ED79    		out	(c),a
F78C: 0D      		dec	c
F78D: 0D      		dec	c
              		
              		; Read into memory again
F78E: CD9BF7  		call	nf_rphy
F791: B7      		or	a
F792: C8      		ret	z
F793: CDD2F5  		call	nf_init		; Error!
F796: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F798: C3BCF7  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F79B: 51      	nf_rphy:ld	d,c
F79C: 59      		ld	e,c
F79D: 14      		inc	d
F79E: 14      		inc	d
F79F: 14      		inc	d
              		
              		; Read command
F7A0: 3E88    		ld	a,0x88
F7A2: ED79    		out	(c),a
F7A4: ED78    	nf_rph1:in	a,(c)
F7A6: 1F      		rra	
F7A7: 3009    		jr	nc,nf_rph2
F7A9: 1F      		rra
F7AA: 30F8    		jr	nc,nf_rph1
F7AC: 4A      		ld	c,d
F7AD: EDA2    		ini
F7AF: 4B      		ld	c,e
F7B0: 18F2    		jr	nf_rph1
F7B2: ED78    	nf_rph2:in	a,(c)
F7B4: E6FC    		and	0xFC
F7B6: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F7B7: 3AD6F8  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F7BA: 1801    		jr	nf_dvsl
F7BC: AF      	nf_udsl:xor	a		; Unselects a drive
F7BD: C5      	nf_dvsl:push	bc
F7BE: 47      		ld	b,a
F7BF: 3AD4F8  		ld	a,(nf_io)
F7C2: C60F    		add	a,0x0F
F7C4: 4F      		ld	c,a
F7C5: ED41    		out	(c),b
F7C7: 06FF    		ld	b,0xFF
F7C9: CDD4F7  		call	nf_stal
F7CC: C1      		pop	bc
F7CD: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F7CE: ED78    	nf_busy:in	a,(c)
F7D0: 1F      		rra
F7D1: 38FB    		jr	c,nf_busy
F7D3: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F7D4: C5      	nf_stal:push	bc
F7D5: C1      		pop	bc
F7D6: 10FC    		djnz	nf_stal
F7D8: C9      		ret


; +++ segments +++

#CODE _TEXT    = $D400 = 54272,  size = $23D9 =  9177
#DATA _BSS     = $F7D9 = 63449,  size = $0554 =  1364

; +++ global symbols +++

_BSS       = $F7D9 = 63449  _BSS    config\config_nfs_hybrid.asm:44 (unused)
_BSS_end   = $FD2D = 64813  _BSS    config\config_nfs_hybrid.asm:44 (unused)
_BSS_size  = $0554 =  1364  _BSS    config\config_nfs_hybrid.asm:44 (unused)
_TEXT      = $D400 = 54272  _TEXT   config\config_nfs_hybrid.asm:43 (unused)
_TEXT_end  = $F7D9 = 63449  _TEXT   config\config_nfs_hybrid.asm:43
_TEXT_size = $23D9 =  9177  _TEXT   config\config_nfs_hybrid.asm:43 (unused)
active     = $DF48 = 57160  _TEXT   CPM22.asm:1709
adda2hl    = $E16A = 57706  _TEXT   CPM22.asm:2138
addhl      = $D659 = 54873  _TEXT   CPM22.asm:432
alloc0     = $E9D0 = 59856  _TEXT   CPM22.asm:3686
alloc1     = $E9D2 = 59858  _TEXT   CPM22.asm:3687
alocvect   = $E9C5 = 59845  _TEXT   CPM22.asm:3676
auto       = $E9E4 = 59876  _TEXT   CPM22.asm:3701
autoflag   = $E9E6 = 59878  _TEXT   CPM22.asm:3703
autosel    = $E857 = 59479  _TEXT   CPM22.asm:3416
autosl1    = $E87B = 59515  _TEXT   CPM22.asm:3432
backup     = $DDAA = 56746  _TEXT   CPM22.asm:1469
backup1    = $DDB2 = 56754  _TEXT   CPM22.asm:1472
badload    = $DB87 = 56199  _TEXT   CPM22.asm:1201
badsctr    = $DC0C = 56332  _TEXT   CPM22.asm:1252
badsec     = $DCD0 = 56528  _TEXT   CPM22.asm:1324
badsel     = $DCDB = 56539  _TEXT   CPM22.asm:1325
badslct    = $DC0E = 56334  _TEXT   CPM22.asm:1253
batch      = $DBB8 = 56248  _TEXT   CPM22.asm:1224
batchfcb   = $DBB9 = 56249  _TEXT   CPM22.asm:1225
bdevsw     = $EB76 = 60278  _TEXT   config\config_nfs_hybrid.asm:162
bdosdrv    = $DCCC = 56524  _TEXT   CPM22.asm:1323
bdoserr    = $DCC0 = 56512  _TEXT   CPM22.asm:1322
bigdisk    = $E9E3 = 59875  _TEXT   CPM22.asm:3700
biodma     = $EB4B = 60235  _TEXT   bios.asm:316
bitmap     = $E2A9 = 58025  _TEXT   CPM22.asm:2431
bitmap1    = $E2B7 = 58039  _TEXT   CPM22.asm:2446
bitmap2    = $E2D8 = 58072  _TEXT   CPM22.asm:2467
bitmap3    = $E2FC = 58108  _TEXT   CPM22.asm:2484
blkmask    = $E9CA = 59850  _TEXT   CPM22.asm:3682
blknmbr    = $E9EB = 59883  _TEXT   CPM22.asm:3707
blkshft    = $E9C9 = 59849  _TEXT   CPM22.asm:3681
boot       = $EA45 = 59973  _TEXT   bios.asm:42
bs         = $0008 =     8  _TEXT   CPM22.asm:31
callbd     = $EAFA = 60154  _TEXT   bios.asm:215
callmj     = $EB48 = 60232  _TEXT   bios.asm:310
cbase      = $D400 = 54272  _TEXT   CPM22.asm:44
cbinit     = $EB64 = 60260  _TEXT   config\config_nfs_hybrid.asm:93
ccpstack   = $DBB8 = 56248  _TEXT   CPM22.asm:1220
cdevsw     = $EBB6 = 60342  _TEXT   config\config_nfs_hybrid.asm:201
cdindi0    = $EB20 = 60192  _TEXT   bios.asm:275
cdindi1    = $EB26 = 60198  _TEXT   bios.asm:279
cdindir    = $EB1C = 60188  _TEXT   bios.asm:273
cdrive     = $DBFC = 56316  _TEXT   CPM22.asm:1231
cfirq      = $EB6A = 60266  _TEXT   config\config_nfs_hybrid.asm:109
charbuf    = $DF14 = 57108  _TEXT   CPM22.asm:1698
check      = $D630 = 54832  _TEXT   CPM22.asm:398
checkdir   = $E1A4 = 57764  _TEXT   CPM22.asm:2211
checksum   = $E0FD = 57597  _TEXT   CPM22.asm:2050
chgdrv     = $DBFD = 56317  _TEXT   CPM22.asm:1232
chgnam1    = $E42D = 58413  _TEXT   CPM22.asm:2723
chgnames   = $E41C = 58396  _TEXT   CPM22.asm:2715
chkblk     = $E08A = 57482  _TEXT   CPM22.asm:1957
chkchar    = $DD1A = 56602  _TEXT   CPM22.asm:1366
chkcon     = $D5C2 = 54722  _TEXT   CPM22.asm:323
chkdir1    = $E1CA = 57802  _TEXT   CPM22.asm:2231
chknmbr    = $E192 = 57746  _TEXT   CPM22.asm:2184
chkrofl    = $E14A = 57674  _TEXT   CPM22.asm:2114
chksum1    = $E103 = 57603  _TEXT   CPM22.asm:2053
chkvect    = $E9C3 = 59843  _TEXT   CPM22.asm:3675
chkwprt    = $E15A = 57690  _TEXT   CPM22.asm:2125
chrout     = $EABD = 60093  _TEXT   bios.asm:156
ckbitmap   = $E23B = 57915  _TEXT   CPM22.asm:2325
ckbmap1    = $E25C = 57948  _TEXT   CPM22.asm:2360
ckcon1     = $DD48 = 56648  _TEXT   CPM22.asm:1396
ckcon2     = $DD4B = 56651  _TEXT   CPM22.asm:1397
ckconsol   = $DD29 = 56617  _TEXT   CPM22.asm:1382
ckfilpos   = $E1FB = 57851  _TEXT   CPM22.asm:2274
ckrof1     = $E14D = 57677  _TEXT   CPM22.asm:2115
cksumtbl   = $E9F2 = 59890  _TEXT   CPM22.asm:3715
clearbuf   = $D758 = 55128  _TEXT   CPM22.asm:598
clears2    = $E178 = 57720  _TEXT   CPM22.asm:2155
close      = $D4DA = 54490  _TEXT   CPM22.asm:138
closefil   = $E8AB = 59563  _TEXT   CPM22.asm:3463
closeflg   = $E9D8 = 59864  _TEXT   CPM22.asm:3692
closeit    = $E4A8 = 58536  _TEXT   CPM22.asm:2809
closeit1   = $E4D3 = 58579  _TEXT   CPM22.asm:2829
closeit2   = $E4E1 = 58593  _TEXT   CPM22.asm:2837
closeit3   = $E4E7 = 58599  _TEXT   CPM22.asm:2841
closeit4   = $E4EE = 58606  _TEXT   CPM22.asm:2844
closeit5   = $E503 = 58627  _TEXT   CPM22.asm:2857
closeit6   = $E51D = 58653  _TEXT   CPM22.asm:2875
closeit7   = $E525 = 58661  _TEXT   CPM22.asm:2878
cmdadr     = $D7CE = 55246  _TEXT   CPM22.asm:680
cmdtbl     = $D710 = 55056  _TEXT   CPM22.asm:552
cmmnd1     = $D782 = 55170  _TEXT   CPM22.asm:633
cmmnd2     = $D7A5 = 55205  _TEXT   CPM22.asm:652
cntrlc     = $0003 =     3  _TEXT   CPM22.asm:29
cntrle     = $0005 =     5  _TEXT   CPM22.asm:30
cntrlp     = $0010 =    16  _TEXT   CPM22.asm:36
cntrlr     = $0012 =    18  _TEXT   CPM22.asm:37
cntrls     = $0013 =    19  _TEXT   CPM22.asm:38
cntrlu     = $0015 =    21  _TEXT   CPM22.asm:39
cntrlx     = $0018 =    24  _TEXT   CPM22.asm:40
cntrlz     = $001A =    26  _TEXT   CPM22.asm:41
comblk     = $E07D = 57469  _TEXT   CPM22.asm:1948
comfile    = $DB90 = 56208  _TEXT   CPM22.asm:1202
command    = $D75C = 55132  _TEXT   CPM22.asm:608
comprand   = $E7AB = 59307  _TEXT   CPM22.asm:3282
conin      = $EAAF = 60079  _TEXT   bios.asm:143
conout     = $EABB = 60091  _TEXT   bios.asm:155
const      = $EAA4 = 60068  _TEXT   bios.asm:131
convert    = $D660 = 54880  _TEXT   CPM22.asm:446
convfst    = $D65E = 54878  _TEXT   CPM22.asm:440
convrt1    = $D689 = 54921  _TEXT   CPM22.asm:469
convrt2    = $D690 = 54928  _TEXT   CPM22.asm:472
convrt3    = $D696 = 54934  _TEXT   CPM22.asm:479
convrt4    = $D698 = 54936  _TEXT   CPM22.asm:480
convrt5    = $D6A9 = 54953  _TEXT   CPM22.asm:487
convrt6    = $D6AB = 54955  _TEXT   CPM22.asm:489
convrt7    = $D6AF = 54959  _TEXT   CPM22.asm:491
convrt8    = $D6B9 = 54969  _TEXT   CPM22.asm:495
counter    = $E9DE = 59870  _TEXT   CPM22.asm:3698
cpmlow     = $EA9C = 60060  _TEXT   bios.asm:120
cr         = $000D =    13  _TEXT   CPM22.asm:35
create     = $D509 = 54537  _TEXT   CPM22.asm:188
crlf       = $D498 = 54424  _TEXT   CPM22.asm:80
curpos     = $DF12 = 57106  _TEXT   CPM22.asm:1696
de2hl      = $DF55 = 57173  _TEXT   CPM22.asm:1727
de2hl1     = $DF56 = 57174  _TEXT   CPM22.asm:1728
decode     = $D805 = 55301  _TEXT   CPM22.asm:707
decode1    = $D815 = 55317  _TEXT   CPM22.asm:713
decode2    = $D837 = 55351  _TEXT   CPM22.asm:733 (unused)
decode3    = $D840 = 55360  _TEXT   CPM22.asm:738
decode4    = $D847 = 55367  _TEXT   CPM22.asm:742 (unused)
default    = $0000 =     0          config\config_nfs_hybrid.asm:19
defdma     = $E1E0 = 57824  _TEXT   CPM22.asm:2249
del        = $007F =   127  _TEXT   CPM22.asm:42
delbatch   = $D5DD = 54749  _TEXT   CPM22.asm:348
delete     = $D4EF = 54511  _TEXT   CPM22.asm:159
delfile    = $E8DD = 59613  _TEXT   CPM22.asm:3494
dirbuf     = $E9BF = 59839  _TEXT   CPM22.asm:3673
dirc1      = $DEE6 = 57062  _TEXT   CPM22.asm:1654
dircbuf    = $F7D9 = 63449  _BSS    config\config_nfs_hybrid.asm:45
dircio     = $DEDA = 57050  _TEXT   CPM22.asm:1648
dirdma     = $E1E6 = 57830  _TEXT   CPM22.asm:2254
dirdma1    = $E1E9 = 57833  _TEXT   CPM22.asm:2259
direct     = $D884 = 55428  _TEXT   CPM22.asm:804
direct1    = $D895 = 55445  _TEXT   CPM22.asm:811
direct2    = $D89C = 55452  _TEXT   CPM22.asm:815
direct3    = $D8A5 = 55461  _TEXT   CPM22.asm:819
direct4    = $D8D9 = 55513  _TEXT   CPM22.asm:846
direct5    = $D8E1 = 55521  _TEXT   CPM22.asm:849
direct6    = $D8E6 = 55526  _TEXT   CPM22.asm:851
direct7    = $D91B = 55579  _TEXT   CPM22.asm:875
direct8    = $D91C = 55580  _TEXT   CPM22.asm:876
direct9    = $D928 = 55592  _TEXT   CPM22.asm:880
dirread    = $E1DA = 57818  _TEXT   CPM22.asm:2244
dirsize    = $E9CE = 59854  _TEXT   CPM22.asm:3685
dirwrite   = $E1CC = 57804  _TEXT   CPM22.asm:2236
diskpb     = $E9C1 = 59841  _TEXT   CPM22.asm:3674
diskro     = $DCE7 = 56551  _TEXT   CPM22.asm:1327
dmaset     = $D5D8 = 54744  _TEXT   CPM22.asm:343
doread     = $DFB8 = 57272  _TEXT   CPM22.asm:1798
dowrite    = $DFBE = 57278  _TEXT   CPM22.asm:1803
drect63    = $D904 = 55556  _TEXT   CPM22.asm:865
drect65    = $D906 = 55558  _TEXT   CPM22.asm:866
dselect    = $D861 = 55393  _TEXT   CPM22.asm:774
dsksel     = $D4BD = 54461  _TEXT   CPM22.asm:112
dsksize    = $E9CC = 59852  _TEXT   CPM22.asm:3684
emptyfcb   = $E9B2 = 59826  _TEXT   CPM22.asm:3660
entry      = $0005 =     5  _TEXT   CPM22.asm:22
entry1     = $D4C3 = 54467  _TEXT   CPM22.asm:119
entry2     = $D4F4 = 54516  _TEXT   CPM22.asm:165
eparam     = $E9DC = 59868  _TEXT   CPM22.asm:3696
erafil1    = $E3AA = 58282  _TEXT   CPM22.asm:2601
erafile    = $E3A2 = 58274  _TEXT   CPM22.asm:2598
erase      = $D92C = 55596  _TEXT   CPM22.asm:889
erase1     = $D94F = 55631  _TEXT   CPM22.asm:904
error1     = $DC9F = 56479  _TEXT   CPM22.asm:1305
error2     = $DCAB = 56491  _TEXT   CPM22.asm:1311
error3     = $DCB1 = 56497  _TEXT   CPM22.asm:1314
error4     = $DCB7 = 56503  _TEXT   CPM22.asm:1317
error5     = $DCBA = 56506  _TEXT   CPM22.asm:1319
exists     = $DA8F = 55951  _TEXT   CPM22.asm:1066
extblk     = $E064 = 57444  _TEXT   CPM22.asm:1929
extblk1    = $E077 = 57463  _TEXT   CPM22.asm:1939
extmask    = $E9CB = 59851  _TEXT   CPM22.asm:3683
extract    = $D858 = 55384  _TEXT   CPM22.asm:764
fbase      = $DC06 = 56326  _TEXT   CPM22.asm:1247
fbase1     = $DC14 = 56340  _TEXT   CPM22.asm:1260
fcb        = $DBDA = 56282  _TEXT   CPM22.asm:1229
fcb2hl     = $E164 = 57700  _TEXT   CPM22.asm:2133
fcbpos     = $E9EF = 59887  _TEXT   CPM22.asm:3709
fcbset     = $E403 = 58371  _TEXT   CPM22.asm:2693
fcreate    = $E8F2 = 59634  _TEXT   CPM22.asm:3511
ff         = $000C =    12  _TEXT   CPM22.asm:34 (unused)
filepos    = $E9F0 = 59888  _TEXT   CPM22.asm:3710
filero     = $DCE2 = 56546  _TEXT   CPM22.asm:1326
filesize   = $E953 = 59731  _TEXT   CPM22.asm:3585
findfst    = $E31E = 58142  _TEXT   CPM22.asm:2518
findnxt    = $E333 = 58163  _TEXT   CPM22.asm:2531
fndnxt1    = $E350 = 58192  _TEXT   CPM22.asm:2544
fndnxt2    = $E359 = 58201  _TEXT   CPM22.asm:2548
fndnxt3    = $E379 = 58233  _TEXT   CPM22.asm:2564
fndnxt4    = $E382 = 58242  _TEXT   CPM22.asm:2573
fndnxt5    = $E389 = 58249  _TEXT   CPM22.asm:2578
fndnxt6    = $E39A = 58266  _TEXT   CPM22.asm:2591
fndspa1    = $E3C6 = 58310  _TEXT   CPM22.asm:2631
fndspa2    = $E3D7 = 58327  _TEXT   CPM22.asm:2654
fndspa3    = $E3F2 = 58354  _TEXT   CPM22.asm:2675
fndspa4    = $E3FA = 58362  _TEXT   CPM22.asm:2685
fndspace   = $E3C4 = 58308  _TEXT   CPM22.asm:2625
fndstat    = $E9DA = 59866  _TEXT   CPM22.asm:3694
functns    = $DC4D = 56397  _TEXT   CPM22.asm:1296
getaloc    = $E917 = 59671  _TEXT   CPM22.asm:3539
getback    = $DB93 = 56211  _TEXT   CPM22.asm:1208
getback1   = $DB96 = 56214  _TEXT   CPM22.asm:1209
getblk1    = $E04B = 57419  _TEXT   CPM22.asm:1907
getblk2    = $E059 = 57433  _TEXT   CPM22.asm:1916
getblk3    = $E062 = 57442  _TEXT   CPM22.asm:1921
getblock   = $E044 = 57412  _TEXT   CPM22.asm:1904
getchar    = $DD01 = 56577  _TEXT   CPM22.asm:1344
getcon     = $DECE = 57038  _TEXT   CPM22.asm:1636
getcrnt    = $E90A = 59658  _TEXT   CPM22.asm:3528
getcsts    = $DF04 = 57092  _TEXT   CPM22.asm:1681
getdsk     = $D5D0 = 54736  _TEXT   CPM22.asm:334
getecho    = $DD0C = 56588  _TEXT   CPM22.asm:1353
getempty   = $E52A = 58666  _TEXT   CPM22.asm:2885
getext     = $D6C0 = 54976  _TEXT   CPM22.asm:502
getext1    = $D6C8 = 54984  _TEXT   CPM22.asm:506
getext2    = $D6D9 = 55001  _TEXT   CPM22.asm:513
getext3    = $D6DB = 55003  _TEXT   CPM22.asm:515
getext4    = $D6DF = 55007  _TEXT   CPM22.asm:517
getext5    = $D6E9 = 55017  _TEXT   CPM22.asm:521
getext6    = $D6F0 = 55024  _TEXT   CPM22.asm:525
getext7    = $D6F2 = 55026  _TEXT   CPM22.asm:526
getext8    = $D701 = 55041  _TEXT   CPM22.asm:538
getext9    = $D709 = 55049  _TEXT   CPM22.asm:543
getfst     = $E8B1 = 59569  _TEXT   CPM22.asm:3470
getfst1    = $E8C8 = 59592  _TEXT   CPM22.asm:3481
getinp     = $D539 = 54585  _TEXT   CPM22.asm:239
getinp1    = $D596 = 54678  _TEXT   CPM22.asm:295
getinp2    = $D5A7 = 54695  _TEXT   CPM22.asm:304
getinp3    = $D5AB = 54699  _TEXT   CPM22.asm:306
getinp4    = $D5BA = 54714  _TEXT   CPM22.asm:315
getiob     = $DEF3 = 57075  _TEXT   CPM22.asm:1662
getlog     = $E904 = 59652  _TEXT   CPM22.asm:3523
getmt1     = $E54C = 58700  _TEXT   CPM22.asm:2901
getnext    = $E560 = 58720  _TEXT   CPM22.asm:2915
getnxt     = $E8CE = 59598  _TEXT   CPM22.asm:3486
getparm    = $E92C = 59692  _TEXT   CPM22.asm:3556
getprm1    = $E92F = 59695  _TEXT   CPM22.asm:3557
getrdr     = $DED4 = 57044  _TEXT   CPM22.asm:1641
getrov     = $E91D = 59677  _TEXT   CPM22.asm:3544
gets2      = $E16F = 57711  _TEXT   CPM22.asm:2147
getsetuc   = $D515 = 54549  _TEXT   CPM22.asm:204
getuser    = $E933 = 59699  _TEXT   CPM22.asm:3564
getusr     = $D513 = 54547  _TEXT   CPM22.asm:199
getver     = $E884 = 59524  _TEXT   CPM22.asm:3440
getwprt    = $E124 = 57636  _TEXT   CPM22.asm:2087
goback     = $E97A = 59770  _TEXT   CPM22.asm:3620
goback1    = $E997 = 59799  _TEXT   CPM22.asm:3632
gtnext1    = $E589 = 58761  _TEXT   CPM22.asm:2935
gtnext2    = $E594 = 58772  _TEXT   CPM22.asm:2944
gtnext3    = $E5B2 = 58802  _TEXT   CPM22.asm:2955
gtnext4    = $E5B5 = 58805  _TEXT   CPM22.asm:2956
gtnext5    = $E5BC = 58812  _TEXT   CPM22.asm:2963
halt       = $D7DC = 55260  _TEXT   CPM22.asm:685
hl2de      = $D84F = 55375  _TEXT   CPM22.asm:754
home       = $EADD = 60125  _TEXT   bios.asm:189
homedrv    = $DFA7 = 57255  _TEXT   CPM22.asm:1784
inbuff     = $D406 = 54278  _TEXT   CPM22.asm:51
inpoint    = $D488 = 54408  _TEXT   CPM22.asm:60
iobyte     = $0003 =     3  _TEXT   CPM22.asm:20
ioerr1     = $DF0B = 57099  _TEXT   CPM22.asm:1691
ioret      = $DFC1 = 57281  _TEXT   CPM22.asm:1804
jumphl     = $DF50 = 57168  _TEXT   CPM22.asm:1719
lf         = $000A =    10  _TEXT   CPM22.asm:33
list       = $EAC7 = 60103  _TEXT   bios.asm:166
logical    = $E090 = 57488  _TEXT   CPM22.asm:1968
logicl1    = $E096 = 57494  _TEXT   CPM22.asm:1970
login      = $E9B5 = 59829  _TEXT   CPM22.asm:3662
logindrv   = $E827 = 59431  _TEXT   CPM22.asm:3384
logoff     = $E959 = 59737  _TEXT   CPM22.asm:3594
logsect    = $E9ED = 59885  _TEXT   CPM22.asm:3708
mem        = $0035 =    53          config\config_nfs_hybrid.asm:38
mode       = $E9DB = 59867  _TEXT   CPM22.asm:3695
morefls    = $E185 = 57733  _TEXT   CPM22.asm:2171
move3      = $D84D = 55373  _TEXT   CPM22.asm:750
movecd     = $D529 = 54569  _TEXT   CPM22.asm:221
movedir    = $E1EF = 57839  _TEXT   CPM22.asm:2266
moveword   = $E49A = 58522  _TEXT   CPM22.asm:2792
namepnt    = $D48A = 54410  _TEXT   CPM22.asm:61
nbytes     = $DBFE = 56318  _TEXT   CPM22.asm:1233
newline    = $DDB7 = 56759  _TEXT   CPM22.asm:1478
newln1     = $DDBF = 56767  _TEXT   CPM22.asm:1481
nf_asva    = $F8DB = 63707  _BSS    nabu_fdc.asm:34
nf_asvb    = $F8F5 = 63733  _BSS    nabu_fdc.asm:35
nf_busy    = $F7CE = 63438  _TEXT   nabu_fdc.asm:524
nf_cach    = $F92D = 63789  _BSS    nabu_fdc.asm:39
nf_ccp     = $F759 = 63321  _TEXT   nabu_fdc.asm:422 (unused)
nf_csva    = $F90F = 63759  _BSS    nabu_fdc.asm:36
nf_csvb    = $F91E = 63774  _BSS    nabu_fdc.asm:37
nf_curd    = $F8D6 = 63702  _BSS    nabu_fdc.asm:28
nf_dirt    = $F8DA = 63706  _BSS    nabu_fdc.asm:32
nf_dpb     = $F5AB = 62891  _TEXT   nabu_fdc.asm:70
nf_dpha    = $F58B = 62859  _TEXT   nabu_fdc.asm:54
nf_dphb    = $F59B = 62875  _TEXT   nabu_fdc.asm:62
nf_dvsc    = $F7B7 = 63415  _TEXT   nabu_fdc.asm:505
nf_dvsl    = $F7BD = 63421  _TEXT   nabu_fdc.asm:508
nf_grb     = $F752 = 63314  _TEXT   nabu_fdc.asm:417 (unused)
nf_home    = $F5FD = 62973  _TEXT   nabu_fdc.asm:144
nf_inco    = $F8D9 = 63705  _BSS    nabu_fdc.asm:31
nf_ini1    = $F5D8 = 62936  _TEXT   nabu_fdc.asm:108
nf_ini2    = $F5E6 = 62950  _TEXT   nabu_fdc.asm:119
nf_init    = $F5D2 = 62930  _TEXT   nabu_fdc.asm:103
nf_io      = $F8D4 = 63700  _BSS    nabu_fdc.asm:25
nf_r2k     = $F75E = 63326  _TEXT   nabu_fdc.asm:427
nf_r2k0    = $F787 = 63367  _TEXT   nabu_fdc.asm:456
nf_r2ks    = $F8D5 = 63701  _BSS    nabu_fdc.asm:26
nf_rdsk    = $0002 =     2  _TEXT   nabu_fdc.asm:42
nf_rdw0    = $F6DD = 63197  _TEXT   nabu_fdc.asm:319
nf_rdw1    = $F6EB = 63211  _TEXT   nabu_fdc.asm:326
nf_rdwr    = $F6BE = 63166  _TEXT   nabu_fdc.asm:298
nf_read    = $F6F0 = 63216  _TEXT   nabu_fdc.asm:332
nf_rph1    = $F7A4 = 63396  _TEXT   nabu_fdc.asm:488
nf_rph2    = $F7B2 = 63410  _TEXT   nabu_fdc.asm:497
nf_rphy    = $F79B = 63387  _TEXT   nabu_fdc.asm:479
nf_sel     = $F615 = 62997  _TEXT   nabu_fdc.asm:167
nf_sel0    = $F62F = 63023  _TEXT   nabu_fdc.asm:186
nf_sel1    = $F649 = 63049  _TEXT   nabu_fdc.asm:200
nf_sel2    = $F65B = 63067  _TEXT   nabu_fdc.asm:213
nf_selc    = $F63C = 63036  _TEXT   nabu_fdc.asm:194 (unused)
nf_seld    = $F620 = 63008  _TEXT   nabu_fdc.asm:175
nf_ssec    = $F69F = 63135  _TEXT   nabu_fdc.asm:271
nf_stal    = $F7D4 = 63444  _TEXT   nabu_fdc.asm:532
nf_str0    = $F682 = 63106  _TEXT   nabu_fdc.asm:245
nf_strk    = $F669 = 63081  _TEXT   nabu_fdc.asm:226
nf_subs    = $F8D7 = 63703  _BSS    nabu_fdc.asm:29
nf_sync    = $F8D8 = 63704  _BSS    nabu_fdc.asm:30
nf_udsl    = $F7BC = 63420  _TEXT   nabu_fdc.asm:507
nf_wde1    = $F72B = 63275  _TEXT   nabu_fdc.asm:380
nf_wde2    = $F739 = 63289  _TEXT   nabu_fdc.asm:389
nf_wde3    = $F74A = 63306  _TEXT   nabu_fdc.asm:408
nf_wde4    = $F74D = 63309  _TEXT   nabu_fdc.asm:411
nf_wdef    = $F710 = 63248  _TEXT   nabu_fdc.asm:362
nf_writ    = $F6F8 = 63224  _TEXT   nabu_fdc.asm:340
nfddev     = $F5BA = 62906  _TEXT   nabu_fdc.asm:87
nfsdev     = $EEBD = 61117  _TEXT   nabu_nfs.asm:73
nfuncts    = $0029 =    41  _TEXT   CPM22.asm:1294
nofile     = $D7FD = 55293  _TEXT   CPM22.asm:700
nonblank   = $D64F = 54863  _TEXT   CPM22.asm:422
none       = $D7F7 = 55287  _TEXT   CPM22.asm:698
nospace    = $DA14 = 55828  _TEXT   CPM22.asm:1008
ns_ace0    = $F111 = 61713  _TEXT   nabu_nfs.asm:556
ns_ace1    = $F11D = 61725  _TEXT   nabu_nfs.asm:566
ns_aces    = $F0FE = 61694  _TEXT   nabu_nfs.asm:543
ns_alv     = $EEBC = 61116  _TEXT   nabu_nfs.asm:67
ns_atla    = $0041 =    65  _TEXT   nabu_nfs.asm:31
ns_ayda    = $0040 =    64  _TEXT   nabu_nfs.asm:30
ns_buff    = $F887 = 63623  _BSS    nabu_nfs.asm:20
ns_ccp     = $EEFB = 61179  _TEXT   nabu_nfs.asm:133
ns_cfcb    = $F8CF = 63695  _BSS    nabu_nfs.asm:24
ns_deco    = $F1F7 = 61943  _TEXT   nabu_nfs.asm:778
ns_del0    = $F0DA = 61658  _TEXT   nabu_nfs.asm:514
ns_dele    = $F0C7 = 61639  _TEXT   nabu_nfs.asm:498
ns_dom0    = $F2A5 = 62117  _TEXT   nabu_nfs.asm:927
ns_domk    = $F2A1 = 62113  _TEXT   nabu_nfs.asm:925
ns_dore    = $F8D1 = 63697  _BSS    nabu_nfs.asm:25
ns_dpb     = $EEAD = 61101  _TEXT   nabu_nfs.asm:55
ns_dph     = $EE9D = 61085  _TEXT   nabu_nfs.asm:47
ns_exit    = $F2D5 = 62165  _TEXT   nabu_nfs.asm:964
ns_fcls    = $EFA1 = 61345  _TEXT   nabu_nfs.asm:257
ns_ffm0    = $F06E = 61550  _TEXT   nabu_nfs.asm:419
ns_ffm1    = $F071 = 61553  _TEXT   nabu_nfs.asm:421
ns_ffmt    = $F063 = 61539  _TEXT   nabu_nfs.asm:413
ns_fild    = $0080 =   128  _TEXT   nabu_nfs.asm:35
ns_find    = $EFF7 = 61431  _TEXT   nabu_nfs.asm:319
ns_fmak    = $F1FF = 61951  _TEXT   nabu_nfs.asm:790
ns_fop0    = $EF9E = 61342  _TEXT   nabu_nfs.asm:249
ns_fopn    = $EF68 = 61288  _TEXT   nabu_nfs.asm:205
ns_for1    = $F3DC = 62428  _TEXT   nabu_nfs.asm:1177
ns_for2    = $F3EC = 62444  _TEXT   nabu_nfs.asm:1185
ns_for3    = $F3F7 = 62455  _TEXT   nabu_nfs.asm:1191
ns_for4    = $F407 = 62471  _TEXT   nabu_nfs.asm:1199
ns_form    = $F3D2 = 62418  _TEXT   nabu_nfs.asm:1173
ns_fre0    = $F18B = 61835  _TEXT   nabu_nfs.asm:666
ns_fre1    = $F193 = 61843  _TEXT   nabu_nfs.asm:672
ns_fre2    = $F1A6 = 61862  _TEXT   nabu_nfs.asm:687
ns_frea    = $F180 = 61824  _TEXT   nabu_nfs.asm:655
ns_frn0    = $F253 = 62035  _TEXT   nabu_nfs.asm:856
ns_frnm    = $F233 = 62003  _TEXT   nabu_nfs.asm:832
ns_fwr0    = $F1B7 = 61879  _TEXT   nabu_nfs.asm:707
ns_fwri    = $F1AC = 61868  _TEXT   nabu_nfs.asm:696
ns_gcre    = $F145 = 61765  _TEXT   nabu_nfs.asm:599
ns_get0    = $F32A = 62250  _TEXT   nabu_nfs.asm:1029
ns_get2    = $F334 = 62260  _TEXT   nabu_nfs.asm:1036
ns_getb    = $F301 = 62209  _TEXT   nabu_nfs.asm:1007
ns_getd    = $F2D8 = 62168  _TEXT   nabu_nfs.asm:973
ns_grb     = $EF00 = 61184  _TEXT   nabu_nfs.asm:137
ns_grb0    = $EF03 = 61187  _TEXT   nabu_nfs.asm:138
ns_grb1    = $EF17 = 61207  _TEXT   nabu_nfs.asm:145
ns_hcca    = $0080 =   128  _TEXT   nabu_nfs.asm:32
ns_hcer    = $F39C = 62364  _TEXT   nabu_nfs.asm:1125
ns_hcr0    = $F38D = 62349  _TEXT   nabu_nfs.asm:1116
ns_hcr1    = $F3A2 = 62370  _TEXT   nabu_nfs.asm:1129
ns_hcrd    = $F382 = 62338  _TEXT   nabu_nfs.asm:1111
ns_hcre    = $F385 = 62341  _TEXT   nabu_nfs.asm:1112
ns_hcw0    = $F3B7 = 62391  _TEXT   nabu_nfs.asm:1149
ns_hcw1    = $F3C8 = 62408  _TEXT   nabu_nfs.asm:1159
ns_hcwd    = $F3AB = 62379  _TEXT   nabu_nfs.asm:1143 (unused)
ns_hcwr    = $F3AE = 62382  _TEXT   nabu_nfs.asm:1144
ns_hini    = $EEE6 = 61158  _TEXT   nabu_nfs.asm:118
ns_init    = $EEC7 = 61127  _TEXT   nabu_nfs.asm:87
ns_isls    = $F8D2 = 63698  _BSS    nabu_nfs.asm:26
ns_lis0    = $F000 = 61440  _TEXT   nabu_nfs.asm:333
ns_lis1    = $F02E = 61486  _TEXT   nabu_nfs.asm:359
ns_lis2    = $F037 = 61495  _TEXT   nabu_nfs.asm:367
ns_lis3    = $F044 = 61508  _TEXT   nabu_nfs.asm:375
ns_lis4    = $F04F = 61519  _TEXT   nabu_nfs.asm:383
ns_list    = $EFFA = 61434  _TEXT   nabu_nfs.asm:329
ns_ltou    = $F41D = 62493  _TEXT   nabu_nfs.asm:1234
ns_m0      = $F442 = 62530  _TEXT   nabu_nfs.asm:1252
ns_m0fl    = $F448 = 62536  _TEXT   nabu_nfs.asm:1256
ns_m0na    = $F44B = 62539  _TEXT   nabu_nfs.asm:1258
ns_m1      = $F45F = 62559  _TEXT   nabu_nfs.asm:1263
ns_m2      = $F465 = 62565  _TEXT   nabu_nfs.asm:1270
ns_m2bn    = $F46B = 62571  _TEXT   nabu_nfs.asm:1274
ns_m3      = $F471 = 62577  _TEXT   nabu_nfs.asm:1279
ns_m3bn    = $F477 = 62583  _TEXT   nabu_nfs.asm:1283
ns_m4      = $F47D = 62589  _TEXT   nabu_nfs.asm:1288
ns_m5      = $F484 = 62596  _TEXT   nabu_nfs.asm:1296
ns_m6      = $F48B = 62603  _TEXT   nabu_nfs.asm:1304
ns_m6na    = $F493 = 62611  _TEXT   nabu_nfs.asm:1309
ns_m7      = $F4A6 = 62630  _TEXT   nabu_nfs.asm:1313
ns_m7n0    = $F4AC = 62636  _TEXT   nabu_nfs.asm:1317
ns_m7n1    = $F4C0 = 62656  _TEXT   nabu_nfs.asm:1319
ns_mask    = $F8CD = 63693  _BSS    nabu_nfs.asm:23
ns_name    = $F8C2 = 63682  _BSS    nabu_nfs.asm:22
ns_nblk    = $F28F = 62095  _TEXT   nabu_nfs.asm:906
ns_nctl    = $0000 =     0  _TEXT   nabu_nfs.asm:33
ns_opef    = $F2E2 = 62178  _TEXT   nabu_nfs.asm:986
ns_open    = $F2DF = 62175  _TEXT   nabu_nfs.asm:985
ns_own0    = $F2BD = 62141  _TEXT   nabu_nfs.asm:949
ns_own1    = $F2C9 = 62153  _TEXT   nabu_nfs.asm:954
ns_own2    = $F2CF = 62159  _TEXT   nabu_nfs.asm:958
ns_ownr    = $F2AD = 62125  _TEXT   nabu_nfs.asm:940
ns_p0      = $F428 = 62504  _TEXT   nabu_nfs.asm:1244
ns_p1      = $F435 = 62517  _TEXT   nabu_nfs.asm:1248
ns_ptrn    = $F8B7 = 63671  _BSS    nabu_nfs.asm:21
ns_put0    = $F34E = 62286  _TEXT   nabu_nfs.asm:1058
ns_putb    = $F33C = 62268  _TEXT   nabu_nfs.asm:1048
ns_rec0    = $F36F = 62319  _TEXT   nabu_nfs.asm:1083
ns_rece    = $F364 = 62308  _TEXT   nabu_nfs.asm:1076
ns_rrea    = $F1C6 = 61894  _TEXT   nabu_nfs.asm:721
ns_rrec    = $F1E4 = 61924  _TEXT   nabu_nfs.asm:756
ns_rwri    = $F1D5 = 61909  _TEXT   nabu_nfs.asm:739
ns_scre    = $F161 = 61793  _TEXT   nabu_nfs.asm:626
ns_sdir    = $F40A = 62474  _TEXT   nabu_nfs.asm:1209
ns_sel     = $EED8 = 61144  _TEXT   nabu_nfs.asm:105
ns_send    = $F379 = 62329  _TEXT   nabu_nfs.asm:1097
ns_sfir    = $F052 = 61522  _TEXT   nabu_nfs.asm:391
ns_size    = $F277 = 62071  _TEXT   nabu_nfs.asm:880
ns_sls0    = $EFEE = 61422  _TEXT   nabu_nfs.asm:305
ns_slst    = $EFB3 = 61363  _TEXT   nabu_nfs.asm:276
ns_snx0    = $F07F = 61567  _TEXT   nabu_nfs.asm:439
ns_snx1    = $F0AB = 61611  _TEXT   nabu_nfs.asm:471
ns_snx2    = $F0AF = 61615  _TEXT   nabu_nfs.asm:474
ns_snx3    = $F0B6 = 61622  _TEXT   nabu_nfs.asm:481
ns_snx4    = $F0BC = 61628  _TEXT   nabu_nfs.asm:486
ns_snxt    = $F077 = 61559  _TEXT   nabu_nfs.asm:431
ns_stmp    = $EF62 = 61282  _TEXT   nabu_nfs.asm:194
ns_sysh    = $EF21 = 61217  _TEXT   nabu_nfs.asm:156
ns_tran    = $F8D3 = 63699  _BSS    nabu_nfs.asm:27
ns_wchd    = $F41A = 62490  _TEXT   nabu_nfs.asm:1225
nulldev    = $EB47 = 60231  _TEXT   bios.asm:307 (unused)
numcmds    = $0006 =     6  _TEXT   CPM22.asm:551
nxent1     = $E21F = 57887  _TEXT   CPM22.asm:2304
nxent2     = $E226 = 57894  _TEXT   CPM22.asm:2307
nxentry    = $E20B = 57867  _TEXT   CPM22.asm:2296
offset     = $E9D4 = 59860  _TEXT   CPM22.asm:3688
olddrv     = $E9E5 = 59877  _TEXT   CPM22.asm:3702
open       = $D4CB = 54475  _TEXT   CPM22.asm:126
openfcb    = $D4D0 = 54480  _TEXT   CPM22.asm:131
openfil    = $E8A2 = 59554  _TEXT   CPM22.asm:3457
openit     = $E457 = 58455  _TEXT   CPM22.asm:2749
openit1    = $E460 = 58464  _TEXT   CPM22.asm:2753
openit2    = $E491 = 58513  _TEXT   CPM22.asm:2781
outchar    = $DD4E = 56654  _TEXT   CPM22.asm:1404
outchr1    = $DD68 = 56680  _TEXT   CPM22.asm:1418
outchr2    = $DD7F = 56703  _TEXT   CPM22.asm:1434
outcon     = $DD96 = 56726  _TEXT   CPM22.asm:1455
outcon1    = $DD9C = 56732  _TEXT   CPM22.asm:1458
outcrlf    = $DDCF = 56783  _TEXT   CPM22.asm:1491
outflag    = $DF10 = 57104  _TEXT   CPM22.asm:1694
params     = $DF49 = 57161  _TEXT   CPM22.asm:1710
pattrn1    = $D728 = 55080  _TEXT   CPM22.asm:562
pattrn2    = $DC00 = 56320  _TEXT   CPM22.asm:1239
pline      = $D4A7 = 54439  _TEXT   CPM22.asm:93
pline2     = $D4AC = 54444  _TEXT   CPM22.asm:96
position   = $E709 = 59145  _TEXT   CPM22.asm:3159
positn1    = $E70D = 59149  _TEXT   CPM22.asm:3164
positn2    = $E74D = 59213  _TEXT   CPM22.asm:3210
positn3    = $E785 = 59269  _TEXT   CPM22.asm:3242
positn4    = $E78A = 59274  _TEXT   CPM22.asm:3248
positn5    = $E791 = 59281  _TEXT   CPM22.asm:3255
pr_atla    = $0041 =    65  _TEXT   nabu_prt.asm:14
pr_ayda    = $0040 =    64  _TEXT   nabu_prt.asm:13
pr_ctrl    = $0000 =     0  _TEXT   nabu_prt.asm:16
pr_init    = $F4DE = 62686  _TEXT   nabu_prt.asm:31
pr_prnt    = $00B0 =   176  _TEXT   nabu_prt.asm:15
pr_read    = $F4E1 = 62689  _TEXT   nabu_prt.asm:46
pr_stat    = $F4DF = 62687  _TEXT   nabu_prt.asm:38
pr_wri0    = $F4E7 = 62695  _TEXT   nabu_prt.asm:56
pr_wri1    = $F4F6 = 62710  _TEXT   nabu_prt.asm:67
pr_writ    = $F4E3 = 62691  _TEXT   nabu_prt.asm:53
print      = $D48C = 54412  _TEXT   CPM22.asm:66
printb     = $D492 = 54418  _TEXT   CPM22.asm:72
printdc    = $EA02 = 59906  _TEXT   CPM22.asm:3718
prstat     = $EB16 = 60182  _TEXT   bios.asm:261
prtdev     = $F4D3 = 62675  _TEXT   nabu_prt.asm:19
prterr     = $DCEB = 56555  _TEXT   CPM22.asm:1331
prtflag    = $DF13 = 57107  _TEXT   CPM22.asm:1697
prtmesg    = $DDD9 = 56793  _TEXT   CPM22.asm:1498
prtstr     = $DEFE = 57086  _TEXT   CPM22.asm:1674
punch      = $EACB = 60107  _TEXT   bios.asm:172
putdma     = $E910 = 59664  _TEXT   CPM22.asm:3533
ransiz1    = $E7EA = 59370  _TEXT   CPM22.asm:3338
ransiz2    = $E80C = 59404  _TEXT   CPM22.asm:3360
ransiz3    = $E812 = 59410  _TEXT   CPM22.asm:3362
ransize    = $E7D8 = 59352  _TEXT   CPM22.asm:3327
rdbuf1     = $DDF5 = 56821  _TEXT   CPM22.asm:1517
rdbuf10    = $DE76 = 56950  _TEXT   CPM22.asm:1579
rdbuf11    = $DE7E = 56958  _TEXT   CPM22.asm:1585
rdbuf12    = $DE90 = 56976  _TEXT   CPM22.asm:1597
rdbuf13    = $DE9F = 56991  _TEXT   CPM22.asm:1604
rdbuf14    = $DEAC = 57004  _TEXT   CPM22.asm:1612
rdbuf15    = $DEAF = 57007  _TEXT   CPM22.asm:1615
rdbuf16    = $DEC3 = 57027  _TEXT   CPM22.asm:1627
rdbuf17    = $DEC7 = 57031  _TEXT   CPM22.asm:1629
rdbuf2     = $DDF7 = 56823  _TEXT   CPM22.asm:1519
rdbuf3     = $DE1C = 56860  _TEXT   CPM22.asm:1536
rdbuf4     = $DE2C = 56876  _TEXT   CPM22.asm:1545
rdbuf5     = $DE3D = 56893  _TEXT   CPM22.asm:1553
rdbuf6     = $DE4E = 56910  _TEXT   CPM22.asm:1562
rdbuf7     = $DE54 = 56916  _TEXT   CPM22.asm:1565
rdbuf8     = $DE65 = 56933  _TEXT   CPM22.asm:1572
rdbuf9     = $DE71 = 56945  _TEXT   CPM22.asm:1577
rdbuff     = $DDE7 = 56807  _TEXT   CPM22.asm:1510
rderr      = $D7EC = 55276  _TEXT   CPM22.asm:694
rderror    = $D7E6 = 55270  _TEXT   CPM22.asm:692
rdrandom   = $E947 = 59719  _TEXT   CPM22.asm:3575
rdrec      = $D4F9 = 54521  _TEXT   CPM22.asm:172
rdseq      = $E5C2 = 58818  _TEXT   CPM22.asm:2968
rdseq1     = $E5C7 = 58823  _TEXT   CPM22.asm:2970
rdseq2     = $E5EC = 58860  _TEXT   CPM22.asm:2985
rdseq3     = $E601 = 58881  _TEXT   CPM22.asm:2995
rdwrtflg   = $E9D9 = 59865  _TEXT   CPM22.asm:3693
read       = $EB0E = 60174  _TEXT   bios.asm:246
reader     = $EACF = 60111  _TEXT   bios.asm:178
readfcb    = $D4FE = 54526  _TEXT   CPM22.asm:177
readran    = $E799 = 59289  _TEXT   CPM22.asm:3262
readseq    = $E8E6 = 59622  _TEXT   CPM22.asm:3501
relblock   = $E9DD = 59869  _TEXT   CPM22.asm:3697
renam      = $D50E = 54542  _TEXT   CPM22.asm:194
rename     = $DA1D = 55837  _TEXT   CPM22.asm:1016
rename1    = $DA4C = 55884  _TEXT   CPM22.asm:1034
rename2    = $DA66 = 55910  _TEXT   CPM22.asm:1048
rename3    = $DA6B = 55915  _TEXT   CPM22.asm:1051 (unused)
rename4    = $DA7A = 55930  _TEXT   CPM22.asm:1059
rename5    = $DA80 = 55936  _TEXT   CPM22.asm:1061
rename6    = $DA86 = 55942  _TEXT   CPM22.asm:1063
renfile    = $E8FB = 59643  _TEXT   CPM22.asm:3517
resccp     = $EB70 = 60272  _TEXT   config\config_nfs_hybrid.asm:151
resdsk     = $D4B8 = 54456  _TEXT   CPM22.asm:107
resetdr    = $D873 = 55411  _TEXT   CPM22.asm:788
resgrb     = $EB73 = 60275  _TEXT   config\config_nfs_hybrid.asm:157
rodisk     = $DC10 = 56336  _TEXT   CPM22.asm:1254
rofile     = $DC12 = 56338  _TEXT   CPM22.asm:1255
rstdsk     = $E889 = 59529  _TEXT   CPM22.asm:3445
rtn        = $DF0A = 57098  _TEXT   CPM22.asm:1687
rtncode    = $DBFB = 56315  _TEXT   CPM22.asm:1230
samext     = $E30D = 58125  _TEXT   CPM22.asm:2499
savatr1    = $E446 = 58438  _TEXT   CPM22.asm:2739
save       = $D9BA = 55738  _TEXT   CPM22.asm:961
save1      = $D9E1 = 55777  _TEXT   CPM22.asm:979
save2      = $D9FE = 55806  _TEXT   CPM22.asm:997
save3      = $DA08 = 55816  _TEXT   CPM22.asm:1004
save4      = $DA0E = 55822  _TEXT   CPM22.asm:1006
saveattr   = $E441 = 58433  _TEXT   CPM22.asm:2737
savefcb    = $E9DF = 59871  _TEXT   CPM22.asm:3699
savext     = $E9E8 = 59880  _TEXT   CPM22.asm:3705
savnrec    = $E9E9 = 59881  _TEXT   CPM22.asm:3706
savnxt     = $E9E7 = 59879  _TEXT   CPM22.asm:3704
scratch1   = $E9B9 = 59833  _TEXT   CPM22.asm:3667
scratch2   = $E9BB = 59835  _TEXT   CPM22.asm:3668
scratch3   = $E9BD = 59837  _TEXT   CPM22.asm:3669
search     = $D72E = 55086  _TEXT   CPM22.asm:570
search1    = $D733 = 55091  _TEXT   CPM22.asm:572
search2    = $D73C = 55100  _TEXT   CPM22.asm:577
search3    = $D74F = 55119  _TEXT   CPM22.asm:589
search4    = $D754 = 55124  _TEXT   CPM22.asm:592
sectors    = $E9C7 = 59847  _TEXT   CPM22.asm:3680
sectrn     = $EB19 = 60185  _TEXT   bios.asm:266
seldsk     = $EAE2 = 60130  _TEXT   bios.asm:198
select     = $DF5F = 57183  _TEXT   CPM22.asm:1738
select1    = $DFA3 = 57251  _TEXT   CPM22.asm:1778
setattr    = $E923 = 59683  _TEXT   CPM22.asm:3549
setbit     = $E111 = 57617  _TEXT   CPM22.asm:2070
setcdrv    = $D51A = 54554  _TEXT   CPM22.asm:209
setdir     = $E1A2 = 57762  _TEXT   CPM22.asm:2204
setdma     = $EB08 = 60168  _TEXT   bios.asm:238
setdsk     = $E84B = 59467  _TEXT   CPM22.asm:3405
setext     = $E0AC = 57516  _TEXT   CPM22.asm:1985
setfile    = $E271 = 57969  _TEXT   CPM22.asm:2389
setfl1     = $E27B = 57979  _TEXT   CPM22.asm:2394
setfl2     = $E28E = 57998  _TEXT   CPM22.asm:2406
setfl3     = $E294 = 58004  _TEXT   CPM22.asm:2412
setfl4     = $E2A3 = 58019  _TEXT   CPM22.asm:2421
sethlde    = $E0B4 = 57524  _TEXT   CPM22.asm:1993
setiob     = $DEF9 = 57081  _TEXT   CPM22.asm:1667
setnrec    = $E0D8 = 57560  _TEXT   CPM22.asm:2019
setran     = $E814 = 59412  _TEXT   CPM22.asm:3368
sets2b7    = $E17E = 57726  _TEXT   CPM22.asm:2161
setsec     = $EB04 = 60164  _TEXT   bios.asm:231
setstat    = $DF07 = 57095  _TEXT   CPM22.asm:1686
settrk     = $EB00 = 60160  _TEXT   bios.asm:224
setuser    = $E941 = 59713  _TEXT   CPM22.asm:3569
shiftl     = $E10A = 57610  _TEXT   CPM22.asm:2061
shiftl1    = $E10B = 57611  _TEXT   CPM22.asm:2062
shiftr     = $E0F0 = 57584  _TEXT   CPM22.asm:2035
shiftr1    = $E0F1 = 57585  _TEXT   CPM22.asm:2036
showit     = $DD85 = 56709  _TEXT   CPM22.asm:1442
siodev     = $F4FD = 62717  _TEXT   nabu_sio.asm:20
slcterr    = $DF4D = 57165  _TEXT   CPM22.asm:1715
so_atab    = $F56D = 62829  _TEXT   nabu_sio.asm:131
so_conf    = $F571 = 62833  _TEXT   nabu_sio.asm:135
so_ini0    = $F510 = 62736  _TEXT   nabu_sio.asm:39
so_ini1    = $F516 = 62742  _TEXT   nabu_sio.asm:43
so_ini2    = $F51D = 62749  _TEXT   nabu_sio.asm:49
so_ini3    = $F529 = 62761  _TEXT   nabu_sio.asm:59
so_init    = $F508 = 62728  _TEXT   nabu_sio.asm:33
so_rea0    = $F550 = 62800  _TEXT   nabu_sio.asm:102
so_read    = $F547 = 62791  _TEXT   nabu_sio.asm:95
so_sta0    = $F53F = 62783  _TEXT   nabu_sio.asm:83
so_stat    = $F536 = 62774  _TEXT   nabu_sio.asm:76
so_wri0    = $F563 = 62819  _TEXT   nabu_sio.asm:121
so_writ    = $F559 = 62809  _TEXT   nabu_sio.asm:113
space      = $D4A2 = 54434  _TEXT   CPM22.asm:87
srchfcb    = $D4E9 = 54505  _TEXT   CPM22.asm:154
srchfst    = $D4DF = 54495  _TEXT   CPM22.asm:144
srchnxt    = $D4E4 = 54500  _TEXT   CPM22.asm:149
starting   = $DF11 = 57105  _TEXT   CPM22.asm:1695
status     = $DF4B = 57163  _TEXT   CPM22.asm:1711
stbitmap   = $E262 = 57954  _TEXT   CPM22.asm:2369
stbmap1    = $E26A = 57962  _TEXT   CPM22.asm:2380
stddma     = $D5D5 = 54741  _TEXT   CPM22.asm:339
stfilpos   = $E204 = 57860  _TEXT   CPM22.asm:2284
stkarea    = $DF47 = 57159  _TEXT   CPM22.asm:1706
stnrec1    = $E0E4 = 57572  _TEXT   CPM22.asm:2024
strdata    = $E0C1 = 57537  _TEXT   CPM22.asm:2003
ststatus   = $E307 = 58119  _TEXT   CPM22.asm:2491
subhl      = $E19B = 57755  _TEXT   CPM22.asm:2194
swindi0    = $EB2F = 60207  _TEXT   bios.asm:290
swindi1    = $EB35 = 60213  _TEXT   bios.asm:294
swindir    = $EB2B = 60203  _TEXT   bios.asm:288
synerr     = $D609 = 54793  _TEXT   CPM22.asm:377
synerr1    = $D60F = 54799  _TEXT   CPM22.asm:379
synerr2    = $D622 = 54818  _TEXT   CPM22.asm:389
syshook    = $EB6D = 60269  _TEXT   config\config_nfs_hybrid.asm:129
tab        = $0009 =     9  _TEXT   CPM22.asm:32
tbase      = $0100 =   256  _TEXT   CPM22.asm:25
tbuff      = $0080 =   128  _TEXT   CPM22.asm:24
tdrive     = $0004 =     4  _TEXT   CPM22.asm:21
tfcb       = $005C =    92  _TEXT   CPM22.asm:23
tm_40c     = $ED9D = 60829  _TEXT   nabu_vdp.asm:399
tm_80c     = $EDAA = 60842  _TEXT   nabu_vdp.asm:406
tm_addh    = $EE8E = 61070  _TEXT   nabu_vdp.asm:603
tm_addr    = $EE90 = 61072  _TEXT   nabu_vdp.asm:605
tm_bs      = $ECFB = 60667  _TEXT   nabu_vdp.asm:290
tm_cbuf    = $F85F = 63583  _BSS    nabu_vdp.asm:28
tm_cha0    = $EE3C = 60988  _TEXT   nabu_vdp.asm:535
tm_chat    = $EE36 = 60982  _TEXT   nabu_vdp.asm:530
tm_cle0    = $ED89 = 60809  _TEXT   nabu_vdp.asm:384
tm_clea    = $ED7A = 60794  _TEXT   nabu_vdp.asm:375
tm_cles    = $ED78 = 60792  _TEXT   nabu_vdp.asm:374
tm_cloc    = $EC29 = 60457  _TEXT   nabu_vdp.asm:129
tm_cls     = $EE7D = 61053  _TEXT   nabu_vdp.asm:589
tm_cls0    = $EE86 = 61062  _TEXT   nabu_vdp.asm:592
tm_cr      = $ECF8 = 60664  _TEXT   nabu_vdp.asm:287
tm_cshm    = $ED0A = 60682  _TEXT   nabu_vdp.asm:304
tm_cupd    = $EDA1 = 60833  _TEXT   nabu_vdp.asm:401
tm_curx    = $F859 = 63577  _BSS    nabu_vdp.asm:22
tm_cury    = $F85A = 63578  _BSS    nabu_vdp.asm:23
tm_data    = $00A0 =   160  _TEXT   nabu_vdp.asm:32
tm_dsc0    = $EDC3 = 60867  _TEXT   nabu_vdp.asm:421
tm_dsco    = $EDB0 = 60848  _TEXT   nabu_vdp.asm:414
tm_esc     = $ED3F = 60735  _TEXT   nabu_vdp.asm:336
tm_esc0    = $ED4D = 60749  _TEXT   nabu_vdp.asm:345
tm_esc1    = $ED62 = 60770  _TEXT   nabu_vdp.asm:357
tm_esc2    = $ED6D = 60781  _TEXT   nabu_vdp.asm:364
tm_escd    = $ED48 = 60744  _TEXT   nabu_vdp.asm:342
tm_esci    = $ED5C = 60764  _TEXT   nabu_vdp.asm:354
tm_escr    = $ED49 = 60745  _TEXT   nabu_vdp.asm:343
tm_escs    = $F85D = 63581  _BSS    nabu_vdp.asm:26
tm_getc    = $EDD6 = 60886  _TEXT   nabu_vdp.asm:442
tm_home    = $ED0D = 60685  _TEXT   nabu_vdp.asm:305
tm_ini0    = $EC1E = 60446  _TEXT   nabu_vdp.asm:116
tm_inir    = $EBDC = 60380  _TEXT   nabu_vdp.asm:67
tm_init    = $EC02 = 60418  _TEXT   nabu_vdp.asm:98
tm_inr0    = $EBDD = 60381  _TEXT   nabu_vdp.asm:68
tm_keyd    = $0090 =   144  _TEXT   nabu_vdp.asm:35
tm_keys    = $0091 =   145  _TEXT   nabu_vdp.asm:36
tm_last    = $F85E = 63582  _BSS    nabu_vdp.asm:27
tm_latc    = $00A1 =   161  _TEXT   nabu_vdp.asm:33
tm_lf      = $ECEC = 60652  _TEXT   nabu_vdp.asm:278
tm_map     = $EDE6 = 60902  _TEXT   nabu_vdp.asm:459
tm_map0    = $EDEA = 60906  _TEXT   nabu_vdp.asm:463
tm_map2    = $EDF6 = 60918  _TEXT   nabu_vdp.asm:476
tm_mapt    = $EDFD = 60925  _TEXT   nabu_vdp.asm:483
tm_mode    = $EE9B = 61083  _TEXT   nabu_vdp.asm:614
tm_oti0    = $EBD4 = 60372  _TEXT   nabu_vdp.asm:54
tm_otir    = $EBD3 = 60371  _TEXT   nabu_vdp.asm:53
tm_outc    = $F85B = 63579  _BSS    nabu_vdp.asm:24
tm_putc    = $EE12 = 60946  _TEXT   nabu_vdp.asm:501
tm_putf    = $EE20 = 60960  _TEXT   nabu_vdp.asm:509 (unused)
tm_rea0    = $EC81 = 60545  _TEXT   nabu_vdp.asm:193
tm_rea1    = $EC96 = 60566  _TEXT   nabu_vdp.asm:206
tm_rea2    = $ECA6 = 60582  _TEXT   nabu_vdp.asm:216
tm_read    = $EC6B = 60523  _TEXT   nabu_vdp.asm:181
tm_ri      = $ECE5 = 60645  _TEXT   nabu_vdp.asm:272
tm_sclf    = $EC41 = 60481  _TEXT   nabu_vdp.asm:145
tm_scr0    = $EC39 = 60473  _TEXT   nabu_vdp.asm:142
tm_scr1    = $EC3F = 60479  _TEXT   nabu_vdp.asm:144
tm_scri    = $EC2F = 60463  _TEXT   nabu_vdp.asm:137
tm_scro    = $F85C = 63580  _BSS    nabu_vdp.asm:25
tm_setp    = $EC4B = 60491  _TEXT   nabu_vdp.asm:155
tm_sta0    = $EBF0 = 60400  _TEXT   nabu_vdp.asm:85
tm_sta1    = $ECB7 = 60599  _TEXT   nabu_vdp.asm:230
tm_stal    = $ECB4 = 60596  _TEXT   nabu_vdp.asm:228
tm_stat    = $EBE5 = 60389  _TEXT   nabu_vdp.asm:80
tm_up      = $ED05 = 60677  _TEXT   nabu_vdp.asm:299
tm_usc0    = $EE69 = 61033  _TEXT   nabu_vdp.asm:568
tm_usco    = $EE5A = 61018  _TEXT   nabu_vdp.asm:561
tm_vcpy    = $EE42 = 60994  _TEXT   nabu_vdp.asm:547
tm_wri0    = $ECD2 = 60626  _TEXT   nabu_vdp.asm:260
tm_wri1    = $ED11 = 60689  _TEXT   nabu_vdp.asm:310
tm_writ    = $ECBD = 60605  _TEXT   nabu_vdp.asm:242
trksec     = $DFC9 = 57289  _TEXT   CPM22.asm:1812
trksec1    = $DFD7 = 57303  _TEXT   CPM22.asm:1821
trksec2    = $DFEA = 57322  _TEXT   CPM22.asm:1834
trksec3    = $E000 = 57344  _TEXT   CPM22.asm:1850
trksec4    = $E015 = 57365  _TEXT   CPM22.asm:1867
type       = $D96A = 55658  _TEXT   CPM22.asm:918
type1      = $D981 = 55681  _TEXT   CPM22.asm:926
type2      = $D984 = 55684  _TEXT   CPM22.asm:927 (unused)
type3      = $D994 = 55700  _TEXT   CPM22.asm:936
type4      = $D9AD = 55725  _TEXT   CPM22.asm:949
type5      = $D9B4 = 55732  _TEXT   CPM22.asm:952
unknown    = $DAB2 = 55986  _TEXT   CPM22.asm:1090
unkwn0     = $DB7E = 56190  _TEXT   CPM22.asm:1198
unkwn1     = $DAD1 = 56017  _TEXT   CPM22.asm:1105
unkwn2     = $DADA = 56026  _TEXT   CPM22.asm:1109 (unused)
unkwn3     = $DAEE = 56046  _TEXT   CPM22.asm:1120
unkwn4     = $DB0E = 56078  _TEXT   CPM22.asm:1139
unkwn5     = $DB3D = 56125  _TEXT   CPM22.asm:1160
unkwn6     = $DB4B = 56139  _TEXT   CPM22.asm:1170
unkwn7     = $DB50 = 56144  _TEXT   CPM22.asm:1172
unkwn8     = $DB5C = 56156  _TEXT   CPM22.asm:1180
unkwn9     = $DB78 = 56184  _TEXT   CPM22.asm:1196
update     = $E407 = 58375  _TEXT   CPM22.asm:2700
update1    = $E416 = 58390  _TEXT   CPM22.asm:2708
upper      = $D530 = 54576  _TEXT   CPM22.asm:228
user       = $DA9B = 55963  _TEXT   CPM22.asm:1074
userdma    = $E9B7 = 59831  _TEXT   CPM22.asm:3663
userno     = $DF47 = 57159  _TEXT   CPM22.asm:1708
usrstack   = $DF15 = 57109  _TEXT   CPM22.asm:1702
vdpdev     = $EBC6 = 60358  _TEXT   nabu_vdp.asm:39
verify     = $D5F5 = 54773  _TEXT   CPM22.asm:363
verify1    = $D5FD = 54781  _TEXT   CPM22.asm:366
wbinit     = $EB4D = 60237  _TEXT   config\config_nfs_hybrid.asm:63
wboot      = $EA53 = 59987  _TEXT   bios.asm:57
wboot0     = $EA76 = 60022  _TEXT   bios.asm:88
wbootin    = $EA15 = 59925  _TEXT   bios.asm:22
wbootr     = $EA66 = 60006  _TEXT   bios.asm:76
write      = $EB12 = 60178  _TEXT   bios.asm:253
writeran   = $E7A2 = 59298  _TEXT   CPM22.asm:3269
wrtprt     = $E9B3 = 59827  _TEXT   CPM22.asm:3661
wrtprtd    = $E132 = 57650  _TEXT   CPM22.asm:2097
wrtrec     = $D504 = 54532  _TEXT   CPM22.asm:183
wrtseq     = $E8EC = 59628  _TEXT   CPM22.asm:3506
wtrandom   = $E94D = 59725  _TEXT   CPM22.asm:3580
wtseq      = $E604 = 58884  _TEXT   CPM22.asm:2999
wtseq1     = $E609 = 58889  _TEXT   CPM22.asm:3001
wtseq10    = $E6D8 = 59096  _TEXT   CPM22.asm:3116
wtseq11    = $E704 = 59140  _TEXT   CPM22.asm:3140
wtseq12    = $E706 = 59142  _TEXT   CPM22.asm:3141
wtseq2     = $E641 = 58945  _TEXT   CPM22.asm:3024
wtseq3     = $E64E = 58958  _TEXT   CPM22.asm:3030
wtseq4     = $E66A = 58986  _TEXT   CPM22.asm:3042
wtseq5     = $E672 = 58994  _TEXT   CPM22.asm:3049
wtseq6     = $E674 = 58996  _TEXT   CPM22.asm:3050
wtseq7     = $E692 = 59026  _TEXT   CPM22.asm:3073
wtseq8     = $E6A0 = 59040  _TEXT   CPM22.asm:3080
wtseq9     = $E6C1 = 59073  _TEXT   CPM22.asm:3100
wtseq99    = $E6E5 = 59109  _TEXT   CPM22.asm:3127 (unused)
wtspecl    = $E9A1 = 59809  _TEXT   CPM22.asm:3646
xlate      = $E9D6 = 59862  _TEXT   CPM22.asm:3689
yesno      = $D95F = 55647  _TEXT   CPM22.asm:910


total time: 0.0708 sec.
no errors
