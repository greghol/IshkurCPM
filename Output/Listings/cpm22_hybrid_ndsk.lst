              	; --------------------------------------
              	; zasm: assemble "cpm22.asm"
              	; date: 2023-04-29 22:20:09
              	; --------------------------------------


              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	;
              	;   set origin for cp/m
              	;
D800:         		org	(mem)*1024
              	;
D800: C35CDB  	cbase:	jp	command		;execute command processor (ccp).
D803: C358DB  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
D806: 7F      	inbuff:	defb	127		;length of input buffer.
D807: 00      		defb	0		;current length of contents.
D808: 494E4954		defb	'INIT '
D80C: 20      	
D80D: FF000000		defb	255,0,0,0
D811: 20313937		defb	' 1979 (c) by Digital Research      '
D815: 39202863	
D819: 29206279	
D81D: 20446967	
D821: 6974616C	
D825: 20526573	
D829: 65617263	
D82D: 68202020	
D831: 202020  	
D834: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D838: 00...   	
D84B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D84F: 00...   	
D862: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D866: 00...   	
D879: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D87D: 00...   	
D888: 08D8    	inpoint:defw	inbuff+2	;input line pointer
D88A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
D88C: 5F      	print:	ld	e,a		;setup bdos call.
D88D: 0E02    		ld	c,2
D88F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
D892: C5      	printb:	push	bc
D893: CD8CD8  		call	print
D896: C1      		pop	bc
D897: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
D898: 3E0D    	crlf:	ld	a,cr
D89A: CD92D8  		call	printb
D89D: 3E0A    		ld	a,lf
D89F: C392D8  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
D8A2: 3E20    	space:	ld	a,' '
D8A4: C392D8  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
D8A7: C5      	pline:	push	bc
D8A8: CD98D8  		call	crlf
D8AB: E1      		pop	hl
D8AC: 7E      	pline2:	ld	a,(hl)
D8AD: B7      		or	a
D8AE: C8      		ret	z
D8AF: 23      		inc	hl
D8B0: E5      		push	hl
D8B1: CD8CD8  		call	print
D8B4: E1      		pop	hl
D8B5: C3ACD8  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
D8B8: 0E0D    	resdsk:	ld	c,13
D8BA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
D8BD: 5F      	dsksel:	ld	e,a
D8BE: 0E0E    		ld	c,14
D8C0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
D8C3: CD0500  	entry1:	call	entry
D8C6: 32FBDF  		ld	(rtncode),a	;save return code.
D8C9: 3C      		inc	a		;set zero if 0ffh returned.
D8CA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
D8CB: 0E0F    	open:	ld	c,15
D8CD: C3C3D8  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
D8D0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
D8D1: 32FADF  		ld	(fcb+32),a
D8D4: 11DADF  		ld	de,fcb
D8D7: C3CBD8  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
D8DA: 0E10    	close:	ld	c,16
D8DC: C3C3D8  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
D8DF: 0E11    	srchfst:ld	c,17
D8E1: C3C3D8  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
D8E4: 0E12    	srchnxt:ld	c,18
D8E6: C3C3D8  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
D8E9: 11DADF  	srchfcb:ld	de,fcb
D8EC: C3DFD8  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
D8EF: 0E13    	delete:	ld	c,19
D8F1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
D8F4: CD0500  	entry2:	call	entry
D8F7: B7      		or	a		;set zero flag if appropriate.
D8F8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
D8F9: 0E14    	rdrec:	ld	c,20
D8FB: C3F4D8  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
D8FE: 11DADF  	readfcb:ld	de,fcb
D901: C3F9D8  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
D904: 0E15    	wrtrec:	ld	c,21
D906: C3F4D8  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
D909: 0E16    	create:	ld	c,22
D90B: C3C3D8  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
D90E: 0E17    	renam:	ld	c,23
D910: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
D913: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
D915: 0E20    	getsetuc: ld	c,32
D917: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
D91A: CD13D9  	setcdrv:call	getusr		;get user number
D91D: 87      		add	a,a		;and shift into the upper 4 bits.
D91E: 87      		add	a,a
D91F: 87      		add	a,a
D920: 87      		add	a,a
D921: 21FCDF  		ld	hl,cdrive	;now add in the current drive number.
D924: B6      		or	(hl)
D925: 320400  		ld	(tdrive),a	;and save.
D928: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
D929: 3AFCDF  	movecd:	ld	a,(cdrive)
D92C: 320400  		ld	(tdrive),a
D92F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
D930: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
D932: D8      		ret	c
D933: FE7B    		cp	'{'
D935: D0      		ret	nc
D936: E65F    		and	5fh		;convert it if found.
D938: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
D939: 3AB8DF  	getinp:	ld	a,(batch)	;if =0, then use console input.
D93C: B7      		or	a
D93D: CA96D9  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
D940: 3AFCDF  		ld	a,(cdrive)	;select drive 0 if need be.
D943: B7      		or	a
D944: 3E00    		ld	a,0		;always use drive a for submit.
D946: C4BDD8  		call	nz,dsksel	;select it if required.
D949: 11B9DF  		ld	de,batchfcb
D94C: CDCBD8  		call	open		;look for it.
D94F: CA96D9  		jp	z,getinp1	;if not there, use normal input.
D952: 3AC8DF  		ld	a,(batchfcb+15)	;get last record number+1.
D955: 3D      		dec	a
D956: 32D9DF  		ld	(batchfcb+32),a
D959: 11B9DF  		ld	de,batchfcb
D95C: CDF9D8  		call	rdrec		;read last record.
D95F: C296D9  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
D962: 1107D8  		ld	de,inbuff+1
D965: 218000  		ld	hl,tbuff	;data was read into buffer here.
D968: 0680    		ld	b,128		;all 128 characters may be used.
D96A: CD4FDC  		call	hl2de		;(hl) to (de), (b) bytes.
D96D: 21C7DF  		ld	hl,batchfcb+14
D970: 3600    		ld	(hl),0		;zero out the 's2' byte.
D972: 23      		inc	hl		;and decrement the record count.
D973: 35      		dec	(hl)
D974: 11B9DF  		ld	de,batchfcb	;close the batch file now.
D977: CDDAD8  		call	close
D97A: CA96D9  		jp	z,getinp1	;quit on an error.
D97D: 3AFCDF  		ld	a,(cdrive)	;re-select previous drive if need be.
D980: B7      		or	a
D981: C4BDD8  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
D984: 2108D8  		ld	hl,inbuff+2
D987: CDACD8  		call	pline2
D98A: CDC2D9  		call	chkcon		;check console, quit on a key.
D98D: CAA7D9  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
D990: CDDDD9  		call	delbatch	;delete the batch file.
D993: C382DB  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
D996: CDDDD9  	getinp1:call	delbatch	;delete file ($$$.sub).
D999: CD1AD9  		call	setcdrv		;reset active disk.
D99C: 0E0A    		ld	c,10		;get line from console device.
D99E: 1106D8  		ld	de,inbuff
D9A1: CD0500  		call	entry
D9A4: CD29D9  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
D9A7: 2107D8  	getinp2:ld	hl,inbuff+1
D9AA: 46      		ld	b,(hl)		;(b)=character counter.
D9AB: 23      	getinp3:inc	hl
D9AC: 78      		ld	a,b		;end of the line?
D9AD: B7      		or	a
D9AE: CABAD9  		jp	z,getinp4
D9B1: 7E      		ld	a,(hl)		;convert to upper case.
D9B2: CD30D9  		call	upper
D9B5: 77      		ld	(hl),a
D9B6: 05      		dec	b		;adjust character count.
D9B7: C3ABD9  		jp	getinp3
D9BA: 77      	getinp4:ld	(hl),a		;add trailing null.
D9BB: 2108D8  		ld	hl,inbuff+2
D9BE: 2288D8  		ld	(inpoint),hl	;reset input line pointer.
D9C1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
D9C2: 0E0B    	chkcon:	ld	c,11		;check console.
D9C4: CD0500  		call	entry
D9C7: B7      		or	a
D9C8: C8      		ret	z		;return if nothing.
D9C9: 0E01    		ld	c,1		;else get character.
D9CB: CD0500  		call	entry
D9CE: B7      		or	a		;clear zero flag and return.
D9CF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
D9D0: 0E19    	getdsk:	ld	c,25
D9D2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
D9D5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
D9D8: 0E1A    	dmaset:	ld	c,26
D9DA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
D9DD: 21B8DF  	delbatch: ld	hl,batch	;is batch active?
D9E0: 7E      		ld	a,(hl)
D9E1: B7      		or	a
D9E2: C8      		ret	z
D9E3: 3600    		ld	(hl),0		;yes, de-activate it.
D9E5: AF      		xor	a
D9E6: CDBDD8  		call	dsksel		;select drive 0 for sure.
D9E9: 11B9DF  		ld	de,batchfcb	;and delete this file.
D9EC: CDEFD8  		call	delete
D9EF: 3AFCDF  		ld	a,(cdrive)	;reset current drive.
D9F2: C3BDD8  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
D9F5: 1128DB  	verify:	ld	de,pattrn1	;these are the serial number bytes.
D9F8: 2100E0  		ld	hl,pattrn2	;ditto, but how could they be different?
D9FB: 0606    		ld	b,6		;6 bytes each.
D9FD: 1A      	verify1:ld	a,(de)
D9FE: BE      		cp	(hl)
D9FF: C2DCDB  		jp	nz,halt		;jump to halt routine.
DA02: 13      		inc	de
DA03: 23      		inc	hl
DA04: 05      		dec	b
DA05: C2FDD9  		jp	nz,verify1
DA08: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
DA09: CD98D8  	synerr:	call	crlf		;end current line.
DA0C: 2A8AD8  		ld	hl,(namepnt)	;this points to name in error.
DA0F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
DA10: FE20    		cp	' '
DA12: CA22DA  		jp	z,synerr2
DA15: B7      		or	a
DA16: CA22DA  		jp	z,synerr2
DA19: E5      		push	hl
DA1A: CD8CD8  		call	print
DA1D: E1      		pop	hl
DA1E: 23      		inc	hl
DA1F: C30FDA  		jp	synerr1
DA22: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
DA24: CD8CD8  		call	print
DA27: CD98D8  		call	crlf
DA2A: CDDDD9  		call	delbatch	;delete any batch file.
DA2D: C382DB  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
DA30: 1A      	check:	ld	a,(de)
DA31: B7      		or	a
DA32: C8      		ret	z
DA33: FE20    		cp	' '		;control characters are not legal here.
DA35: DA09DA  		jp	c,synerr
DA38: C8      		ret	z		;check for valid delimiter.
DA39: FE3D    		cp	'='
DA3B: C8      		ret	z
DA3C: FE5F    		cp	'_'
DA3E: C8      		ret	z
DA3F: FE2E    		cp	'.'
DA41: C8      		ret	z
DA42: FE3A    		cp	':'
DA44: C8      		ret	z
DA45: FE3B    		cp	';'
DA47: C8      		ret	z
DA48: FE3C    		cp	'<'
DA4A: C8      		ret	z
DA4B: FE3E    		cp	'>'
DA4D: C8      		ret	z
DA4E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
DA4F: 1A      	nonblank: ld	a,(de)
DA50: B7      		or	a		;string ends with a null.
DA51: C8      		ret	z
DA52: FE20    		cp	' '
DA54: C0      		ret	nz
DA55: 13      		inc	de
DA56: C34FDA  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
DA59: 85      	addhl:	add	a,l
DA5A: 6F      		ld	l,a
DA5B: D0      		ret	nc		;take care of any carry.
DA5C: 24      		inc	h
DA5D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
DA5E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
DA60: 21DADF  	convert:ld	hl,fcb
DA63: CD59DA  		call	addhl
DA66: E5      		push	hl
DA67: E5      		push	hl
DA68: AF      		xor	a
DA69: 32FDDF  		ld	(chgdrv),a	;initialize drive change flag.
DA6C: 2A88D8  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
DA6F: EB      		ex	de,hl
DA70: CD4FDA  		call	nonblank	;get next non-blank character.
DA73: EB      		ex	de,hl
DA74: 228AD8  		ld	(namepnt),hl	;save pointer here for any error message.
DA77: EB      		ex	de,hl
DA78: E1      		pop	hl
DA79: 1A      		ld	a,(de)		;get first character.
DA7A: B7      		or	a
DA7B: CA89DA  		jp	z,convrt1
DA7E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
DA80: 47      		ld	b,a		;and save.
DA81: 13      		inc	de		;check next character for a ':'.
DA82: 1A      		ld	a,(de)
DA83: FE3A    		cp	':'
DA85: CA90DA  		jp	z,convrt2
DA88: 1B      		dec	de		;nope, move pointer back to the start of the line.
DA89: 3AFCDF  	convrt1:ld	a,(cdrive)
DA8C: 77      		ld	(hl),a
DA8D: C396DA  		jp	convrt3
DA90: 78      	convrt2:ld	a,b
DA91: 32FDDF  		ld	(chgdrv),a	;set change in drives flag.
DA94: 70      		ld	(hl),b
DA95: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
DA96: 0608    	convrt3:ld	b,08h
DA98: CD30DA  	convrt4:call	check
DA9B: CAB9DA  		jp	z,convrt8
DA9E: 23      		inc	hl
DA9F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
DAA1: C2A9DA  		jp	nz,convrt5	;field with '?'.
DAA4: 363F    		ld	(hl),'?'
DAA6: C3ABDA  		jp	convrt6
DAA9: 77      	convrt5:ld	(hl),a
DAAA: 13      		inc	de
DAAB: 05      	convrt6:dec	b
DAAC: C298DA  		jp	nz,convrt4
DAAF: CD30DA  	convrt7:call	check		;get next delimiter.
DAB2: CAC0DA  		jp	z,getext
DAB5: 13      		inc	de
DAB6: C3AFDA  		jp	convrt7
DAB9: 23      	convrt8:inc	hl		;blank fill the file name.
DABA: 3620    		ld	(hl),' '
DABC: 05      		dec	b
DABD: C2B9DA  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
DAC0: 0603    	getext:	ld	b,03h
DAC2: FE2E    		cp	'.'
DAC4: C2E9DA  		jp	nz,getext5
DAC7: 13      		inc	de
DAC8: CD30DA  	getext1:call	check
DACB: CAE9DA  		jp	z,getext5
DACE: 23      		inc	hl
DACF: FE2A    		cp	'*'
DAD1: C2D9DA  		jp	nz,getext2
DAD4: 363F    		ld	(hl),'?'
DAD6: C3DBDA  		jp	getext3
DAD9: 77      	getext2:ld	(hl),a
DADA: 13      		inc	de
DADB: 05      	getext3:dec	b
DADC: C2C8DA  		jp	nz,getext1
DADF: CD30DA  	getext4:call	check
DAE2: CAF0DA  		jp	z,getext6
DAE5: 13      		inc	de
DAE6: C3DFDA  		jp	getext4
DAE9: 23      	getext5:inc	hl
DAEA: 3620    		ld	(hl),' '
DAEC: 05      		dec	b
DAED: C2E9DA  		jp	nz,getext5
DAF0: 0603    	getext6:ld	b,3
DAF2: 23      	getext7:inc	hl
DAF3: 3600    		ld	(hl),0
DAF5: 05      		dec	b
DAF6: C2F2DA  		jp	nz,getext7
DAF9: EB      		ex	de,hl
DAFA: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DAFD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
DAFE: 010B00  		ld	bc,11		;set name length.
DB01: 23      	getext8:inc	hl
DB02: 7E      		ld	a,(hl)
DB03: FE3F    		cp	'?'		;any question marks?
DB05: C209DB  		jp	nz,getext9
DB08: 04      		inc	b		;count them.
DB09: 0D      	getext9:dec	c
DB0A: C201DB  		jp	nz,getext8
DB0D: 78      		ld	a,b
DB0E: B7      		or	a
DB0F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
DB10: 44495220	cmdtbl:	defb	'DIR '
DB14: 45524120		defb	'ERA '
DB18: 54595045		defb	'TYPE'
DB1C: 53415645		defb	'SAVE'
DB20: 52454E20		defb	'REN '
DB24: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
DB28: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
DB2C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
DB2E: 2110DB  	search:	ld	hl,cmdtbl
DB31: 0E00    		ld	c,0
DB33: 79      	search1:ld	a,c
DB34: FE06    		cp	numcmds		;this commands exists.
DB36: D0      		ret	nc
DB37: 11DBDF  		ld	de,fcb+1	;check this one.
DB3A: 0604    		ld	b,4		;max command length.
DB3C: 1A      	search2:ld	a,(de)
DB3D: BE      		cp	(hl)
DB3E: C24FDB  		jp	nz,search3	;not a match.
DB41: 13      		inc	de
DB42: 23      		inc	hl
DB43: 05      		dec	b
DB44: C23CDB  		jp	nz,search2
DB47: 1A      		ld	a,(de)		;allow a 3 character command to match.
DB48: FE20    		cp	' '
DB4A: C254DB  		jp	nz,search4
DB4D: 79      		ld	a,c		;set return register for this command.
DB4E: C9      		ret	
DB4F: 23      	search3:inc	hl
DB50: 05      		dec	b
DB51: C24FDB  		jp	nz,search3
DB54: 0C      	search4:inc	c
DB55: C333DB  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
DB58: AF      	clearbuf: xor	a
DB59: 3207D8  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
DB5C: 31B8DF  	command:ld	sp,ccpstack	;setup stack area.
DB5F: C5      		push	bc		;note that (c) should be equal to:
DB60: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
DB61: 1F      		rra			;and 'dddd' is the drive number.
DB62: 1F      		rra	
DB63: 1F      		rra	
DB64: 1F      		rra	
DB65: E60F    		and	0fh		;isolate the user number.
DB67: 5F      		ld	e,a
DB68: CD15D9  		call	getsetuc	;and set it.
DB6B: CDB8D8  		call	resdsk		;reset the disk system.
DB6E: 32B8DF  		ld	(batch),a	;clear batch mode flag.
DB71: C1      		pop	bc
DB72: 79      		ld	a,c
DB73: E60F    		and	0fh		;isolate the drive number.
DB75: 32FCDF  		ld	(cdrive),a	;and save.
DB78: CDBDD8  		call	dsksel		;...and select.
DB7B: 3A07D8  		ld	a,(inbuff+1)
DB7E: B7      		or	a		;anything in input buffer already?
DB7F: C2A5DB  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
DB82: 31B8DF  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
DB85: CD98D8  		call	crlf		;start a new line on the screen.
DB88: CDD0D9  		call	getdsk		;get current drive.
DB8B: C641    		add	a,'A'
DB8D: CD8CD8  		call	print		;print current drive.
DB90: 00      		nop
DB91: 00      		nop
DB92: 00      		nop
DB93: 00      		nop
DB94: 00      		nop
DB95: CD13D9  		call	getusr		;get current user.
DB98: C630    		add	a,'0'
DB9A: CD02EE  		call	printdc		;print current user.
DB9D: 3E3E    		ld	a,'>'
DB9F: CD8CD8  		call	print		;and add prompt.
DBA2: CD39D9  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
DBA5: 118000  	cmmnd2:	ld	de,tbuff
DBA8: CDD8D9  		call	dmaset		;set standard dma address.
DBAB: CDD0D9  		call	getdsk
DBAE: 32FCDF  		ld	(cdrive),a	;set current drive.
DBB1: CD5EDA  		call	convfst		;convert name typed in.
DBB4: C409DA  		call	nz,synerr	;wild cards are not allowed.
DBB7: 3AFDDF  		ld	a,(chgdrv)	;if a change in drives was indicated,
DBBA: B7      		or	a		;then treat this as an unknown command
DBBB: C2B2DE  		jp	nz,unknown	;which gets executed.
DBBE: CD2EDB  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
DBC1: 21CEDB  		ld	hl,cmdadr	;now, look thru our address table for command (a).
DBC4: 5F      		ld	e,a		;set (de) to command number.
DBC5: 1600    		ld	d,0
DBC7: 19      		add	hl,de
DBC8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
DBC9: 7E      		ld	a,(hl)		;now pick out this address.
DBCA: 23      		inc	hl
DBCB: 66      		ld	h,(hl)
DBCC: 6F      		ld	l,a
DBCD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
DBCE: 84DC2CDD	cmdadr:	defw	direct,erase,type,save
DBD2: 6ADDBADD	
DBD6: 1DDE9BDE		defw	rename,user,unknown
DBDA: B2DE    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
DBDC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
DBDF: 2200D8  		ld	(cbase),hl
DBE2: 2100D8  		ld	hl,cbase
DBE5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
DBE6: 01ECDB  	rderror:ld	bc,rderr
DBE9: C3A7D8  		jp	pline
DBEC: 72656164	rderr:	defb	'read error',0
DBF0: 20657272	
DBF4: 6F7200  	
              	;
              	;   required file was not located.
              	;
DBF7: 01FDDB  	none:	ld	bc,nofile
DBFA: C3A7D8  		jp	pline
DBFD: 6E6F2066	nofile:	defb	'no file',0
DC01: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
DC05: CD5EDA  	decode:	call	convfst		;convert filename.
DC08: 3AFDDF  		ld	a,(chgdrv)	;do not allow a drive to be specified.
DC0B: B7      		or	a
DC0C: C209DA  		jp	nz,synerr
DC0F: 21DBDF  		ld	hl,fcb+1	;convert number now.
DC12: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
DC15: 7E      	decode1:ld	a,(hl)
DC16: FE20    		cp	' '		;a space terminates the numeral.
DC18: CA40DC  		jp	z,decode3
DC1B: 23      		inc	hl
DC1C: D630    		sub	'0'		;make binary from ascii.
DC1E: FE0A    		cp	10		;legal digit?
DC20: D209DA  		jp	nc,synerr
DC23: 57      		ld	d,a		;yes, save it in (d).
DC24: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
DC25: E6E0    		and	0e0h
DC27: C209DA  		jp	nz,synerr
DC2A: 78      		ld	a,b
DC2B: 07      		rlca	
DC2C: 07      		rlca	
DC2D: 07      		rlca			;(a)=(b)*8
DC2E: 80      		add	a,b		;.......*9
DC2F: DA09DA  		jp	c,synerr
DC32: 80      		add	a,b		;.......*10
DC33: DA09DA  		jp	c,synerr
DC36: 82      		add	a,d		;add in new digit now.
DC37: DA09DA  	decode2:jp	c,synerr
DC3A: 47      		ld	b,a		;and save result.
DC3B: 0D      		dec	c		;only look at 11 digits.
DC3C: C215DC  		jp	nz,decode1
DC3F: C9      		ret	
DC40: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
DC41: FE20    		cp	' '
DC43: C209DA  		jp	nz,synerr
DC46: 23      		inc	hl
DC47: 0D      	decode4:dec	c
DC48: C240DC  		jp	nz,decode3
DC4B: 78      		ld	a,b		;set (a)=the numeric value entered.
DC4C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
DC4D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
DC4F: 7E      	hl2de:	ld	a,(hl)
DC50: 12      		ld	(de),a
DC51: 23      		inc	hl
DC52: 13      		inc	de
DC53: 05      		dec	b
DC54: C24FDC  		jp	nz,hl2de
DC57: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
DC58: 218000  	extract:ld	hl,tbuff
DC5B: 81      		add	a,c
DC5C: CD59DA  		call	addhl
DC5F: 7E      		ld	a,(hl)
DC60: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
DC61: AF      	dselect:xor	a		;null out first byte of fcb.
DC62: 32DADF  		ld	(fcb),a
DC65: 3AFDDF  		ld	a,(chgdrv)	;a drive change indicated?
DC68: B7      		or	a
DC69: C8      		ret	z
DC6A: 3D      		dec	a		;yes, is it the same as the current drive?
DC6B: 21FCDF  		ld	hl,cdrive
DC6E: BE      		cp	(hl)
DC6F: C8      		ret	z
DC70: C3BDD8  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
DC73: 3AFDDF  	resetdr:ld	a,(chgdrv)	;drive change indicated?
DC76: B7      		or	a
DC77: C8      		ret	z
DC78: 3D      		dec	a		;yes, was it a different drive?
DC79: 21FCDF  		ld	hl,cdrive
DC7C: BE      		cp	(hl)
DC7D: C8      		ret	z
DC7E: 3AFCDF  		ld	a,(cdrive)	;yes, re-select our old drive.
DC81: C3BDD8  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
DC84: CD5EDA  	direct:	call	convfst		;convert file name.
DC87: CD61DC  		call	dselect		;select indicated drive.
DC8A: 21DBDF  		ld	hl,fcb+1	;was any file indicated?
DC8D: 7E      		ld	a,(hl)
DC8E: FE20    		cp	' '
DC90: C29CDC  		jp	nz,direct2
DC93: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
DC95: 363F    	direct1:ld	(hl),'?'
DC97: 23      		inc	hl
DC98: 05      		dec	b
DC99: C295DC  		jp	nz,direct1
DC9C: 1E00    	direct2:ld	e,0		;set initial cursor position.
DC9E: D5      		push	de
DC9F: CDE9D8  		call	srchfcb		;get first file name.
DCA2: CCF7DB  		call	z,none		;none found at all?
DCA5: CA28DD  	direct3:jp	z,direct9	;terminate if no more names.
DCA8: 3AFBDF  		ld	a,(rtncode)	;get file's position in segment (0-3).
DCAB: 0F      		rrca	
DCAC: 0F      		rrca	
DCAD: 0F      		rrca	
DCAE: E660    		and	60h		;(a)=position*32
DCB0: 4F      		ld	c,a
DCB1: 3E0A    		ld	a,10
DCB3: CD58DC  		call	extract		;extract the tenth entry in fcb.
DCB6: 17      		rla			;check system file status bit.
DCB7: DA1CDD  		jp	c,direct8	;we don't list them.
DCBA: D1      		pop	de
DCBB: 7B      		ld	a,e		;bump name count.
DCBC: 1C      		inc	e
DCBD: D5      		push	de
DCBE: E603    		and	03h		;at end of line?
DCC0: F5      		push	af
DCC1: C2D9DC  		jp	nz,direct4
DCC4: CD98D8  		call	crlf		;yes, end this line and start another.
DCC7: C5      		push	bc
DCC8: CDD0D9  		call	getdsk		;start line with ('a:').
DCCB: C1      		pop	bc
DCCC: C641    		add	a,'A'
DCCE: CD92D8  		call	printb
DCD1: 3E3A    		ld	a,':'
DCD3: CD92D8  		call	printb
DCD6: C3E1DC  		jp	direct5
DCD9: CDA2D8  	direct4:call	space		;add seperator between file names.
DCDC: 3E3A    		ld	a,':'
DCDE: CD92D8  		call	printb
DCE1: CDA2D8  	direct5:call	space
DCE4: 0601    		ld	b,1		;'extract' each file name character at a time.
DCE6: 78      	direct6:ld	a,b
DCE7: CD58DC  		call	extract
DCEA: E67F    		and	7fh		;strip bit 7 (status bit).
DCEC: FE20    		cp	' '		;are we at the end of the name?
DCEE: C206DD  		jp	nz,drect65
DCF1: F1      		pop	af		;yes, don't print spaces at the end of a line.
DCF2: F5      		push	af
DCF3: FE03    		cp	3
DCF5: C204DD  		jp	nz,drect63
DCF8: 3E09    		ld	a,9		;first check for no extension.
DCFA: CD58DC  		call	extract
DCFD: E67F    		and	7fh
DCFF: FE20    		cp	' '
DD01: CA1BDD  		jp	z,direct7	;don't print spaces.
DD04: 3E20    	drect63:ld	a,' '		;else print them.
DD06: CD92D8  	drect65:call	printb
DD09: 04      		inc	b		;bump to next character psoition.
DD0A: 78      		ld	a,b
DD0B: FE0C    		cp	12		;end of the name?
DD0D: D21BDD  		jp	nc,direct7
DD10: FE09    		cp	9		;nope, starting extension?
DD12: C2E6DC  		jp	nz,direct6
DD15: CDA2D8  		call	space		;yes, add seperating space.
DD18: C3E6DC  		jp	direct6
DD1B: F1      	direct7:pop	af		;get the next file name.
DD1C: CDC2D9  	direct8:call	chkcon		;first check console, quit on anything.
DD1F: C228DD  		jp	nz,direct9
DD22: CDE4D8  		call	srchnxt		;get next name.
DD25: C3A5DC  		jp	direct3		;and continue with our list.
DD28: D1      	direct9:pop	de		;restore the stack and return to command level.
DD29: C393DF  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DD2C: CD5EDA  	erase:	call	convfst		;convert file name.
DD2F: FE0B    		cp	11		;was '*.*' entered?
DD31: C24FDD  		jp	nz,erase1
DD34: 015FDD  		ld	bc,yesno	;yes, ask for confirmation.
DD37: CDA7D8  		call	pline
DD3A: CD39D9  		call	getinp
DD3D: 2107D8  		ld	hl,inbuff+1
DD40: 35      		dec	(hl)		;must be exactly 'y'.
DD41: C282DB  		jp	nz,cmmnd1
DD44: 23      		inc	hl
DD45: 7E      		ld	a,(hl)
DD46: FE79    		cp	'y'
DD48: C282DB  		jp	nz,cmmnd1
DD4B: 23      		inc	hl
DD4C: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DD4F: CD61DC  	erase1:	call	dselect		;select desired disk.
DD52: 11DADF  		ld	de,fcb
DD55: CDEFD8  		call	delete		;delete the file.
DD58: 3C      		inc	a
DD59: CCF7DB  		call	z,none		;not there?
DD5C: C393DF  		jp	getback		;return to command level now.
DD5F: 616C6C20	yesno:	defb	'all (y/n)?',0
DD63: 28792F6E	
DD67: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DD6A: CD5EDA  	type:	call	convfst		;convert file name.
DD6D: C209DA  		jp	nz,synerr	;wild cards not allowed.
DD70: CD61DC  		call	dselect		;select indicated drive.
DD73: CDD0D8  		call	openfcb		;open the file.
DD76: CAB4DD  		jp	z,type5		;not there?
DD79: CD98D8  		call	crlf		;ok, start a new line on the screen.
DD7C: 21FEDF  		ld	hl,nbytes	;initialize byte counter.
DD7F: 36FF    		ld	(hl),0ffh	;set to read first sector.
DD81: 21FEDF  	type1:	ld	hl,nbytes
DD84: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
DD85: FE80    		cp	128
DD87: DA94DD  		jp	c,type3
DD8A: E5      		push	hl		;yes, read in the next one.
DD8B: CDFED8  		call	readfcb
DD8E: E1      		pop	hl
DD8F: C2ADDD  		jp	nz,type4	;end or error?
DD92: AF      		xor	a		;ok, clear byte counter.
DD93: 77      		ld	(hl),a
DD94: 34      	type3:	inc	(hl)		;count this byte.
DD95: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
DD98: CD59DA  		call	addhl
DD9B: 7E      		ld	a,(hl)
DD9C: FE1A    		cp	cntrlz		;end of file mark?
DD9E: CA93DF  		jp	z,getback
DDA1: CD8CD8  		call	print		;no, print it.
DDA4: CDC2D9  		call	chkcon		;check console, quit if anything ready.
DDA7: C293DF  		jp	nz,getback
DDAA: C381DD  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
DDAD: 3D      	type4:	dec	a		;read error?
DDAE: CA93DF  		jp	z,getback
DDB1: CDE6DB  		call	rderror		;yes, print message.
DDB4: CD73DC  	type5:	call	resetdr		;and reset proper drive
DDB7: C309DA  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DDBA: CD05DC  	save:	call	decode		;get numeric number that follows save.
DDBD: F5      		push	af		;save number of pages to write.
DDBE: CD5EDA  		call	convfst		;convert file name.
DDC1: C209DA  		jp	nz,synerr	;wild cards not allowed.
DDC4: CD61DC  		call	dselect		;select specified drive.
DDC7: 11DADF  		ld	de,fcb		;now delete this file.
DDCA: D5      		push	de
DDCB: CDEFD8  		call	delete
DDCE: D1      		pop	de
DDCF: CD09D9  		call	create		;and create it again.
DDD2: CA08DE  		jp	z,save3		;can't create?
DDD5: AF      		xor	a		;clear record number byte.
DDD6: 32FADF  		ld	(fcb+32),a
DDD9: F1      		pop	af		;convert pages to sectors.
DDDA: 6F      		ld	l,a
DDDB: 2600    		ld	h,0
DDDD: 29      		add	hl,hl		;(hl)=number of sectors to write.
DDDE: 110001  		ld	de,tbase	;and we start from here.
DDE1: 7C      	save1:	ld	a,h		;done yet?
DDE2: B5      		or	l
DDE3: CAFEDD  		jp	z,save2
DDE6: 2B      		dec	hl		;nope, count this and compute the start
DDE7: E5      		push	hl		;of the next 128 byte sector.
DDE8: 218000  		ld	hl,128
DDEB: 19      		add	hl,de
DDEC: E5      		push	hl		;save it and set the transfer address.
DDED: CDD8D9  		call	dmaset
DDF0: 11DADF  		ld	de,fcb		;write out this sector now.
DDF3: CD04D9  		call	wrtrec
DDF6: D1      		pop	de		;reset (de) to the start of the last sector.
DDF7: E1      		pop	hl		;restore sector count.
DDF8: C208DE  		jp	nz,save3	;write error?
DDFB: C3E1DD  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
DDFE: 11DADF  	save2:	ld	de,fcb		;now close the file.
DE01: CDDAD8  		call	close
DE04: 3C      		inc	a		;did it close ok?
DE05: C20EDE  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
DE08: 0114DE  	save3:	ld	bc,nospace
DE0B: CDA7D8  		call	pline
DE0E: CDD5D9  	save4:	call	stddma		;reset the standard dma address.
DE11: C393DF  		jp	getback
DE14: 6E6F2073	nospace:defb	'no space',0
DE18: 70616365	
DE1C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
DE1D: CD5EDA  	rename:	call	convfst		;convert first file name.
DE20: C209DA  		jp	nz,synerr	;wild cards not allowed.
DE23: 3AFDDF  		ld	a,(chgdrv)	;remember any change in drives specified.
DE26: F5      		push	af
DE27: CD61DC  		call	dselect		;and select this drive.
DE2A: CDE9D8  		call	srchfcb		;is this file present?
DE2D: C286DE  		jp	nz,rename6	;yes, print error message.
DE30: 21DADF  		ld	hl,fcb		;yes, move this name into second slot.
DE33: 11EADF  		ld	de,fcb+16
DE36: 0610    		ld	b,16
DE38: CD4FDC  		call	hl2de
DE3B: 2A88D8  		ld	hl,(inpoint)	;get input pointer.
DE3E: EB      		ex	de,hl
DE3F: CD4FDA  		call	nonblank	;get next non blank character.
DE42: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
DE44: CA4CDE  		jp	z,rename1
DE47: FE5F    		cp	'_'
DE49: C280DE  		jp	nz,rename5
DE4C: EB      	rename1:ex	de,hl
DE4D: 23      		inc	hl		;ok, skip seperator.
DE4E: 2288D8  		ld	(inpoint),hl	;save input line pointer.
DE51: CD5EDA  		call	convfst		;convert this second file name now.
DE54: C280DE  		jp	nz,rename5	;again, no wild cards.
DE57: F1      		pop	af		;if a drive was specified, then it
DE58: 47      		ld	b,a		;must be the same as before.
DE59: 21FDDF  		ld	hl,chgdrv
DE5C: 7E      		ld	a,(hl)
DE5D: B7      		or	a
DE5E: CA66DE  		jp	z,rename2
DE61: B8      		cp	b
DE62: 70      		ld	(hl),b
DE63: C280DE  		jp	nz,rename5	;they were different, error.
DE66: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
DE67: AF      		xor	a
DE68: 32DADF  		ld	(fcb),a		;clear the drive byte of the fcb.
DE6B: CDE9D8  	rename3:call	srchfcb		;and go look for second file.
DE6E: CA7ADE  		jp	z,rename4	;doesn't exist?
DE71: 11DADF  		ld	de,fcb
DE74: CD0ED9  		call	renam		;ok, rename the file.
DE77: C393DF  		jp	getback
              	;
              	;   process rename errors here.
              	;
DE7A: CDF7DB  	rename4:call	none		;file not there.
DE7D: C393DF  		jp	getback
DE80: CD73DC  	rename5:call	resetdr		;bad command format.
DE83: C309DA  		jp	synerr
DE86: 018FDE  	rename6:ld	bc,exists	;destination file already exists.
DE89: CDA7D8  		call	pline
DE8C: C393DF  		jp	getback
DE8F: 66696C65	exists:	defb	'file exists',0
DE93: 20657869	
DE97: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
DE9B: CD05DC  	user:	call	decode		;get numeric value following command.
DE9E: FE10    		cp	16		;legal user number?
DEA0: D209DA  		jp	nc,synerr
DEA3: 5F      		ld	e,a		;yes but is there anything else?
DEA4: 3ADBDF  		ld	a,(fcb+1)
DEA7: FE20    		cp	' '
DEA9: CA09DA  		jp	z,synerr	;yes, that is not allowed.
DEAC: CD15D9  		call	getsetuc	;ok, set user code.
DEAF: C396DF  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
DEB2: CDF5D9  	unknown:call	verify		;check for valid system (why?).
DEB5: 3ADBDF  		ld	a,(fcb+1)	;anything to execute?
DEB8: FE20    		cp	' '
DEBA: C2D1DE  		jp	nz,unkwn1
DEBD: 3AFDDF  		ld	a,(chgdrv)	;nope, only a drive change?
DEC0: B7      		or	a
DEC1: CA96DF  		jp	z,getback1	;neither???
DEC4: 3D      		dec	a
DEC5: 32FCDF  		ld	(cdrive),a	;ok, store new drive.
DEC8: CD29D9  		call	movecd		;set (tdrive) also.
DECB: CDBDD8  		call	dsksel		;and select this drive.
DECE: C396DF  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
DED1: 11E3DF  	unkwn1:	ld	de,fcb+9	;an extension specified?
DED4: 1A      		ld	a,(de)
DED5: FE20    		cp	' '
DED7: C209DA  		jp	nz,synerr	;yes, not allowed.
DEDA: D5      	unkwn2:	push	de
DEDB: CD61DC  		call	dselect		;select specified drive.
DEDE: D1      		pop	de
DEDF: 2190DF  		ld	hl,comfile	;set the extension to 'com'.
DEE2: CD4DDC  		call	move3
DEE5: CDD0D8  		call	openfcb		;and open this file.
DEE8: CA78DF  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
DEEB: 210001  		ld	hl,tbase	;store the program starting here.
DEEE: E5      	unkwn3:	push	hl
DEEF: EB      		ex	de,hl
DEF0: CDD8D9  		call	dmaset		;set transfer address.
DEF3: 11DADF  		ld	de,fcb		;and read the next record.
DEF6: CDF9D8  		call	rdrec
DEF9: C20EDF  		jp	nz,unkwn4	;end of file or read error?
DEFC: E1      		pop	hl		;nope, bump pointer for next sector.
DEFD: 118000  		ld	de,128
DF00: 19      		add	hl,de
DF01: 1100D8  		ld	de,cbase	;enough room for the whole file?
DF04: 7D      		ld	a,l
DF05: 93      		sub	e
DF06: 7C      		ld	a,h
DF07: 9A      		sbc	a,d
DF08: D27EDF  		jp	nc,unkwn0	;no, it can't fit.
DF0B: C3EEDE  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
DF0E: E1      	unkwn4:	pop	hl
DF0F: 3D      		dec	a		;normal end of file?
DF10: C27EDF  		jp	nz,unkwn0
DF13: CD73DC  		call	resetdr		;yes, reset previous drive.
DF16: CD5EDA  		call	convfst		;convert the first file name that follows
DF19: 21FDDF  		ld	hl,chgdrv	;command name.
DF1C: E5      		push	hl
DF1D: 7E      		ld	a,(hl)		;set drive code in default fcb.
DF1E: 32DADF  		ld	(fcb),a
DF21: 3E10    		ld	a,16		;put second name 16 bytes later.
DF23: CD60DA  		call	convert		;convert second file name.
DF26: E1      		pop	hl
DF27: 7E      		ld	a,(hl)		;and set the drive for this second file.
DF28: 32EADF  		ld	(fcb+16),a
DF2B: AF      		xor	a		;clear record byte in fcb.
DF2C: 32FADF  		ld	(fcb+32),a
DF2F: 115C00  		ld	de,tfcb		;move it into place at(005ch).
DF32: 21DADF  		ld	hl,fcb
DF35: 0621    		ld	b,33
DF37: CD4FDC  		call	hl2de
DF3A: 2108D8  		ld	hl,inbuff+2	;now move the remainder of the input
DF3D: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
DF3E: B7      		or	a		;or a null.
DF3F: CA4BDF  		jp	z,unkwn6
DF42: FE20    		cp	' '
DF44: CA4BDF  		jp	z,unkwn6
DF47: 23      		inc	hl
DF48: C33DDF  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
DF4B: 0600    	unkwn6:	ld	b,0		;keep a character count.
DF4D: 118100  		ld	de,tbuff+1	;data gets put here.
DF50: 7E      	unkwn7:	ld	a,(hl)		;move it now.
DF51: 12      		ld	(de),a
DF52: B7      		or	a
DF53: CA5CDF  		jp	z,unkwn8
DF56: 04      		inc	b
DF57: 23      		inc	hl
DF58: 13      		inc	de
DF59: C350DF  		jp	unkwn7
DF5C: 78      	unkwn8:	ld	a,b		;now store the character count.
DF5D: 328000  		ld	(tbuff),a
DF60: CD98D8  		call	crlf		;clean up the screen.
DF63: CDD5D9  		call	stddma		;set standard transfer address.
DF66: CD1AD9  		call	setcdrv		;reset current drive.
DF69: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
DF6C: 31B8DF  		ld	sp,batch	;set stack first off.
DF6F: CD29D9  		call	movecd		;move current drive into place (tdrive).
DF72: CDBDD8  		call	dsksel		;and reselect it.
DF75: C382DB  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
DF78: CD73DC  	unkwn9:	call	resetdr		;inproper format.
DF7B: C309DA  		jp	synerr
DF7E: 0187DF  	unkwn0:	ld	bc,badload	;read error or won't fit.
DF81: CDA7D8  		call	pline
DF84: C393DF  		jp	getback
DF87: 42616420	badload:defb	'Bad load',0
DF8B: 6C6F6164	
DF8F: 00      	
DF90: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
DF93: CD73DC  	getback:call	resetdr		;reset previous drive.
DF96: CD5EDA  	getback1: call	convfst		;convert first name in (fcb).
DF99: 3ADBDF  		ld	a,(fcb+1)	;if this was just a drive change request,
DF9C: D620    		sub	' '		;make sure it was valid.
DF9E: 21FDDF  		ld	hl,chgdrv
DFA1: B6      		or	(hl)
DFA2: C209DA  		jp	nz,synerr
DFA5: C382DB  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
DFA8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DFAC: 00...   	
DFB8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
DFB8: 00      	batch:	defb	0		;batch mode flag (0=not active).
DFB9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DFBD: 20202020	
DFC1: 20535542	
DFC5: 00000000	
DFC9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
DFDA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
DFDE: 20202020	
DFE2: 20202020	
DFE6: 00000000	
DFEA: 00202020	
DFEE: 20202020	
DFF2: 20202020	
DFF6: 00000000	
DFFA: 00      	
DFFB: 00      	rtncode:defb	0		;status returned from bdos call.
DFFC: 00      	cdrive:	defb	0		;currently active drive.
DFFD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
DFFE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E000: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E004: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E006: C314E0  	fbase:	jp	fbase1
E009: C345EE  		jp	boot
              	;
              	;   bdos error table.
              	;
E00C: 9FE0    	badsctr:defw	error1		;bad sector on read or write.
E00E: ABE0    	badslct:defw	error2		;bad disk select.
E010: B1E0    	rodisk:	defw	error3		;disk is read only.
E012: B7E0    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E014: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E015: 2249E3  		ld	(params),hl
E018: EB      		ex	de,hl
E019: 7B      		ld	a,e		;and save register (e) in particular.
E01A: 32DCED  		ld	(eparam),a
E01D: 210000  		ld	hl,0
E020: 224BE3  		ld	(status),hl	;clear return status.
E023: 39      		add	hl,sp
E024: 2215E3  		ld	(usrstack),hl	;save users stack pointer.
E027: 3147E3  		ld	sp,stkarea	;and set our own.
E02A: AF      		xor	a		;clear auto select storage space.
E02B: 32E6ED  		ld	(autoflag),a
E02E: 32E4ED  		ld	(auto),a
E031: 217AED  		ld	hl,goback	;set return address.
E034: E5      		push	hl
E035: CD65EF  		call	syshook		; see if anyone wants to intercept the call
E038: 79      		ld	a,c		;get function number.
E039: FE29    		cp	nfuncts		;valid function number?
E03B: D0      		ret	nc
E03C: 4B      		ld	c,e		;keep single register function here.
E03D: 214DE0  		ld	hl,functns	;now look thru the function table.
E040: 5F      		ld	e,a
E041: 1600    		ld	d,0		;(de)=function number.
E043: 19      		add	hl,de
E044: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E045: 5E      		ld	e,(hl)
E046: 23      		inc	hl
E047: 56      		ld	d,(hl)		;now (de)=address for this function.
E048: 2A49E3  		ld	hl,(params)	;retrieve parameters.
E04B: EB      		ex	de,hl		;now (de) has the original parameters.
E04C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E04D: 53EECEE2	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E051: 96E1D4E2	
E055: C9EEC5EE	
E059: DAE2F3E2	
E05D: F9E2FEE2		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E061: E7E104E3	
E065: 84EC89EC	
E069: 4BECA2EC	
E06D: ABECB1EC		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E071: CEECDDEC	
E075: E6ECECEC	
E079: F2EC    	
E07B: FBEC04ED		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E07F: 0AED10ED	
E083: 17ED32E5	
E087: 1DED23ED	
E08B: 2CED33ED		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E08F: 47ED4DED	
E093: 53ED14EC	
E097: 59ED0AE3	
E09B: 0AE3A1ED		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E09F: 21D0E0  	error1:	ld	hl,badsec	;bad sector message.
E0A2: CDEBE0  		call	prterr		;print it and get a 1 char responce.
E0A5: FE03    		cp	cntrlc		;re-boot request (control-c)?
E0A7: CA0000  		jp	z,0		;yes.
E0AA: C9      		ret			;no, return to retry i/o function.
              	;
E0AB: 21DBE0  	error2:	ld	hl,badsel	;bad drive selected.
E0AE: C3BAE0  		jp	error5
              	;
E0B1: 21E7E0  	error3:	ld	hl,diskro	;disk is read only.
E0B4: C3BAE0  		jp	error5
              	;
E0B7: 21E2E0  	error4:	ld	hl,filero	;file is read only.
              	;
E0BA: CDEBE0  	error5:	call	prterr
E0BD: C30000  		jp	0		;always reboot on these errors.
              	;
E0C0: 42646F73	bdoserr:defb	'Bdos Err on '
E0C4: 20457272	
E0C8: 206F6E20	
E0CC: 203A2024	bdosdrv:defb	' : $'
E0D0: 42616420	badsec:	defb	'Bad Sector$'
E0D4: 53656374	
E0D8: 6F7224  	
E0DB: 53656C65	badsel:	defb	'Select$'
E0DF: 637424  	
E0E2: 46696C65	filero:	defb	'File '
E0E6: 20      	
E0E7: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E0EB: E5      	prterr:	push	hl		;save second message pointer.
E0EC: CDCFE1  		call	outcrlf		;send (cr)(lf).
E0EF: 3A48E3  		ld	a,(active)	;get active drive.
E0F2: C641    		add	a,'A'		;make ascii.
E0F4: 32CCE0  		ld	(bdosdrv),a	;and put in message.
E0F7: 01C0E0  		ld	bc,bdoserr	;and print it.
E0FA: CDD9E1  		call	prtmesg
E0FD: C1      		pop	bc		;print second message line now.
E0FE: CDD9E1  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E101: 2114E3  	getchar:ld	hl,charbuf	;check character buffer.
E104: 7E      		ld	a,(hl)		;anything present already?
E105: 3600    		ld	(hl),0		;...either case clear it.
E107: B7      		or	a
E108: C0      		ret	nz		;yes, use it.
E109: C3ADEE  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E10C: CD01E1  	getecho:call	getchar		;input a character.
E10F: CD1AE1  		call	chkchar		;carriage control?
E112: D8      		ret	c		;no, a regular control char so don't echo.
E113: F5      		push	af		;ok, save character now.
E114: 4F      		ld	c,a
E115: CD96E1  		call	outcon		;and echo it.
E118: F1      		pop	af		;get character and return.
E119: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E11A: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E11C: C8      		ret	z		;or a tab.
E11D: FE0A    		cp	lf
E11F: C8      		ret	z
E120: FE09    		cp	tab
E122: C8      		ret	z
E123: FE08    		cp	bs
E125: C8      		ret	z
E126: FE20    		cp	' '		;other control char? set carry flag.
E128: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E129: 3A14E3  	ckconsol: ld	a,(charbuf)	;check buffer.
E12C: B7      		or	a		;if anything, just return without checking.
E12D: C24BE1  		jp	nz,ckcon2
E130: CDA2EE  		call	const		;nothing in buffer. check console.
E133: E601    		and	01h		;look at bit 0.
E135: C8      		ret	z		;return if nothing.
E136: CDADEE  		call	conin		;ok, get it.
E139: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E13B: C248E1  		jp	nz,ckcon1
E13E: CDADEE  		call	conin		;halt processing until another char
E141: FE03    		cp	cntrlc		;is typed. control-c?
E143: CA0000  		jp	z,0		;yes, reboot now.
E146: AF      		xor	a		;no, just pretend nothing was ever ready.
E147: C9      		ret	
E148: 3214E3  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E14B: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E14D: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E14E: 3A10E3  	outchar:ld	a,(outflag)	;check output flag.
E151: B7      		or	a		;anything and we won't generate output.
E152: C268E1  		jp	nz,outchr1
E155: C5      		push	bc
E156: CD29E1  		call	ckconsol	;check console (we don't care whats there).
E159: C1      		pop	bc
E15A: C5      		push	bc
E15B: CDB9EE  		call	conout		;output (c) to the screen.
E15E: C1      		pop	bc
E15F: C5      		push	bc
E160: 3A13E3  		ld	a,(prtflag)	;check printer flip-flop flag.
E163: B7      		or	a
E164: C4C5EE  		call	nz,list		;print it also if non-zero.
E167: C1      		pop	bc
E168: 79      	outchr1:ld	a,c		;update cursors position.
E169: 2112E3  		ld	hl,curpos
E16C: FE7F    		cp	del		;rubouts don't do anything here.
E16E: C8      		ret	z
E16F: 34      		inc	(hl)		;bump line pointer.
E170: FE20    		cp	' '		;and return if a normal character.
E172: D0      		ret	nc
E173: 35      		dec	(hl)		;restore and check for the start of the line.
E174: 7E      		ld	a,(hl)
E175: B7      		or	a
E176: C8      		ret	z		;ingnore control characters at the start of the line.
E177: 79      		ld	a,c
E178: FE08    		cp	bs		;is it a backspace?
E17A: C27FE1  		jp	nz,outchr2
E17D: 35      		dec	(hl)		;yes, backup pointer.
E17E: C9      		ret	
E17F: FE0A    	outchr2:cp	lf		;is it a line feed?
E181: C0      		ret	nz		;ignore anything else.
E182: 3600    		ld	(hl),0		;reset pointer to start of line.
E184: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E185: 79      	showit:	ld	a,c
E186: CD1AE1  		call	chkchar		;check character.
E189: D296E1  		jp	nc,outcon	;not a control, use normal output.
E18C: F5      		push	af
E18D: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E18F: CD4EE1  		call	outchar
E192: F1      		pop	af
E193: F640    		or	'@'		;and then use the letter equivelant.
E195: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E196: 79      	outcon:	ld	a,c
E197: FE09    		cp	tab		;is it a tab?
E199: C24EE1  		jp	nz,outchar	;use regular output.
E19C: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E19E: CD4EE1  		call	outchar
E1A1: 3A12E3  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E1A4: E607    		and	07h		;position.
E1A6: C29CE1  		jp	nz,outcon1
E1A9: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E1AA: CDB2E1  	backup:	call	backup1		;backup the screen 1 place.
E1AD: 0E20    		ld	c,' '		;then blank that character.
E1AF: CDB9EE  		call	conout
E1B2: 0E08    	backup1:ld	c,bs		;then back space once more.
E1B4: C3B9EE  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E1B7: 0E23    	newline:ld	c,'#'
E1B9: CD4EE1  		call	outchar		;print this.
E1BC: CDCFE1  		call	outcrlf		;start new line.
E1BF: 3A12E3  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E1C2: 2111E3  		ld	hl,starting
E1C5: BE      		cp	(hl)
E1C6: D0      		ret	nc		;there yet?
E1C7: 0E20    		ld	c,' '
E1C9: CD4EE1  		call	outchar		;nope, keep going.
E1CC: C3BFE1  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E1CF: 0E0D    	outcrlf:ld	c,cr
E1D1: CD4EE1  		call	outchar
E1D4: 0E0A    		ld	c,lf
E1D6: C34EE1  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E1D9: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E1DA: FE24    		cp	'$'
E1DC: C8      		ret	z
E1DD: 03      		inc	bc
E1DE: C5      		push	bc		;otherwise, bump pointer and print it.
E1DF: 4F      		ld	c,a
E1E0: CD96E1  		call	outcon
E1E3: C1      		pop	bc
E1E4: C3D9E1  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E1E7: 3A12E3  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E1EA: 3211E3  		ld	(starting),a
E1ED: 2A49E3  		ld	hl,(params)	;get the maximum buffer space.
E1F0: 4E      		ld	c,(hl)
E1F1: 23      		inc	hl		;point to first available space.
E1F2: E5      		push	hl		;and save.
E1F3: 0600    		ld	b,0		;keep a character count.
E1F5: C5      	rdbuf1:	push	bc
E1F6: E5      		push	hl
E1F7: CD01E1  	rdbuf2:	call	getchar		;get the next input character.
E1FA: E67F    		and	7fh		;strip bit 7.
E1FC: E1      		pop	hl		;reset registers.
E1FD: C1      		pop	bc
E1FE: FE0D    		cp	cr		;en of the line?
E200: CAC7E2  		jp	z,rdbuf17
E203: FE0A    		cp	lf
E205: CAC7E2  		jp	z,rdbuf17
E208: FE08    		cp	bs		;how about a backspace?
E20A: C21CE2  		jp	nz,rdbuf3
E20D: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E20E: B7      		or	a
E20F: CAF5E1  		jp	z,rdbuf1
E212: 05      		dec	b		;ok, update counter.
E213: 3A12E3  		ld	a,(curpos)	;if we backspace to the start of the line,
E216: 3210E3  		ld	(outflag),a	;treat as a cancel (control-x).
E219: C376E2  		jp	rdbuf10
E21C: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E21E: C22CE2  		jp	nz,rdbuf4
E221: 78      		ld	a,b		;ignore at the start of the line.
E222: B7      		or	a
E223: CAF5E1  		jp	z,rdbuf1
E226: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E227: 05      		dec	b		;and reset pointers (counters).
E228: 2B      		dec	hl
E229: C3AFE2  		jp	rdbuf15
E22C: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E22E: C23DE2  		jp	nz,rdbuf5
E231: C5      		push	bc		;yes, do it.
E232: E5      		push	hl
E233: CDCFE1  		call	outcrlf
E236: AF      		xor	a		;and update starting position.
E237: 3211E3  		ld	(starting),a
E23A: C3F7E1  		jp	rdbuf2
E23D: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E23F: C24EE2  		jp	nz,rdbuf6
E242: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E243: 2113E3  		ld	hl,prtflag
E246: 3E01    		ld	a,1		;prtflag=1-prtflag
E248: 96      		sub	(hl)
E249: 77      		ld	(hl),a
E24A: E1      		pop	hl
E24B: C3F5E1  		jp	rdbuf1
E24E: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E250: C265E2  		jp	nz,rdbuf8
E253: E1      		pop	hl
E254: 3A11E3  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E257: 2112E3  		ld	hl,curpos
E25A: BE      		cp	(hl)
E25B: D2E7E1  		jp	nc,rdbuff	;done yet?
E25E: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E25F: CDAAE1  		call	backup
E262: C354E2  		jp	rdbuf7
E265: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E267: C271E2  		jp	nz,rdbuf9
E26A: CDB7E1  		call	newline		;start a new line.
E26D: E1      		pop	hl
E26E: C3E7E1  		jp	rdbuff
E271: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E273: C2ACE2  		jp	nz,rdbuf14
E276: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E277: CDB7E1  		call	newline
E27A: C1      		pop	bc
E27B: E1      		pop	hl
E27C: E5      		push	hl
E27D: C5      		push	bc
E27E: 78      	rdbuf11:ld	a,b		;done whole line yet?
E27F: B7      		or	a
E280: CA90E2  		jp	z,rdbuf12
E283: 23      		inc	hl		;nope, get next character.
E284: 4E      		ld	c,(hl)
E285: 05      		dec	b		;count it.
E286: C5      		push	bc
E287: E5      		push	hl
E288: CD85E1  		call	showit		;and display it.
E28B: E1      		pop	hl
E28C: C1      		pop	bc
E28D: C37EE2  		jp	rdbuf11
E290: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E291: 3A10E3  		ld	a,(outflag)	;then update cursor position.
E294: B7      		or	a
E295: CAF7E1  		jp	z,rdbuf2
E298: 2112E3  		ld	hl,curpos	;because this line is shorter, we must
E29B: 96      		sub	(hl)		;back up the cursor (not the screen however)
E29C: 3210E3  		ld	(outflag),a	;some number of positions.
E29F: CDAAE1  	rdbuf13:call	backup		;note that as long as (outflag) is non
E2A2: 2110E3  		ld	hl,outflag	;zero, the screen will not be changed.
E2A5: 35      		dec	(hl)
E2A6: C29FE2  		jp	nz,rdbuf13
E2A9: C3F7E1  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E2AC: 23      	rdbuf14:inc	hl
E2AD: 77      		ld	(hl),a		;store character.
E2AE: 04      		inc	b		;and count it.
E2AF: C5      	rdbuf15:push	bc
E2B0: E5      		push	hl
E2B1: 4F      		ld	c,a		;echo it now.
E2B2: CD85E1  		call	showit
E2B5: E1      		pop	hl
E2B6: C1      		pop	bc
E2B7: 7E      		ld	a,(hl)		;was it an abort request?
E2B8: FE03    		cp	cntrlc		;control-c abort?
E2BA: 78      		ld	a,b
E2BB: C2C3E2  		jp	nz,rdbuf16
E2BE: FE01    		cp	1		;only if at start of line.
E2C0: CA0000  		jp	z,0
E2C3: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E2C4: DAF5E1  		jp	c,rdbuf1
E2C7: E1      	rdbuf17:pop	hl		;yes end the line and return.
E2C8: 70      		ld	(hl),b
E2C9: 0E0D    		ld	c,cr
E2CB: C34EE1  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E2CE: CD0CE1  	getcon:	call	getecho		;get and echo.
E2D1: C307E3  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E2D4: CDCDEE  	getrdr:	call	reader		;get a character from reader, set status and return.
E2D7: C307E3  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E2DA: 79      	dircio:	ld	a,c		;test for (ff).
E2DB: 3C      		inc	a
E2DC: CAE6E2  		jp	z,dirc1
E2DF: 3C      		inc	a		;test for (fe).
E2E0: CAA2EE  		jp	z,const
E2E3: C3B9EE  		jp	conout		;just output (c).
E2E6: CDA2EE  	dirc1:	call	const		;this is an input request.
E2E9: B7      		or	a
E2EA: CA97ED  		jp	z,goback1	;not ready? just return (directly).
E2ED: CDADEE  		call	conin		;yes, get character.
E2F0: C307E3  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E2F3: 3A0300  	getiob:	ld	a,(iobyte)
E2F6: C307E3  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E2F9: 210300  	setiob:	ld	hl,iobyte
E2FC: 71      		ld	(hl),c
E2FD: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E2FE: EB      	prtstr:	ex	de,hl
E2FF: 4D      		ld	c,l
E300: 44      		ld	b,h		;now (bc) points to it.
E301: C3D9E1  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E304: CD29E1  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E307: 324BE3  	setstat:ld	(status),a
E30A: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E30B: 3E01    	ioerr1:	ld	a,1
E30D: C307E3  		jp	setstat
              	;
E310: 00      	outflag:defb	0		;output flag (non zero means no output).
E311: 02      	starting: defb	2		;starting position for cursor.
E312: 00      	curpos:	defb	0		;cursor position (0=start of line).
E313: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E314: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E315: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E317: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E31B: 00...   	
E32F: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E333: 00...   	
E347:         	stkarea equ	$		;end of stack area.
              	;
E347: 00      	userno:	defb	0		;current user number.
E348: 00      	active:	defb	0		;currently active drive.
E349: 0000    	params:	defw	0		;save (de) parameters here on entry.
E34B: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E34D: 210EE0  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E350: 5E      	jumphl:	ld	e,(hl)
E351: 23      		inc	hl
E352: 56      		ld	d,(hl)		;now (de) contain the desired address.
E353: EB      		ex	de,hl
E354: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E355: 0C      	de2hl:	inc	c		;is count down to zero?
E356: 0D      	de2hl1:	dec	c
E357: C8      		ret	z		;yes, we are done.
E358: 1A      		ld	a,(de)		;no, move one more byte.
E359: 77      		ld	(hl),a
E35A: 13      		inc	de
E35B: 23      		inc	hl
E35C: C356E3  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E35F: 3A48E3  	select:	ld	a,(active)	;get active disk.
E362: 4F      		ld	c,a
E363: CDE0EE  		call	seldsk		;select it.
E366: 7C      		ld	a,h		;valid drive?
E367: B5      		or	l		;valid drive?
E368: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E369: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E36A: 23      		inc	hl
E36B: 56      		ld	d,(hl)
E36C: 23      		inc	hl
E36D: 22B9ED  		ld	(scratch1),hl	;save pointers to scratch areas.
E370: 23      		inc	hl
E371: 23      		inc	hl
E372: 22BBED  		ld	(scratch2),hl	;ditto.
E375: 23      		inc	hl
E376: 23      		inc	hl
E377: 22BDED  		ld	(scratch3),hl	;ditto.
E37A: 23      		inc	hl
E37B: 23      		inc	hl
E37C: EB      		ex	de,hl		;now save the translation table address.
E37D: 22D6ED  		ld	(xlate),hl
E380: 21BFED  		ld	hl,dirbuf	;put the next 8 bytes here.
E383: 0E08    		ld	c,8		;they consist of the directory buffer
E385: CD55E3  		call	de2hl		;pointer, parameter block pointer,
E388: 2AC1ED  		ld	hl,(diskpb)	;check and allocation vectors.
E38B: EB      		ex	de,hl
E38C: 21C7ED  		ld	hl,sectors	;move parameter block into our ram.
E38F: 0E0F    		ld	c,15		;it is 15 bytes long.
E391: CD55E3  		call	de2hl
E394: 2ACCED  		ld	hl,(dsksize)	;check disk size.
E397: 7C      		ld	a,h		;more than 256 blocks on this?
E398: 21E3ED  		ld	hl,bigdisk
E39B: 36FF    		ld	(hl),0ffh	;set to samll.
E39D: B7      		or	a
E39E: CAA3E3  		jp	z,select1
E3A1: 3600    		ld	(hl),0		;wrong, set to large.
E3A3: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E3A5: B7      		or	a
E3A6: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E3A7: CDDBEE  	homedrv:call	home		;home the head.
E3AA: AF      		xor	a
E3AB: 2ABBED  		ld	hl,(scratch2)	;set our track pointer also.
E3AE: 77      		ld	(hl),a
E3AF: 23      		inc	hl
E3B0: 77      		ld	(hl),a
E3B1: 2ABDED  		ld	hl,(scratch3)	;and our sector pointer.
E3B4: 77      		ld	(hl),a
E3B5: 23      		inc	hl
E3B6: 77      		ld	(hl),a
E3B7: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E3B8: CD0CEF  	doread:	call	read
E3BB: C3C1E3  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E3BE: CD10EF  	dowrite:call	write
E3C1: B7      	ioret:	or	a
E3C2: C8      		ret	z		;return unless an error occured.
E3C3: 210CE0  		ld	hl,badsctr	;bad read/write on this sector.
E3C6: C350E3  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E3C9: 2AF0ED  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E3CC: 0E02    		ld	c,2		;in directory and compute sector #.
E3CE: CDF0E4  		call	shiftr		;sector #=file-position/4.
E3D1: 22EBED  		ld	(blknmbr),hl	;save this as the block number of interest.
E3D4: 22F2ED  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E3D7: 21EBED  	trksec1:ld	hl,blknmbr
E3DA: 4E      		ld	c,(hl)		;move sector number into (bc).
E3DB: 23      		inc	hl
E3DC: 46      		ld	b,(hl)
E3DD: 2ABDED  		ld	hl,(scratch3)	;get current sector number and
E3E0: 5E      		ld	e,(hl)		;move this into (de).
E3E1: 23      		inc	hl
E3E2: 56      		ld	d,(hl)
E3E3: 2ABBED  		ld	hl,(scratch2)	;get current track number.
E3E6: 7E      		ld	a,(hl)		;and this into (hl).
E3E7: 23      		inc	hl
E3E8: 66      		ld	h,(hl)
E3E9: 6F      		ld	l,a
E3EA: 79      	trksec2:ld	a,c		;is desired sector before current one?
E3EB: 93      		sub	e
E3EC: 78      		ld	a,b
E3ED: 9A      		sbc	a,d
E3EE: D200E4  		jp	nc,trksec3
E3F1: E5      		push	hl		;yes, decrement sectors by one track.
E3F2: 2AC7ED  		ld	hl,(sectors)	;get sectors per track.
E3F5: 7B      		ld	a,e
E3F6: 95      		sub	l
E3F7: 5F      		ld	e,a
E3F8: 7A      		ld	a,d
E3F9: 9C      		sbc	a,h
E3FA: 57      		ld	d,a		;now we have backed up one full track.
E3FB: E1      		pop	hl
E3FC: 2B      		dec	hl		;adjust track counter.
E3FD: C3EAE3  		jp	trksec2
E400: E5      	trksec3:push	hl		;desired sector is after current one.
E401: 2AC7ED  		ld	hl,(sectors)	;get sectors per track.
E404: 19      		add	hl,de		;bump sector pointer to next track.
E405: DA15E4  		jp	c,trksec4
E408: 79      		ld	a,c		;is desired sector now before current one?
E409: 95      		sub	l
E40A: 78      		ld	a,b
E40B: 9C      		sbc	a,h
E40C: DA15E4  		jp	c,trksec4
E40F: EB      		ex	de,hl		;not yes, increment track counter
E410: E1      		pop	hl		;and continue until it is.
E411: 23      		inc	hl
E412: C300E4  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E415: E1      	trksec4:pop	hl		;get track number (hl).
E416: C5      		push	bc
E417: D5      		push	de
E418: E5      		push	hl
E419: EB      		ex	de,hl
E41A: 2AD4ED  		ld	hl,(offset)	;adjust for first track offset.
E41D: 19      		add	hl,de
E41E: 44      		ld	b,h
E41F: 4D      		ld	c,l
E420: CDFEEE  		call	settrk		;select this track.
E423: D1      		pop	de		;reset current track pointer.
E424: 2ABBED  		ld	hl,(scratch2)
E427: 73      		ld	(hl),e
E428: 23      		inc	hl
E429: 72      		ld	(hl),d
E42A: D1      		pop	de
E42B: 2ABDED  		ld	hl,(scratch3)	;reset the first sector on this track.
E42E: 73      		ld	(hl),e
E42F: 23      		inc	hl
E430: 72      		ld	(hl),d
E431: C1      		pop	bc
E432: 79      		ld	a,c		;now subtract the desired one.
E433: 93      		sub	e		;to make it relative (1-# sectors/track).
E434: 4F      		ld	c,a
E435: 78      		ld	a,b
E436: 9A      		sbc	a,d
E437: 47      		ld	b,a
E438: 2AD6ED  		ld	hl,(xlate)	;translate this sector according to this table.
E43B: EB      		ex	de,hl
E43C: CD17EF  		call	sectrn		;let the bios translate it.
E43F: 4D      		ld	c,l
E440: 44      		ld	b,h
E441: C302EF  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E444: 21C9ED  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E447: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E448: 3AE9ED  		ld	a,(savnrec)	;get record number.
E44B: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E44C: 1F      		rra	
E44D: 0D      		dec	c
E44E: C24BE4  		jp	nz,getblk1
E451: 47      		ld	b,a		;save result in (b).
E452: 3E08    		ld	a,8
E454: 96      		sub	(hl)
E455: 4F      		ld	c,a		;compute (c)=8-blkshft.
E456: 3AE8ED  		ld	a,(savext)
E459: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E45A: CA62E4  		jp	z,getblk3
E45D: B7      		or	a
E45E: 17      		rla	
E45F: C359E4  		jp	getblk2
E462: 80      	getblk3:add	a,b
E463: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E464: 2A49E3  	extblk:	ld	hl,(params)	;get fcb address.
E467: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E46A: 19      		add	hl,de
E46B: 09      		add	hl,bc
E46C: 3AE3ED  		ld	a,(bigdisk)	;are we using a big-disk?
E46F: B7      		or	a
E470: CA77E4  		jp	z,extblk1
E473: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E474: 2600    		ld	h,0
E476: C9      		ret	
E477: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E478: 5E      		ld	e,(hl)
E479: 23      		inc	hl
E47A: 56      		ld	d,(hl)
E47B: EB      		ex	de,hl		;return in (hl).
E47C: C9      		ret	
              	;
              	;   compute block number.
              	;
E47D: CD44E4  	comblk:	call	getblock
E480: 4F      		ld	c,a
E481: 0600    		ld	b,0
E483: CD64E4  		call	extblk
E486: 22EBED  		ld	(blknmbr),hl
E489: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E48A: 2AEBED  	chkblk:	ld	hl,(blknmbr)
E48D: 7D      		ld	a,l		;is it zero?
E48E: B4      		or	h
E48F: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E490: 3AC9ED  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E493: 2AEBED  		ld	hl,(blknmbr)	;get physical sector desired.
E496: 29      	logicl1:add	hl,hl		;compute logical sector number.
E497: 3D      		dec	a		;note logical sectors are 128 bytes long.
E498: C296E4  		jp	nz,logicl1
E49B: 22EDED  		ld	(logsect),hl	;save logical sector.
E49E: 3ACAED  		ld	a,(blkmask)	;get block mask.
E4A1: 4F      		ld	c,a
E4A2: 3AE9ED  		ld	a,(savnrec)	;get next sector to access.
E4A5: A1      		and	c		;extract the relative position within physical block.
E4A6: B5      		or	l		;and add it too logical sector.
E4A7: 6F      		ld	l,a
E4A8: 22EBED  		ld	(blknmbr),hl	;and store.
E4AB: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E4AC: 2A49E3  	setext:	ld	hl,(params)
E4AF: 110C00  		ld	de,12		;it is the twelth byte.
E4B2: 19      		add	hl,de
E4B3: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E4B4: 2A49E3  	sethlde:ld	hl,(params)
E4B7: 110F00  		ld	de,15		;record count byte (#15).
E4BA: 19      		add	hl,de
E4BB: EB      		ex	de,hl
E4BC: 211100  		ld	hl,17		;next record number (#32).
E4BF: 19      		add	hl,de
E4C0: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E4C1: CDB4E4  	strdata:call	sethlde
E4C4: 7E      		ld	a,(hl)		;get and store record count byte.
E4C5: 32E9ED  		ld	(savnrec),a
E4C8: EB      		ex	de,hl
E4C9: 7E      		ld	a,(hl)		;get and store next record number byte.
E4CA: 32E7ED  		ld	(savnxt),a
E4CD: CDACE4  		call	setext		;point to extent byte.
E4D0: 3ACBED  		ld	a,(extmask)	;get extent mask.
E4D3: A6      		and	(hl)
E4D4: 32E8ED  		ld	(savext),a	;and save extent here.
E4D7: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E4D8: CDB4E4  	setnrec:call	sethlde
E4DB: 3ADBED  		ld	a,(mode)	;get sequential flag (=1).
E4DE: FE02    		cp	2		;a 2 indicates that no adder is needed.
E4E0: C2E4E4  		jp	nz,stnrec1
E4E3: AF      		xor	a		;clear adder (random access?).
E4E4: 4F      	stnrec1:ld	c,a
E4E5: 3AE9ED  		ld	a,(savnrec)	;get last record number.
E4E8: 81      		add	a,c		;increment record count.
E4E9: 77      		ld	(hl),a		;and set fcb's next record byte.
E4EA: EB      		ex	de,hl
E4EB: 3AE7ED  		ld	a,(savnxt)	;get next record byte from storage.
E4EE: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E4EF: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E4F0: 0C      	shiftr:	inc	c
E4F1: 0D      	shiftr1:dec	c
E4F2: C8      		ret	z
E4F3: 7C      		ld	a,h
E4F4: B7      		or	a
E4F5: 1F      		rra	
E4F6: 67      		ld	h,a
E4F7: 7D      		ld	a,l
E4F8: 1F      		rra	
E4F9: 6F      		ld	l,a
E4FA: C3F1E4  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E4FD: 0E80    	checksum: ld	c,128		;length of buffer.
E4FF: 2ABFED  		ld	hl,(dirbuf)	;get its location.
E502: AF      		xor	a		;clear summation byte.
E503: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E504: 23      		inc	hl
E505: 0D      		dec	c
E506: C203E5  		jp	nz,chksum1
E509: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E50A: 0C      	shiftl:	inc	c
E50B: 0D      	shiftl1:dec	c
E50C: C8      		ret	z
E50D: 29      		add	hl,hl		;shift left 1 bit.
E50E: C30BE5  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E511: C5      	setbit:	push	bc		;save 16 bit word.
E512: 3A48E3  		ld	a,(active)	;get active drive.
E515: 4F      		ld	c,a
E516: 210100  		ld	hl,1
E519: CD0AE5  		call	shiftl		;shift bit 0 into place.
E51C: C1      		pop	bc		;now 'or' this with the original word.
E51D: 79      		ld	a,c
E51E: B5      		or	l
E51F: 6F      		ld	l,a		;low byte done, do high byte.
E520: 78      		ld	a,b
E521: B4      		or	h
E522: 67      		ld	h,a
E523: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E524: 2AB3ED  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E527: 3A48E3  		ld	a,(active)	;which drive is current?
E52A: 4F      		ld	c,a
E52B: CDF0E4  		call	shiftr		;shift status such that bit 0 is the
E52E: 7D      		ld	a,l		;one of interest for this drive.
E52F: E601    		and	01h		;and isolate it.
E531: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E532: 21B3ED  	wrtprtd:ld	hl,wrtprt	;point to status word.
E535: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E536: 23      		inc	hl
E537: 46      		ld	b,(hl)
E538: CD11E5  		call	setbit		;and set this bit according to current drive.
E53B: 22B3ED  		ld	(wrtprt),hl	;then save.
E53E: 2ACEED  		ld	hl,(dirsize)	;now save directory size limit.
E541: 23      		inc	hl		;remember the last one.
E542: EB      		ex	de,hl
E543: 2AB9ED  		ld	hl,(scratch1)	;and store it here.
E546: 73      		ld	(hl),e		;put low byte.
E547: 23      		inc	hl
E548: 72      		ld	(hl),d		;then high byte.
E549: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E54A: CD64E5  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E54D: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E550: 19      		add	hl,de
E551: 7E      		ld	a,(hl)
E552: 17      		rla	
E553: D0      		ret	nc		;return if ok.
E554: 2112E0  		ld	hl,rofile	;else, print error message and terminate.
E557: C350E3  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E55A: CD24E5  	chkwprt:call	getwprt
E55D: C8      		ret	z		;return if ok.
E55E: 2110E0  		ld	hl,rodisk	;else print message and terminate.
E561: C350E3  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E564: 2ABFED  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E567: 3AEFED  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E56A: 85      	adda2hl:add	a,l
E56B: 6F      		ld	l,a
E56C: D0      		ret	nc
E56D: 24      		inc	h		;take care of any carry.
E56E: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E56F: 2A49E3  	gets2:	ld	hl,(params)	;get address of fcb.
E572: 110E00  		ld	de,14		;relative position of 's2'.
E575: 19      		add	hl,de
E576: 7E      		ld	a,(hl)		;extract this byte.
E577: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E578: CD6FE5  	clears2:call	gets2		;this sets (hl) pointing to it.
E57B: 3600    		ld	(hl),0		;now clear it.
E57D: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E57E: CD6FE5  	sets2b7:call	gets2		;get the byte.
E581: F680    		or	80h		;and set bit 7.
E583: 77      		ld	(hl),a		;then store.
E584: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E585: 2AF0ED  	morefls:ld	hl,(filepos)	;we are here.
E588: EB      		ex	de,hl
E589: 2AB9ED  		ld	hl,(scratch1)	;and don't go past here.
E58C: 7B      		ld	a,e		;compute difference but don't keep.
E58D: 96      		sub	(hl)
E58E: 23      		inc	hl
E58F: 7A      		ld	a,d
E590: 9E      		sbc	a,(hl)		;set carry if no more names.
E591: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E592: CD85E5  	chknmbr:call	morefls		;scratch1 too big?
E595: D8      		ret	c
E596: 13      		inc	de		;yes, reset it to (filepos).
E597: 72      		ld	(hl),d
E598: 2B      		dec	hl
E599: 73      		ld	(hl),e
E59A: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E59B: 7B      	subhl:	ld	a,e		;compute difference.
E59C: 95      		sub	l
E59D: 6F      		ld	l,a		;store low byte.
E59E: 7A      		ld	a,d
E59F: 9C      		sbc	a,h
E5A0: 67      		ld	h,a		;and then high byte.
E5A1: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E5A2: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E5A4: 2AF2ED  	checkdir: ld	hl,(cksumtbl)
E5A7: EB      		ex	de,hl
E5A8: 2AD2ED  		ld	hl,(alloc1)
E5AB: CD9BE5  		call	subhl
E5AE: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E5AF: C5      		push	bc
E5B0: CDFDE4  		call	checksum	;else compute checksum.
E5B3: 2AC3ED  		ld	hl,(chkvect)	;get address of checksum table.
E5B6: EB      		ex	de,hl
E5B7: 2AF2ED  		ld	hl,(cksumtbl)
E5BA: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E5BB: C1      		pop	bc
E5BC: 0C      		inc	c		;set or check ?
E5BD: CACAE5  		jp	z,chkdir1
E5C0: BE      		cp	(hl)		;check them.
E5C1: C8      		ret	z		;return if they are the same.
E5C2: CD85E5  		call	morefls		;not the same, do we care?
E5C5: D0      		ret	nc
E5C6: CD32E5  		call	wrtprtd		;yes, mark this as write protected.
E5C9: C9      		ret	
E5CA: 77      	chkdir1:ld	(hl),a		;just set the byte.
E5CB: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E5CC: CDA2E5  	dirwrite: call	setdir		;set checksum byte.
E5CF: CDE6E5  		call	dirdma		;set directory dma address.
E5D2: 0E01    		ld	c,1		;tell the bios to actually write.
E5D4: CDBEE3  		call	dowrite		;then do the write.
E5D7: C3E0E5  		jp	defdma
              	;
              	;   read from the directory.
              	;
E5DA: CDE6E5  	dirread:call	dirdma		;set the directory dma address.
E5DD: CDB8E3  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E5E0: 21B7ED  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E5E3: C3E9E5  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E5E6: 21BFED  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E5E9: 4E      	dirdma1:ld	c,(hl)
E5EA: 23      		inc	hl
E5EB: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E5EC: C306EF  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E5EF: 2ABFED  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E5F2: EB      		ex	de,hl
E5F3: 2AB7ED  		ld	hl,(userdma)	; put it here.
E5F6: 0E80    		ld	c,128		;this is its length.
E5F8: C355E3  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E5FB: 21F0ED  	ckfilpos: ld	hl,filepos
E5FE: 7E      		ld	a,(hl)
E5FF: 23      		inc	hl
E600: BE      		cp	(hl)		;are both bytes the same?
E601: C0      		ret	nz
E602: 3C      		inc	a		;yes, but are they each 0ffh?
E603: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E604: 21FFFF  	stfilpos: ld	hl,0ffffh
E607: 22F0ED  		ld	(filepos),hl
E60A: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
E60B: 2ACEED  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
E60E: EB      		ex	de,hl
E60F: 2AF0ED  		ld	hl,(filepos)	;get current count.
E612: 23      		inc	hl		;go on to the next one.
E613: 22F0ED  		ld	(filepos),hl
E616: CD9BE5  		call	subhl		;(hl)=(dirsize)-(filepos)
E619: D21FE6  		jp	nc,nxent1	;is there more room left?
E61C: C304E6  		jp	stfilpos	;no. set this flag and return.
E61F: 3AF0ED  	nxent1:	ld	a,(filepos)	;get file position within directory.
E622: E603    		and	03h		;only look within this sector (only 4 entries fit).
E624: 0605    		ld	b,5		;convert to relative position (32 bytes each).
E626: 87      	nxent2:	add	a,a		;note that this is not efficient code.
E627: 05      		dec	b		;5 'add a's would be better.
E628: C226E6  		jp	nz,nxent2
E62B: 32EFED  		ld	(fcbpos),a	;save it as position of fcb.
E62E: B7      		or	a
E62F: C0      		ret	nz		;return if we are within buffer.
E630: C5      		push	bc
E631: CDC9E3  		call	trksec		;we need the next directory sector.
E634: CDDAE5  		call	dirread
E637: C1      		pop	bc
E638: C3A4E5  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
E63B: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
E63C: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
E63E: 3C      		inc	a
E63F: 5F      		ld	e,a		;save particular bit number.
E640: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
E641: 79      		ld	a,c
E642: 0F      		rrca			;now shift right 3 bits.
E643: 0F      		rrca	
E644: 0F      		rrca	
E645: E61F    		and	1fh		;and clear bits 7,6,5.
E647: 4F      		ld	c,a
E648: 78      		ld	a,b
E649: 87      		add	a,a		;now shift (b) into bits 7,6,5.
E64A: 87      		add	a,a
E64B: 87      		add	a,a
E64C: 87      		add	a,a
E64D: 87      		add	a,a
E64E: B1      		or	c		;and add in (c).
E64F: 4F      		ld	c,a		;ok, (c) ha been completed.
E650: 78      		ld	a,b		;is there a better way of doing this?
E651: 0F      		rrca	
E652: 0F      		rrca	
E653: 0F      		rrca	
E654: E61F    		and	1fh
E656: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
E657: 2AC5ED  		ld	hl,(alocvect)
E65A: 09      		add	hl,bc
E65B: 7E      		ld	a,(hl)		;now get correct byte.
E65C: 07      	ckbmap1:rlca			;get correct bit into position 0.
E65D: 1D      		dec	e
E65E: C25CE6  		jp	nz,ckbmap1
E661: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
E662: D5      	stbitmap: push	de
E663: CD3BE6  		call	ckbitmap	;get the byte of interest.
E666: E6FE    		and	0feh		;clear the affected bit.
E668: C1      		pop	bc
E669: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
E66A: 0F      	stbmap1:rrca			;restore original bit position.
E66B: 15      		dec	d
E66C: C26AE6  		jp	nz,stbmap1
E66F: 77      		ld	(hl),a		;and stor byte in table.
E670: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
E671: CD64E5  	setfile:call	fcb2hl		;get address of fcb
E674: 111000  		ld	de,16
E677: 19      		add	hl,de		;get to block number bytes.
E678: C5      		push	bc
E679: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
E67B: D1      	setfl1:	pop	de
E67C: 0D      		dec	c		;done all bytes yet?
E67D: C8      		ret	z
E67E: D5      		push	de
E67F: 3AE3ED  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
E682: B7      		or	a
E683: CA8EE6  		jp	z,setfl2
E686: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
E687: E5      		push	hl
E688: 4E      		ld	c,(hl)		;get low byte from table, always
E689: 0600    		ld	b,0		;set high byte to zero.
E68B: C394E6  		jp	setfl3
E68E: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
E68F: C5      		push	bc
E690: 4E      		ld	c,(hl)		;now get both the low and high bytes.
E691: 23      		inc	hl
E692: 46      		ld	b,(hl)
E693: E5      		push	hl
E694: 79      	setfl3:	ld	a,c		;block used?
E695: B0      		or	b
E696: CAA3E6  		jp	z,setfl4
E699: 2ACCED  		ld	hl,(dsksize)	;is this block number within the
E69C: 7D      		ld	a,l		;space on the disk?
E69D: 91      		sub	c
E69E: 7C      		ld	a,h
E69F: 98      		sbc	a,b
E6A0: D462E6  		call	nc,stbitmap	;yes, set the proper bit.
E6A3: E1      	setfl4:	pop	hl		;point to next block number in fcb.
E6A4: 23      		inc	hl
E6A5: C1      		pop	bc
E6A6: C37BE6  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
E6A9: 2ACCED  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
E6AC: 0E03    		ld	c,3
E6AE: CDF0E4  		call	shiftr		;(hl)=(hl)/8.
E6B1: 23      		inc	hl		;at lease 1 byte.
E6B2: 44      		ld	b,h
E6B3: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
E6B4: 2AC5ED  		ld	hl,(alocvect)	;now zero out the table now.
E6B7: 3600    	bitmap1:ld	(hl),0
E6B9: 23      		inc	hl
E6BA: 0B      		dec	bc
E6BB: 78      		ld	a,b
E6BC: B1      		or	c
E6BD: C2B7E6  		jp	nz,bitmap1
E6C0: 2AD0ED  		ld	hl,(alloc0)	;get initial space used by directory.
E6C3: EB      		ex	de,hl
E6C4: 2AC5ED  		ld	hl,(alocvect)	;and put this into map.
E6C7: 73      		ld	(hl),e
E6C8: 23      		inc	hl
E6C9: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
E6CA: CDA7E3  		call	homedrv		;now home the drive.
E6CD: 2AB9ED  		ld	hl,(scratch1)
E6D0: 3603    		ld	(hl),3		;force next directory request to read
E6D2: 23      		inc	hl		;in a sector.
E6D3: 3600    		ld	(hl),0
E6D5: CD04E6  		call	stfilpos	;clear initial file position also.
E6D8: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
E6DA: CD0BE6  		call	nxentry		;and set checksum byte.
E6DD: CDFBE5  		call	ckfilpos	;is there another file?
E6E0: C8      		ret	z
E6E1: CD64E5  		call	fcb2hl		;yes, get its address.
E6E4: 3EE5    		ld	a,0e5h
E6E6: BE      		cp	(hl)		;empty file entry?
E6E7: CAD8E6  		jp	z,bitmap2
E6EA: 3A47E3  		ld	a,(userno)	;no, correct user number?
E6ED: BE      		cp	(hl)
E6EE: C2FCE6  		jp	nz,bitmap3
E6F1: 23      		inc	hl
E6F2: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
E6F3: D624    		sub	'$'
E6F5: C2FCE6  		jp	nz,bitmap3
E6F8: 3D      		dec	a		;yes, set atatus to minus one.
E6F9: 324BE3  		ld	(status),a
E6FC: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
E6FE: CD71E6  		call	setfile
E701: CD92E5  		call	chknmbr		;keep (scratch1) in bounds.
E704: C3D8E6  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
E707: 3ADAED  	ststatus: ld	a,(fndstat)
E70A: C307E3  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
E70D: C5      	samext:	push	bc
E70E: F5      		push	af
E70F: 3ACBED  		ld	a,(extmask)	;get extent mask and use it to
E712: 2F      		cpl			;to compare both extent numbers.
E713: 47      		ld	b,a		;save resulting mask here.
E714: 79      		ld	a,c		;mask first extent and save in (c).
E715: A0      		and	b
E716: 4F      		ld	c,a
E717: F1      		pop	af		;now mask second extent and compare
E718: A0      		and	b		;with the first one.
E719: 91      		sub	c
E71A: E61F    		and	1fh		;(* only check buts 0-4 *)
E71C: C1      		pop	bc		;the zero flag is set if they are the same.
E71D: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
E71E: 3EFF    	findfst:ld	a,0ffh
E720: 32DAED  		ld	(fndstat),a
E723: 21DEED  		ld	hl,counter	;save character count.
E726: 71      		ld	(hl),c
E727: 2A49E3  		ld	hl,(params)	;get filename to match.
E72A: 22DFED  		ld	(savefcb),hl	;and save.
E72D: CD04E6  		call	stfilpos	;clear initial file position (set to 0ffffh).
E730: CDA7E3  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
E733: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
E735: CD0BE6  		call	nxentry		;get next filename entry in directory.
E738: CDFBE5  		call	ckfilpos	;is file position = 0ffffh?
E73B: CA9AE7  		jp	z,fndnxt6	;yes, exit now then.
E73E: 2ADFED  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
E741: EB      		ex	de,hl
E742: 1A      		ld	a,(de)
E743: FEE5    		cp	0e5h		;empty directory entry?
E745: CA50E7  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
E748: D5      		push	de
E749: CD85E5  		call	morefls		;more files in directory?
E74C: D1      		pop	de
E74D: D29AE7  		jp	nc,fndnxt6	;no more. exit now.
E750: CD64E5  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
E753: 3ADEED  		ld	a,(counter)	;get number of bytes (characters) to check.
E756: 4F      		ld	c,a
E757: 0600    		ld	b,0		;initialize byte position counter.
E759: 79      	fndnxt2:ld	a,c		;are we done with the compare?
E75A: B7      		or	a
E75B: CA89E7  		jp	z,fndnxt5
E75E: 1A      		ld	a,(de)		;no, check next byte.
E75F: FE3F    		cp	'?'		;don't care about this character?
E761: CA82E7  		jp	z,fndnxt4
E764: 78      		ld	a,b		;get bytes position in fcb.
E765: FE0D    		cp	13		;don't care about the thirteenth byte either.
E767: CA82E7  		jp	z,fndnxt4
E76A: FE0C    		cp	12		;extent byte?
E76C: 1A      		ld	a,(de)
E76D: CA79E7  		jp	z,fndnxt3
E770: 96      		sub	(hl)		;otherwise compare characters.
E771: E67F    		and	7fh
E773: C233E7  		jp	nz,findnxt	;not the same, check next entry.
E776: C382E7  		jp	fndnxt4		;so far so good, keep checking.
E779: C5      	fndnxt3:push	bc		;check the extent byte here.
E77A: 4E      		ld	c,(hl)
E77B: CD0DE7  		call	samext
E77E: C1      		pop	bc
E77F: C233E7  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
E782: 13      	fndnxt4:inc	de		;bump pointers.
E783: 23      		inc	hl
E784: 04      		inc	b
E785: 0D      		dec	c		;adjust character counter.
E786: C359E7  		jp	fndnxt2
E789: 3AF0ED  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
E78C: E603    		and	03h
E78E: 324BE3  		ld	(status),a
E791: 21DAED  		ld	hl,fndstat
E794: 7E      		ld	a,(hl)
E795: 17      		rla	
E796: D0      		ret	nc
E797: AF      		xor	a
E798: 77      		ld	(hl),a
E799: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
E79A: CD04E6  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
E79D: 3EFF    		ld	a,0ffh		;say not located.
E79F: C307E3  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
E7A2: CD5AE5  	erafile:call	chkwprt		;is disk write protected?
E7A5: 0E0C    		ld	c,12		;only compare file names.
E7A7: CD1EE7  		call	findfst		;get first file name.
E7AA: CDFBE5  	erafil1:call	ckfilpos	;any found?
E7AD: C8      		ret	z		;nope, we must be done.
E7AE: CD4AE5  		call	chkrofl		;is file read only?
E7B1: CD64E5  		call	fcb2hl		;nope, get address of fcb and
E7B4: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
E7B6: 0E00    		ld	c,0		;clear the space from the bit map.
E7B8: CD71E6  		call	setfile
E7BB: CDCCE5  		call	dirwrite	;now write the directory sector back out.
E7BE: CD33E7  		call	findnxt		;find the next file name.
E7C1: C3AAE7  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
E7C4: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
E7C5: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
E7C6: 79      	fndspa1:ld	a,c		;is block 0 specified?
E7C7: B0      		or	b
E7C8: CAD7E7  		jp	z,fndspa2
E7CB: 0B      		dec	bc		;nope, check previous block.
E7CC: D5      		push	de
E7CD: C5      		push	bc
E7CE: CD3BE6  		call	ckbitmap
E7D1: 1F      		rra			;is this block empty?
E7D2: D2F2E7  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
E7D5: C1      		pop	bc		;nope, check some more.
E7D6: D1      		pop	de
              	;
              	;   now look after target block.
              	;
E7D7: 2ACCED  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
E7DA: 7B      		ld	a,e
E7DB: 95      		sub	l
E7DC: 7A      		ld	a,d
E7DD: 9C      		sbc	a,h
E7DE: D2FAE7  		jp	nc,fndspa4
E7E1: 13      		inc	de		;yes, move on to next one.
E7E2: C5      		push	bc
E7E3: D5      		push	de
E7E4: 42      		ld	b,d
E7E5: 4B      		ld	c,e
E7E6: CD3BE6  		call	ckbitmap	;check it.
E7E9: 1F      		rra			;empty?
E7EA: D2F2E7  		jp	nc,fndspa3
E7ED: D1      		pop	de		;nope, continue searching.
E7EE: C1      		pop	bc
E7EF: C3C6E7  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
E7F2: 17      	fndspa3:rla			;reset byte.
E7F3: 3C      		inc	a		;and set bit 0.
E7F4: CD6AE6  		call	stbmap1		;update bit map.
E7F7: E1      		pop	hl		;set return registers.
E7F8: D1      		pop	de
E7F9: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
E7FA: 79      	fndspa4:ld	a,c
E7FB: B0      		or	b
E7FC: C2C6E7  		jp	nz,fndspa1
E7FF: 210000  		ld	hl,0		;set 'not found' status.
E802: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
E803: 0E00    	fcbset:	ld	c,0
E805: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
E807: D5      	update:	push	de
E808: 0600    		ld	b,0		;set (bc) to relative byte position.
E80A: 2A49E3  		ld	hl,(params)	;get address of fcb.
E80D: 09      		add	hl,bc		;compute starting byte.
E80E: EB      		ex	de,hl
E80F: CD64E5  		call	fcb2hl		;get address of fcb to update in directory.
E812: C1      		pop	bc		;set (c) to number of bytes to change.
E813: CD55E3  		call	de2hl
E816: CDC9E3  	update1:call	trksec		;determine the track and sector affected.
E819: C3CCE5  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
E81C: CD5AE5  	chgnames: call	chkwprt		;check for a write protected disk.
E81F: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
E821: CD1EE7  		call	findfst		;get first name.
E824: 2A49E3  		ld	hl,(params)	;get address of fcb.
E827: 7E      		ld	a,(hl)		;get user number.
E828: 111000  		ld	de,16		;move over to desired name.
E82B: 19      		add	hl,de
E82C: 77      		ld	(hl),a		;keep same user number.
E82D: CDFBE5  	chgnam1:call	ckfilpos	;any matching file found?
E830: C8      		ret	z		;no, we must be done.
E831: CD4AE5  		call	chkrofl		;check for read only file.
E834: 0E10    		ld	c,16		;start 16 bytes into fcb.
E836: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
E838: CD07E8  		call	update
E83B: CD33E7  		call	findnxt		;get te next file name.
E83E: C32DE8  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
E841: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
E843: CD1EE7  		call	findfst		;look for first filename.
E846: CDFBE5  	savatr1:call	ckfilpos	;was one found?
E849: C8      		ret	z		;nope, we must be done.
E84A: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
E84C: 1E0C    		ld	e,12
E84E: CD07E8  		call	update		;update filename and write directory.
E851: CD33E7  		call	findnxt		;and get the next file.
E854: C346E8  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
E857: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
E859: CD1EE7  		call	findfst		;get the first one in directory.
E85C: CDFBE5  		call	ckfilpos	;any at all?
E85F: C8      		ret	z
E860: CDACE4  	openit1:call	setext		;point to extent byte within users fcb.
E863: 7E      		ld	a,(hl)		;and get it.
E864: F5      		push	af		;save it and address.
E865: E5      		push	hl
E866: CD64E5  		call	fcb2hl		;point to fcb in directory.
E869: EB      		ex	de,hl
E86A: 2A49E3  		ld	hl,(params)	;this is the users copy.
E86D: 0E20    		ld	c,32		;move it into users space.
E86F: D5      		push	de
E870: CD55E3  		call	de2hl
E873: CD7EE5  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
E876: D1      		pop	de		;now get the extent byte from this fcb.
E877: 210C00  		ld	hl,12
E87A: 19      		add	hl,de
E87B: 4E      		ld	c,(hl)		;into (c).
E87C: 210F00  		ld	hl,15		;now get the record count byte into (b).
E87F: 19      		add	hl,de
E880: 46      		ld	b,(hl)
E881: E1      		pop	hl		;keep the same extent as the user had originally.
E882: F1      		pop	af
E883: 77      		ld	(hl),a
E884: 79      		ld	a,c		;is it the same as in the directory fcb?
E885: BE      		cp	(hl)
E886: 78      		ld	a,b		;if yes, then use the same record count.
E887: CA91E8  		jp	z,openit2
E88A: 3E00    		ld	a,0		;if the user specified an extent greater than
E88C: DA91E8  		jp	c,openit2	;the one in the directory, then set record count to 0.
E88F: 3E80    		ld	a,128		;otherwise set to maximum.
E891: 2A49E3  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
E894: 110F00  		ld	de,15
E897: 19      		add	hl,de		;compute relative position.
E898: 77      		ld	(hl),a		;and set the record count.
E899: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
E89A: 7E      	moveword: ld	a,(hl)		;check for a zero word.
E89B: 23      		inc	hl
E89C: B6      		or	(hl)		;both bytes zero?
E89D: 2B      		dec	hl
E89E: C0      		ret	nz		;nope, just return.
E89F: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
E8A0: 77      		ld	(hl),a		;this zero space.
E8A1: 13      		inc	de
E8A2: 23      		inc	hl
E8A3: 1A      		ld	a,(de)
E8A4: 77      		ld	(hl),a
E8A5: 1B      		dec	de		;don't disturb these registers.
E8A6: 2B      		dec	hl
E8A7: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
E8A8: AF      	closeit:xor	a		;clear status and file position bytes.
E8A9: 324BE3  		ld	(status),a
E8AC: 32F0ED  		ld	(filepos),a
E8AF: 32F1ED  		ld	(filepos+1),a
E8B2: CD24E5  		call	getwprt		;get write protect bit for this drive.
E8B5: C0      		ret	nz		;just return if it is set.
E8B6: CD6FE5  		call	gets2		;else get the 's2' byte.
E8B9: E680    		and	80h		;and look at bit 7 (file unmodified?).
E8BB: C0      		ret	nz		;just return if set.
E8BC: 0E0F    		ld	c,15		;else look up this file in directory.
E8BE: CD1EE7  		call	findfst
E8C1: CDFBE5  		call	ckfilpos	;was it found?
E8C4: C8      		ret	z		;just return if not.
E8C5: 011000  		ld	bc,16		;set (hl) pointing to records used section.
E8C8: CD64E5  		call	fcb2hl
E8CB: 09      		add	hl,bc
E8CC: EB      		ex	de,hl
E8CD: 2A49E3  		ld	hl,(params)	;do the same for users specified fcb.
E8D0: 09      		add	hl,bc
E8D1: 0E10    		ld	c,16		;this many bytes are present in this extent.
E8D3: 3AE3ED  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
E8D6: B7      		or	a
E8D7: CAEEE8  		jp	z,closeit4
E8DA: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
E8DB: B7      		or	a
E8DC: 1A      		ld	a,(de)		;now get one from directory fcb.
E8DD: C2E1E8  		jp	nz,closeit2
E8E0: 77      		ld	(hl),a		;users byte was zero. update from directory.
E8E1: B7      	closeit2: or	a
E8E2: C2E7E8  		jp	nz,closeit3
E8E5: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
E8E6: 12      		ld	(de),a
E8E7: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
E8E8: C225E9  		jp	nz,closeit7	;then close error if they are not the same.
E8EB: C303E9  		jp	closeit5	;ok so far, get to next byte in fcbs.
E8EE: CD9AE8  	closeit4: call	moveword	;update users fcb if it is zero.
E8F1: EB      		ex	de,hl
E8F2: CD9AE8  		call	moveword	;update directories fcb if it is zero.
E8F5: EB      		ex	de,hl
E8F6: 1A      		ld	a,(de)		;if these two values are no different,
E8F7: BE      		cp	(hl)		;then a close error occured.
E8F8: C225E9  		jp	nz,closeit7
E8FB: 13      		inc	de		;check second byte.
E8FC: 23      		inc	hl
E8FD: 1A      		ld	a,(de)
E8FE: BE      		cp	(hl)
E8FF: C225E9  		jp	nz,closeit7
E902: 0D      		dec	c		;remember 16 bit values.
E903: 13      	closeit5: inc	de		;bump to next item in table.
E904: 23      		inc	hl
E905: 0D      		dec	c		;there are 16 entries only.
E906: C2D3E8  		jp	nz,closeit1	;continue if more to do.
E909: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
E90C: 09      		add	hl,bc
E90D: EB      		ex	de,hl
E90E: 09      		add	hl,bc
E90F: 1A      		ld	a,(de)
E910: BE      		cp	(hl)		;directory's extent already greater than the
E911: DA1DE9  		jp	c,closeit6	;users extent?
E914: 77      		ld	(hl),a		;no, update directory extent.
E915: 010300  		ld	bc,3		;and update the record count byte in
E918: 09      		add	hl,bc		;directories fcb.
E919: EB      		ex	de,hl
E91A: 09      		add	hl,bc
E91B: 7E      		ld	a,(hl)		;get from user.
E91C: 12      		ld	(de),a		;and put in directory.
E91D: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
E91F: 32D8ED  		ld	(closeflg),a
E922: C316E8  		jp	update1		;update the directory now.
E925: 214BE3  	closeit7: ld	hl,status	;set return status and then return.
E928: 35      		dec	(hl)
E929: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
E92A: CD5AE5  	getempty: call	chkwprt		;make sure disk is not write protected.
E92D: 2A49E3  		ld	hl,(params)	;save current parameters (fcb).
E930: E5      		push	hl
E931: 21B2ED  		ld	hl,emptyfcb	;use special one for empty space.
E934: 2249E3  		ld	(params),hl
E937: 0E01    		ld	c,1		;search for first empty spot in directory.
E939: CD1EE7  		call	findfst		;(* only check first byte *)
E93C: CDFBE5  		call	ckfilpos	;none?
E93F: E1      		pop	hl
E940: 2249E3  		ld	(params),hl	;restore original fcb address.
E943: C8      		ret	z		;return if no more space.
E944: EB      		ex	de,hl
E945: 210F00  		ld	hl,15		;point to number of records for this file.
E948: 19      		add	hl,de
E949: 0E11    		ld	c,17		;and clear all of this space.
E94B: AF      		xor	a
E94C: 77      	getmt1:	ld	(hl),a
E94D: 23      		inc	hl
E94E: 0D      		dec	c
E94F: C24CE9  		jp	nz,getmt1
E952: 210D00  		ld	hl,13		;clear the 's1' byte also.
E955: 19      		add	hl,de
E956: 77      		ld	(hl),a
E957: CD92E5  		call	chknmbr		;keep (scratch1) within bounds.
E95A: CD03E8  		call	fcbset		;write out this fcb entry to directory.
E95D: C37EE5  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
E960: AF      	getnext:xor	a
E961: 32D8ED  		ld	(closeflg),a	;clear close flag.
E964: CDA8E8  		call	closeit		;close this extent.
E967: CDFBE5  		call	ckfilpos
E96A: C8      		ret	z		;not there???
E96B: 2A49E3  		ld	hl,(params)	;get extent byte.
E96E: 010C00  		ld	bc,12
E971: 09      		add	hl,bc
E972: 7E      		ld	a,(hl)		;and increment it.
E973: 3C      		inc	a
E974: E61F    		and	1fh		;keep within range 0-31.
E976: 77      		ld	(hl),a
E977: CA89E9  		jp	z,gtnext1	;overflow?
E97A: 47      		ld	b,a		;mask extent byte.
E97B: 3ACBED  		ld	a,(extmask)
E97E: A0      		and	b
E97F: 21D8ED  		ld	hl,closeflg	;check close flag (0ffh is ok).
E982: A6      		and	(hl)
E983: CA94E9  		jp	z,gtnext2	;if zero, we must read in next extent.
E986: C3B2E9  		jp	gtnext3		;else, it is already in memory.
E989: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
E98C: 09      		add	hl,bc
E98D: 34      		inc	(hl)		;and bump it.
E98E: 7E      		ld	a,(hl)		;too many extents?
E98F: E60F    		and	0fh
E991: CABCE9  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
E994: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
E996: CD1EE7  		call	findfst		;find the first one.
E999: CDFBE5  		call	ckfilpos	;none available?
E99C: C2B2E9  		jp	nz,gtnext3
E99F: 3AD9ED  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
E9A2: 3C      		inc	a		;0ffh means reading (so not possible).
E9A3: CABCE9  		jp	z,gtnext5	;or an error.
E9A6: CD2AE9  		call	getempty	;we are writing, get an empty entry.
E9A9: CDFBE5  		call	ckfilpos	;none?
E9AC: CABCE9  		jp	z,gtnext5	;error if true.
E9AF: C3B5E9  		jp	gtnext4		;else we are almost done.
E9B2: CD60E8  	gtnext3:call	openit1		;open this extent.
E9B5: CDC1E4  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
E9B8: AF      		xor	a		;clear status and return.
E9B9: C307E3  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
E9BC: CD0BE3  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
E9BF: C37EE5  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
E9C2: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
E9C4: 32DBED  		ld	(mode),a
E9C7: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
E9C9: 32D9ED  		ld	(rdwrtflg),a
E9CC: CDC1E4  		call	strdata		;put rec# and ext# into fcb.
E9CF: 3AE9ED  		ld	a,(savnrec)	;get next record to read.
E9D2: 21E7ED  		ld	hl,savnxt	;get number of records in extent.
E9D5: BE      		cp	(hl)		;within this extent?
E9D6: DAECE9  		jp	c,rdseq2
E9D9: FE80    		cp	128		;no. is this extent fully used?
E9DB: C201EA  		jp	nz,rdseq3	;no. end-of-file.
E9DE: CD60E9  		call	getnext		;yes, open the next one.
E9E1: AF      		xor	a		;reset next record to read.
E9E2: 32E9ED  		ld	(savnrec),a
E9E5: 3A4BE3  		ld	a,(status)	;check on open, successful?
E9E8: B7      		or	a
E9E9: C201EA  		jp	nz,rdseq3	;no, error.
E9EC: CD7DE4  	rdseq2:	call	comblk		;ok. compute block number to read.
E9EF: CD8AE4  		call	chkblk		;check it. within bounds?
E9F2: CA01EA  		jp	z,rdseq3	;no, error.
E9F5: CD90E4  		call	logical		;convert (blknmbr) to logical sector (128 byte).
E9F8: CDD7E3  		call	trksec1		;set the track and sector for this block #.
E9FB: CDB8E3  		call	doread		;and read it.
E9FE: C3D8E4  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EA01: C30BE3  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EA04: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EA06: 32DBED  		ld	(mode),a
EA09: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EA0B: 32D9ED  		ld	(rdwrtflg),a
EA0E: CD5AE5  		call	chkwprt		;check write protect status.
EA11: 2A49E3  		ld	hl,(params)
EA14: CD4DE5  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EA17: CDC1E4  		call	strdata		;put updated data into fcb.
EA1A: 3AE9ED  		ld	a,(savnrec)	;get record number to write.
EA1D: FE80    		cp	128		;within range?
EA1F: D20BE3  		jp	nc,ioerr1	;no, error(?).
EA22: CD7DE4  		call	comblk		;compute block number.
EA25: CD8AE4  		call	chkblk		;check number.
EA28: 0E00    		ld	c,0		;is there one to write to?
EA2A: C274EA  		jp	nz,wtseq6	;yes, go do it.
EA2D: CD44E4  		call	getblock	;get next block number within fcb to use.
EA30: 32DDED  		ld	(relblock),a	;and save.
EA33: 010000  		ld	bc,0		;start looking for space from the start
EA36: B7      		or	a		;if none allocated as yet.
EA37: CA41EA  		jp	z,wtseq2
EA3A: 4F      		ld	c,a		;extract previous block number from fcb
EA3B: 0B      		dec	bc		;so we can be closest to it.
EA3C: CD64E4  		call	extblk
EA3F: 44      		ld	b,h
EA40: 4D      		ld	c,l
EA41: CDC4E7  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EA44: 7D      		ld	a,l		;check for a zero number.
EA45: B4      		or	h
EA46: C24EEA  		jp	nz,wtseq3
EA49: 3E02    		ld	a,2		;no more space?
EA4B: C307E3  		jp	setstat
EA4E: 22EBED  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EA51: EB      		ex	de,hl		;put block number into (de).
EA52: 2A49E3  		ld	hl,(params)	;now we must update the fcb for this
EA55: 011000  		ld	bc,16		;newly allocated block.
EA58: 09      		add	hl,bc
EA59: 3AE3ED  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EA5C: B7      		or	a
EA5D: 3ADDED  		ld	a,(relblock)	;(* update this entry *)
EA60: CA6AEA  		jp	z,wtseq4	;zero means 16 bit ones.
EA63: CD6AE5  		call	adda2hl		;(hl)=(hl)+(a)
EA66: 73      		ld	(hl),e		;store new block number.
EA67: C372EA  		jp	wtseq5
EA6A: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EA6B: 0600    		ld	b,0
EA6D: 09      		add	hl,bc
EA6E: 09      		add	hl,bc
EA6F: 73      		ld	(hl),e		;stuff block number (de) there.
EA70: 23      		inc	hl
EA71: 72      		ld	(hl),d
EA72: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EA74: 3A4BE3  	wtseq6:	ld	a,(status)	;are we ok so far?
EA77: B7      		or	a
EA78: C0      		ret	nz
EA79: C5      		push	bc		;yes, save write flag for bios (register c).
EA7A: CD90E4  		call	logical		;convert (blknmbr) over to loical sectors.
EA7D: 3ADBED  		ld	a,(mode)	;get access mode flag (1=sequential,
EA80: 3D      		dec	a		;0=random, 2=special?).
EA81: 3D      		dec	a
EA82: C2C1EA  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EA85: C1      		pop	bc
EA86: C5      		push	bc
EA87: 79      		ld	a,c		;get write status flag (2=writing unused space).
EA88: 3D      		dec	a
EA89: 3D      		dec	a
EA8A: C2C1EA  		jp	nz,wtseq9
EA8D: E5      		push	hl
EA8E: 2ABFED  		ld	hl,(dirbuf)	;zero out the directory buffer.
EA91: 57      		ld	d,a		;note that (a) is zero here.
EA92: 77      	wtseq7:	ld	(hl),a
EA93: 23      		inc	hl
EA94: 14      		inc	d		;do 128 bytes.
EA95: F292EA  		jp	p,wtseq7
EA98: CDE6E5  		call	dirdma		;tell the bios the dma address for directory access.
EA9B: 2AEDED  		ld	hl,(logsect)	;get sector that starts current block.
EA9E: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EAA0: 22EBED  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EAA3: C5      		push	bc
EAA4: CDD7E3  		call	trksec1		;determine its track and sector numbers.
EAA7: C1      		pop	bc
EAA8: CDBEE3  		call	dowrite		;now write out 128 bytes of zeros.
EAAB: 2AEBED  		ld	hl,(blknmbr)	;get sector number.
EAAE: 0E00    		ld	c,0		;set normal write flag.
EAB0: 3ACAED  		ld	a,(blkmask)	;determine if we have written the entire
EAB3: 47      		ld	b,a		;physical block.
EAB4: A5      		and	l
EAB5: B8      		cp	b
EAB6: 23      		inc	hl		;prepare for the next one.
EAB7: C2A0EA  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EABA: E1      		pop	hl		;reset next sector number.
EABB: 22EBED  		ld	(blknmbr),hl
EABE: CDE0E5  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EAC1: CDD7E3  	wtseq9:	call	trksec1		;determine track and sector for this write.
EAC4: C1      		pop	bc		;get write status flag.
EAC5: C5      		push	bc
EAC6: CDBEE3  		call	dowrite		;and write this out.
EAC9: C1      		pop	bc
EACA: 3AE9ED  		ld	a,(savnrec)	;get number of records in file.
EACD: 21E7ED  		ld	hl,savnxt	;get last record written.
EAD0: BE      		cp	(hl)
EAD1: DAD8EA  		jp	c,wtseq10
EAD4: 77      		ld	(hl),a		;we have to update record count.
EAD5: 34      		inc	(hl)
EAD6: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EAD8: 00      	wtseq10:nop			;was 'dcr c'
EAD9: 00      		nop			;was 'dcr c'
EADA: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EADD: F5      		push	af
EADE: CD6FE5  		call	gets2		;set 'extent written to' flag.
EAE1: E67F    		and	7fh		;(* clear bit 7 *)
EAE3: 77      		ld	(hl),a
EAE4: F1      		pop	af		;get record count for this extent.
EAE5: FE7F    	wtseq99:cp	127		;is it full?
EAE7: C206EB  		jp	nz,wtseq12
EAEA: 3ADBED  		ld	a,(mode)	;yes, are we in sequential mode?
EAED: FE01    		cp	1
EAEF: C206EB  		jp	nz,wtseq12
EAF2: CDD8E4  		call	setnrec		;yes, set next record number.
EAF5: CD60E9  		call	getnext		;and get next empty space in directory.
EAF8: 214BE3  		ld	hl,status	;ok?
EAFB: 7E      		ld	a,(hl)
EAFC: B7      		or	a
EAFD: C204EB  		jp	nz,wtseq11
EB00: 3D      		dec	a		;yes, set record count to -1.
EB01: 32E9ED  		ld	(savnrec),a
EB04: 3600    	wtseq11:ld	(hl),0		;clear status.
EB06: C3D8E4  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EB09: AF      	position: xor	a		;set random i/o flag.
EB0A: 32DBED  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EB0D: C5      	positn1:push	bc		;save read/write flag.
EB0E: 2A49E3  		ld	hl,(params)	;get address of fcb.
EB11: EB      		ex	de,hl
EB12: 212100  		ld	hl,33		;now get byte 'r0'.
EB15: 19      		add	hl,de
EB16: 7E      		ld	a,(hl)
EB17: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EB19: F5      		push	af
EB1A: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EB1B: 17      		rla	
EB1C: 23      		inc	hl
EB1D: 7E      		ld	a,(hl)
EB1E: 17      		rla	
EB1F: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EB21: 4F      		ld	c,a		;this is the extent byte.
EB22: 7E      		ld	a,(hl)		;now get the extra extent byte.
EB23: 1F      		rra	
EB24: 1F      		rra	
EB25: 1F      		rra	
EB26: 1F      		rra	
EB27: E60F    		and	0fh
EB29: 47      		ld	b,a		;and save it in (b).
EB2A: F1      		pop	af		;get record number back to (a).
EB2B: 23      		inc	hl		;check overflow byte 'r2'.
EB2C: 6E      		ld	l,(hl)
EB2D: 2C      		inc	l
EB2E: 2D      		dec	l
EB2F: 2E06    		ld	l,6		;prepare for error.
EB31: C291EB  		jp	nz,positn5	;out of disk space error.
EB34: 212000  		ld	hl,32		;store record number into fcb.
EB37: 19      		add	hl,de
EB38: 77      		ld	(hl),a
EB39: 210C00  		ld	hl,12		;and now check the extent byte.
EB3C: 19      		add	hl,de
EB3D: 79      		ld	a,c
EB3E: 96      		sub	(hl)		;same extent as before?
EB3F: C24DEB  		jp	nz,positn2
EB42: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EB45: 19      		add	hl,de
EB46: 78      		ld	a,b
EB47: 96      		sub	(hl)
EB48: E67F    		and	7fh
EB4A: CA85EB  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EB4D: C5      	positn2:push	bc
EB4E: D5      		push	de
EB4F: CDA8E8  		call	closeit		;close current extent.
EB52: D1      		pop	de
EB53: C1      		pop	bc
EB54: 2E03    		ld	l,3		;prepare for error.
EB56: 3A4BE3  		ld	a,(status)
EB59: 3C      		inc	a
EB5A: CA8AEB  		jp	z,positn4	;close error.
EB5D: 210C00  		ld	hl,12		;put desired extent into fcb now.
EB60: 19      		add	hl,de
EB61: 71      		ld	(hl),c
EB62: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EB65: 19      		add	hl,de
EB66: 70      		ld	(hl),b
EB67: CD57E8  		call	openit		;try and get this extent.
EB6A: 3A4BE3  		ld	a,(status)	;was it there?
EB6D: 3C      		inc	a
EB6E: C285EB  		jp	nz,positn3
EB71: C1      		pop	bc		;no. can we create a new one (writing?).
EB72: C5      		push	bc
EB73: 2E04    		ld	l,4		;prepare for error.
EB75: 0C      		inc	c
EB76: CA8AEB  		jp	z,positn4	;nope, reading unwritten space error.
EB79: CD2AE9  		call	getempty	;yes we can, try to find space.
EB7C: 2E05    		ld	l,5		;prepare for error.
EB7E: 3A4BE3  		ld	a,(status)
EB81: 3C      		inc	a
EB82: CA8AEB  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EB85: C1      	positn3:pop	bc		;restore stack.
EB86: AF      		xor	a		;and clear error code byte.
EB87: C307E3  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EB8A: E5      	positn4:push	hl
EB8B: CD6FE5  		call	gets2
EB8E: 36C0    		ld	(hl),0c0h
EB90: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EB91: C1      	positn5:pop	bc
EB92: 7D      		ld	a,l		;get error code.
EB93: 324BE3  		ld	(status),a
EB96: C37EE5  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EB99: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EB9B: CD09EB  		call	position	;position the file to proper record.
EB9E: CCC7E9  		call	z,rdseq1	;and read it as usual (if no errors).
EBA1: C9      		ret	
              	;
              	;   write to a random record.
              	;
EBA2: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EBA4: CD09EB  		call	position	;position the file to proper record.
EBA7: CC09EA  		call	z,wtseq1	;and write as usual (if no errors).
EBAA: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EBAB: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EBAC: 19      		add	hl,de		;compute relative position of record #.
EBAD: 4E      		ld	c,(hl)		;get record number into (bc).
EBAE: 0600    		ld	b,0
EBB0: 210C00  		ld	hl,12		;now get extent.
EBB3: 19      		add	hl,de
EBB4: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EBB5: 0F      		rrca			;move lower bit into bit 7.
EBB6: E680    		and	80h		;and ignore all other bits.
EBB8: 81      		add	a,c		;add to our record number.
EBB9: 4F      		ld	c,a
EBBA: 3E00    		ld	a,0		;take care of any carry.
EBBC: 88      		adc	a,b
EBBD: 47      		ld	b,a
EBBE: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EBBF: 0F      		rrca			;bit positions 0-3.
EBC0: E60F    		and	0fh		;and ignore all others.
EBC2: 80      		add	a,b		;add this in to 'r1' byte.
EBC3: 47      		ld	b,a
EBC4: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EBC7: 19      		add	hl,de
EBC8: 7E      		ld	a,(hl)
EBC9: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EBCA: 87      		add	a,a
EBCB: 87      		add	a,a
EBCC: 87      		add	a,a
EBCD: F5      		push	af		;save carry flag (bit 0 of flag byte).
EBCE: 80      		add	a,b		;now add extra extent into 'r1'.
EBCF: 47      		ld	b,a
EBD0: F5      		push	af		;and save carry (overflow byte 'r2').
EBD1: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EBD2: 7D      		ld	a,l
EBD3: E1      		pop	hl		;and same for first carry flag.
EBD4: B5      		or	l		;either one of these set?
EBD5: E601    		and	01h		;only check the carry flags.
EBD7: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EBD8: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EBDA: CD1EE7  		call	findfst		;this name.
EBDD: 2A49E3  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EBE0: 112100  		ld	de,33
EBE3: 19      		add	hl,de
EBE4: E5      		push	hl
EBE5: 72      		ld	(hl),d		;note that (d)=0.
EBE6: 23      		inc	hl
EBE7: 72      		ld	(hl),d
EBE8: 23      		inc	hl
EBE9: 72      		ld	(hl),d
EBEA: CDFBE5  	ransiz1:call	ckfilpos	;is there an extent to process?
EBED: CA12EC  		jp	z,ransiz3	;no, we are done.
EBF0: CD64E5  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EBF3: 110F00  		ld	de,15		;point to last record in extent.
EBF6: CDABEB  		call	comprand	;and compute random parameters.
EBF9: E1      		pop	hl
EBFA: E5      		push	hl		;now check these values against those
EBFB: 5F      		ld	e,a		;already in fcb.
EBFC: 79      		ld	a,c		;the carry flag will be set if those
EBFD: 96      		sub	(hl)		;in the fcb represent a larger size than
EBFE: 23      		inc	hl		;this extent does.
EBFF: 78      		ld	a,b
EC00: 9E      		sbc	a,(hl)
EC01: 23      		inc	hl
EC02: 7B      		ld	a,e
EC03: 9E      		sbc	a,(hl)
EC04: DA0CEC  		jp	c,ransiz2
EC07: 73      		ld	(hl),e		;we found a larger (in size) extent.
EC08: 2B      		dec	hl		;stuff these values into fcb.
EC09: 70      		ld	(hl),b
EC0A: 2B      		dec	hl
EC0B: 71      		ld	(hl),c
EC0C: CD33E7  	ransiz2:call	findnxt		;now get the next extent.
EC0F: C3EAEB  		jp	ransiz1		;continue til all done.
EC12: E1      	ransiz3:pop	hl		;we are done, restore the stack and
EC13: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
EC14: 2A49E3  	setran:	ld	hl,(params)	;point to fcb.
EC17: 112000  		ld	de,32		;and to last used record.
EC1A: CDABEB  		call	comprand	;compute random position.
EC1D: 212100  		ld	hl,33		;now stuff these values into fcb.
EC20: 19      		add	hl,de
EC21: 71      		ld	(hl),c		;move 'r0'.
EC22: 23      		inc	hl
EC23: 70      		ld	(hl),b		;and 'r1'.
EC24: 23      		inc	hl
EC25: 77      		ld	(hl),a		;and lastly 'r2'.
EC26: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
EC27: 2AB5ED  	logindrv: ld	hl,(login)	;get the login vector.
EC2A: 3A48E3  		ld	a,(active)	;get the default drive.
EC2D: 4F      		ld	c,a
EC2E: CDF0E4  		call	shiftr		;position active bit for this drive
EC31: E5      		push	hl		;into bit 0.
EC32: EB      		ex	de,hl
EC33: CD5FE3  		call	select		;select this drive.
EC36: E1      		pop	hl
EC37: CC4DE3  		call	z,slcterr	;valid drive?
EC3A: 7D      		ld	a,l		;is this a newly activated drive?
EC3B: 1F      		rra	
EC3C: D8      		ret	c
EC3D: 2AB5ED  		ld	hl,(login)	;yes, update the login vector.
EC40: 4D      		ld	c,l
EC41: 44      		ld	b,h
EC42: CD11E5  		call	setbit
EC45: 22B5ED  		ld	(login),hl	;and save.
EC48: C3A9E6  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
EC4B: 3ADCED  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
EC4E: 2148E3  		ld	hl,active	;represents a change in drives.
EC51: BE      		cp	(hl)
EC52: C8      		ret	z
EC53: 77      		ld	(hl),a		;yes it does, log it in.
EC54: C327EC  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
EC57: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
EC59: 32E4ED  		ld	(auto),a
EC5C: 2A49E3  		ld	hl,(params)	;get drive specified.
EC5F: 7E      		ld	a,(hl)
EC60: E61F    		and	1fh		;look at lower 5 bits.
EC62: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
EC63: 32DCED  		ld	(eparam),a	;and save for the select routine.
EC66: FE1E    		cp	1eh		;check for 'no change' condition.
EC68: D27BEC  		jp	nc,autosl1	;yes, don't change.
EC6B: 3A48E3  		ld	a,(active)	;we must change, save currently active
EC6E: 32E5ED  		ld	(olddrv),a	;drive.
EC71: 7E      		ld	a,(hl)		;and save first byte of fcb also.
EC72: 32E6ED  		ld	(autoflag),a	;this must be non-zero.
EC75: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
EC77: 77      		ld	(hl),a		;something)?
EC78: CD4BEC  		call	setdsk		;select and log in this drive.
EC7B: 3A47E3  	autosl1:ld	a,(userno)	;move user number into fcb.
EC7E: 2A49E3  		ld	hl,(params)	;(* upper half of first byte *)
EC81: B6      		or	(hl)
EC82: 77      		ld	(hl),a
EC83: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
EC84: 3E22    	getver:	ld	a,022h		;version 2.2
EC86: C307E3  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
EC89: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
EC8C: 22B3ED  		ld	(wrtprt),hl	;in vector.
EC8F: 22B5ED  		ld	(login),hl
EC92: AF      		xor	a		;select drive 'a'.
EC93: 3248E3  		ld	(active),a
EC96: 218000  		ld	hl,tbuff	;setup default dma address.
EC99: 22B7ED  		ld	(userdma),hl
EC9C: CDE0E5  		call	defdma
EC9F: C327EC  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
ECA2: CD78E5  	openfil:call	clears2		;clear 's2' byte.
ECA5: CD57EC  		call	autosel		;select proper disk.
ECA8: C357E8  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
ECAB: CD57EC  	closefil: call	autosel		;select proper disk.
ECAE: C3A8E8  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
ECB1: 0E00    	getfst:	ld	c,0		;prepare for special search.
ECB3: EB      		ex	de,hl
ECB4: 7E      		ld	a,(hl)		;is first byte a '?'?
ECB5: FE3F    		cp	'?'
ECB7: CAC8EC  		jp	z,getfst1	;yes, just get very first entry (zero length match).
ECBA: CDACE4  		call	setext		;get the extension byte from fcb.
ECBD: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
ECBE: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
ECC0: C478E5  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
ECC3: CD57EC  		call	autosel		;select proper drive.
ECC6: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
ECC8: CD1EE7  	getfst1:call	findfst		;find an entry and then move it into
ECCB: C3EFE5  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
ECCE: 2ADFED  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
ECD1: 2249E3  		ld	(params),hl	;other dbos calls are allowed.
ECD4: CD57EC  		call	autosel		;no error will be returned, but the
ECD7: CD33E7  		call	findnxt		;results will be wrong.
ECDA: C3EFE5  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
ECDD: CD57EC  	delfile:call	autosel		;select proper drive.
ECE0: CDA2E7  		call	erafile		;erase the file.
ECE3: C307E7  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
ECE6: CD57EC  	readseq:call	autosel		;select proper drive then read.
ECE9: C3C2E9  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
ECEC: CD57EC  	wrtseq:	call	autosel		;select proper drive then write.
ECEF: C304EA  		jp	wtseq
              	;
              	;   create a file function.
              	;
ECF2: CD78E5  	fcreate:call	clears2		;clear the 's2' byte on all creates.
ECF5: CD57EC  		call	autosel		;select proper drive and get the next
ECF8: C32AE9  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
ECFB: CD57EC  	renfile:call	autosel		;select proper drive and then switch
ECFE: CD1CE8  		call	chgnames	;file names.
ED01: C307E7  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
ED04: 2AB5ED  	getlog:	ld	hl,(login)
ED07: C32FED  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
ED0A: 3A48E3  	getcrnt:ld	a,(active)
ED0D: C307E3  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
ED10: EB      	putdma:	ex	de,hl
ED11: 22B7ED  		ld	(userdma),hl	;save in our space and then get to
ED14: C3E0E5  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
ED17: 2AC5ED  	getaloc:ld	hl,(alocvect)
ED1A: C32FED  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
ED1D: 2AB3ED  	getrov:	ld	hl,(wrtprt)
ED20: C32FED  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
ED23: CD57EC  	setattr:call	autosel		;select proper drive then save attributes.
ED26: CD41E8  		call	saveattr
ED29: C307E7  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
ED2C: 2AC1ED  	getparm:ld	hl,(diskpb)
ED2F: 224BE3  	getprm1:ld	(status),hl
ED32: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
ED33: 3ADCED  	getuser:ld	a,(eparam)	;get parameter.
ED36: FEFF    		cp	0ffh		;get user number?
ED38: C241ED  		jp	nz,setuser
ED3B: 3A47E3  		ld	a,(userno)	;yes, just do it.
ED3E: C307E3  		jp	setstat
ED41: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
ED43: 3247E3  		ld	(userno),a	;bits (0-4) only.
ED46: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
ED47: CD57EC  	rdrandom: call	autosel		;select proper drive and read.
ED4A: C399EB  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
ED4D: CD57EC  	wtrandom: call	autosel		;select proper drive and write.
ED50: C3A2EB  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
ED53: CD57EC  	filesize: call	autosel		;select proper drive and check file length
ED56: C3D8EB  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
ED59: 2A49E3  	logoff:	ld	hl,(params)	;get drives to log off.
ED5C: 7D      		ld	a,l		;for each bit that is set, we want
ED5D: 2F      		cpl			;to clear that bit in (login)
ED5E: 5F      		ld	e,a		;and (wrtprt).
ED5F: 7C      		ld	a,h
ED60: 2F      		cpl	
ED61: 2AB5ED  		ld	hl,(login)	;reset the login vector.
ED64: A4      		and	h
ED65: 57      		ld	d,a
ED66: 7D      		ld	a,l
ED67: A3      		and	e
ED68: 5F      		ld	e,a
ED69: 2AB3ED  		ld	hl,(wrtprt)
ED6C: EB      		ex	de,hl
ED6D: 22B5ED  		ld	(login),hl	;and save.
ED70: 7D      		ld	a,l		;now do the write protect vector.
ED71: A3      		and	e
ED72: 6F      		ld	l,a
ED73: 7C      		ld	a,h
ED74: A2      		and	d
ED75: 67      		ld	h,a
ED76: 22B3ED  		ld	(wrtprt),hl	;and save. all done.
ED79: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
ED7A: 3AE4ED  	goback:	ld	a,(auto)	;was auto select activated?
ED7D: B7      		or	a
ED7E: CA97ED  		jp	z,goback1
ED81: 2A49E3  		ld	hl,(params)	;yes, but was a change made?
ED84: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
ED86: 3AE6ED  		ld	a,(autoflag)
ED89: B7      		or	a
ED8A: CA97ED  		jp	z,goback1
ED8D: 77      		ld	(hl),a		;yes, reset first byte properly.
ED8E: 3AE5ED  		ld	a,(olddrv)	;and get the old drive and select it.
ED91: 32DCED  		ld	(eparam),a
ED94: CD4BEC  		call	setdsk
ED97: 2A15E3  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
ED9A: F9      		ld	sp,hl
ED9B: 2A4BE3  		ld	hl,(status)	;get return status.
ED9E: 7D      		ld	a,l		;force version 1.4 compatability.
ED9F: 44      		ld	b,h
EDA0: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
EDA1: CD57EC  	wtspecl:call	autosel		;select proper drive.
EDA4: 3E02    		ld	a,2		;use special write mode.
EDA6: 32DBED  		ld	(mode),a
EDA9: 0E00    		ld	c,0		;set write indicator.
EDAB: CD0DEB  		call	positn1		;position the file.
EDAE: CC09EA  		call	z,wtseq1	;and write (if no errors).
EDB1: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
EDB2: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
EDB3: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
EDB5: 0000    	login:	defw	0		;drive active word (1 bit per drive).
EDB7: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
EDB9: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
EDBB: 0000    	scratch2: defw	0		;last selected track number.
EDBD: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
EDBF: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
EDC1: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
EDC3: 0000    	chkvect:defw	0		;address of check vector.
EDC5: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
EDC7: 0000    	sectors:defw	0		;sectors per track from bios.
EDC9: 00      	blkshft:defb	0		;block shift.
EDCA: 00      	blkmask:defb	0		;block mask.
EDCB: 00      	extmask:defb	0		;extent mask.
EDCC: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
EDCE: 0000    	dirsize:defw	0		;directory size.
EDD0: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
EDD2: 0000    	alloc1:	defw	0
EDD4: 0000    	offset:	defw	0		;first usable track number.
EDD6: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
EDD8: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
EDD9: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
EDDA: 00      	fndstat:defb	0		;filename found status (0=found first entry).
EDDB: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
EDDC: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
EDDD: 00      	relblock: defb	0		;relative position within fcb of block number written.
EDDE: 00      	counter:defb	0		;byte counter for directory name searches.
EDDF: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
EDE3: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
EDE4: 00      	auto:	defb	0		;if non-zero, then auto select activated.
EDE5: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
EDE6: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
EDE7: 00      	savnxt:	defb	0		;storage for next record number to access.
EDE8: 00      	savext:	defb	0		;storage for extent number of file.
EDE9: 0000    	savnrec:defw	0		;storage for number of records in file.
EDEB: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
EDED: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
EDEF: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
EDF0: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
EDF2: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
EDF6: 00...   	
              		
              	; Small routine to print a decimal 0-19
EE02: FE3A    	printdc:cp	':'
EE04: DA8CD8  		jp	c,print
EE07: D60A    		sub	10
EE09: F5      		push	af
EE0A: 3E31    		ld	a,'1'
EE0C: CD8CD8  		call	print
EE0F: F1      		pop	af
EE10: 18F0    		jr	printdc
              		
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS. 
              	;*
              	;**************************************************************
              	;
EE12: C345EE  		jp	boot
EE15: C353EE  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
EE18: C3A2EE  		jp	const
EE1B: C3ADEE  		jp	conin
EE1E: C3B9EE  		jp	conout
EE21: C3C5EE  		jp	list
EE24: C3C9EE  		jp	punch
EE27: C3CDEE  		jp	reader
EE2A: C3DBEE  		jp	home
EE2D: C3E0EE  		jp	seldsk
EE30: C3FEEE  		jp	settrk
EE33: C302EF  		jp	setsec
EE36: C306EF  		jp	setdma
EE39: C30CEF  		jp	read
EE3C: C310EF  		jp	write
EE3F: C314EF  		jp	prstat
EE42: C317EF  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
EE45: 3100D8  	boot:	ld	sp,cbase
              	
EE48: CD64EE  		call	wbootr
              		
              		; Enable INIT to run
EE4B: 3E06    		ld	a,6
EE4D: 3207D8  		ld	(inbulen),a
              	
              		; Jump to CP/M
EE50: C300D8  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
EE53: 3100D8  	wboot:	ld	sp,cbase
              	
              		; Save IOBYTE
EE56: 3A0300  		ld	a,(iobyte)
EE59: F5      		push	af
              	
              		; Warm boot
EE5A: CD64EE  		call	wbootr
              		
              		; Restore IOBYTE
EE5D: F1      		pop	af
EE5E: 320300  		ld	(iobyte),a
              		
EE61: C300D8  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
EE64: F3      	wbootr:	di
              		
              		; Zero out BSS
EE65: AF      		xor	a
EE66: 21C1F7  		ld	hl,imgtop
EE69: 77      		ld	(hl),a
EE6A: 11C2F7  		ld	de,imgtop+1
EE6D: 013E08  		ld	bc,0xFFFF-imgtop
EE70: EDB0    		ldir
              	
              		; Send init signals to all devices
EE72: 0600    		ld	b,0
EE74: C5      	wboot0:	push	bc
EE75: 216CEF  		ld	hl,bdevsw
EE78: 78      		ld	a,b
EE79: CD29EF  		call	swindir
EE7C: AF      		xor	a
EE7D: 14      		inc	d
EE7E: CC46EF  		call	z,callmj
EE81: C1      		pop	bc
EE82: 04      		inc	b
EE83: 3E14    		ld	a,20
EE85: B8      		cp	b
EE86: 20EC    		jr	nz,wboot0
              	
              		; Call config init
EE88: CD4BEF  		call	cfinit
              	
              		; Load the CCP
EE8B: CD66EF  		call	resccp
              	
              		
              		; Set up lower memory
EE8E: 219AEE  		ld	hl,cpmlow
EE91: 110000  		ld	de,0
EE94: 010800  		ld	bc,8
EE97: EDB0    		ldir
              	
              		; Return
EE99: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
EE9A: C315EE  	cpmlow:	jp	wbootin	; Call jump table version instead
EE9D: 81      		defb	0x81	; Default IOBYTE
EE9E: 00      		defb	0	; Default drive
EE9F: C302E0  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
EEA2: 0600    	const:	ld	b,0
EEA4: CD1AEF  		call	cdindir
EEA7: 14      		inc	d
EEA8: C0      		ret	nz
EEA9: 3C      		inc	a
EEAA: C346EF  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
EEAD: 0600    	conin:	ld	b,0
EEAF: CD1AEF  		call	cdindir
EEB2: 14      		inc	d
EEB3: C0      		ret	nz
EEB4: 3E02    		ld	a,2
EEB6: C346EF  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
EEB9: 0600    	conout:	ld	b,0
EEBB: CD1AEF  	chrout:	call	cdindir
EEBE: 14      		inc	d
EEBF: C0      		ret	nz
EEC0: 3E03    		ld	a,3
EEC2: C346EF  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
EEC5: 0606    	list:	ld	b,6
EEC7: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
EEC9: 0604    	punch:	ld	b,4
EECB: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
EECD: 0602    	reader:	ld	b,2
EECF: CD1AEF  		call	cdindir
EED2: 14      		inc	d
EED3: 3E1A    		ld	a,0x1A
EED5: C0      		ret	nz
EED6: 3E02    		ld	a,2
EED8: C346EF  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
EEDB: 3E01    	home:	ld	a,1
EEDD: C3F8EE  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
EEE0: 79      	seldsk:	ld	a,c
EEE1: 43      		ld	b,e
EEE2: 216CEF  		ld	hl,bdevsw
EEE5: CD29EF  		call	swindir
EEE8: 22F9EE  		ld	(callbd+1),hl
EEEB: 210000  		ld	hl,0
EEEE: 14      		inc	d
EEEF: C0      		ret	nz
EEF0: 2A47EF  		ld	hl,(callmj+1)
EEF3: 22FCEE  		ld	(callbd+4),hl
EEF6: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
EEF8: 21      	callbd:	defb	0x21
EEF9: 0000    		defw	0
EEFB: C3      		defb	0xC3
EEFC: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
EEFE: 3E03    	settrk:	ld	a,3
EF00: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
EF02: 3E04    	setsec:	ld	a,4
EF04: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
EF06: 60      	setdma:	ld	h,b
EF07: 69      		ld	l,c
EF08: 2249EF  		ld	(biodma),hl
EF0B: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
EF0C: 3E05    	read:	ld	a,5
EF0E: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
EF10: 3E06    	write:	ld	a,6
EF12: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
EF14: 3EFF    	prstat:	ld	a,0xFF
EF16: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
EF17: 60      	sectrn:	ld	h,b
EF18: 69      		ld	l,c
EF19: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
EF1A: 04      	cdindir:inc	b
EF1B: 3A0300  		ld	a,(iobyte)
EF1E: 05      	cdindi0:dec	b
EF1F: 2803    		jr	z,cdindi1
EF21: 1F      		rra
EF22: 18FA    		jr	cdindi0
EF24: E603    	cdindi1:and	0x03
EF26: 21ACEF  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
EF29: 110400  	swindir:ld	de,4
EF2C: B7      		or	a
EF2D: 2804    	swindi0:jr	z,swindi1
EF2F: 19      		add	hl,de
EF30: 3D      		dec	a
EF31: 18FA    		jr	swindi0
EF33: 7E      	swindi1:ld	a,(hl)
EF34: 3247EF  		ld	(callmj+1),a
EF37: 23      		inc	hl
EF38: BE      		cp	(hl)
EF39: C8      		ret	z
EF3A: 7E      		ld	a,(hl)
EF3B: 3248EF  		ld	(callmj+2),a
EF3E: 23      		inc	hl
EF3F: 7E      		ld	a,(hl)
EF40: 23      		inc	hl
EF41: 66      		ld	h,(hl)
EF42: 6F      		ld	l,a
EF43: 16FF    		ld	d,255
EF45: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
EF46: C3      	callmj: defb	0xC3
EF47: 0000    		defw	0
              	
              	
              	
              	; Variables
EF49: 0000    	biodma:	defw	0	; Block device DMA address
              	#include "config.asm"
              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0036:         	mem	equ	54		; CP/M image starts at mem*1024
              	
D807:         	inbulen	equ	0xD807	; Address in inbuff length byte
              	
              	;
              	;**************************************************************
              	;*
              	;*              D E V I C E   B S S   B A S E S
              	;*
              	;*        Many devices need a section of uninitialized
              	;*        memory space to hold buffers. This will not
              	;*        be included in the system image to reduce space
              	;*        so their location must be defined here.
              	;*       
              	;*        This memory is usually found above the system image.
              	;*        All memory that is in this area will be automatically
              	;*        zeroed on a warm boot.
              	;*
              	;**************************************************************
              	;
              	
F900:         	dircbuf	equ	0xF900	; 128 bytes
F980:         	tm_bss	equ	0xF980	; 48 bytes
F9B0:         	nd_bss	equ	0xF9B0	; 384 bytes
FB30:         	nf_bss	equ	0xFB30	; 90 bytes
FC00:         	nf_cach equ	0xFC00	; 1024 bytes
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
EF4B: 3E01    	cfinit:	ld	a,0x01		; Bank out ROM
EF4D: D300    		out	(0x00),a
              		
EF4F: 3EC3    		ld	a,0xC3		; Set up IRQ handler
EF51: 323800  		ld	(0x38),a	
EF54: 2162EF  		ld	hl,cfirq
EF57: 223900  		ld	(0x39),hl
              		
EF5A: 3E0E    		ld	a,0x0E		; Enable clock
              		;out	(0x41),a
EF5C: 3E00    		ld	a,0x00
              		;out	(0x40),a
              		
              		
EF5E: ED56    		im	1		; Start interrupts
EF60: F3      		di
EF61: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
EF62: FB      	cfirq:	ei
EF63: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
EF65: C9      	syshook:ret
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
EF66: C35EF3  	resccp:	jp	nd_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
EF69: C363F3  	resgrb:	jp	nd_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EF6C: C2F20000	bdevsw:	defw	ndkdev,	0	; 'A'
EF70: C2F20100		defw	ndkdev,	1	; 'B'
EF74: EAF40000		defw	nfddev,	0	; 'C'
EF78: EAF40100		defw	nfddev,	1	; 'D'
EF7C: 00000000		defw	0,	0	; 'E'
EF80: 00000000		defw	0,	0	; 'F'
EF84: 00000000		defw	0,	0	; 'G'
EF88: 00000000		defw	0,	0	; 'H'
EF8C: 00000000		defw	0,	0	; 'I'
EF90: 00000000		defw	0,	0	; 'J'
EF94: 00000000		defw	0,	0	; 'K'
EF98: 00000000		defw	0,	0	; 'L'
EF9C: 00000000		defw	0,	0	; 'M'
EFA0: 00000000		defw	0,	0	; 'N'
EFA4: 00000000		defw	0,	0	; 'O'
EFA8: 00000000		defw	0,	0	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EFAC: 33F70000	cdevsw:	defw	siodev,	0	; TTY device
EFB0: BCEF0000		defw	vdpdev,	0	; Console device
EFB4: 09F70000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
EFB8: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
              	; Driver jump table
EFBC: B7      	vdpdev:	or	a
EFBD: 2839    		jr	z,tm_init
EFBF: 3D      		dec	a
EFC0: 2819    		jr	z,tm_stat
EFC2: 3D      		dec	a
EFC3: CA61F0  		jp	z,tm_read
EFC6: C3B3F0  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EFC9: F5      	tm_otir:push	af
EFCA: 7E      	tm_oti0:ld	a,(hl)
EFCB: ED79    		out	(c),a
EFCD: 23      		inc	hl
EFCE: 10FA    		djnz	tm_oti0
EFD0: F1      		pop	af
EFD1: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EFD2: F5      	tm_inir:push	af
EFD3: ED78    	tm_inr0:in	a,(c)
EFD5: 77      		ld	(hl),a
EFD6: 23      		inc	hl
EFD7: 10FA    		djnz	tm_inr0
EFD9: F1      		pop	af
EFDA: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
EFDB: 3A85F9  	tm_stat:ld	a,(tm_last)
EFDE: FEE4    		cp	0xE4
EFE0: 2843    		jr	z,tm_scri
EFE2: FEE5    		cp	0xE5
EFE4: 2851    		jr	z,tm_sclf
EFE6: 3A82F9  	tm_sta0:ld	a,(tm_outc)
EFE9: 3C      		inc	a
EFEA: 3EFF    		ld	a,0xFF
EFEC: C0      		ret	nz
EFED: CDCCF1  		call	tm_getc
EFF0: 3282F9  		ld	(tm_outc),a
EFF3: 3C      		inc	a
EFF4: C8      		ret	z
EFF5: 3EFF    		ld	a,0xFF
EFF7: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
EFF8: CD69EF  	tm_init:call	resgrb
              	
              		; Set up registers
EFFB: CD41F0  		call	tm_setp
              		
              		; Set TMS pattern generator block to 0
EFFE: DBA1    		in	a,(tm_latc)
F000: AF      		xor	a
F001: D3A1    		out	(tm_latc),a
F003: 3E84    		ld	a,0x84
F005: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F007: 010040  		ld	bc,0x4000
F00A: CD86F2  		call	tm_addr
F00D: 2100D8  		ld	hl,cbase
F010: 0EA0    		ld	c,tm_data
F012: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F014: 0600    	tm_ini0:ld	b,0
F016: CDC9EF  		call	tm_otir
F019: 3D      		dec	a
F01A: 20F8    		jr	nz,tm_ini0
              		
              		; Clear the terminal
F01C: CD73F2  		call	tm_cls
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F01F: 3EFF    	tm_cloc:ld	a,0xFF
F021: 3282F9  		ld	(tm_outc),a
              	
F024: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F025: 3A83F9  	tm_scri:ld	a,(tm_scro)
F028: B7      		or	a
F029: FE28    		cp	40
F02B: 2808    		jr	z,tm_scr1
F02D: C604    		add	a,4
F02F: 3283F9  	tm_scr0:ld	(tm_scro),a
F032: CD50F2  		call	tm_usco
F035: 18AF    	tm_scr1:jr	tm_sta0
F037: 3A83F9  	tm_sclf:ld	a,(tm_scro)
F03A: B7      		or	a
F03B: 28F8    		jr	z,tm_scr1
F03D: D604    		sub	4
F03F: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
F041: 2A91F2  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
F044: DBA1    		in	a,(tm_latc)
F046: 7C      		ld	a,h
F047: D3A1    		out	(tm_latc),a
F049: 3E80    		ld	a,0x80
F04B: D3A1    		out	(tm_latc),a
F04D: DBA1    		in	a,(tm_latc)
F04F: 3EF0    		ld	a,0xF0
F051: D3A1    		out	(tm_latc),a
F053: 3E81    		ld	a,0x81
F055: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F057: DBA1    		in	a,(tm_latc)
F059: 7D      		ld	a,l
F05A: D3A1    		out	(tm_latc),a
F05C: 3E82    		ld	a,0x82
F05E: D3A1    		out	(tm_latc),a
F060: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F061: 3A80F9  	tm_read:ld	a,(tm_curx)
F064: 4F      		ld	c,a
F065: 3A81F9  		ld	a,(tm_cury)
F068: 57      		ld	d,a
F069: 210010  		ld	hl,0x1000
F06C: 3E50    		ld	a,80
F06E: CD2CF2  		call	tm_chat
F071: DBA0    		in	a,(tm_data)	; char is in A
F073: 57      		ld	d,a		; char key
F074: 5F      		ld	e,a		; blinking char
F075: 0601    		ld	b,1
              		
F077: D5      	tm_rea0:push	de
F078: CDDBEF  		call	tm_stat
F07B: D1      		pop	de
F07C: 3C      		inc	a
F07D: 200D    		jr	nz,tm_rea1
F07F: 5A      		ld	e,d
F080: CD9CF0  		call	tm_rea2
F083: 3A82F9  		ld	a,(tm_outc)
F086: 47      		ld	b,a
F087: CD1FF0  		call	tm_cloc
F08A: 78      		ld	a,b
F08B: C9      		ret
              		
F08C: CDAAF0  	tm_rea1:call	tm_stal
F08F: 10E6    		djnz	tm_rea0
F091: 3E80    		ld	a,0x80
F093: AB      		xor	e
F094: 5F      		ld	e,a
F095: CD9CF0  		call	tm_rea2
F098: 06BE    		ld	b,190
F09A: 18DB    		jr	tm_rea0
              	
              	
F09C: D5      	tm_rea2:push	de
F09D: 3A80F9  		ld	a,(tm_curx)
F0A0: 4F      		ld	c,a
F0A1: 3A81F9  		ld	a,(tm_cury)
F0A4: 57      		ld	d,a
F0A5: CD08F2  		call	tm_putc
F0A8: D1      		pop	de
F0A9: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F0AA: C5      	tm_stal:push	bc
F0AB: 06FF    		ld	b,255
F0AD: C5      	tm_sta1:push	bc
F0AE: C1      		pop	bc
F0AF: 10FC    		djnz	tm_sta1
F0B1: C1      		pop	bc
F0B2: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F0B3: 59      	tm_writ:ld	e,c
F0B4: 3A80F9  		ld	a,(tm_curx)
F0B7: 4F      		ld	c,a
F0B8: 3A81F9  		ld	a,(tm_cury)
F0BB: 57      		ld	d,a
F0BC: CDC8F0  		call	tm_wri0
F0BF: 78      		ld	a,b
F0C0: 3281F9  		ld	(tm_cury),a
F0C3: 79      		ld	a,c
F0C4: 3280F9  		ld	(tm_curx),a
F0C7: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F0C8: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F0C9: 3A84F9  		ld	a,(tm_escs)
F0CC: B7      		or	a		; Process escape code
F0CD: C235F1  		jp	nz,tm_esc
F0D0: 3E1F    		ld	a,0x1F
F0D2: BB      		cp	e
F0D3: D207F1  		jp	nc,tm_wri1	; Process control code
F0D6: C5      		push	bc
F0D7: CD08F2  		call	tm_putc		; Write character
F0DA: C1      		pop	bc
              		
              		; Increment character
F0DB: 0C      	tm_ri	inc	c
F0DC: 3E50    		ld	a,80
F0DE: B9      		cp	c
F0DF: C0      		ret	nz
F0E0: AF      		xor	a
F0E1: 4F      		ld	c,a
F0E2: 04      	tm_lf:  inc	b	; Line feed
F0E3: 3E18    		ld	a,24
F0E5: B8      		cp	b
F0E6: C0      		ret	nz
F0E7: C5      		push	bc
F0E8: CDA6F1  		call	tm_dsco
F0EB: C1      		pop	bc
F0EC: 05      		dec	b
F0ED: C9      		ret
F0EE: AF      	tm_cr:	xor	a	; Carriage return
F0EF: 4F      		ld	c,a
F0F0: C9      		ret
F0F1: 0D      	tm_bs:	dec	c	; Backspace 
F0F2: F0      		ret	p
F0F3: 0E4F    		ld	c,79
F0F5: 05      		dec	b
F0F6: F0      		ret	p
F0F7: AF      		xor	a
F0F8: 47      		ld	b,a
F0F9: 4F      		ld	c,a
F0FA: C9      		ret
F0FB: AF      	tm_up:	xor	a	; Move up
F0FC: B8      		cp	b
F0FD: C8      		ret	z
F0FE: 05      		dec	b
F0FF: C9      		ret
F100: CD73F2  	tm_cshm:call	tm_cls
F103: AF      	tm_home:xor	a
F104: 47      		ld	b,a
F105: 4F      		ld	c,a
F106: C9      		ret
              	
F107: 7B      	tm_wri1:ld	a,e
F108: FE08    		cp	0x08	; '\b' (Cursor left)
F10A: 28E5    		jr	z,tm_bs
F10C: FE12    		cp	0x12	; Cursor right
F10E: 28CB    		jr	z,tm_ri
F110: FE0A    		cp	0x0A	; '\n' (Cursor down)
F112: 28CE    		jr	z,tm_lf
F114: FE0B    		cp	0x0B	; Cursor up
F116: 28E3    		jr	z,tm_up
F118: FE0D    		cp	0x0D	; '\r' 
F11A: 28D2    		jr	z,tm_cr
F11C: FE17    		cp	0x17	; Clear end of screen
F11E: 284E    		jr	z,tm_cles
F120: FE18    		cp	0x18	; Clear end of line
F122: 284C    		jr	z,tm_clea
F124: FE1A    		cp	0x1A	; Clear screen, home cursor
F126: 28D8    		jr	z,tm_cshm
F128: FE1E    		cp	0x1E	; Home cursor
F12A: 28D7    		jr	z,tm_home
F12C: FE1B    		cp	0x1B	; Escape
F12E: C0      		ret	nz
F12F: 3E01    		ld	a,1
F131: 3284F9  		ld	(tm_escs),a
F134: C9      		ret
              		
              		; Handle escape sequence
F135: 3D      	tm_esc:	dec	a
F136: 280B    		jr	z,tm_esc0
F138: 3D      		dec	a
F139: 281D    		jr	z,tm_esc1
F13B: 3D      		dec	a
F13C: 2825    		jr	z,tm_esc2
F13E: AF      	tm_escd:xor	a	; Escape done
F13F: 3284F9  	tm_escr:ld	(tm_escs),a
F142: C9      		ret
F143: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
F145: BB      		cp	e
F146: 284B    		jr	z,tm_40c
F148: 3EFE    		ld	a,0xFE	; Do 80-col
F14A: BB      		cp	e
F14B: 2853    		jr	z,tm_80c
F14D: 3E3D    		ld	a,0x3D	; '='
F14F: BB      		cp	e
F150: 20EC    		jr	nz,tm_escd
F152: 3A84F9  	tm_esci:ld	a,(tm_escs)
F155: 3C      		inc	a
F156: 18E7    		jr	tm_escr
F158: 7B      	tm_esc1:ld	a,e
F159: 1E20    		ld	e,0x20
F15B: 93      		sub	e
F15C: FE18    		cp	24
F15E: 30DE    		jr	nc,tm_escd
F160: 47      		ld	b,a
F161: 18EF    		jr	tm_esci
F163: 7B      	tm_esc2:ld	a,e
F164: 1E20    		ld	e,0x20
F166: 93      		sub	e
F167: FE50    		cp	80
F169: 30D3    		jr	nc,tm_escd
F16B: 4F      		ld	c,a
F16C: 18D0    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F16E: 0617    	tm_cles:ld	b,23
F170: 04      	tm_clea:inc	b
F171: 1E00    		ld	e,0
F173: C5      		push	bc
F174: D5      		push	de
F175: 3E50    		ld	a,80
F177: 210050  		ld	hl,0x5000
F17A: CD2CF2  		call	tm_chat
F17D: D1      		pop	de
F17E: C1      		pop	bc
F17F: AF      	tm_cle0:xor	a
F180: D3A0    		out	(tm_data),a
F182: 0C      		inc	c
F183: 3E50    		ld	a,80
F185: B9      		cp	c
F186: 20F7    		jr	nz,tm_cle0
F188: 14      		inc	d
F189: AF      		xor	a
F18A: 4F      		ld	c,a
F18B: 7A      		ld	a,d
F18C: B8      		cp	b
F18D: 20F0    		jr	nz,tm_cle0
F18F: D1      		pop	de	; Do not update character
F190: C350F2  		jp	tm_usco
              		
F193: E5      	tm_40c:	push	hl
F194: 210200  		ld	hl,0x0002
F197: 2291F2  	tm_cupd:ld	(tm_mode),hl
F19A: CD41F0  		call	tm_setp
F19D: E1      		pop	hl
F19E: 189E    		jr	tm_escd
              		
F1A0: E5      	tm_80c:	push	hl
F1A1: 210404  		ld	hl,0x0404
F1A4: 18F1    		jr	tm_cupd
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F1A6: 212808  	tm_dsco:ld	hl,0x0800+40
F1A9: 110048  		ld	de,0x4800
F1AC: 0618    		ld	b,24
F1AE: CDB9F1  		call	tm_dsc0
F1B1: 215010  		ld	hl,0x1000+80
F1B4: 110050  		ld	de,0x5000
F1B7: 0630    		ld	b,48
F1B9: C5      	tm_dsc0:push	bc
F1BA: D5      		push	de
F1BB: E5      		push	hl
F1BC: CD38F2  		call	tm_vcpy
F1BF: E1      		pop	hl
F1C0: D1      		pop	de
F1C1: 012800  		ld	bc,40
F1C4: 09      		add	hl,bc
F1C5: EB      		ex	de,hl
F1C6: 09      		add	hl,bc
F1C7: EB      		ex	de,hl
F1C8: C1      		pop	bc
F1C9: 10EE    		djnz	tm_dsc0
F1CB: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F1CC: DB91    	tm_getc:in	a,(tm_keys)
F1CE: E602    		and	2
F1D0: 3D      		dec	a
F1D1: F8      		ret	m
              		
              		; Grab the key
F1D2: DB90    		in	a,(tm_keyd)
F1D4: 3285F9  		ld	(tm_last),a
F1D7: CDDCF1  		call	tm_map
F1DA: 79      		ld	a,c
F1DB: C9      		ret
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F1DC: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
F1DD: 21F3F1  		ld	hl,tm_mapt
F1E0: 7E      	tm_map0:ld	a,(hl)
F1E1: B7      		or	a
F1E2: 2808    		jr	z,tm_map2
F1E4: B9      		cp	c
F1E5: 23      		inc	hl
F1E6: 7E      		ld	a,(hl)
F1E7: 23      		inc	hl
F1E8: 20F6    		jr	nz,tm_map0
F1EA: 4F      		ld	c,a
F1EB: C9      		ret
              		
              		
              		; Filter non-ASCII
F1EC: 79      	tm_map2:ld	a,c
F1ED: E680    		and	0x80	
F1EF: C8      		ret	z
F1F0: 0EFF    		ld	c,0xFF
F1F2: C9      		ret
              		
              	; Map table
F1F3: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
F1F5: E108    		defb	0xE1,0x08	; '<-' -> BS
F1F7: EA7F    		defb	0xEA,0x7F	; TV -> DEL
F1F9: E00C    		defb	0xE0,0x0C	; '->' -> Right
F1FB: E20B    		defb	0xE2,0x0B	; '/\' -> Up
F1FD: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
F1FF: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
F201: E860    		defb	0xE8,0x60	; SYM -> '@'
F203: E67C    		defb	0xE6,0x7C	; NO -> '|'
F205: E77E    		defb	0xE7,0x7E	; YES -> '~'
F207: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F208: 210050  	tm_putc:ld	hl,0x5000
F20B: 3E50    		ld	a,80
F20D: C5      		push	bc
F20E: D5      		push	de
F20F: CD2CF2  		call	tm_chat	; Place it in the 80 col buffer
F212: ED59    		out	(c),e
F214: D1      		pop	de
F215: C1      		pop	bc
F216: 3A83F9  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F219: 47      		ld	b,a
F21A: 79      		ld	a,c
F21B: 90      		sub	b	; If character is less than scroll...
F21C: 4F      		ld	c,a
F21D: F8      		ret	m
F21E: FE28    		cp	40	; If desired position is 40 or more
F220: D0      		ret	nc
F221: 210048  		ld	hl,0x4800
F224: 3E28    		ld	a,40
F226: CD2CF2  		call	tm_chat	; Place it in the 40 col screen buffer
F229: ED59    		out	(c),e
F22B: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
F22C: 0600    	tm_chat:ld	b,0
F22E: 09      		add	hl,bc
F22F: 4F      		ld	c,a
F230: AF      		xor	a
F231: BA      		cp	d
F232: 2850    	tm_cha0:jr	z,tm_addh
F234: 09      		add	hl,bc
F235: 15      		dec	d
F236: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F238: CD84F2  	tm_vcpy:call	tm_addh
F23B: 0628    		ld	b,40
F23D: 2186F9  		ld	hl,tm_cbuf
F240: CDD2EF  		call	tm_inir
F243: EB      		ex	de,hl
F244: CD84F2  		call	tm_addh
F247: 0628    		ld	b,40
F249: 2186F9  		ld	hl,tm_cbuf
F24C: CDC9EF  		call	tm_otir
F24F: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F250: 210010  	tm_usco:ld	hl,0x1000
F253: 110048  		ld	de,0x4800
F256: 3A83F9  		ld	a,(tm_scro)
F259: 0600    		ld	b,0
F25B: 4F      		ld	c,a
F25C: 09      		add	hl,bc
F25D: 0618    		ld	b,24
F25F: C5      	tm_usc0:push	bc
F260: D5      		push	de
F261: E5      		push	hl
F262: CD38F2  		call	tm_vcpy
F265: E1      		pop	hl
F266: D1      		pop	de
F267: 0E50    		ld	c,80
F269: 09      		add	hl,bc
F26A: EB      		ex	de,hl
F26B: 0E28    		ld	c,40
F26D: 09      		add	hl,bc
F26E: EB      		ex	de,hl
F26F: C1      		pop	bc
F270: 10ED    		djnz	tm_usc0
F272: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F273: 010048  	tm_cls:	ld	bc,0x4800
F276: 110010  		ld	de,0x1000
F279: CD86F2  		call	tm_addr
F27C: ED71    	tm_cls0:out	(c),0
F27E: 1B      		dec	de
F27F: 7A      		ld	a,d
F280: B3      		or	e
F281: 20F9    		jr	nz,tm_cls0
F283: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; uses: af, bc
F284: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F285: 4D      		ld	c,l
F286: DBA1    	tm_addr:in	a,(tm_latc)
F288: 79      		ld	a,c
F289: D3A1    		out	(tm_latc),a
F28B: 78      		ld	a,b
F28C: D3A1    		out	(tm_latc),a
F28E: 0EA0    		ld	c,tm_data
F290: C9      		ret
              		
              	; Variables
F291: 0200    	tm_mode:defw	0x0002
              	
              	
F980:         	tm_curx:equ	tm_bss		; Cursor X
F981:         	tm_cury:equ	tm_bss+1	; Cursor Y
F982:         	tm_outc:equ	tm_bss+2	; Output character
F983:         	tm_scro:equ	tm_bss+3	; Scroll width
F984:         	tm_escs:equ	tm_bss+4	; Escape state
F985:         	tm_last:equ	tm_bss+5	; Last character read
F986:         	tm_cbuf:equ	tm_bss+6	; 40 byte character buffer
              	#include "dev/nabu_ndsk.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   V I R T U A L   D I S K
              	;*
              	;*     This driver allows for IshkurCP/M to access a virtual
              	;*     disk using the NHACP protocol. Indiviual files are 
              	;*     mounted as file systems and accessed like a disk
              	;*     normally would.
              	;*
              	;*     This particular driver uses the Nabu HCCA port to 
              	;*     facilitate communication between it and an adapter
              	;*
              	;*     In order to service CCP and GRB requests, the 
              	;*     following special files must exist:
              	;*
              	;*     '${STORAGE}/CPM22.SYS' <- For CP/M system components
              	;*     '${STORAGE}/FONT.GRB' <- For graphical driver components
              	;*
              	;*
              	;*
              	;*
              	;*     Device requires 384 bytes of bss space (nd_bss)
              	;* 
              	;**************************************************************
              	;
              	
0040:         	nd_ayda	equ	0x40		; AY-3-8910 data port
0041:         	nd_atla	equ	0x41		; AY-3-8910 latch port
0080:         	nd_hcca	equ	0x80		; Modem data port
0000:         	nd_nctl	equ	0x00		; NABU control port
              	
0080:         	nd_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F293: 00000000	nd_dpha:defw	0,0,0,0
F297: 00000000	
F29B: 00F9    		defw	dircbuf	; DIRBUF
F29D: B3F2    		defw	nd_dpb	; DPB
F29F: 0000    		defw	0	; CSV
F2A1: FCF9    		defw	nd_asva	; ALV (129 bytes)
              		
              	; Disk B DPH
F2A3: 00000000	nd_dphb:defw	0,0,0,0
F2A7: 00000000	
F2AB: 00F9    		defw	dircbuf	; DIRBUF
F2AD: B3F2    		defw	nd_dpb	; DPB
F2AF: 0000    		defw	0	; CSV
F2B1: 7DFA    		defw	nd_asvb	; ALV (129 bytes)
              		
              	; NSHD8 format
F2B3: 4000    	nd_dpb:	defw	64	; # sectors per track
F2B5: 06      		defb	6	; BSH
F2B6: 3F      		defb	63	; BLM
F2B7: 03      		defb	3	; EXM
F2B8: FF03    		defw	1023	; DSM
F2BA: FF00    		defw	255	; DRM
F2BC: 80      		defb	0x80	; AL0
F2BD: 00      		defb	0	; AL1
F2BE: 0000    		defw	0	; Size of directory check vector
F2C0: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F2C2: B7      	ndkdev:	or	a
F2C3: 2815    		jr	z,nd_init
F2C5: 3D      		dec	a
F2C6: 2813    		jr	z,nd_home
F2C8: 3D      		dec	a
F2C9: 2817    		jr	z,nd_sel
F2CB: 3D      		dec	a
F2CC: CA0CF3  		jp	z,nd_strk
F2CF: 3D      		dec	a
F2D0: CA12F3  		jp	z,nd_ssec
F2D3: 3D      		dec	a
F2D4: CA17F3  		jp	z,nd_read
F2D7: C328F3  		jp	nd_writ
              		
              	; Inits the device
              	; Not really needed atm
              	; hl = Call argument
              	;
              	; uses: none
F2DA: C9      	nd_init:ret
              	
              	; Sets "track" back to zero
              	;
              	; uses: none
F2DB: 210000  	nd_home:ld	hl,0
F2DE: 22B1F9  		ld	(nd_ctrk),hl
F2E1: C9      		ret
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
F2E2: E5      	nd_sel:	push	hl
F2E3: CD49F3  		call	nd_hini
F2E6: E1      		pop	hl
F2E7: E5      		push	hl
F2E8: 7D      		ld	a,l
F2E9: C641    		add	a,0x41		; Convert to ASCII
F2EB: 327DF4  		ld	(nd_p2im),a
F2EE: 2178F4  		ld	hl,nd_p2
F2F1: 118CF4  		ld	de,nd_m0na
F2F4: 010B00  		ld	bc,11
F2F7: EDB0    		ldir
F2F9: CD84F3  		call	nd_open		; Open the file
F2FC: E1      		pop	hl		; Select DPH
F2FD: 7D      		ld	a,l
F2FE: B7      		or	a
F2FF: 2193F2  		ld	hl,nd_dpha
F302: C8      		ret	z
F303: 3D      		dec	a
F304: 21A3F2  		ld	hl,nd_dphb
F307: C8      		ret	z
F308: 210000  		ld	hl,0
F30B: C9      		ret
              		
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: nonoe
F30C: 60      	nd_strk:ld	h,b
F30D: 69      		ld	l,c
F30E: 22B1F9  		ld	(nd_ctrk),hl
F311: C9      		ret
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: none
F312: 79      	nd_ssec:ld	a,c
F313: 32B0F9  		ld	(nd_csec),a
F316: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
              	;
              	; uses: af
F317: CD49F3  	nd_read:call	nd_hini
F31A: CD39F3  		call	nd_gbno
F31D: 2A49EF  		ld	hl,(biodma)
F320: CD9BF3  		call	nd_getb
F323: 3E01    		ld	a,1
F325: D8      		ret	c
F326: AF      		xor	a
F327: C9      		ret
              		
              	; Write a sector from DMA
              	;
              	; uses: af
F328: CD49F3  	nd_writ:call	nd_hini
F32B: CD39F3  		call	nd_gbno
F32E: 2A49EF  		ld	hl,(biodma)
F331: CDCEF3  		call	nd_putb
F334: 3E01    		ld	a,1
F336: D8      		ret	c
F337: AF      		xor	a
F338: C9      		ret
              		
              		
              	; Gets the block # for read / write operations
              	;
              	; Returns block # in de
              	; uses: af, de, hl 
F339: 2AB1F9  	nd_gbno:ld	hl,(nd_ctrk)
F33C: 29      		add	hl,hl
F33D: 29      		add	hl,hl
F33E: 29      		add	hl,hl
F33F: 29      		add	hl,hl
F340: 29      		add	hl,hl
F341: 29      		add	hl,hl
F342: 3AB0F9  		ld	a,(nd_csec)
F345: B5      		or	l
F346: 6F      		ld	l,a
F347: EB      		ex	de,hl
F348: C9      		ret
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a
F349: 3E07    	nd_hini:ld	a,0x07
F34B: D341    		out	(nd_atla),a	; AY register = 7
F34D: 3E7F    		ld	a,0x7F
F34F: D340    		out	(nd_ayda),a	; Configure AY port I/O
              		
F351: 3E0E    		ld	a,0x0E
F353: D341    		out	(nd_atla),a	; AY register = 14
F355: 3EC0    		ld	a,0xC0
F357: D340    		out	(nd_ayda),a	; Enable HCCA receive and send
              		
F359: 3E0F    		ld	a,0x0F
F35B: D341    		out	(nd_atla),a	; AY register = 15
F35D: C9      		ret
              	; Loads the CCP into the CCP space
F35E: 2164F4  	nd_ccp:	ld	hl,nd_p0
F361: 1803    		jr	nd_grb0
              		
              	; Loads the GRB into the CCP space
F363: 216EF4  	nd_grb:	ld	hl,nd_p1
F366: 118CF4  	nd_grb0:ld	de,nd_m0na
F369: 010A00  		ld	bc,10
F36C: EDB0    		ldir			; Copy name to file open
F36E: CD49F3  		call	nd_hini		; Go to HCCA mode
F371: CD84F3  		call	nd_open		; Open the file
F374: 110000  		ld	de,0
F377: 2100D8  		ld	hl,cbase
F37A: CD9BF3  	nd_grb1:call	nd_getb
F37D: 1C      		inc	e
F37E: 3E10    		ld	a,16
F380: BB      		cp	e
F381: 20F7    		jr	nz,nd_grb1
F383: C9      		ret
              		
              	
              	; Open the prepared file
              	; Closes the existing file too
              	;
              	; uses: af, b, hl
F384: 219BF4  	nd_open:ld	hl,nd_m1
F387: 0606    		ld	b,6
F389: CD0BF4  		call	nd_send
F38C: 2183F4  		ld	hl,nd_m0
F38F: 0617    		ld	b,23
F391: CD0BF4  		call	nd_send
F394: 21B6F9  		ld	hl,nd_buff
F397: CDF6F3  		call	nd_rece
F39A: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F39B: EB      	nd_getb:ex	de,hl
F39C: 22A9F4  		ld	(nd_m2bn),hl
F39F: EB      		ex	de,hl
F3A0: E5      		push	hl
F3A1: 21A3F4  		ld	hl,nd_m2
F3A4: 060C    		ld	b,12
F3A6: CD0BF4  		call	nd_send
F3A9: E1      		pop	hl
F3AA: D8      		ret	c
F3AB: CD14F4  		call	nd_hcrd
F3AE: CD17F4  		call	nd_hcre
F3B1: D8      		ret	c
F3B2: FE84    		cp	0x84
F3B4: 37      		scf
F3B5: 200F    		jr	nz,nh_get1
F3B7: CD14F4  		call	nd_hcrd
F3BA: 0680    		ld	b,128
F3BC: CD17F4  	nd_get0:call	nd_hcre
F3BF: D8      		ret	c
F3C0: 77      		ld	(hl),a
F3C1: 23      		inc	hl
F3C2: 10F8    		djnz	nd_get0
F3C4: B7      		or	a
F3C5: C9      		ret
F3C6: CD14F4  	nh_get1:call	nd_hcrd	; Read the error message and exit
F3C9: CD17F4  		call	nd_hcre
F3CC: 37      		scf
F3CD: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F3CE: EB      	nd_putb:ex	de,hl
F3CF: 22B5F4  		ld	(nd_m3bn),hl
F3D2: EB      		ex	de,hl
F3D3: E5      		push	hl
F3D4: 21AFF4  		ld	hl,nd_m3
F3D7: 060C    		ld	b,12
F3D9: CD0BF4  		call	nd_send		; Send message precursor
F3DC: E1      		pop	hl
F3DD: D8      		ret	c
F3DE: 0680    		ld	b,128
F3E0: 7E      	nd_put0:ld	a,(hl)		; Send the block
F3E1: CD40F4  		call	nd_hcwr
F3E4: D8      		ret	c
F3E5: 23      		inc	hl
F3E6: 10F8    		djnz	nd_put0
F3E8: 21B6F9  		ld	hl,nd_buff
F3EB: CDF6F3  		call	nd_rece
F3EE: 3AB6F9  		ld	a,(nd_buff)
F3F1: FE81    		cp	0x81
F3F3: C8      		ret	z
F3F4: 37      		scf
F3F5: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F3F6: CD17F4  	nd_rece:call	nd_hcre
F3F9: D8      		ret	c		; Existing error
F3FA: 47      		ld	b,a
F3FB: CD17F4  		call	nd_hcre
F3FE: D8      		ret	c		; Existing error
F3FF: 37      		scf
F400: C0      		ret	nz		; Message too big!
F401: CD17F4  	nd_rec0:call	nd_hcre
F404: D8      		ret	c		; Error!
F405: 77      		ld	(hl),a
F406: 23      		inc	hl
F407: 10F8    		djnz	nd_rec0
F409: B7      		or	a
F40A: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F40B: 7E      	nd_send:ld	a,(hl)
F40C: 23      		inc	hl
F40D: CD40F4  		call	nd_hcwr
F410: D8      		ret	c		; Error!
F411: 10F8    		djnz	nd_send
F413: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns return in a
              	; Carry flag set on error
              	; Uses: af
F414: CD17F4  	nd_hcrd:call	nd_hcre
F417: D5      	nd_hcre:push	de
F418: 3E09    		ld	a,0x09
F41A: D300    		out	(nd_nctl),a	; Turn on recv light
F41C: 11FFFF  		ld	de,0xFFFF
F41F: DB40    	nd_hcr0:in	a,(nd_ayda)
F421: CB47    		bit	0,a
F423: 28FA    		jr	z,nd_hcr0	; Await an interrupt
F425: CB4F    		bit	1,a
F427: 280B    		jr	z,nd_hcr1
F429: 1B      		dec	de
F42A: 7B      		ld	a,e
F42B: B2      		or	d
F42C: 20F1    		jr	nz,nd_hcr0
F42E: 3E01    	nd_hcer:ld	a,0x01
F430: D300    		out	(nd_nctl),a	; Turn off recv light
F432: 37      		scf
F433: C9      		ret			; Timed out waiting
F434: 3E01    	nd_hcr1:ld	a,0x01
F436: D300    		out	(nd_nctl),a	; Turn off recv light
F438: DB80    		in	a,(nd_hcca)
F43A: D1      		pop	de
F43B: B7      		or	a
F43C: C9      		ret
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F43D: CD40F4  	nd_hcwd:call	nd_hcwr
F440: D5      	nd_hcwr:push	de
F441: F5      		push	af
F442: 11FFFF  		ld	de,0xFFFF
F445: 3E21    		ld	a,0x21
F447: D300    		out	(nd_nctl),a	; Turn on send light
F449: DB40    	nd_hcw0:in	a,(nd_ayda)
F44B: CB47    		bit	0,a
F44D: 28FA    		jr	z,nd_hcw0	; Await an interrupt
F44F: CB4F    		bit	1,a
F451: 2007    		jr	nz,nd_hcw1
F453: 1B      		dec	de
F454: 7B      		ld	a,e
F455: B2      		or	d
F456: 20F1    		jr	nz,nd_hcw0
F458: 18D4    		jr	nd_hcer		; Timed out waiting
F45A: 3E01    	nd_hcw1:ld	a,0x01
F45C: D300    		out	(nd_nctl),a	; Turn off send light
F45E: F1      		pop	af
F45F: D380    		out	(nd_hcca),a
F461: D1      		pop	de
F462: B7      		or	a
F463: C9      		ret
              		
              	; Path to CP/M image
              	; Total length: 10 bytes
F464: 43504D32	nd_p0:	defb	'CPM22.SYS',0
F468: 322E5359	
F46C: 5300    	
              	
              	; Path to GRB image
              	; Total length: 10 bytes
F46E: 464F4E54	nd_p1:	defb	'FONT.GRB',0,0
F472: 2E475242	
F476: 0000    	
              	
              	; Path to a generic disk image
              	; Total length: 11
F478: 4E44534B	nd_p2:	defb	'NDSK_'
F47C: 5F      	
F47D: 3F      	nd_p2im:defb	'?'		; Disk image name
F47E: 2E494D47		defb	'.IMG',0
F482: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 23 bytes
F483: 8F00    	nd_m0:	defb	0x8F,0x00
F485: 1300    		defw	19		; Message length
F487: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F488: 80      		defb	nd_fild		; Default file descriptor
F489: 0100    	nd_m0fl:defw	0x01		; Read/Write flags
F48B: 0E      		defb	0x0E		; Message length
F48C: 58585858	nd_m0na:defb	'XXXXXXXXXXXXXX'; File name field
F490: 58...   	
F49A: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F49B: 8F00    	nd_m1:	defb	0x8F,0x00
F49D: 0200    		defw	2		; Message length
F49F: 05      		defb	0x05		; Cmd: FILE-CLOSE
F4A0: 80      		defb	nd_fild		; Default file descriptor
F4A1: 0000    		defw	0x00		; Magic bytes
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F4A3: 8F00    	nd_m2:	defb	0x8F,0x00
F4A5: 0800    		defw	8		; Message length
F4A7: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F4A8: 80      		defb	nd_fild		; Default file descritor
F4A9: 00000000	nd_m2bn:defw	0x00,0x00	; Block number
F4AD: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F4AF: 8F00    	nd_m3:	defb	0x8F,0x00
F4B1: 8800    		defw	136		; Message length
F4B3: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F4B4: 80      		defb	nd_fild		; Default file descritor
F4B5: 00000000	nd_m3bn:defw	0x00,0x00	; Block number
F4B9: 8000    		defw	128		; Block length
              	
              	; Variables
F9B0:         	nd_csec	equ	nd_bss		; Current sector (1b)
F9B1:         	nd_ctrk	equ	nd_bss+1	; Current track (2b)
F9B6:         	nd_buff	equ	nd_bss+6	; Buffer (64b)
F9FC:         	nd_asva	equ	nd_buff+70	; ASV #1 (129b)
FA7D:         	nd_asvb	equ	nd_buff+199	; ASV #1 (129b)
              	#include "dev/nabu_fdc.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F4BB:         	nf_dpha:
F4BB: 00000000		defw	0,0,0,0
F4BF: 00000000	
F4C3: 00F9    		defw	dircbuf	; DIRBUF
F4C5: DBF4    		defw	nf_dpb	; DPB
F4C7: 69FB    		defw	nf_csva	; CSV
F4C9: 37FB    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F4CB:         	nf_dphb:
F4CB: 00000000		defw	0,0,0,0
F4CF: 00000000	
F4D3: 00F9    		defw	dircbuf	; DIRBUF
F4D5: DBF4    		defw	nf_dpb	; DPB
F4D7: 79FB    		defw	nf_csvb	; CSV
F4D9: 50FB    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F4DB:         	nf_dpb:
F4DB: 2800    		defw	40	; # sectors per track
F4DD: 03      		defb	3	; BSH
F4DE: 07      		defb	7	; BLM
F4DF: 00      		defb	0	; EXM
F4E0: B800    		defw	184	; DSM
F4E2: 3F00    		defw	63	; DRM
F4E4: C0      		defb	0xC0	; AL0
F4E5: 00      		defb	0	; AL1
F4E6: 1000    		defw	16	; Size of directory check vector
F4E8: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F4EA: B7      	nfddev:	or	a
F4EB: 2815    		jr	z,nf_init
F4ED: 3D      		dec	a
F4EE: 283D    		jr	z,nf_home
F4F0: 3D      		dec	a
F4F1: 2852    		jr	z,nf_sel
F4F3: 3D      		dec	a
F4F4: CA99F5  		jp	z,nf_strk
F4F7: 3D      		dec	a
F4F8: CACFF5  		jp	z,nf_ssec
F4FB: 3D      		dec	a
F4FC: CA20F6  		jp	z,nf_read
F4FF: C328F6  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F502: AF      	nf_init:xor	a
F503: 3230FB  		ld	(nf_io),a
              	
              		; Look for the FDC
F506: 0ECF    		ld	c,0xCF
F508: ED78    	nf_ini1:in	a,(c)
F50A: FE10    		cp	0x10
F50C: 2808    		jr	z,nf_ini2
F50E: 0C      		inc	c
F50F: C8      		ret	z	; Should not be possible!
F510: 3E0F    		ld	a,0x0F
F512: 81      		add	a,c
F513: 4F      		ld	c,a
F514: 18F2    		jr	nf_ini1
              		
              		; Get command register
F516: 79      	nf_ini2:ld	a,c
F517: D60F    		sub	15
F519: 4F      		ld	c,a
F51A: 3230FB  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F51D: CB25    		sla	l
F51F: 3E02    		ld	a,2
F521: 85      		add	l
F522: 3232FB  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F525: 3ED0    		ld	a,0xD0
F527: ED79    		out	(c),a
              		
              		; Re-home drive
F529: CD2DF5  		call	nf_home
              		
              		; De-select drive
              		
F52C: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F52D: CD40F6  	nf_home:call	nf_wdef
F530: CDE7F6  		call	nf_dvsc
              	
F533: 3A30FB  		ld	a,(nf_io)
F536: 4F      		ld	c,a
              		
              		; Restore to track 0
F537: 3E09    		ld	a,0x09
F539: ED79    		out	(c),a 
F53B: CDFEF6  		call	nf_busy
              		
              		; Reset sync flag
F53E: AF      		xor	a
F53F: 3234FB  		ld	(nf_sync),a
              		
              		; De-select drive
F542: C3ECF6  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F545: 3A30FB  	nf_sel:	ld	a,(nf_io)
F548: B7      		or	a
F549: FA50F5  		jp	m,nf_seld
              		
              		; no FDC card
F54C: 210000  		ld	hl,0
F54F: C9      		ret
              	
F550: 7D      	nf_seld:ld	a,l		; Select a disk
F551: 0602    		ld	b,2
F553: B7      		or	a
F554: 2809    		jr	z,nf_sel0
F556: 3D      		dec	a
F557: 0604    		ld	b,4
F559: 2804    		jr	z,nf_sel0
F55B: 210000  		ld	hl,0
F55E: C9      		ret
              	
              		; Move control of drive buffers
F55F: CD40F6  	nf_sel0:call	nf_wdef		; Write back if needed
F562: 3EFF    		ld	a,0xFF
F564: 3234FB  		ld	(nf_sync),a	; Set sync flag
F567: 78      		ld	a,b
F568: 3232FB  		ld	(nf_curd),a	; Set current drive
F56B: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F56C: 16FF    	nf_selc	ld	d,255
F56E: CDE7F6  		call	nf_dvsc
F571: 3A30FB  		ld	a,(nf_io)
F574: 4F      		ld	c,a
F575: 3ED0    		ld	a,0xD0
F577: ED79    		out	(c),a		; Force FDC interrupt
F579: CD04F7  	nf_sel1:call	nf_stal
F57C: ED78    		in	a,(c)
F57E: E602    		and	0x02
F580: 2009    		jr	nz,nf_sel2
F582: 15      		dec	d
F583: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F585: 210000  		ld	hl,0
F588: C3ECF6  		jp	nf_udsl
              		
              		
              		; Output DPH
F58B: CDECF6  	nf_sel2:call	nf_udsl
F58E: 21BBF4  		ld	hl,nf_dpha
F591: 3E02    		ld	a,2
F593: BB      		cp	e
F594: C8      		ret	z
F595: 21CBF4  		ld	hl,nf_dphb
F598: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F599: 51      	nf_strk:ld	d,c		; Track = d
F59A: 3A30FB  		ld	a,(nf_io)
F59D: 4F      		ld	c,a
F59E: 3A34FB  		ld	a,(nf_sync)
F5A1: B7      		or	a
F5A2: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F5A4: CDE7F6  		call	nf_dvsc
              		
              		; Restore to track 0
F5A7: 3E09    		ld	a,0x09
F5A9: ED79    		out	(c),a 
F5AB: CDFEF6  		call	nf_busy
              		
              		; Reset sync flag
F5AE: AF      		xor	a
F5AF: 3234FB  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F5B2: 59      	nf_str0:ld	e,c
F5B3: 0C      		inc	c
F5B4: ED78    		in	a,(c)
F5B6: BA      		cp	d
F5B7: CAECF6  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F5BA: CD40F6  		call	nf_wdef
              	
              		; Seek to track
F5BD: CDE7F6  		call	nf_dvsc
F5C0: 0C      		inc	c
F5C1: 0C      		inc	c
F5C2: ED51    		out	(c),d
F5C4: 3E19    		ld	a,0x19
F5C6: 4B      		ld	c,e
F5C7: ED79    		out	(c),a 
F5C9: CDFEF6  		call	nf_busy	
              		
F5CC: C3ECF6  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F5CF: 79      	nf_ssec:ld	a,c
F5D0: E607    		and	0x07
F5D2: 3233FB  		ld	(nf_subs),a
F5D5: 79      		ld	a,c
              		
              		; Compute physical sector
F5D6: CB3F    		srl	a
F5D8: CB3F    		srl	a
F5DA: CB3F    		srl	a
F5DC: 3C      		inc	a
F5DD: 47      		ld	b,a	; b = Physical sector
F5DE: 3A30FB  		ld	a,(nf_io)
F5E1: 3C      		inc	a
F5E2: 3C      		inc	a
F5E3: 4F      		ld	c,a
F5E4: ED78    		in	a,(c)
F5E6: B8      		cp	b
F5E7: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F5E8: CD40F6  		call	nf_wdef
F5EB: ED41    		out	(c),b
F5ED: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F5EE: 3A35FB  	nf_rdwr:ld	a,(nf_inco)
F5F1: B7      		or	a
F5F2: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F5F4: CDE7F6  		call	nf_dvsc
F5F7: 3A30FB  		ld	a,(nf_io)
F5FA: 4F      		ld	c,a
F5FB: 2100FC  		ld	hl,nf_cach
F5FE: CDCBF6  		call	nf_rphy
F601: 47      		ld	b,a
F602: CDECF6  		call	nf_udsl
F605: 78      		ld	a,b
              		
              		; Error checking
F606: B7      		or	a
F607: 3E01    		ld	a,1
F609: C0      		ret	nz
F60A: 3235FB  		ld	(nf_inco),a
              		
              		; DMA subsector
F60D: 2A49EF  	nf_rdw0:ld	hl,(biodma)
F610: EB      		ex	de,hl
              	
F611: 3A33FB  		ld	a,(nf_subs)
F614: 2180FB  		ld	hl,nf_cach-128
F617: 018000  		ld	bc,128
F61A: 3C      		inc	a
F61B: 09      	nf_rdw1:add	hl,bc
F61C: 3D      		dec	a
F61D: 20FC    		jr	nz,nf_rdw1
F61F: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F620: CDEEF5  	nf_read:call	nf_rdwr
F623: B7      		or	a
F624: C0      		ret	nz
F625: EDB0    		ldir
F627: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F628: C5      	nf_writ:push	bc
F629: CDEEF5  		call	nf_rdwr
F62C: B7      		or	a
F62D: C1      		pop	bc
F62E: C0      		ret	nz
F62F: 3E01    		ld	a,1
F631: 3236FB  		ld	(nf_dirt),a
F634: 79      		ld	a,c
F635: 018000  		ld	bc,128
F638: EB      		ex	de,hl
F639: EDB0    		ldir
F63B: FE01    		cp	1
F63D: 3E00    		ld	a,0
F63F: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F640: 3A36FB  	nf_wdef:ld	a,(nf_dirt)
F643: B7      		or	a
F644: 2837    		jr	z,nf_wde4
              	
F646: C5      		push	bc
F647: D5      		push	de
F648: E5      		push	hl
              		
              		; Write physical sector
F649: CDE7F6  		call	nf_dvsc
F64C: 3A30FB  		ld	a,(nf_io)
F64F: 4F      		ld	c,a
F650: C603    		add	a,3
F652: 57      		ld	d,a
F653: 59      		ld	e,c
F654: 3EA8    		ld	a,0xA8		; Write command
F656: ED79    		out	(c),a
F658: 2100FC  		ld	hl,nf_cach
F65B: ED78    	nf_wde1:in	a,(c)
F65D: 1F      		rra	
F65E: 3009    		jr	nc,nf_wde2
F660: 1F      		rra
F661: 30F8    		jr	nc,nf_wde1
F663: 4A      		ld	c,d
F664: EDA3    		outi 
F666: 4B      		ld	c,e
F667: 18F2    		jr	nf_wde1
F669: ED78    	nf_wde2:in	a,(c)
              		
              		; Deselect drive
F66B: 47      		ld	b,a
F66C: CDECF6  		call	nf_udsl
F66F: 78      		ld	a,b
              		
F670: E1      		pop	hl
F671: D1      		pop	de
F672: C1      		pop	bc
              		
              		; Error checking
F673: E6FC    		and	0xFC
F675: 2803    		jr	z,nf_wde3
              		
F677: 3E01    		ld	a,1
F679: C9      		ret
              		
              		; Cache is no longer dirty
F67A: 3236FB  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F67D: AF      	nf_wde4:xor	a
F67E: 3235FB  		ld	(nf_inco),a
              		
F681: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F682: 3E02    	nf_grb:	ld	a,2
F684: 3231FB  		ld	(nf_r2ks),a
F687: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F689: 3E04    	nf_ccp:	ld	a,4
F68B: 3231FB  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F68E: 3E02    	nf_r2k: ld	a,nf_rdsk
F690: CDEDF6  		call	nf_dvsl
              		
              		; Restore to track 0
F693: 3A30FB  		ld	a,(nf_io)
F696: 4F      		ld	c,a
F697: 3E09    		ld	a,0x09
F699: ED79    		out	(c),a 
F69B: CDFEF6  		call	nf_busy
              		
              		; Set sector # to 4
F69E: 3A31FB  		ld	a,(nf_r2ks)
F6A1: 0C      		inc	c
F6A2: 0C      		inc	c
F6A3: ED79    		out	(c),a
F6A5: C5      		push	bc
F6A6: 0D      		dec	c
F6A7: 0D      		dec	c
              		
              		; Read into memory
F6A8: 2100D8  		ld	hl,cbase
F6AB: CDCBF6  		call	nf_rphy
F6AE: C1      		pop	bc
F6AF: B7      		or	a
F6B0: 2805    		jr	z,nf_r2k0
F6B2: CD02F5  		call	nf_init		; Error!
F6B5: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F6B7: ED78    	nf_r2k0:in	a,(c)
F6B9: 3C      		inc	a
F6BA: ED79    		out	(c),a
F6BC: 0D      		dec	c
F6BD: 0D      		dec	c
              		
              		; Read into memory again
F6BE: CDCBF6  		call	nf_rphy
F6C1: B7      		or	a
F6C2: C8      		ret	z
F6C3: CD02F5  		call	nf_init		; Error!
F6C6: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F6C8: C3ECF6  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F6CB: 51      	nf_rphy:ld	d,c
F6CC: 59      		ld	e,c
F6CD: 14      		inc	d
F6CE: 14      		inc	d
F6CF: 14      		inc	d
              		
              		; Read command
F6D0: 3E88    		ld	a,0x88
F6D2: ED79    		out	(c),a
F6D4: ED78    	nf_rph1:in	a,(c)
F6D6: 1F      		rra	
F6D7: 3009    		jr	nc,nf_rph2
F6D9: 1F      		rra
F6DA: 30F8    		jr	nc,nf_rph1
F6DC: 4A      		ld	c,d
F6DD: EDA2    		ini
F6DF: 4B      		ld	c,e
F6E0: 18F2    		jr	nf_rph1
F6E2: ED78    	nf_rph2:in	a,(c)
F6E4: E6FC    		and	0xFC
F6E6: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F6E7: 3A32FB  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F6EA: 1801    		jr	nf_dvsl
F6EC: AF      	nf_udsl:xor	a		; Unselects a drive
F6ED: C5      	nf_dvsl:push	bc
F6EE: 47      		ld	b,a
F6EF: 3A30FB  		ld	a,(nf_io)
F6F2: C60F    		add	a,0x0F
F6F4: 4F      		ld	c,a
F6F5: ED41    		out	(c),b
F6F7: 06FF    		ld	b,0xFF
F6F9: CD04F7  		call	nf_stal
F6FC: C1      		pop	bc
F6FD: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F6FE: ED78    	nf_busy:in	a,(c)
F700: 1F      		rra
F701: 38FB    		jr	c,nf_busy
F703: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F704: C5      	nf_stal:push	bc
F705: C1      		pop	bc
F706: 10FC    		djnz	nf_stal
F708: C9      		ret
              	
              	
              	; Variables
FB30:         	nf_io:	equ	nf_bss	; FDC address
FB31:         	nf_r2ks:equ	nf_bss+1; Temp storaged used in nf_r2k
              	
FB32:         	nf_curd:equ	nf_bss+2; Currently selected disk
FB33:         	nf_subs:equ	nf_bss+3; Current subsector
FB34:         	nf_sync:equ	nf_bss+4; Set if disk needs to be rehomed
FB35:         	nf_inco:equ	nf_bss+5; Set if sector is in core already
FB36:         	nf_dirt:equ	nf_bss+6; Set if cache is dirty
              	
              	; Misc CP/M buffer
FB37:         	nf_asva:equ	nf_bss+7
FB50:         	nf_asvb:equ	nf_bss+32
FB69:         	nf_csva:equ	nf_bss+57
FB79:         	nf_csvb:equ	nf_bss+73
              	#include "dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F709: B7      	prtdev:	or	a
F70A: 2808    		jr	z,pr_init
F70C: 3D      		dec	a
F70D: 2806    		jr	z,pr_stat
F70F: 3D      		dec	a
F710: 2805    		jr	z,pr_read
F712: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F714: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F715: AF      	pr_stat:xor	a
F716: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F717: AF      	pr_read:xor	a
F718: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F719: 3E0F    	pr_writ:ld	a,0x0F
F71B: D341    		out	(pr_atla),a	; AY register = 15
              		
F71D: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F71F: E610    		and	0x10
F721: 20FA    		jr	nz,pr_wri0
              		
F723: 79      		ld	a,c
F724: D3B0    		out	(pr_prnt),a	; Write data
              		
F726: 3E05    		ld	a,0x05		; Strobe
F728: D300    		out	(pr_ctrl),a
              		
F72A: 0620    		ld	b,32		
F72C: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
F72E: 3E01    		ld	a,0x01		; Strobe off
F730: D300    		out	(pr_ctrl),a
              		
F732: C9      		ret
              		
              	#include "dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	
              	
              	
              	; Driver jump table 
F733: B7      	siodev:	or	a
F734: 2808    		jr	z,so_init
F736: 3D      		dec	a
F737: 2833    		jr	z,so_stat
F739: 3D      		dec	a
F73A: 2841    		jr	z,so_read
F73C: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
F73E: 11A3F7  	so_init:ld	de,so_atab
F741: 45      		ld	b,l
F742: 04      		inc	b		; Slot 1,2,3,...
F743: 19      		add	hl,de 		; Get address table entry
F744: 0ECF    		ld	c,0xCF		; First slot
              		
F746: ED78    	so_ini0:in	a,(c)
F748: FE08    		cp	0x08
F74A: 2807    		jr	z,so_ini2
              		
F74C: 3E10    	so_ini1:ld	a,0x10
F74E: 81      		add	c
F74F: F0      		ret	p		; Can't find, failure
F750: 4F      		ld	c,a
F751: 18F3    		jr	so_ini0
              		
F753: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
F755: 79      		ld	a,c
F756: D60F    		sub	0x0F
F758: 4F      		ld	c,a
F759: 71      		ld	(hl),c
F75A: 11A7F7  		ld	de,so_conf
F75D: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
F75F: 1A      	so_ini3:ld	a,(de)
F760: 13      		inc	de
F761: 86      		add	a,(hl)
F762: 4F      		ld	c,a
F763: 1A      		ld	a,(de)
F764: 13      		inc	de
F765: ED79    		out	(c),a
F767: E5      		push	hl
F768: E1      		pop	hl	; Small delay
F769: 10F4    		djnz	so_ini3
F76B: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F76C: 11A3F7  	so_stat:ld	de,so_atab
F76F: 19      		add	hl,de
F770: AF      		xor	a
F771: BE      		cp	(hl)
F772: C8      		ret	z	; No device, return 0
F773: 4E      		ld	c,(hl)
F774: 0C      		inc	c
F775: ED78    	so_sta0:in	a,(c)	; Check status register
F777: E602    		and	0x02
F779: C8      		ret	z
F77A: 3EFF    		ld	a,0xFF
F77C: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
F77D: 11A3F7  	so_read:ld	de,so_atab
F780: 19      		add	hl,de
F781: AF      		xor	a
F782: BE      		cp	(hl)
F783: C8      		ret	z	; No device, return 0
F784: 4E      		ld	c,(hl)
F785: 0C      		inc	c
F786: CD75F7  	so_rea0:call	so_sta0	; Wait for a character
F789: 28FB    		jr	z,so_rea0
F78B: 0D      		dec	c
F78C: ED78    		in	a,(c)
F78E: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
F78F: 41      	so_writ:ld	b,c
F790: 11A3F7  		ld	de,so_atab
F793: 19      		add	hl,de
F794: AF      		xor	a
F795: BE      		cp	(hl)
F796: C8      		ret	z	; No device, return 0
F797: 4E      		ld	c,(hl)
F798: 0C      		inc	c
F799: ED78    	so_wri0:in	a,(c)
F79B: E601    		and	0x01
F79D: 28FA    		jr	z,so_wri0
F79F: 0D      		dec	c
F7A0: ED41    		out	(c),b
F7A2: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
F7A3: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
F7A7: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
F7A9: 0412    		defb	0x04,0x12
F7AB: 0400    		defb	0x04,0x00
F7AD: 0777    		defb	0x07,0x77	; Counter 2 setup
F7AF: 0512    		defb	0x05,0x12
F7B1: 0500    		defb	0x05,0x00
              		
F7B3: 0100    		defb	0x01,0x00	; 8251 setup
F7B5: 0100    		defb	0x01,0x00
F7B7: 0100    		defb	0x01,0x00
F7B9: 0100    		defb	0x01,0x00
F7BB: 0140    		defb	0x01,0x40
F7BD: 014E    		defb	0x01,0x4E
F7BF: 0137    		defb	0x01,0x37
              	
              	; Image top, no more code after this
F7C1:         	imgtop:
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	


; +++ segments +++

#CODE          = $D800 = 55296,  size = $1FC1 =  8129

; +++ global symbols +++

_end     = $F7C1 = 63425          cpm22.asm:42 (unused)
_size    = $1FC1 =  8129          cpm22.asm:42 (unused)
active   = $E348 = 58184          cpm22.asm:1709
adda2hl  = $E56A = 58730          cpm22.asm:2138
addhl    = $DA59 = 55897          cpm22.asm:432
alloc0   = $EDD0 = 60880          cpm22.asm:3686
alloc1   = $EDD2 = 60882          cpm22.asm:3687
alocvect = $EDC5 = 60869          cpm22.asm:3676
auto     = $EDE4 = 60900          cpm22.asm:3701
autoflag = $EDE6 = 60902          cpm22.asm:3703
autosel  = $EC57 = 60503          cpm22.asm:3416
autosl1  = $EC7B = 60539          cpm22.asm:3432
backup   = $E1AA = 57770          cpm22.asm:1469
backup1  = $E1B2 = 57778          cpm22.asm:1472
badload  = $DF87 = 57223          cpm22.asm:1201
badsctr  = $E00C = 57356          cpm22.asm:1252
badsec   = $E0D0 = 57552          cpm22.asm:1324
badsel   = $E0DB = 57563          cpm22.asm:1325
badslct  = $E00E = 57358          cpm22.asm:1253
batch    = $DFB8 = 57272          cpm22.asm:1224
batchfcb = $DFB9 = 57273          cpm22.asm:1225
bdevsw   = $EF6C = 61292          config.asm:140
bdosdrv  = $E0CC = 57548          cpm22.asm:1323
bdoserr  = $E0C0 = 57536          cpm22.asm:1322
bigdisk  = $EDE3 = 60899          cpm22.asm:3700
biodma   = $EF49 = 61257          bios.asm:314
bitmap   = $E6A9 = 59049          cpm22.asm:2431
bitmap1  = $E6B7 = 59063          cpm22.asm:2446
bitmap2  = $E6D8 = 59096          cpm22.asm:2467
bitmap3  = $E6FC = 59132          cpm22.asm:2484
blkmask  = $EDCA = 60874          cpm22.asm:3682
blknmbr  = $EDEB = 60907          cpm22.asm:3707
blkshft  = $EDC9 = 60873          cpm22.asm:3681
boot     = $EE45 = 60997          bios.asm:42
bs       = $0008 =     8          cpm22.asm:27
callbd   = $EEF8 = 61176          bios.asm:213
callmj   = $EF46 = 61254          bios.asm:308
cbase    = $D800 = 55296          cpm22.asm:44
ccpstack = $DFB8 = 57272          cpm22.asm:1220
cdevsw   = $EFAC = 61356          config.asm:179
cdindi0  = $EF1E = 61214          bios.asm:273
cdindi1  = $EF24 = 61220          bios.asm:277
cdindir  = $EF1A = 61210          bios.asm:271
cdrive   = $DFFC = 57340          cpm22.asm:1231
cfinit   = $EF4B = 61259          config.asm:57
cfirq    = $EF62 = 61282          config.asm:87
charbuf  = $E314 = 58132          cpm22.asm:1698
check    = $DA30 = 55856          cpm22.asm:398
checkdir = $E5A4 = 58788          cpm22.asm:2211
checksum = $E4FD = 58621          cpm22.asm:2050
chgdrv   = $DFFD = 57341          cpm22.asm:1232
chgnam1  = $E82D = 59437          cpm22.asm:2723
chgnames = $E81C = 59420          cpm22.asm:2715
chkblk   = $E48A = 58506          cpm22.asm:1957
chkchar  = $E11A = 57626          cpm22.asm:1366
chkcon   = $D9C2 = 55746          cpm22.asm:323
chkdir1  = $E5CA = 58826          cpm22.asm:2231
chknmbr  = $E592 = 58770          cpm22.asm:2184
chkrofl  = $E54A = 58698          cpm22.asm:2114
chksum1  = $E503 = 58627          cpm22.asm:2053
chkvect  = $EDC3 = 60867          cpm22.asm:3675
chkwprt  = $E55A = 58714          cpm22.asm:2125
chrout   = $EEBB = 61115          bios.asm:154
ckbitmap = $E63B = 58939          cpm22.asm:2325
ckbmap1  = $E65C = 58972          cpm22.asm:2360
ckcon1   = $E148 = 57672          cpm22.asm:1396
ckcon2   = $E14B = 57675          cpm22.asm:1397
ckconsol = $E129 = 57641          cpm22.asm:1382
ckfilpos = $E5FB = 58875          cpm22.asm:2274
ckrof1   = $E54D = 58701          cpm22.asm:2115
cksumtbl = $EDF2 = 60914          cpm22.asm:3715
clearbuf = $DB58 = 56152          cpm22.asm:598
clears2  = $E578 = 58744          cpm22.asm:2155
close    = $D8DA = 55514          cpm22.asm:138
closefil = $ECAB = 60587          cpm22.asm:3463
closeflg = $EDD8 = 60888          cpm22.asm:3692
closeit  = $E8A8 = 59560          cpm22.asm:2809
closeit1 = $E8D3 = 59603          cpm22.asm:2829
closeit2 = $E8E1 = 59617          cpm22.asm:2837
closeit3 = $E8E7 = 59623          cpm22.asm:2841
closeit4 = $E8EE = 59630          cpm22.asm:2844
closeit5 = $E903 = 59651          cpm22.asm:2857
closeit6 = $E91D = 59677          cpm22.asm:2875
closeit7 = $E925 = 59685          cpm22.asm:2878
cmdadr   = $DBCE = 56270          cpm22.asm:680
cmdtbl   = $DB10 = 56080          cpm22.asm:552
cmmnd1   = $DB82 = 56194          cpm22.asm:633
cmmnd2   = $DBA5 = 56229          cpm22.asm:652
cntrlc   = $0003 =     3          cpm22.asm:25
cntrle   = $0005 =     5          cpm22.asm:26
cntrlp   = $0010 =    16          cpm22.asm:32
cntrlr   = $0012 =    18          cpm22.asm:33
cntrls   = $0013 =    19          cpm22.asm:34
cntrlu   = $0015 =    21          cpm22.asm:35
cntrlx   = $0018 =    24          cpm22.asm:36
cntrlz   = $001A =    26          cpm22.asm:37
comblk   = $E47D = 58493          cpm22.asm:1948
comfile  = $DF90 = 57232          cpm22.asm:1202
command  = $DB5C = 56156          cpm22.asm:608
comprand = $EBAB = 60331          cpm22.asm:3282
conin    = $EEAD = 61101          bios.asm:141
conout   = $EEB9 = 61113          bios.asm:153
const    = $EEA2 = 61090          bios.asm:129
convert  = $DA60 = 55904          cpm22.asm:446
convfst  = $DA5E = 55902          cpm22.asm:440
convrt1  = $DA89 = 55945          cpm22.asm:469
convrt2  = $DA90 = 55952          cpm22.asm:472
convrt3  = $DA96 = 55958          cpm22.asm:479
convrt4  = $DA98 = 55960          cpm22.asm:480
convrt5  = $DAA9 = 55977          cpm22.asm:487
convrt6  = $DAAB = 55979          cpm22.asm:489
convrt7  = $DAAF = 55983          cpm22.asm:491
convrt8  = $DAB9 = 55993          cpm22.asm:495
counter  = $EDDE = 60894          cpm22.asm:3698
cpmlow   = $EE9A = 61082          bios.asm:118
cr       = $000D =    13          cpm22.asm:31
create   = $D909 = 55561          cpm22.asm:188
crlf     = $D898 = 55448          cpm22.asm:80
curpos   = $E312 = 58130          cpm22.asm:1696
de2hl    = $E355 = 58197          cpm22.asm:1727
de2hl1   = $E356 = 58198          cpm22.asm:1728
decode   = $DC05 = 56325          cpm22.asm:707
decode1  = $DC15 = 56341          cpm22.asm:713
decode2  = $DC37 = 56375          cpm22.asm:733 (unused)
decode3  = $DC40 = 56384          cpm22.asm:738
decode4  = $DC47 = 56391          cpm22.asm:742 (unused)
defdma   = $E5E0 = 58848          cpm22.asm:2249
del      = $007F =   127          cpm22.asm:38
delbatch = $D9DD = 55773          cpm22.asm:348
delete   = $D8EF = 55535          cpm22.asm:159
delfile  = $ECDD = 60637          cpm22.asm:3494
dirbuf   = $EDBF = 60863          cpm22.asm:3673
dirc1    = $E2E6 = 58086          cpm22.asm:1654
dircbuf  = $F900 = 63744          config.asm:40
dircio   = $E2DA = 58074          cpm22.asm:1648
dirdma   = $E5E6 = 58854          cpm22.asm:2254
dirdma1  = $E5E9 = 58857          cpm22.asm:2259
direct   = $DC84 = 56452          cpm22.asm:804
direct1  = $DC95 = 56469          cpm22.asm:811
direct2  = $DC9C = 56476          cpm22.asm:815
direct3  = $DCA5 = 56485          cpm22.asm:819
direct4  = $DCD9 = 56537          cpm22.asm:846
direct5  = $DCE1 = 56545          cpm22.asm:849
direct6  = $DCE6 = 56550          cpm22.asm:851
direct7  = $DD1B = 56603          cpm22.asm:875
direct8  = $DD1C = 56604          cpm22.asm:876
direct9  = $DD28 = 56616          cpm22.asm:880
dirread  = $E5DA = 58842          cpm22.asm:2244
dirsize  = $EDCE = 60878          cpm22.asm:3685
dirwrite = $E5CC = 58828          cpm22.asm:2236
diskpb   = $EDC1 = 60865          cpm22.asm:3674
diskro   = $E0E7 = 57575          cpm22.asm:1327
dmaset   = $D9D8 = 55768          cpm22.asm:343
doread   = $E3B8 = 58296          cpm22.asm:1798
dowrite  = $E3BE = 58302          cpm22.asm:1803
drect63  = $DD04 = 56580          cpm22.asm:865
drect65  = $DD06 = 56582          cpm22.asm:866
dselect  = $DC61 = 56417          cpm22.asm:774
dsksel   = $D8BD = 55485          cpm22.asm:112
dsksize  = $EDCC = 60876          cpm22.asm:3684
emptyfcb = $EDB2 = 60850          cpm22.asm:3660
entry    = $0005 =     5          cpm22.asm:18
entry1   = $D8C3 = 55491          cpm22.asm:119
entry2   = $D8F4 = 55540          cpm22.asm:165
eparam   = $EDDC = 60892          cpm22.asm:3696
erafil1  = $E7AA = 59306          cpm22.asm:2601
erafile  = $E7A2 = 59298          cpm22.asm:2598
erase    = $DD2C = 56620          cpm22.asm:889
erase1   = $DD4F = 56655          cpm22.asm:904
error1   = $E09F = 57503          cpm22.asm:1305
error2   = $E0AB = 57515          cpm22.asm:1311
error3   = $E0B1 = 57521          cpm22.asm:1314
error4   = $E0B7 = 57527          cpm22.asm:1317
error5   = $E0BA = 57530          cpm22.asm:1319
exists   = $DE8F = 56975          cpm22.asm:1066
extblk   = $E464 = 58468          cpm22.asm:1929
extblk1  = $E477 = 58487          cpm22.asm:1939
extmask  = $EDCB = 60875          cpm22.asm:3683
extract  = $DC58 = 56408          cpm22.asm:764
fbase    = $E006 = 57350          cpm22.asm:1247
fbase1   = $E014 = 57364          cpm22.asm:1260
fcb      = $DFDA = 57306          cpm22.asm:1229
fcb2hl   = $E564 = 58724          cpm22.asm:2133
fcbpos   = $EDEF = 60911          cpm22.asm:3709
fcbset   = $E803 = 59395          cpm22.asm:2693
fcreate  = $ECF2 = 60658          cpm22.asm:3511
ff       = $000C =    12          cpm22.asm:30 (unused)
filepos  = $EDF0 = 60912          cpm22.asm:3710
filero   = $E0E2 = 57570          cpm22.asm:1326
filesize = $ED53 = 60755          cpm22.asm:3585
findfst  = $E71E = 59166          cpm22.asm:2518
findnxt  = $E733 = 59187          cpm22.asm:2531
fndnxt1  = $E750 = 59216          cpm22.asm:2544
fndnxt2  = $E759 = 59225          cpm22.asm:2548
fndnxt3  = $E779 = 59257          cpm22.asm:2564
fndnxt4  = $E782 = 59266          cpm22.asm:2573
fndnxt5  = $E789 = 59273          cpm22.asm:2578
fndnxt6  = $E79A = 59290          cpm22.asm:2591
fndspa1  = $E7C6 = 59334          cpm22.asm:2631
fndspa2  = $E7D7 = 59351          cpm22.asm:2654
fndspa3  = $E7F2 = 59378          cpm22.asm:2675
fndspa4  = $E7FA = 59386          cpm22.asm:2685
fndspace = $E7C4 = 59332          cpm22.asm:2625
fndstat  = $EDDA = 60890          cpm22.asm:3694
functns  = $E04D = 57421          cpm22.asm:1296
getaloc  = $ED17 = 60695          cpm22.asm:3539
getback  = $DF93 = 57235          cpm22.asm:1208
getback1 = $DF96 = 57238          cpm22.asm:1209
getblk1  = $E44B = 58443          cpm22.asm:1907
getblk2  = $E459 = 58457          cpm22.asm:1916
getblk3  = $E462 = 58466          cpm22.asm:1921
getblock = $E444 = 58436          cpm22.asm:1904
getchar  = $E101 = 57601          cpm22.asm:1344
getcon   = $E2CE = 58062          cpm22.asm:1636
getcrnt  = $ED0A = 60682          cpm22.asm:3528
getcsts  = $E304 = 58116          cpm22.asm:1681
getdsk   = $D9D0 = 55760          cpm22.asm:334
getecho  = $E10C = 57612          cpm22.asm:1353
getempty = $E92A = 59690          cpm22.asm:2885
getext   = $DAC0 = 56000          cpm22.asm:502
getext1  = $DAC8 = 56008          cpm22.asm:506
getext2  = $DAD9 = 56025          cpm22.asm:513
getext3  = $DADB = 56027          cpm22.asm:515
getext4  = $DADF = 56031          cpm22.asm:517
getext5  = $DAE9 = 56041          cpm22.asm:521
getext6  = $DAF0 = 56048          cpm22.asm:525
getext7  = $DAF2 = 56050          cpm22.asm:526
getext8  = $DB01 = 56065          cpm22.asm:538
getext9  = $DB09 = 56073          cpm22.asm:543
getfst   = $ECB1 = 60593          cpm22.asm:3470
getfst1  = $ECC8 = 60616          cpm22.asm:3481
getinp   = $D939 = 55609          cpm22.asm:239
getinp1  = $D996 = 55702          cpm22.asm:295
getinp2  = $D9A7 = 55719          cpm22.asm:304
getinp3  = $D9AB = 55723          cpm22.asm:306
getinp4  = $D9BA = 55738          cpm22.asm:315
getiob   = $E2F3 = 58099          cpm22.asm:1662
getlog   = $ED04 = 60676          cpm22.asm:3523
getmt1   = $E94C = 59724          cpm22.asm:2901
getnext  = $E960 = 59744          cpm22.asm:2915
getnxt   = $ECCE = 60622          cpm22.asm:3486
getparm  = $ED2C = 60716          cpm22.asm:3556
getprm1  = $ED2F = 60719          cpm22.asm:3557
getrdr   = $E2D4 = 58068          cpm22.asm:1641
getrov   = $ED1D = 60701          cpm22.asm:3544
gets2    = $E56F = 58735          cpm22.asm:2147
getsetuc = $D915 = 55573          cpm22.asm:204
getuser  = $ED33 = 60723          cpm22.asm:3564
getusr   = $D913 = 55571          cpm22.asm:199
getver   = $EC84 = 60548          cpm22.asm:3440
getwprt  = $E524 = 58660          cpm22.asm:2087
goback   = $ED7A = 60794          cpm22.asm:3620
goback1  = $ED97 = 60823          cpm22.asm:3632
gtnext1  = $E989 = 59785          cpm22.asm:2935
gtnext2  = $E994 = 59796          cpm22.asm:2944
gtnext3  = $E9B2 = 59826          cpm22.asm:2955
gtnext4  = $E9B5 = 59829          cpm22.asm:2956
gtnext5  = $E9BC = 59836          cpm22.asm:2963
halt     = $DBDC = 56284          cpm22.asm:685
hl2de    = $DC4F = 56399          cpm22.asm:754
home     = $EEDB = 61147          bios.asm:187
homedrv  = $E3A7 = 58279          cpm22.asm:1784
imgtop   = $F7C1 = 63425          config.asm:199
inbuff   = $D806 = 55302          cpm22.asm:51
inbulen  = $D807 = 55303          config.asm:21
inpoint  = $D888 = 55432          cpm22.asm:60
iobyte   = $0003 =     3          cpm22.asm:16
ioerr1   = $E30B = 58123          cpm22.asm:1691
ioret    = $E3C1 = 58305          cpm22.asm:1804
jumphl   = $E350 = 58192          cpm22.asm:1719
lf       = $000A =    10          cpm22.asm:29
list     = $EEC5 = 61125          bios.asm:164
logical  = $E490 = 58512          cpm22.asm:1968
logicl1  = $E496 = 58518          cpm22.asm:1970
login    = $EDB5 = 60853          cpm22.asm:3662
logindrv = $EC27 = 60455          cpm22.asm:3384
logoff   = $ED59 = 60761          cpm22.asm:3594
logsect  = $EDED = 60909          cpm22.asm:3708
mem      = $0036 =    54          config.asm:19
mode     = $EDDB = 60891          cpm22.asm:3695
morefls  = $E585 = 58757          cpm22.asm:2171
move3    = $DC4D = 56397          cpm22.asm:750
movecd   = $D929 = 55593          cpm22.asm:221
movedir  = $E5EF = 58863          cpm22.asm:2266
moveword = $E89A = 59546          cpm22.asm:2792
namepnt  = $D88A = 55434          cpm22.asm:61
nbytes   = $DFFE = 57342          cpm22.asm:1233
nd_asva  = $F9FC = 63996          nabu_ndsk.asm:464
nd_asvb  = $FA7D = 64125          nabu_ndsk.asm:465
nd_atla  = $0041 =    65          nabu_ndsk.asm:29
nd_ayda  = $0040 =    64          nabu_ndsk.asm:28
nd_bss   = $F9B0 = 63920          config.asm:42
nd_buff  = $F9B6 = 63926          nabu_ndsk.asm:463
nd_ccp   = $F35E = 62302          nabu_ndsk.asm:212
nd_csec  = $F9B0 = 63920          nabu_ndsk.asm:461
nd_ctrk  = $F9B1 = 63921          nabu_ndsk.asm:462
nd_dpb   = $F2B3 = 62131          nabu_ndsk.asm:59
nd_dpha  = $F293 = 62099          nabu_ndsk.asm:45
nd_dphb  = $F2A3 = 62115          nabu_ndsk.asm:52
nd_fild  = $0080 =   128          nabu_ndsk.asm:33
nd_gbno  = $F339 = 62265          nabu_ndsk.asm:178
nd_get0  = $F3BC = 62396          nabu_ndsk.asm:271
nd_getb  = $F39B = 62363          nabu_ndsk.asm:254
nd_grb   = $F363 = 62307          nabu_ndsk.asm:216
nd_grb0  = $F366 = 62310          nabu_ndsk.asm:217
nd_grb1  = $F37A = 62330          nabu_ndsk.asm:224
nd_hcca  = $0080 =   128          nabu_ndsk.asm:30
nd_hcer  = $F42E = 62510          nabu_ndsk.asm:367
nd_hcr0  = $F41F = 62495          nabu_ndsk.asm:358
nd_hcr1  = $F434 = 62516          nabu_ndsk.asm:371
nd_hcrd  = $F414 = 62484          nabu_ndsk.asm:353
nd_hcre  = $F417 = 62487          nabu_ndsk.asm:354
nd_hcw0  = $F449 = 62537          nabu_ndsk.asm:391
nd_hcw1  = $F45A = 62554          nabu_ndsk.asm:401
nd_hcwd  = $F43D = 62525          nabu_ndsk.asm:385 (unused)
nd_hcwr  = $F440 = 62528          nabu_ndsk.asm:386
nd_hini  = $F349 = 62281          nabu_ndsk.asm:198
nd_home  = $F2DB = 62171          nabu_ndsk.asm:98
nd_init  = $F2DA = 62170          nabu_ndsk.asm:93
nd_m0    = $F483 = 62595          nabu_ndsk.asm:425
nd_m0fl  = $F489 = 62601          nabu_ndsk.asm:429 (unused)
nd_m0na  = $F48C = 62604          nabu_ndsk.asm:431
nd_m1    = $F49B = 62619          nabu_ndsk.asm:436
nd_m2    = $F4A3 = 62627          nabu_ndsk.asm:444
nd_m2bn  = $F4A9 = 62633          nabu_ndsk.asm:448
nd_m3    = $F4AF = 62639          nabu_ndsk.asm:453
nd_m3bn  = $F4B5 = 62645          nabu_ndsk.asm:457
nd_nctl  = $0000 =     0          nabu_ndsk.asm:31
nd_open  = $F384 = 62340          nabu_ndsk.asm:236
nd_p0    = $F464 = 62564          nabu_ndsk.asm:411
nd_p1    = $F46E = 62574          nabu_ndsk.asm:415
nd_p2    = $F478 = 62584          nabu_ndsk.asm:419
nd_p2im  = $F47D = 62589          nabu_ndsk.asm:420
nd_put0  = $F3E0 = 62432          nabu_ndsk.asm:300
nd_putb  = $F3CE = 62414          nabu_ndsk.asm:290
nd_read  = $F317 = 62231          nabu_ndsk.asm:152
nd_rec0  = $F401 = 62465          nabu_ndsk.asm:325
nd_rece  = $F3F6 = 62454          nabu_ndsk.asm:318
nd_sel   = $F2E2 = 62178          nabu_ndsk.asm:107
nd_send  = $F40B = 62475          nabu_ndsk.asm:339
nd_ssec  = $F312 = 62226          nabu_ndsk.asm:145
nd_strk  = $F30C = 62220          nabu_ndsk.asm:135
nd_writ  = $F328 = 62248          nabu_ndsk.asm:164
ndkdev   = $F2C2 = 62146          nabu_ndsk.asm:74
newline  = $E1B7 = 57783          cpm22.asm:1478
newln1   = $E1BF = 57791          cpm22.asm:1481
nf_asva  = $FB37 = 64311          nabu_fdc.asm:531
nf_asvb  = $FB50 = 64336          nabu_fdc.asm:532
nf_bss   = $FB30 = 64304          config.asm:43
nf_busy  = $F6FE = 63230          nabu_fdc.asm:506
nf_cach  = $FC00 = 64512          config.asm:44
nf_ccp   = $F689 = 63113          nabu_fdc.asm:404 (unused)
nf_csva  = $FB69 = 64361          nabu_fdc.asm:533
nf_csvb  = $FB79 = 64377          nabu_fdc.asm:534
nf_curd  = $FB32 = 64306          nabu_fdc.asm:524
nf_dirt  = $FB36 = 64310          nabu_fdc.asm:528
nf_dpb   = $F4DB = 62683          nabu_fdc.asm:52
nf_dpha  = $F4BB = 62651          nabu_fdc.asm:36
nf_dphb  = $F4CB = 62667          nabu_fdc.asm:44
nf_dvsc  = $F6E7 = 63207          nabu_fdc.asm:487
nf_dvsl  = $F6ED = 63213          nabu_fdc.asm:490
nf_grb   = $F682 = 63106          nabu_fdc.asm:399 (unused)
nf_home  = $F52D = 62765          nabu_fdc.asm:126
nf_inco  = $FB35 = 64309          nabu_fdc.asm:527
nf_ini1  = $F508 = 62728          nabu_fdc.asm:90
nf_ini2  = $F516 = 62742          nabu_fdc.asm:101
nf_init  = $F502 = 62722          nabu_fdc.asm:85
nf_io    = $FB30 = 64304          nabu_fdc.asm:521
nf_r2k   = $F68E = 63118          nabu_fdc.asm:409
nf_r2k0  = $F6B7 = 63159          nabu_fdc.asm:438
nf_r2ks  = $FB31 = 64305          nabu_fdc.asm:522
nf_rdsk  = $0002 =     2          nabu_fdc.asm:24
nf_rdw0  = $F60D = 62989          nabu_fdc.asm:301
nf_rdw1  = $F61B = 63003          nabu_fdc.asm:308
nf_rdwr  = $F5EE = 62958          nabu_fdc.asm:280
nf_read  = $F620 = 63008          nabu_fdc.asm:314
nf_rph1  = $F6D4 = 63188          nabu_fdc.asm:470
nf_rph2  = $F6E2 = 63202          nabu_fdc.asm:479
nf_rphy  = $F6CB = 63179          nabu_fdc.asm:461
nf_sel   = $F545 = 62789          nabu_fdc.asm:149
nf_sel0  = $F55F = 62815          nabu_fdc.asm:168
nf_sel1  = $F579 = 62841          nabu_fdc.asm:182
nf_sel2  = $F58B = 62859          nabu_fdc.asm:195
nf_selc  = $F56C = 62828          nabu_fdc.asm:176 (unused)
nf_seld  = $F550 = 62800          nabu_fdc.asm:157
nf_ssec  = $F5CF = 62927          nabu_fdc.asm:253
nf_stal  = $F704 = 63236          nabu_fdc.asm:514
nf_str0  = $F5B2 = 62898          nabu_fdc.asm:227
nf_strk  = $F599 = 62873          nabu_fdc.asm:208
nf_subs  = $FB33 = 64307          nabu_fdc.asm:525
nf_sync  = $FB34 = 64308          nabu_fdc.asm:526
nf_udsl  = $F6EC = 63212          nabu_fdc.asm:489
nf_wde1  = $F65B = 63067          nabu_fdc.asm:362
nf_wde2  = $F669 = 63081          nabu_fdc.asm:371
nf_wde3  = $F67A = 63098          nabu_fdc.asm:390
nf_wde4  = $F67D = 63101          nabu_fdc.asm:393
nf_wdef  = $F640 = 63040          nabu_fdc.asm:344
nf_writ  = $F628 = 63016          nabu_fdc.asm:322
nfddev   = $F4EA = 62698          nabu_fdc.asm:69
nfuncts  = $0029 =    41          cpm22.asm:1294
nh_get1  = $F3C6 = 62406          nabu_ndsk.asm:278
nofile   = $DBFD = 56317          cpm22.asm:700
nonblank = $DA4F = 55887          cpm22.asm:422
none     = $DBF7 = 56311          cpm22.asm:698
nospace  = $DE14 = 56852          cpm22.asm:1008
nulldev  = $EF45 = 61253          bios.asm:305 (unused)
numcmds  = $0006 =     6          cpm22.asm:551
nxent1   = $E61F = 58911          cpm22.asm:2304
nxent2   = $E626 = 58918          cpm22.asm:2307
nxentry  = $E60B = 58891          cpm22.asm:2296
offset   = $EDD4 = 60884          cpm22.asm:3688
olddrv   = $EDE5 = 60901          cpm22.asm:3702
open     = $D8CB = 55499          cpm22.asm:126
openfcb  = $D8D0 = 55504          cpm22.asm:131
openfil  = $ECA2 = 60578          cpm22.asm:3457
openit   = $E857 = 59479          cpm22.asm:2749
openit1  = $E860 = 59488          cpm22.asm:2753
openit2  = $E891 = 59537          cpm22.asm:2781
outchar  = $E14E = 57678          cpm22.asm:1404
outchr1  = $E168 = 57704          cpm22.asm:1418
outchr2  = $E17F = 57727          cpm22.asm:1434
outcon   = $E196 = 57750          cpm22.asm:1455
outcon1  = $E19C = 57756          cpm22.asm:1458
outcrlf  = $E1CF = 57807          cpm22.asm:1491
outflag  = $E310 = 58128          cpm22.asm:1694
params   = $E349 = 58185          cpm22.asm:1710
pattrn1  = $DB28 = 56104          cpm22.asm:562
pattrn2  = $E000 = 57344          cpm22.asm:1239
pline    = $D8A7 = 55463          cpm22.asm:93
pline2   = $D8AC = 55468          cpm22.asm:96
position = $EB09 = 60169          cpm22.asm:3159
positn1  = $EB0D = 60173          cpm22.asm:3164
positn2  = $EB4D = 60237          cpm22.asm:3210
positn3  = $EB85 = 60293          cpm22.asm:3242
positn4  = $EB8A = 60298          cpm22.asm:3248
positn5  = $EB91 = 60305          cpm22.asm:3255
pr_atla  = $0041 =    65          nabu_prt.asm:13
pr_ayda  = $0040 =    64          nabu_prt.asm:12
pr_ctrl  = $0000 =     0          nabu_prt.asm:15
pr_init  = $F714 = 63252          nabu_prt.asm:30
pr_prnt  = $00B0 =   176          nabu_prt.asm:14
pr_read  = $F717 = 63255          nabu_prt.asm:45
pr_stat  = $F715 = 63253          nabu_prt.asm:37
pr_wri0  = $F71D = 63261          nabu_prt.asm:55
pr_wri1  = $F72C = 63276          nabu_prt.asm:66
pr_writ  = $F719 = 63257          nabu_prt.asm:52
print    = $D88C = 55436          cpm22.asm:66
printb   = $D892 = 55442          cpm22.asm:72
printdc  = $EE02 = 60930          cpm22.asm:3718
prstat   = $EF14 = 61204          bios.asm:259
prtdev   = $F709 = 63241          nabu_prt.asm:18
prterr   = $E0EB = 57579          cpm22.asm:1331
prtflag  = $E313 = 58131          cpm22.asm:1697
prtmesg  = $E1D9 = 57817          cpm22.asm:1498
prtstr   = $E2FE = 58110          cpm22.asm:1674
punch    = $EEC9 = 61129          bios.asm:170
putdma   = $ED10 = 60688          cpm22.asm:3533
ransiz1  = $EBEA = 60394          cpm22.asm:3338
ransiz2  = $EC0C = 60428          cpm22.asm:3360
ransiz3  = $EC12 = 60434          cpm22.asm:3362
ransize  = $EBD8 = 60376          cpm22.asm:3327
rdbuf1   = $E1F5 = 57845          cpm22.asm:1517
rdbuf10  = $E276 = 57974          cpm22.asm:1579
rdbuf11  = $E27E = 57982          cpm22.asm:1585
rdbuf12  = $E290 = 58000          cpm22.asm:1597
rdbuf13  = $E29F = 58015          cpm22.asm:1604
rdbuf14  = $E2AC = 58028          cpm22.asm:1612
rdbuf15  = $E2AF = 58031          cpm22.asm:1615
rdbuf16  = $E2C3 = 58051          cpm22.asm:1627
rdbuf17  = $E2C7 = 58055          cpm22.asm:1629
rdbuf2   = $E1F7 = 57847          cpm22.asm:1519
rdbuf3   = $E21C = 57884          cpm22.asm:1536
rdbuf4   = $E22C = 57900          cpm22.asm:1545
rdbuf5   = $E23D = 57917          cpm22.asm:1553
rdbuf6   = $E24E = 57934          cpm22.asm:1562
rdbuf7   = $E254 = 57940          cpm22.asm:1565
rdbuf8   = $E265 = 57957          cpm22.asm:1572
rdbuf9   = $E271 = 57969          cpm22.asm:1577
rdbuff   = $E1E7 = 57831          cpm22.asm:1510
rderr    = $DBEC = 56300          cpm22.asm:694
rderror  = $DBE6 = 56294          cpm22.asm:692
rdrandom = $ED47 = 60743          cpm22.asm:3575
rdrec    = $D8F9 = 55545          cpm22.asm:172
rdseq    = $E9C2 = 59842          cpm22.asm:2968
rdseq1   = $E9C7 = 59847          cpm22.asm:2970
rdseq2   = $E9EC = 59884          cpm22.asm:2985
rdseq3   = $EA01 = 59905          cpm22.asm:2995
rdwrtflg = $EDD9 = 60889          cpm22.asm:3693
read     = $EF0C = 61196          bios.asm:244
reader   = $EECD = 61133          bios.asm:176
readfcb  = $D8FE = 55550          cpm22.asm:177
readran  = $EB99 = 60313          cpm22.asm:3262
readseq  = $ECE6 = 60646          cpm22.asm:3501
relblock = $EDDD = 60893          cpm22.asm:3697
renam    = $D90E = 55566          cpm22.asm:194
rename   = $DE1D = 56861          cpm22.asm:1016
rename1  = $DE4C = 56908          cpm22.asm:1034
rename2  = $DE66 = 56934          cpm22.asm:1048
rename3  = $DE6B = 56939          cpm22.asm:1051 (unused)
rename4  = $DE7A = 56954          cpm22.asm:1059
rename5  = $DE80 = 56960          cpm22.asm:1061
rename6  = $DE86 = 56966          cpm22.asm:1063
renfile  = $ECFB = 60667          cpm22.asm:3517
resccp   = $EF66 = 61286          config.asm:129
resdsk   = $D8B8 = 55480          cpm22.asm:107
resetdr  = $DC73 = 56435          cpm22.asm:788
resgrb   = $EF69 = 61289          config.asm:135
rodisk   = $E010 = 57360          cpm22.asm:1254
rofile   = $E012 = 57362          cpm22.asm:1255
rstdsk   = $EC89 = 60553          cpm22.asm:3445
rtn      = $E30A = 58122          cpm22.asm:1687
rtncode  = $DFFB = 57339          cpm22.asm:1230
samext   = $E70D = 59149          cpm22.asm:2499
savatr1  = $E846 = 59462          cpm22.asm:2739
save     = $DDBA = 56762          cpm22.asm:961
save1    = $DDE1 = 56801          cpm22.asm:979
save2    = $DDFE = 56830          cpm22.asm:997
save3    = $DE08 = 56840          cpm22.asm:1004
save4    = $DE0E = 56846          cpm22.asm:1006
saveattr = $E841 = 59457          cpm22.asm:2737
savefcb  = $EDDF = 60895          cpm22.asm:3699
savext   = $EDE8 = 60904          cpm22.asm:3705
savnrec  = $EDE9 = 60905          cpm22.asm:3706
savnxt   = $EDE7 = 60903          cpm22.asm:3704
scratch1 = $EDB9 = 60857          cpm22.asm:3667
scratch2 = $EDBB = 60859          cpm22.asm:3668
scratch3 = $EDBD = 60861          cpm22.asm:3669
search   = $DB2E = 56110          cpm22.asm:570
search1  = $DB33 = 56115          cpm22.asm:572
search2  = $DB3C = 56124          cpm22.asm:577
search3  = $DB4F = 56143          cpm22.asm:589
search4  = $DB54 = 56148          cpm22.asm:592
sectors  = $EDC7 = 60871          cpm22.asm:3680
sectrn   = $EF17 = 61207          bios.asm:264
seldsk   = $EEE0 = 61152          bios.asm:196
select   = $E35F = 58207          cpm22.asm:1738
select1  = $E3A3 = 58275          cpm22.asm:1778
setattr  = $ED23 = 60707          cpm22.asm:3549
setbit   = $E511 = 58641          cpm22.asm:2070
setcdrv  = $D91A = 55578          cpm22.asm:209
setdir   = $E5A2 = 58786          cpm22.asm:2204
setdma   = $EF06 = 61190          bios.asm:236
setdsk   = $EC4B = 60491          cpm22.asm:3405
setext   = $E4AC = 58540          cpm22.asm:1985
setfile  = $E671 = 58993          cpm22.asm:2389
setfl1   = $E67B = 59003          cpm22.asm:2394
setfl2   = $E68E = 59022          cpm22.asm:2406
setfl3   = $E694 = 59028          cpm22.asm:2412
setfl4   = $E6A3 = 59043          cpm22.asm:2421
sethlde  = $E4B4 = 58548          cpm22.asm:1993
setiob   = $E2F9 = 58105          cpm22.asm:1667
setnrec  = $E4D8 = 58584          cpm22.asm:2019
setran   = $EC14 = 60436          cpm22.asm:3368
sets2b7  = $E57E = 58750          cpm22.asm:2161
setsec   = $EF02 = 61186          bios.asm:229
setstat  = $E307 = 58119          cpm22.asm:1686
settrk   = $EEFE = 61182          bios.asm:222
setuser  = $ED41 = 60737          cpm22.asm:3569
shiftl   = $E50A = 58634          cpm22.asm:2061
shiftl1  = $E50B = 58635          cpm22.asm:2062
shiftr   = $E4F0 = 58608          cpm22.asm:2035
shiftr1  = $E4F1 = 58609          cpm22.asm:2036
showit   = $E185 = 57733          cpm22.asm:1442
siodev   = $F733 = 63283          nabu_sio.asm:19
slcterr  = $E34D = 58189          cpm22.asm:1715
so_atab  = $F7A3 = 63395          nabu_sio.asm:130
so_conf  = $F7A7 = 63399          nabu_sio.asm:134
so_ini0  = $F746 = 63302          nabu_sio.asm:38
so_ini1  = $F74C = 63308          nabu_sio.asm:42
so_ini2  = $F753 = 63315          nabu_sio.asm:48
so_ini3  = $F75F = 63327          nabu_sio.asm:58
so_init  = $F73E = 63294          nabu_sio.asm:32
so_rea0  = $F786 = 63366          nabu_sio.asm:101
so_read  = $F77D = 63357          nabu_sio.asm:94
so_sta0  = $F775 = 63349          nabu_sio.asm:82
so_stat  = $F76C = 63340          nabu_sio.asm:75
so_wri0  = $F799 = 63385          nabu_sio.asm:120
so_writ  = $F78F = 63375          nabu_sio.asm:112
space    = $D8A2 = 55458          cpm22.asm:87
srchfcb  = $D8E9 = 55529          cpm22.asm:154
srchfst  = $D8DF = 55519          cpm22.asm:144
srchnxt  = $D8E4 = 55524          cpm22.asm:149
starting = $E311 = 58129          cpm22.asm:1695
status   = $E34B = 58187          cpm22.asm:1711
stbitmap = $E662 = 58978          cpm22.asm:2369
stbmap1  = $E66A = 58986          cpm22.asm:2380
stddma   = $D9D5 = 55765          cpm22.asm:339
stfilpos = $E604 = 58884          cpm22.asm:2284
stkarea  = $E347 = 58183          cpm22.asm:1706
stnrec1  = $E4E4 = 58596          cpm22.asm:2024
strdata  = $E4C1 = 58561          cpm22.asm:2003
ststatus = $E707 = 59143          cpm22.asm:2491
subhl    = $E59B = 58779          cpm22.asm:2194
swindi0  = $EF2D = 61229          bios.asm:288
swindi1  = $EF33 = 61235          bios.asm:292
swindir  = $EF29 = 61225          bios.asm:286
synerr   = $DA09 = 55817          cpm22.asm:377
synerr1  = $DA0F = 55823          cpm22.asm:379
synerr2  = $DA22 = 55842          cpm22.asm:389
syshook  = $EF65 = 61285          config.asm:107
tab      = $0009 =     9          cpm22.asm:28
tbase    = $0100 =   256          cpm22.asm:21
tbuff    = $0080 =   128          cpm22.asm:20
tdrive   = $0004 =     4          cpm22.asm:17
tfcb     = $005C =    92          cpm22.asm:19
tm_40c   = $F193 = 61843          nabu_vdp.asm:389
tm_80c   = $F1A0 = 61856          nabu_vdp.asm:396
tm_addh  = $F284 = 62084          nabu_vdp.asm:593
tm_addr  = $F286 = 62086          nabu_vdp.asm:595
tm_bs    = $F0F1 = 61681          nabu_vdp.asm:280
tm_bss   = $F980 = 63872          config.asm:41
tm_cbuf  = $F986 = 63878          nabu_vdp.asm:613
tm_cha0  = $F232 = 62002          nabu_vdp.asm:525
tm_chat  = $F22C = 61996          nabu_vdp.asm:520
tm_cle0  = $F17F = 61823          nabu_vdp.asm:374
tm_clea  = $F170 = 61808          nabu_vdp.asm:365
tm_cles  = $F16E = 61806          nabu_vdp.asm:364
tm_cloc  = $F01F = 61471          nabu_vdp.asm:119
tm_cls   = $F273 = 62067          nabu_vdp.asm:579
tm_cls0  = $F27C = 62076          nabu_vdp.asm:582
tm_cr    = $F0EE = 61678          nabu_vdp.asm:277
tm_cshm  = $F100 = 61696          nabu_vdp.asm:294
tm_cupd  = $F197 = 61847          nabu_vdp.asm:391
tm_curx  = $F980 = 63872          nabu_vdp.asm:607
tm_cury  = $F981 = 63873          nabu_vdp.asm:608
tm_data  = $00A0 =   160          nabu_vdp.asm:22
tm_dsc0  = $F1B9 = 61881          nabu_vdp.asm:411
tm_dsco  = $F1A6 = 61862          nabu_vdp.asm:404
tm_esc   = $F135 = 61749          nabu_vdp.asm:326
tm_esc0  = $F143 = 61763          nabu_vdp.asm:335
tm_esc1  = $F158 = 61784          nabu_vdp.asm:347
tm_esc2  = $F163 = 61795          nabu_vdp.asm:354
tm_escd  = $F13E = 61758          nabu_vdp.asm:332
tm_esci  = $F152 = 61778          nabu_vdp.asm:344
tm_escr  = $F13F = 61759          nabu_vdp.asm:333
tm_escs  = $F984 = 63876          nabu_vdp.asm:611
tm_getc  = $F1CC = 61900          nabu_vdp.asm:432
tm_home  = $F103 = 61699          nabu_vdp.asm:295
tm_ini0  = $F014 = 61460          nabu_vdp.asm:106
tm_inir  = $EFD2 = 61394          nabu_vdp.asm:57
tm_init  = $EFF8 = 61432          nabu_vdp.asm:88
tm_inr0  = $EFD3 = 61395          nabu_vdp.asm:58
tm_keyd  = $0090 =   144          nabu_vdp.asm:25
tm_keys  = $0091 =   145          nabu_vdp.asm:26
tm_last  = $F985 = 63877          nabu_vdp.asm:612
tm_latc  = $00A1 =   161          nabu_vdp.asm:23
tm_lf    = $F0E2 = 61666          nabu_vdp.asm:268
tm_map   = $F1DC = 61916          nabu_vdp.asm:449
tm_map0  = $F1E0 = 61920          nabu_vdp.asm:453
tm_map2  = $F1EC = 61932          nabu_vdp.asm:466
tm_mapt  = $F1F3 = 61939          nabu_vdp.asm:473
tm_mode  = $F291 = 62097          nabu_vdp.asm:604
tm_oti0  = $EFCA = 61386          nabu_vdp.asm:44
tm_otir  = $EFC9 = 61385          nabu_vdp.asm:43
tm_outc  = $F982 = 63874          nabu_vdp.asm:609
tm_putc  = $F208 = 61960          nabu_vdp.asm:491
tm_putf  = $F216 = 61974          nabu_vdp.asm:499 (unused)
tm_rea0  = $F077 = 61559          nabu_vdp.asm:183
tm_rea1  = $F08C = 61580          nabu_vdp.asm:196
tm_rea2  = $F09C = 61596          nabu_vdp.asm:206
tm_read  = $F061 = 61537          nabu_vdp.asm:171
tm_ri    = $F0DB = 61659          nabu_vdp.asm:262
tm_sclf  = $F037 = 61495          nabu_vdp.asm:135
tm_scr0  = $F02F = 61487          nabu_vdp.asm:132
tm_scr1  = $F035 = 61493          nabu_vdp.asm:134
tm_scri  = $F025 = 61477          nabu_vdp.asm:127
tm_scro  = $F983 = 63875          nabu_vdp.asm:610
tm_setp  = $F041 = 61505          nabu_vdp.asm:145
tm_sta0  = $EFE6 = 61414          nabu_vdp.asm:75
tm_sta1  = $F0AD = 61613          nabu_vdp.asm:220
tm_stal  = $F0AA = 61610          nabu_vdp.asm:218
tm_stat  = $EFDB = 61403          nabu_vdp.asm:70
tm_up    = $F0FB = 61691          nabu_vdp.asm:289
tm_usc0  = $F25F = 62047          nabu_vdp.asm:558
tm_usco  = $F250 = 62032          nabu_vdp.asm:551
tm_vcpy  = $F238 = 62008          nabu_vdp.asm:537
tm_wri0  = $F0C8 = 61640          nabu_vdp.asm:250
tm_wri1  = $F107 = 61703          nabu_vdp.asm:300
tm_writ  = $F0B3 = 61619          nabu_vdp.asm:232
trksec   = $E3C9 = 58313          cpm22.asm:1812
trksec1  = $E3D7 = 58327          cpm22.asm:1821
trksec2  = $E3EA = 58346          cpm22.asm:1834
trksec3  = $E400 = 58368          cpm22.asm:1850
trksec4  = $E415 = 58389          cpm22.asm:1867
type     = $DD6A = 56682          cpm22.asm:918
type1    = $DD81 = 56705          cpm22.asm:926
type2    = $DD84 = 56708          cpm22.asm:927 (unused)
type3    = $DD94 = 56724          cpm22.asm:936
type4    = $DDAD = 56749          cpm22.asm:949
type5    = $DDB4 = 56756          cpm22.asm:952
unknown  = $DEB2 = 57010          cpm22.asm:1090
unkwn0   = $DF7E = 57214          cpm22.asm:1198
unkwn1   = $DED1 = 57041          cpm22.asm:1105
unkwn2   = $DEDA = 57050          cpm22.asm:1109 (unused)
unkwn3   = $DEEE = 57070          cpm22.asm:1120
unkwn4   = $DF0E = 57102          cpm22.asm:1139
unkwn5   = $DF3D = 57149          cpm22.asm:1160
unkwn6   = $DF4B = 57163          cpm22.asm:1170
unkwn7   = $DF50 = 57168          cpm22.asm:1172
unkwn8   = $DF5C = 57180          cpm22.asm:1180
unkwn9   = $DF78 = 57208          cpm22.asm:1196
update   = $E807 = 59399          cpm22.asm:2700
update1  = $E816 = 59414          cpm22.asm:2708
upper    = $D930 = 55600          cpm22.asm:228
user     = $DE9B = 56987          cpm22.asm:1074
userdma  = $EDB7 = 60855          cpm22.asm:3663
userno   = $E347 = 58183          cpm22.asm:1708
usrstack = $E315 = 58133          cpm22.asm:1702
vdpdev   = $EFBC = 61372          nabu_vdp.asm:29
verify   = $D9F5 = 55797          cpm22.asm:363
verify1  = $D9FD = 55805          cpm22.asm:366
wboot    = $EE53 = 61011          bios.asm:56
wboot0   = $EE74 = 61044          bios.asm:86
wbootin  = $EE15 = 60949          bios.asm:22
wbootr   = $EE64 = 61028          bios.asm:74
write    = $EF10 = 61200          bios.asm:251
writeran = $EBA2 = 60322          cpm22.asm:3269
wrtprt   = $EDB3 = 60851          cpm22.asm:3661
wrtprtd  = $E532 = 58674          cpm22.asm:2097
wrtrec   = $D904 = 55556          cpm22.asm:183
wrtseq   = $ECEC = 60652          cpm22.asm:3506
wtrandom = $ED4D = 60749          cpm22.asm:3580
wtseq    = $EA04 = 59908          cpm22.asm:2999
wtseq1   = $EA09 = 59913          cpm22.asm:3001
wtseq10  = $EAD8 = 60120          cpm22.asm:3116
wtseq11  = $EB04 = 60164          cpm22.asm:3140
wtseq12  = $EB06 = 60166          cpm22.asm:3141
wtseq2   = $EA41 = 59969          cpm22.asm:3024
wtseq3   = $EA4E = 59982          cpm22.asm:3030
wtseq4   = $EA6A = 60010          cpm22.asm:3042
wtseq5   = $EA72 = 60018          cpm22.asm:3049
wtseq6   = $EA74 = 60020          cpm22.asm:3050
wtseq7   = $EA92 = 60050          cpm22.asm:3073
wtseq8   = $EAA0 = 60064          cpm22.asm:3080
wtseq9   = $EAC1 = 60097          cpm22.asm:3100
wtseq99  = $EAE5 = 60133          cpm22.asm:3127 (unused)
wtspecl  = $EDA1 = 60833          cpm22.asm:3646
xlate    = $EDD6 = 60886          cpm22.asm:3689
yesno    = $DD5F = 56671          cpm22.asm:910


total time: 0.0413 sec.
no errors
