              	; --------------------------------------
              	; zasm: assemble "config\config_fdc.asm"
              	; date: 2023-05-15 01:28:00
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0037:         	mem	equ	55		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
DC00:         	#code	_TEXT,(mem)*1024
F9A1:         	#data	_BSS,_TEXT_end
F9A1: 00000000	dircbuf:defs	128
F9A5: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "CPM22.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*         Custom CCP prompt by NabuNetwork.com
              	;*
              	;**************************************************************
              	;
              	;   set origin for cp/m
              	;
              	;	org	(mem)*1024
              	;
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0005:         	entry	equ	5		;entry point for the cp/m bdos.
005C:         	tfcb	equ	5ch		;default file control block.
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
DC00: C35CDF  	cbase:	jp	command		;execute command processor (ccp).
DC03: C358DF  		jp	clearbuf	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   standard cp/m ccp input buffer. format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
DC06: 7F      	inbuff:	defb	127		;length of input buffer.
DC07: 00      		defb	0		;current length of contents.
DC08: 494E4954		defb	'INIT '
DC0C: 20      	
DC0D: FF000000		defb	255,0,0,0
DC11: 20313937		defb	' 1979 (c) by Digital Research      '
DC15: 39202863	
DC19: 29206279	
DC1D: 20446967	
DC21: 6974616C	
DC25: 20526573	
DC29: 65617263	
DC2D: 68202020	
DC31: 202020  	
DC34: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC38: 00...   	
DC4B: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC4F: 00...   	
DC62: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC66: 00...   	
DC79: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC7D: 00...   	
DC88: 08DC    	inpoint:defw	inbuff+2	;input line pointer
DC8A: 0000    	namepnt:defw	0		;input line pointer used for error message. points to
              	;			;start of name in error.
              	;
              	;   routine to print (a) on the console. all registers used.
              	;
DC8C: 5F      	print:	ld	e,a		;setup bdos call.
DC8D: 0E02    		ld	c,2
DC8F: C30500  		jp	entry
              	;
              	;   routine to print (a) on the console and to save (bc).
              	;
DC92: C5      	printb:	push	bc
DC93: CD8CDC  		call	print
DC96: C1      		pop	bc
DC97: C9      		ret	
              	;
              	;   routine to send a carriage return, line feed combination
              	; to the console.
              	;
DC98: 3E0D    	crlf:	ld	a,cr
DC9A: CD92DC  		call	printb
DC9D: 3E0A    		ld	a,lf
DC9F: C392DC  		jp	printb
              	;
              	;   routine to send one space to the console and save (bc).
              	;
DCA2: 3E20    	space:	ld	a,' '
DCA4: C392DC  		jp	printb
              	;
              	;   routine to print character string pointed to be (bc) on the
              	; console. it must terminate with a null byte.
              	;
DCA7: C5      	pline:	push	bc
DCA8: CD98DC  		call	crlf
DCAB: E1      		pop	hl
DCAC: 7E      	pline2:	ld	a,(hl)
DCAD: B7      		or	a
DCAE: C8      		ret	z
DCAF: 23      		inc	hl
DCB0: E5      		push	hl
DCB1: CD8CDC  		call	print
DCB4: E1      		pop	hl
DCB5: C3ACDC  		jp	pline2
              	;
              	;   routine to reset the disk system.
              	;
DCB8: 0E0D    	resdsk:	ld	c,13
DCBA: C30500  		jp	entry
              	;
              	;   routine to select disk (a).
              	;
DCBD: 5F      	dsksel:	ld	e,a
DCBE: 0E0E    		ld	c,14
DCC0: C30500  		jp	entry
              	;
              	;   routine to call bdos and save the return code. the zero
              	; flag is set on a return of 0ffh.
              	;
DCC3: CD0500  	entry1:	call	entry
DCC6: 32FBE3  		ld	(rtncode),a	;save return code.
DCC9: 3C      		inc	a		;set zero if 0ffh returned.
DCCA: C9      		ret	
              	;
              	;   routine to open a file. (de) must point to the fcb.
              	;
DCCB: 0E0F    	open:	ld	c,15
DCCD: C3C3DC  		jp	entry1
              	;
              	;   routine to open file at (fcb).
              	;
DCD0: AF      	openfcb:xor	a		;clear the record number byte at fcb+32
DCD1: 32FAE3  		ld	(fcb+32),a
DCD4: 11DAE3  		ld	de,fcb
DCD7: C3CBDC  		jp	open
              	;
              	;   routine to close a file. (de) points to fcb.
              	;
DCDA: 0E10    	close:	ld	c,16
DCDC: C3C3DC  		jp	entry1
              	;
              	;   routine to search for the first file with ambigueous name
              	; (de).
              	;
DCDF: 0E11    	srchfst:ld	c,17
DCE1: C3C3DC  		jp	entry1
              	;
              	;   search for the next ambigeous file name.
              	;
DCE4: 0E12    	srchnxt:ld	c,18
DCE6: C3C3DC  		jp	entry1
              	;
              	;   search for file at (fcb).
              	;
DCE9: 11DAE3  	srchfcb:ld	de,fcb
DCEC: C3DFDC  		jp	srchfst
              	;
              	;   routine to delete a file pointed to by (de).
              	;
DCEF: 0E13    	delete:	ld	c,19
DCF1: C30500  		jp	entry
              	;
              	;   routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
DCF4: CD0500  	entry2:	call	entry
DCF7: B7      		or	a		;set zero flag if appropriate.
DCF8: C9      		ret	
              	;
              	;   routine to read the next record from a sequential file.
              	; (de) points to the fcb.
              	;
DCF9: 0E14    	rdrec:	ld	c,20
DCFB: C3F4DC  		jp	entry2
              	;
              	;   routine to read file at (fcb).
              	;
DCFE: 11DAE3  	readfcb:ld	de,fcb
DD01: C3F9DC  		jp	rdrec
              	;
              	;   routine to write the next record of a sequential file.
              	; (de) points to the fcb.
              	;
DD04: 0E15    	wrtrec:	ld	c,21
DD06: C3F4DC  		jp	entry2
              	;
              	;   routine to create the file pointed to by (de).
              	;
DD09: 0E16    	create:	ld	c,22
DD0B: C3C3DC  		jp	entry1
              	;
              	;   routine to rename the file pointed to by (de). note that
              	; the new name starts at (de+16).
              	;
DD0E: 0E17    	renam:	ld	c,23
DD10: C30500  		jp	entry
              	;
              	;   get the current user code.
              	;
DD13: 1EFF    	getusr:	ld	e,0ffh
              	;
              	;   routne to get or set the current user code.
              	; if (e) is ff then this is a get, else it is a set.
              	;
DD15: 0E20    	getsetuc: ld	c,32
DD17: C30500  		jp	entry
              	;
              	;   routine to set the current drive byte at (tdrive).
              	;
DD1A: CD13DD  	setcdrv:call	getusr		;get user number
DD1D: 87      		add	a,a		;and shift into the upper 4 bits.
DD1E: 87      		add	a,a
DD1F: 87      		add	a,a
DD20: 87      		add	a,a
DD21: 21FCE3  		ld	hl,cdrive	;now add in the current drive number.
DD24: B6      		or	(hl)
DD25: 320400  		ld	(tdrive),a	;and save.
DD28: C9      		ret	
              	;
              	;   move currently active drive down to (tdrive).
              	;
DD29: 3AFCE3  	movecd:	ld	a,(cdrive)
DD2C: 320400  		ld	(tdrive),a
DD2F: C9      		ret	
              	;
              	;   routine to convert (a) into upper case ascii. only letters
              	; are affected.
              	;
DD30: FE61    	upper:	cp	'a'		;check for letters in the range of 'a' to 'z'.
DD32: D8      		ret	c
DD33: FE7B    		cp	'{'
DD35: D0      		ret	nc
DD36: E65F    		and	5fh		;convert it if found.
DD38: C9      		ret	
              	;
              	;   routine to get a line of input. we must check to see if the
              	; user is in (batch) mode. if so, then read the input from file
              	; ($$$.sub). at the end, reset to console input.
              	;
DD39: 3AB8E3  	getinp:	ld	a,(batch)	;if =0, then use console input.
DD3C: B7      		or	a
DD3D: CA96DD  		jp	z,getinp1
              	;
              	;   use the submit file ($$$.sub) which is prepared by a
              	; submit run. it must be on drive (a) and it will be deleted
              	; if and error occures (like eof).
              	;
DD40: 3AFCE3  		ld	a,(cdrive)	;select drive 0 if need be.
DD43: B7      		or	a
DD44: 3E00    		ld	a,0		;always use drive a for submit.
DD46: C4BDDC  		call	nz,dsksel	;select it if required.
DD49: 11B9E3  		ld	de,batchfcb
DD4C: CDCBDC  		call	open		;look for it.
DD4F: CA96DD  		jp	z,getinp1	;if not there, use normal input.
DD52: 3AC8E3  		ld	a,(batchfcb+15)	;get last record number+1.
DD55: 3D      		dec	a
DD56: 32D9E3  		ld	(batchfcb+32),a
DD59: 11B9E3  		ld	de,batchfcb
DD5C: CDF9DC  		call	rdrec		;read last record.
DD5F: C296DD  		jp	nz,getinp1	;quit on end of file.
              	;
              	;   move this record into input buffer.
              	;
DD62: 1107DC  		ld	de,inbuff+1
DD65: 218000  		ld	hl,tbuff	;data was read into buffer here.
DD68: 0680    		ld	b,128		;all 128 characters may be used.
DD6A: CD4FE0  		call	hl2de		;(hl) to (de), (b) bytes.
DD6D: 21C7E3  		ld	hl,batchfcb+14
DD70: 3600    		ld	(hl),0		;zero out the 's2' byte.
DD72: 23      		inc	hl		;and decrement the record count.
DD73: 35      		dec	(hl)
DD74: 11B9E3  		ld	de,batchfcb	;close the batch file now.
DD77: CDDADC  		call	close
DD7A: CA96DD  		jp	z,getinp1	;quit on an error.
DD7D: 3AFCE3  		ld	a,(cdrive)	;re-select previous drive if need be.
DD80: B7      		or	a
DD81: C4BDDC  		call	nz,dsksel	;don't do needless selects.
              	;
              	;   print line just read on console.
              	;
DD84: 2108DC  		ld	hl,inbuff+2
DD87: CDACDC  		call	pline2
DD8A: CDC2DD  		call	chkcon		;check console, quit on a key.
DD8D: CAA7DD  		jp	z,getinp2	;jump if no key is pressed.
              	;
              	;   terminate the submit job on any keyboard input. delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
DD90: CDDDDD  		call	delbatch	;delete the batch file.
DD93: C382DF  		jp	cmmnd1		;and restart command input.
              	;
              	;   get here for normal keyboard input. delete the submit file
              	; incase there was one.
              	;
DD96: CDDDDD  	getinp1:call	delbatch	;delete file ($$$.sub).
DD99: CD1ADD  		call	setcdrv		;reset active disk.
DD9C: 0E0A    		ld	c,10		;get line from console device.
DD9E: 1106DC  		ld	de,inbuff
DDA1: CD0500  		call	entry
DDA4: CD29DD  		call	movecd		;reset current drive (again).
              	;
              	;   convert input line to upper case.
              	;
DDA7: 2107DC  	getinp2:ld	hl,inbuff+1
DDAA: 46      		ld	b,(hl)		;(b)=character counter.
DDAB: 23      	getinp3:inc	hl
DDAC: 78      		ld	a,b		;end of the line?
DDAD: B7      		or	a
DDAE: CABADD  		jp	z,getinp4
DDB1: 7E      		ld	a,(hl)		;convert to upper case.
DDB2: CD30DD  		call	upper
DDB5: 77      		ld	(hl),a
DDB6: 05      		dec	b		;adjust character count.
DDB7: C3ABDD  		jp	getinp3
DDBA: 77      	getinp4:ld	(hl),a		;add trailing null.
DDBB: 2108DC  		ld	hl,inbuff+2
DDBE: 2288DC  		ld	(inpoint),hl	;reset input line pointer.
DDC1: C9      		ret	
              	;
              	;   routine to check the console for a key pressed. the zero
              	; flag is set is none, else the character is returned in (a).
              	;
DDC2: 0E0B    	chkcon:	ld	c,11		;check console.
DDC4: CD0500  		call	entry
DDC7: B7      		or	a
DDC8: C8      		ret	z		;return if nothing.
DDC9: 0E01    		ld	c,1		;else get character.
DDCB: CD0500  		call	entry
DDCE: B7      		or	a		;clear zero flag and return.
DDCF: C9      		ret	
              	;
              	;   routine to get the currently active drive number.
              	;
DDD0: 0E19    	getdsk:	ld	c,25
DDD2: C30500  		jp	entry
              	;
              	;   set the stabdard dma address.
              	;
DDD5: 118000  	stddma:	ld	de,tbuff
              	;
              	;   routine to set the dma address to (de).
              	;
DDD8: 0E1A    	dmaset:	ld	c,26
DDDA: C30500  		jp	entry
              	;
              	;  delete the batch file created by submit.
              	;
DDDD: 21B8E3  	delbatch: ld	hl,batch	;is batch active?
DDE0: 7E      		ld	a,(hl)
DDE1: B7      		or	a
DDE2: C8      		ret	z
DDE3: 3600    		ld	(hl),0		;yes, de-activate it.
DDE5: AF      		xor	a
DDE6: CDBDDC  		call	dsksel		;select drive 0 for sure.
DDE9: 11B9E3  		ld	de,batchfcb	;and delete this file.
DDEC: CDEFDC  		call	delete
DDEF: 3AFCE3  		ld	a,(cdrive)	;reset current drive.
DDF2: C3BDDC  		jp	dsksel
              	;
              	;   check to two strings at (pattrn1) and (pattrn2). they must be
              	; the same or we halt....
              	;
DDF5: 1128DF  	verify:	ld	de,pattrn1	;these are the serial number bytes.
DDF8: 2100E4  		ld	hl,pattrn2	;ditto, but how could they be different?
DDFB: 0606    		ld	b,6		;6 bytes each.
DDFD: 1A      	verify1:ld	a,(de)
DDFE: BE      		cp	(hl)
DDFF: C2DCDF  		jp	nz,halt		;jump to halt routine.
DE02: 13      		inc	de
DE03: 23      		inc	hl
DE04: 05      		dec	b
DE05: C2FDDD  		jp	nz,verify1
DE08: C9      		ret	
              	;
              	;   print back file name with a '?' to indicate a syntax error.
              	;
DE09: CD98DC  	synerr:	call	crlf		;end current line.
DE0C: 2A8ADC  		ld	hl,(namepnt)	;this points to name in error.
DE0F: 7E      	synerr1:ld	a,(hl)		;print it until a space or null is found.
DE10: FE20    		cp	' '
DE12: CA22DE  		jp	z,synerr2
DE15: B7      		or	a
DE16: CA22DE  		jp	z,synerr2
DE19: E5      		push	hl
DE1A: CD8CDC  		call	print
DE1D: E1      		pop	hl
DE1E: 23      		inc	hl
DE1F: C30FDE  		jp	synerr1
DE22: 3E3F    	synerr2:ld	a,'?'		;add trailing '?'.
DE24: CD8CDC  		call	print
DE27: CD98DC  		call	crlf
DE2A: CDDDDD  		call	delbatch	;delete any batch file.
DE2D: C382DF  		jp	cmmnd1		;and restart from console input.
              	;
              	;   check character at (de) for legal command input. note that the
              	; zero flag is set if the character is a delimiter.
              	;
DE30: 1A      	check:	ld	a,(de)
DE31: B7      		or	a
DE32: C8      		ret	z
DE33: FE20    		cp	' '		;control characters are not legal here.
DE35: DA09DE  		jp	c,synerr
DE38: C8      		ret	z		;check for valid delimiter.
DE39: FE3D    		cp	'='
DE3B: C8      		ret	z
DE3C: FE5F    		cp	'_'
DE3E: C8      		ret	z
DE3F: FE2E    		cp	'.'
DE41: C8      		ret	z
DE42: FE3A    		cp	':'
DE44: C8      		ret	z
DE45: FE3B    		cp	';'
DE47: C8      		ret	z
DE48: FE3C    		cp	'<'
DE4A: C8      		ret	z
DE4B: FE3E    		cp	'>'
DE4D: C8      		ret	z
DE4E: C9      		ret	
              	;
              	;   get the next non-blank character from (de).
              	;
DE4F: 1A      	nonblank: ld	a,(de)
DE50: B7      		or	a		;string ends with a null.
DE51: C8      		ret	z
DE52: FE20    		cp	' '
DE54: C0      		ret	nz
DE55: 13      		inc	de
DE56: C34FDE  		jp	nonblank
              	;
              	;   add (hl)=(hl)+(a)
              	;
DE59: 85      	addhl:	add	a,l
DE5A: 6F      		ld	l,a
DE5B: D0      		ret	nc		;take care of any carry.
DE5C: 24      		inc	h
DE5D: C9      		ret	
              	;
              	;   convert the first name in (fcb).
              	;
DE5E: 3E00    	convfst:ld	a,0
              	;
              	;   format a file name (convert * to '?', etc.). on return,
              	; (a)=0 is an unambigeous name was specified. enter with (a) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
DE60: 21DAE3  	convert:ld	hl,fcb
DE63: CD59DE  		call	addhl
DE66: E5      		push	hl
DE67: E5      		push	hl
DE68: AF      		xor	a
DE69: 32FDE3  		ld	(chgdrv),a	;initialize drive change flag.
DE6C: 2A88DC  		ld	hl,(inpoint)	;set (hl) as pointer into input line.
DE6F: EB      		ex	de,hl
DE70: CD4FDE  		call	nonblank	;get next non-blank character.
DE73: EB      		ex	de,hl
DE74: 228ADC  		ld	(namepnt),hl	;save pointer here for any error message.
DE77: EB      		ex	de,hl
DE78: E1      		pop	hl
DE79: 1A      		ld	a,(de)		;get first character.
DE7A: B7      		or	a
DE7B: CA89DE  		jp	z,convrt1
DE7E: DE40    		sbc	a,'A'-1		;might be a drive name, convert to binary.
DE80: 47      		ld	b,a		;and save.
DE81: 13      		inc	de		;check next character for a ':'.
DE82: 1A      		ld	a,(de)
DE83: FE3A    		cp	':'
DE85: CA90DE  		jp	z,convrt2
DE88: 1B      		dec	de		;nope, move pointer back to the start of the line.
DE89: 3AFCE3  	convrt1:ld	a,(cdrive)
DE8C: 77      		ld	(hl),a
DE8D: C396DE  		jp	convrt3
DE90: 78      	convrt2:ld	a,b
DE91: 32FDE3  		ld	(chgdrv),a	;set change in drives flag.
DE94: 70      		ld	(hl),b
DE95: 13      		inc	de
              	;
              	;   convert the basic file name.
              	;
DE96: 0608    	convrt3:ld	b,08h
DE98: CD30DE  	convrt4:call	check
DE9B: CAB9DE  		jp	z,convrt8
DE9E: 23      		inc	hl
DE9F: FE2A    		cp	'*'		;note that an '*' will fill the remaining
DEA1: C2A9DE  		jp	nz,convrt5	;field with '?'.
DEA4: 363F    		ld	(hl),'?'
DEA6: C3ABDE  		jp	convrt6
DEA9: 77      	convrt5:ld	(hl),a
DEAA: 13      		inc	de
DEAB: 05      	convrt6:dec	b
DEAC: C298DE  		jp	nz,convrt4
DEAF: CD30DE  	convrt7:call	check		;get next delimiter.
DEB2: CAC0DE  		jp	z,getext
DEB5: 13      		inc	de
DEB6: C3AFDE  		jp	convrt7
DEB9: 23      	convrt8:inc	hl		;blank fill the file name.
DEBA: 3620    		ld	(hl),' '
DEBC: 05      		dec	b
DEBD: C2B9DE  		jp	nz,convrt8
              	;
              	;   get the extension and convert it.
              	;
DEC0: 0603    	getext:	ld	b,03h
DEC2: FE2E    		cp	'.'
DEC4: C2E9DE  		jp	nz,getext5
DEC7: 13      		inc	de
DEC8: CD30DE  	getext1:call	check
DECB: CAE9DE  		jp	z,getext5
DECE: 23      		inc	hl
DECF: FE2A    		cp	'*'
DED1: C2D9DE  		jp	nz,getext2
DED4: 363F    		ld	(hl),'?'
DED6: C3DBDE  		jp	getext3
DED9: 77      	getext2:ld	(hl),a
DEDA: 13      		inc	de
DEDB: 05      	getext3:dec	b
DEDC: C2C8DE  		jp	nz,getext1
DEDF: CD30DE  	getext4:call	check
DEE2: CAF0DE  		jp	z,getext6
DEE5: 13      		inc	de
DEE6: C3DFDE  		jp	getext4
DEE9: 23      	getext5:inc	hl
DEEA: 3620    		ld	(hl),' '
DEEC: 05      		dec	b
DEED: C2E9DE  		jp	nz,getext5
DEF0: 0603    	getext6:ld	b,3
DEF2: 23      	getext7:inc	hl
DEF3: 3600    		ld	(hl),0
DEF5: 05      		dec	b
DEF6: C2F2DE  		jp	nz,getext7
DEF9: EB      		ex	de,hl
DEFA: 2288DC  		ld	(inpoint),hl	;save input line pointer.
DEFD: E1      		pop	hl
              	;
              	;   check to see if this is an ambigeous file name specification.
              	; set the (a) register to non zero if it is.
              	;
DEFE: 010B00  		ld	bc,11		;set name length.
DF01: 23      	getext8:inc	hl
DF02: 7E      		ld	a,(hl)
DF03: FE3F    		cp	'?'		;any question marks?
DF05: C209DF  		jp	nz,getext9
DF08: 04      		inc	b		;count them.
DF09: 0D      	getext9:dec	c
DF0A: C201DF  		jp	nz,getext8
DF0D: 78      		ld	a,b
DF0E: B7      		or	a
DF0F: C9      		ret	
              	;
              	;   cp/m command table. note commands can be either 3 or 4 characters long.
              	;
0006:         	numcmds equ	6		;number of commands
DF10: 44495220	cmdtbl:	defb	'DIR '
DF14: 45524120		defb	'ERA '
DF18: 54595045		defb	'TYPE'
DF1C: 53415645		defb	'SAVE'
DF20: 52454E20		defb	'REN '
DF24: 55534552		defb	'USER'
              	;
              	;   the following six bytes must agree with those at (pattrn2)
              	; or cp/m will halt. why?
              	;
DF28: 00160000	pattrn1:defb	0,22,0,0,0,0	;(* serial number bytes *).
DF2C: 0000    	
              	;
              	;   search the command table for a match with what has just
              	; been entered. if a match is found, then we jump to the
              	; proper section. else jump to (unknown).
              	; on return, the (c) register is set to the command number
              	; that matched (or numcmds+1 if no match).
              	;
DF2E: 2110DF  	search:	ld	hl,cmdtbl
DF31: 0E00    		ld	c,0
DF33: 79      	search1:ld	a,c
DF34: FE06    		cp	numcmds		;this commands exists.
DF36: D0      		ret	nc
DF37: 11DBE3  		ld	de,fcb+1	;check this one.
DF3A: 0604    		ld	b,4		;max command length.
DF3C: 1A      	search2:ld	a,(de)
DF3D: BE      		cp	(hl)
DF3E: C24FDF  		jp	nz,search3	;not a match.
DF41: 13      		inc	de
DF42: 23      		inc	hl
DF43: 05      		dec	b
DF44: C23CDF  		jp	nz,search2
DF47: 1A      		ld	a,(de)		;allow a 3 character command to match.
DF48: FE20    		cp	' '
DF4A: C254DF  		jp	nz,search4
DF4D: 79      		ld	a,c		;set return register for this command.
DF4E: C9      		ret	
DF4F: 23      	search3:inc	hl
DF50: 05      		dec	b
DF51: C24FDF  		jp	nz,search3
DF54: 0C      	search4:inc	c
DF55: C333DF  		jp	search1
              	;
              	;   set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
DF58: AF      	clearbuf: xor	a
DF59: 3207DC  		ld	(inbuff+1),a	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
DF5C: 31B8E3  	command:ld	sp,ccpstack	;setup stack area.
DF5F: C5      		push	bc		;note that (c) should be equal to:
DF60: 79      		ld	a,c		;(uuuudddd) where 'uuuu' is the user number
DF61: 1F      		rra			;and 'dddd' is the drive number.
DF62: 1F      		rra	
DF63: 1F      		rra	
DF64: 1F      		rra	
DF65: E60F    		and	0fh		;isolate the user number.
DF67: 5F      		ld	e,a
DF68: CD15DD  		call	getsetuc	;and set it.
DF6B: CDB8DC  		call	resdsk		;reset the disk system.
DF6E: 32B8E3  		ld	(batch),a	;clear batch mode flag.
DF71: C1      		pop	bc
DF72: 79      		ld	a,c
DF73: E60F    		and	0fh		;isolate the drive number.
DF75: 32FCE3  		ld	(cdrive),a	;and save.
DF78: CDBDDC  		call	dsksel		;...and select.
DF7B: 3A07DC  		ld	a,(inbuff+1)
DF7E: B7      		or	a		;anything in input buffer already?
DF7F: C2A5DF  		jp	nz,cmmnd2	;yes, we just process it.
              	;
              	;   entry point to get a command line from the console.
              	;
              	;   Big thanks to NabuNetwork.com for the modified prompt!
              	;
DF82: 31B8E3  	cmmnd1:	ld	sp,ccpstack	;set stack straight.
DF85: CD98DC  		call	crlf		;start a new line on the screen.
DF88: CDD0DD  		call	getdsk		;get current drive.
DF8B: C641    		add	a,'A'
DF8D: CD8CDC  		call	print		;print current drive.
DF90: 00      		nop
DF91: 00      		nop
DF92: 00      		nop
DF93: 00      		nop
DF94: 00      		nop
DF95: CD13DD  		call	getusr		;get current user.
DF98: C630    		add	a,'0'
DF9A: CD02F2  		call	printdc		;print current user.
DF9D: 3E3E    		ld	a,'>'
DF9F: CD8CDC  		call	print		;and add prompt.
DFA2: CD39DD  		call	getinp		;get line from user.
              	;
              	;   process command line here.
              	;
DFA5: 118000  	cmmnd2:	ld	de,tbuff
DFA8: CDD8DD  		call	dmaset		;set standard dma address.
DFAB: CDD0DD  		call	getdsk
DFAE: 32FCE3  		ld	(cdrive),a	;set current drive.
DFB1: CD5EDE  		call	convfst		;convert name typed in.
DFB4: C409DE  		call	nz,synerr	;wild cards are not allowed.
DFB7: 3AFDE3  		ld	a,(chgdrv)	;if a change in drives was indicated,
DFBA: B7      		or	a		;then treat this as an unknown command
DFBB: C2B2E2  		jp	nz,unknown	;which gets executed.
DFBE: CD2EDF  		call	search		;else search command table for a match.
              	;
              	;   note that an unknown command returns
              	; with (a) pointing to the last address
              	; in our table which is (unknown).
              	;
DFC1: 21CEDF  		ld	hl,cmdadr	;now, look thru our address table for command (a).
DFC4: 5F      		ld	e,a		;set (de) to command number.
DFC5: 1600    		ld	d,0
DFC7: 19      		add	hl,de
DFC8: 19      		add	hl,de		;(hl)=(cmdadr)+2*(command number).
DFC9: 7E      		ld	a,(hl)		;now pick out this address.
DFCA: 23      		inc	hl
DFCB: 66      		ld	h,(hl)
DFCC: 6F      		ld	l,a
DFCD: E9      		jp	(hl)		;now execute it.
              	;
              	;   cp/m command address table.
              	;
DFCE: 84E02CE1	cmdadr:	defw	direct,erase,type,save
DFD2: 6AE1BAE1	
DFD6: 1DE29BE2		defw	rename,user,unknown
DFDA: B2E2    	
              	;
              	;   halt the system. reason for this is unknown at present.
              	;
DFDC: 21F376  	halt:	ld	hl,76f3h	;'di hlt' instructions.
DFDF: 2200DC  		ld	(cbase),hl
DFE2: 2100DC  		ld	hl,cbase
DFE5: E9      		jp	(hl)
              	;
              	;   read error while typeing a file.
              	;
DFE6: 01ECDF  	rderror:ld	bc,rderr
DFE9: C3A7DC  		jp	pline
DFEC: 72656164	rderr:	defb	'read error',0
DFF0: 20657272	
DFF4: 6F7200  	
              	;
              	;   required file was not located.
              	;
DFF7: 01FDDF  	none:	ld	bc,nofile
DFFA: C3A7DC  		jp	pline
DFFD: 6E6F2066	nofile:	defb	'no file',0
E001: 696C6500	
              	;
              	;   decode a command of the form 'a>filename number{ filename}.
              	; note that a drive specifier is not allowed on the first file
              	; name. on return, the number is in register (a). any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
E005: CD5EDE  	decode:	call	convfst		;convert filename.
E008: 3AFDE3  		ld	a,(chgdrv)	;do not allow a drive to be specified.
E00B: B7      		or	a
E00C: C209DE  		jp	nz,synerr
E00F: 21DBE3  		ld	hl,fcb+1	;convert number now.
E012: 010B00  		ld	bc,11		;(b)=sum register, (c)=max digit count.
E015: 7E      	decode1:ld	a,(hl)
E016: FE20    		cp	' '		;a space terminates the numeral.
E018: CA40E0  		jp	z,decode3
E01B: 23      		inc	hl
E01C: D630    		sub	'0'		;make binary from ascii.
E01E: FE0A    		cp	10		;legal digit?
E020: D209DE  		jp	nc,synerr
E023: 57      		ld	d,a		;yes, save it in (d).
E024: 78      		ld	a,b		;compute (b)=(b)*10 and check for overflow.
E025: E6E0    		and	0e0h
E027: C209DE  		jp	nz,synerr
E02A: 78      		ld	a,b
E02B: 07      		rlca	
E02C: 07      		rlca	
E02D: 07      		rlca			;(a)=(b)*8
E02E: 80      		add	a,b		;.......*9
E02F: DA09DE  		jp	c,synerr
E032: 80      		add	a,b		;.......*10
E033: DA09DE  		jp	c,synerr
E036: 82      		add	a,d		;add in new digit now.
E037: DA09DE  	decode2:jp	c,synerr
E03A: 47      		ld	b,a		;and save result.
E03B: 0D      		dec	c		;only look at 11 digits.
E03C: C215E0  		jp	nz,decode1
E03F: C9      		ret	
E040: 7E      	decode3:ld	a,(hl)		;spaces must follow (why?).
E041: FE20    		cp	' '
E043: C209DE  		jp	nz,synerr
E046: 23      		inc	hl
E047: 0D      	decode4:dec	c
E048: C240E0  		jp	nz,decode3
E04B: 78      		ld	a,b		;set (a)=the numeric value entered.
E04C: C9      		ret	
              	;
              	;   move 3 bytes from (hl) to (de). note that there is only
              	; one reference to this at (a2d5h).
              	;
E04D: 0603    	move3:	ld	b,3
              	;
              	;   move (b) bytes from (hl) to (de).
              	;
E04F: 7E      	hl2de:	ld	a,(hl)
E050: 12      		ld	(de),a
E051: 23      		inc	hl
E052: 13      		inc	de
E053: 05      		dec	b
E054: C24FE0  		jp	nz,hl2de
E057: C9      		ret	
              	;
              	;   compute (hl)=(tbuff)+(a)+(c) and get the byte that's here.
              	;
E058: 218000  	extract:ld	hl,tbuff
E05B: 81      		add	a,c
E05C: CD59DE  		call	addhl
E05F: 7E      		ld	a,(hl)
E060: C9      		ret	
              	;
              	;  check drive specified. if it means a change, then the new
              	; drive will be selected. in any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
E061: AF      	dselect:xor	a		;null out first byte of fcb.
E062: 32DAE3  		ld	(fcb),a
E065: 3AFDE3  		ld	a,(chgdrv)	;a drive change indicated?
E068: B7      		or	a
E069: C8      		ret	z
E06A: 3D      		dec	a		;yes, is it the same as the current drive?
E06B: 21FCE3  		ld	hl,cdrive
E06E: BE      		cp	(hl)
E06F: C8      		ret	z
E070: C3BDDC  		jp	dsksel		;no. select it then.
              	;
              	;   check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
E073: 3AFDE3  	resetdr:ld	a,(chgdrv)	;drive change indicated?
E076: B7      		or	a
E077: C8      		ret	z
E078: 3D      		dec	a		;yes, was it a different drive?
E079: 21FCE3  		ld	hl,cdrive
E07C: BE      		cp	(hl)
E07D: C8      		ret	z
E07E: 3AFCE3  		ld	a,(cdrive)	;yes, re-select our old drive.
E081: C3BDDC  		jp	dsksel
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
E084: CD5EDE  	direct:	call	convfst		;convert file name.
E087: CD61E0  		call	dselect		;select indicated drive.
E08A: 21DBE3  		ld	hl,fcb+1	;was any file indicated?
E08D: 7E      		ld	a,(hl)
E08E: FE20    		cp	' '
E090: C29CE0  		jp	nz,direct2
E093: 060B    		ld	b,11		;no. fill field with '?' - same as *.*.
E095: 363F    	direct1:ld	(hl),'?'
E097: 23      		inc	hl
E098: 05      		dec	b
E099: C295E0  		jp	nz,direct1
E09C: 1E00    	direct2:ld	e,0		;set initial cursor position.
E09E: D5      		push	de
E09F: CDE9DC  		call	srchfcb		;get first file name.
E0A2: CCF7DF  		call	z,none		;none found at all?
E0A5: CA28E1  	direct3:jp	z,direct9	;terminate if no more names.
E0A8: 3AFBE3  		ld	a,(rtncode)	;get file's position in segment (0-3).
E0AB: 0F      		rrca	
E0AC: 0F      		rrca	
E0AD: 0F      		rrca	
E0AE: E660    		and	60h		;(a)=position*32
E0B0: 4F      		ld	c,a
E0B1: 3E0A    		ld	a,10
E0B3: CD58E0  		call	extract		;extract the tenth entry in fcb.
E0B6: 17      		rla			;check system file status bit.
E0B7: DA1CE1  		jp	c,direct8	;we don't list them.
E0BA: D1      		pop	de
E0BB: 7B      		ld	a,e		;bump name count.
E0BC: 1C      		inc	e
E0BD: D5      		push	de
E0BE: E603    		and	03h		;at end of line?
E0C0: F5      		push	af
E0C1: C2D9E0  		jp	nz,direct4
E0C4: CD98DC  		call	crlf		;yes, end this line and start another.
E0C7: C5      		push	bc
E0C8: CDD0DD  		call	getdsk		;start line with ('a:').
E0CB: C1      		pop	bc
E0CC: C641    		add	a,'A'
E0CE: CD92DC  		call	printb
E0D1: 3E3A    		ld	a,':'
E0D3: CD92DC  		call	printb
E0D6: C3E1E0  		jp	direct5
E0D9: CDA2DC  	direct4:call	space		;add seperator between file names.
E0DC: 3E3A    		ld	a,':'
E0DE: CD92DC  		call	printb
E0E1: CDA2DC  	direct5:call	space
E0E4: 0601    		ld	b,1		;'extract' each file name character at a time.
E0E6: 78      	direct6:ld	a,b
E0E7: CD58E0  		call	extract
E0EA: E67F    		and	7fh		;strip bit 7 (status bit).
E0EC: FE20    		cp	' '		;are we at the end of the name?
E0EE: C206E1  		jp	nz,drect65
E0F1: F1      		pop	af		;yes, don't print spaces at the end of a line.
E0F2: F5      		push	af
E0F3: FE03    		cp	3
E0F5: C204E1  		jp	nz,drect63
E0F8: 3E09    		ld	a,9		;first check for no extension.
E0FA: CD58E0  		call	extract
E0FD: E67F    		and	7fh
E0FF: FE20    		cp	' '
E101: CA1BE1  		jp	z,direct7	;don't print spaces.
E104: 3E20    	drect63:ld	a,' '		;else print them.
E106: CD92DC  	drect65:call	printb
E109: 04      		inc	b		;bump to next character psoition.
E10A: 78      		ld	a,b
E10B: FE0C    		cp	12		;end of the name?
E10D: D21BE1  		jp	nc,direct7
E110: FE09    		cp	9		;nope, starting extension?
E112: C2E6E0  		jp	nz,direct6
E115: CDA2DC  		call	space		;yes, add seperating space.
E118: C3E6E0  		jp	direct6
E11B: F1      	direct7:pop	af		;get the next file name.
E11C: CDC2DD  	direct8:call	chkcon		;first check console, quit on anything.
E11F: C228E1  		jp	nz,direct9
E122: CDE4DC  		call	srchnxt		;get next name.
E125: C3A5E0  		jp	direct3		;and continue with our list.
E128: D1      	direct9:pop	de		;restore the stack and return to command level.
E129: C393E3  		jp	getback
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E12C: CD5EDE  	erase:	call	convfst		;convert file name.
E12F: FE0B    		cp	11		;was '*.*' entered?
E131: C24FE1  		jp	nz,erase1
E134: 015FE1  		ld	bc,yesno	;yes, ask for confirmation.
E137: CDA7DC  		call	pline
E13A: CD39DD  		call	getinp
E13D: 2107DC  		ld	hl,inbuff+1
E140: 35      		dec	(hl)		;must be exactly 'y'.
E141: C282DF  		jp	nz,cmmnd1
E144: 23      		inc	hl
E145: 7E      		ld	a,(hl)
E146: FE79    		cp	'y'
E148: C282DF  		jp	nz,cmmnd1
E14B: 23      		inc	hl
E14C: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E14F: CD61E0  	erase1:	call	dselect		;select desired disk.
E152: 11DAE3  		ld	de,fcb
E155: CDEFDC  		call	delete		;delete the file.
E158: 3C      		inc	a
E159: CCF7DF  		call	z,none		;not there?
E15C: C393E3  		jp	getback		;return to command level now.
E15F: 616C6C20	yesno:	defb	'all (y/n)?',0
E163: 28792F6E	
E167: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E16A: CD5EDE  	type:	call	convfst		;convert file name.
E16D: C209DE  		jp	nz,synerr	;wild cards not allowed.
E170: CD61E0  		call	dselect		;select indicated drive.
E173: CDD0DC  		call	openfcb		;open the file.
E176: CAB4E1  		jp	z,type5		;not there?
E179: CD98DC  		call	crlf		;ok, start a new line on the screen.
E17C: 21FEE3  		ld	hl,nbytes	;initialize byte counter.
E17F: 36FF    		ld	(hl),0ffh	;set to read first sector.
E181: 21FEE3  	type1:	ld	hl,nbytes
E184: 7E      	type2:	ld	a,(hl)		;have we written the entire sector?
E185: FE80    		cp	128
E187: DA94E1  		jp	c,type3
E18A: E5      		push	hl		;yes, read in the next one.
E18B: CDFEDC  		call	readfcb
E18E: E1      		pop	hl
E18F: C2ADE1  		jp	nz,type4	;end or error?
E192: AF      		xor	a		;ok, clear byte counter.
E193: 77      		ld	(hl),a
E194: 34      	type3:	inc	(hl)		;count this byte.
E195: 218000  		ld	hl,tbuff	;and get the (a)th one from the buffer (tbuff).
E198: CD59DE  		call	addhl
E19B: 7E      		ld	a,(hl)
E19C: FE1A    		cp	cntrlz		;end of file mark?
E19E: CA93E3  		jp	z,getback
E1A1: CD8CDC  		call	print		;no, print it.
E1A4: CDC2DD  		call	chkcon		;check console, quit if anything ready.
E1A7: C293E3  		jp	nz,getback
E1AA: C381E1  		jp	type1
              	;
              	;   get here on an end of file or read error.
              	;
E1AD: 3D      	type4:	dec	a		;read error?
E1AE: CA93E3  		jp	z,getback
E1B1: CDE6DF  		call	rderror		;yes, print message.
E1B4: CD73E0  	type5:	call	resetdr		;and reset proper drive
E1B7: C309DE  		jp	synerr		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E1BA: CD05E0  	save:	call	decode		;get numeric number that follows save.
E1BD: F5      		push	af		;save number of pages to write.
E1BE: CD5EDE  		call	convfst		;convert file name.
E1C1: C209DE  		jp	nz,synerr	;wild cards not allowed.
E1C4: CD61E0  		call	dselect		;select specified drive.
E1C7: 11DAE3  		ld	de,fcb		;now delete this file.
E1CA: D5      		push	de
E1CB: CDEFDC  		call	delete
E1CE: D1      		pop	de
E1CF: CD09DD  		call	create		;and create it again.
E1D2: CA08E2  		jp	z,save3		;can't create?
E1D5: AF      		xor	a		;clear record number byte.
E1D6: 32FAE3  		ld	(fcb+32),a
E1D9: F1      		pop	af		;convert pages to sectors.
E1DA: 6F      		ld	l,a
E1DB: 2600    		ld	h,0
E1DD: 29      		add	hl,hl		;(hl)=number of sectors to write.
E1DE: 110001  		ld	de,tbase	;and we start from here.
E1E1: 7C      	save1:	ld	a,h		;done yet?
E1E2: B5      		or	l
E1E3: CAFEE1  		jp	z,save2
E1E6: 2B      		dec	hl		;nope, count this and compute the start
E1E7: E5      		push	hl		;of the next 128 byte sector.
E1E8: 218000  		ld	hl,128
E1EB: 19      		add	hl,de
E1EC: E5      		push	hl		;save it and set the transfer address.
E1ED: CDD8DD  		call	dmaset
E1F0: 11DAE3  		ld	de,fcb		;write out this sector now.
E1F3: CD04DD  		call	wrtrec
E1F6: D1      		pop	de		;reset (de) to the start of the last sector.
E1F7: E1      		pop	hl		;restore sector count.
E1F8: C208E2  		jp	nz,save3	;write error?
E1FB: C3E1E1  		jp	save1
              	;
              	;   get here after writing all of the file.
              	;
E1FE: 11DAE3  	save2:	ld	de,fcb		;now close the file.
E201: CDDADC  		call	close
E204: 3C      		inc	a		;did it close ok?
E205: C20EE2  		jp	nz,save4
              	;
              	;   print out error message (no space).
              	;
E208: 0114E2  	save3:	ld	bc,nospace
E20B: CDA7DC  		call	pline
E20E: CDD5DD  	save4:	call	stddma		;reset the standard dma address.
E211: C393E3  		jp	getback
E214: 6E6F2073	nospace:defb	'no space',0
E218: 70616365	
E21C: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
E21D: CD5EDE  	rename:	call	convfst		;convert first file name.
E220: C209DE  		jp	nz,synerr	;wild cards not allowed.
E223: 3AFDE3  		ld	a,(chgdrv)	;remember any change in drives specified.
E226: F5      		push	af
E227: CD61E0  		call	dselect		;and select this drive.
E22A: CDE9DC  		call	srchfcb		;is this file present?
E22D: C286E2  		jp	nz,rename6	;yes, print error message.
E230: 21DAE3  		ld	hl,fcb		;yes, move this name into second slot.
E233: 11EAE3  		ld	de,fcb+16
E236: 0610    		ld	b,16
E238: CD4FE0  		call	hl2de
E23B: 2A88DC  		ld	hl,(inpoint)	;get input pointer.
E23E: EB      		ex	de,hl
E23F: CD4FDE  		call	nonblank	;get next non blank character.
E242: FE3D    		cp	'='		;only allow an '=' or '_' seperator.
E244: CA4CE2  		jp	z,rename1
E247: FE5F    		cp	'_'
E249: C280E2  		jp	nz,rename5
E24C: EB      	rename1:ex	de,hl
E24D: 23      		inc	hl		;ok, skip seperator.
E24E: 2288DC  		ld	(inpoint),hl	;save input line pointer.
E251: CD5EDE  		call	convfst		;convert this second file name now.
E254: C280E2  		jp	nz,rename5	;again, no wild cards.
E257: F1      		pop	af		;if a drive was specified, then it
E258: 47      		ld	b,a		;must be the same as before.
E259: 21FDE3  		ld	hl,chgdrv
E25C: 7E      		ld	a,(hl)
E25D: B7      		or	a
E25E: CA66E2  		jp	z,rename2
E261: B8      		cp	b
E262: 70      		ld	(hl),b
E263: C280E2  		jp	nz,rename5	;they were different, error.
E266: 70      	rename2:ld	(hl),b		;	reset as per the first file specification.
E267: AF      		xor	a
E268: 32DAE3  		ld	(fcb),a		;clear the drive byte of the fcb.
E26B: CDE9DC  	rename3:call	srchfcb		;and go look for second file.
E26E: CA7AE2  		jp	z,rename4	;doesn't exist?
E271: 11DAE3  		ld	de,fcb
E274: CD0EDD  		call	renam		;ok, rename the file.
E277: C393E3  		jp	getback
              	;
              	;   process rename errors here.
              	;
E27A: CDF7DF  	rename4:call	none		;file not there.
E27D: C393E3  		jp	getback
E280: CD73E0  	rename5:call	resetdr		;bad command format.
E283: C309DE  		jp	synerr
E286: 018FE2  	rename6:ld	bc,exists	;destination file already exists.
E289: CDA7DC  		call	pline
E28C: C393E3  		jp	getback
E28F: 66696C65	exists:	defb	'file exists',0
E293: 20657869	
E297: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
E29B: CD05E0  	user:	call	decode		;get numeric value following command.
E29E: FE10    		cp	16		;legal user number?
E2A0: D209DE  		jp	nc,synerr
E2A3: 5F      		ld	e,a		;yes but is there anything else?
E2A4: 3ADBE3  		ld	a,(fcb+1)
E2A7: FE20    		cp	' '
E2A9: CA09DE  		jp	z,synerr	;yes, that is not allowed.
E2AC: CD15DD  		call	getsetuc	;ok, set user code.
E2AF: C396E3  		jp	getback1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
E2B2: CDF5DD  	unknown:call	verify		;check for valid system (why?).
E2B5: 3ADBE3  		ld	a,(fcb+1)	;anything to execute?
E2B8: FE20    		cp	' '
E2BA: C2D1E2  		jp	nz,unkwn1
E2BD: 3AFDE3  		ld	a,(chgdrv)	;nope, only a drive change?
E2C0: B7      		or	a
E2C1: CA96E3  		jp	z,getback1	;neither???
E2C4: 3D      		dec	a
E2C5: 32FCE3  		ld	(cdrive),a	;ok, store new drive.
E2C8: CD29DD  		call	movecd		;set (tdrive) also.
E2CB: CDBDDC  		call	dsksel		;and select this drive.
E2CE: C396E3  		jp	getback1	;then return.
              	;
              	;   here a file name was typed. prepare to execute it.
              	;
E2D1: 11E3E3  	unkwn1:	ld	de,fcb+9	;an extension specified?
E2D4: 1A      		ld	a,(de)
E2D5: FE20    		cp	' '
E2D7: C209DE  		jp	nz,synerr	;yes, not allowed.
E2DA: D5      	unkwn2:	push	de
E2DB: CD61E0  		call	dselect		;select specified drive.
E2DE: D1      		pop	de
E2DF: 2190E3  		ld	hl,comfile	;set the extension to 'com'.
E2E2: CD4DE0  		call	move3
E2E5: CDD0DC  		call	openfcb		;and open this file.
E2E8: CA78E3  		jp	z,unkwn9	;not present?
              	;
              	;   load in the program.
              	;
E2EB: 210001  		ld	hl,tbase	;store the program starting here.
E2EE: E5      	unkwn3:	push	hl
E2EF: EB      		ex	de,hl
E2F0: CDD8DD  		call	dmaset		;set transfer address.
E2F3: 11DAE3  		ld	de,fcb		;and read the next record.
E2F6: CDF9DC  		call	rdrec
E2F9: C20EE3  		jp	nz,unkwn4	;end of file or read error?
E2FC: E1      		pop	hl		;nope, bump pointer for next sector.
E2FD: 118000  		ld	de,128
E300: 19      		add	hl,de
E301: 1100DC  		ld	de,cbase	;enough room for the whole file?
E304: 7D      		ld	a,l
E305: 93      		sub	e
E306: 7C      		ld	a,h
E307: 9A      		sbc	a,d
E308: D27EE3  		jp	nc,unkwn0	;no, it can't fit.
E30B: C3EEE2  		jp	unkwn3
              	;
              	;   get here after finished reading.
              	;
E30E: E1      	unkwn4:	pop	hl
E30F: 3D      		dec	a		;normal end of file?
E310: C27EE3  		jp	nz,unkwn0
E313: CD73E0  		call	resetdr		;yes, reset previous drive.
E316: CD5EDE  		call	convfst		;convert the first file name that follows
E319: 21FDE3  		ld	hl,chgdrv	;command name.
E31C: E5      		push	hl
E31D: 7E      		ld	a,(hl)		;set drive code in default fcb.
E31E: 32DAE3  		ld	(fcb),a
E321: 3E10    		ld	a,16		;put second name 16 bytes later.
E323: CD60DE  		call	convert		;convert second file name.
E326: E1      		pop	hl
E327: 7E      		ld	a,(hl)		;and set the drive for this second file.
E328: 32EAE3  		ld	(fcb+16),a
E32B: AF      		xor	a		;clear record byte in fcb.
E32C: 32FAE3  		ld	(fcb+32),a
E32F: 115C00  		ld	de,tfcb		;move it into place at(005ch).
E332: 21DAE3  		ld	hl,fcb
E335: 0621    		ld	b,33
E337: CD4FE0  		call	hl2de
E33A: 2108DC  		ld	hl,inbuff+2	;now move the remainder of the input
E33D: 7E      	unkwn5:	ld	a,(hl)		;line down to (0080h). look for a non blank.
E33E: B7      		or	a		;or a null.
E33F: CA4BE3  		jp	z,unkwn6
E342: FE20    		cp	' '
E344: CA4BE3  		jp	z,unkwn6
E347: 23      		inc	hl
E348: C33DE3  		jp	unkwn5
              	;
              	;   do the line move now. it ends in a null byte.
              	;
E34B: 0600    	unkwn6:	ld	b,0		;keep a character count.
E34D: 118100  		ld	de,tbuff+1	;data gets put here.
E350: 7E      	unkwn7:	ld	a,(hl)		;move it now.
E351: 12      		ld	(de),a
E352: B7      		or	a
E353: CA5CE3  		jp	z,unkwn8
E356: 04      		inc	b
E357: 23      		inc	hl
E358: 13      		inc	de
E359: C350E3  		jp	unkwn7
E35C: 78      	unkwn8:	ld	a,b		;now store the character count.
E35D: 328000  		ld	(tbuff),a
E360: CD98DC  		call	crlf		;clean up the screen.
E363: CDD5DD  		call	stddma		;set standard transfer address.
E366: CD1ADD  		call	setcdrv		;reset current drive.
E369: CD0001  		call	tbase		;and execute the program.
              	;
              	;   transiant programs return here (or reboot).
              	;
E36C: 31B8E3  		ld	sp,batch	;set stack first off.
E36F: CD29DD  		call	movecd		;move current drive into place (tdrive).
E372: CDBDDC  		call	dsksel		;and reselect it.
E375: C382DF  		jp	cmmnd1		;back to comand mode.
              	;
              	;   get here if some error occured.
              	;
E378: CD73E0  	unkwn9:	call	resetdr		;inproper format.
E37B: C309DE  		jp	synerr
E37E: 0187E3  	unkwn0:	ld	bc,badload	;read error or won't fit.
E381: CDA7DC  		call	pline
E384: C393E3  		jp	getback
E387: 42616420	badload:defb	'Bad load',0
E38B: 6C6F6164	
E38F: 00      	
E390: 434F4D  	comfile:defb	'COM'		;command file extension.
              	;
              	;   get here to return to command level. we will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
E393: CD73E0  	getback:call	resetdr		;reset previous drive.
E396: CD5EDE  	getback1: call	convfst		;convert first name in (fcb).
E399: 3ADBE3  		ld	a,(fcb+1)	;if this was just a drive change request,
E39C: D620    		sub	' '		;make sure it was valid.
E39E: 21FDE3  		ld	hl,chgdrv
E3A1: B6      		or	(hl)
E3A2: C209DE  		jp	nz,synerr
E3A5: C382DF  		jp	cmmnd1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
E3A8: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3AC: 00...   	
E3B8:         	ccpstack equ	$	;end of ccp stack area.
              	;
              	;   batch (or submit) processing information storage.
              	;
E3B8: 00      	batch:	defb	0		;batch mode flag (0=not active).
E3B9: 00242424	batchfcb: defb	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3BD: 20202020	
E3C1: 20535542	
E3C5: 00000000	
E3C9: 00...   	
              	;
              	;   file control block setup by the ccp.
              	;
E3DA: 00202020	fcb:	defb	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
E3DE: 20202020	
E3E2: 20202020	
E3E6: 00000000	
E3EA: 00202020	
E3EE: 20202020	
E3F2: 20202020	
E3F6: 00000000	
E3FA: 00      	
E3FB: 00      	rtncode:defb	0		;status returned from bdos call.
E3FC: 00      	cdrive:	defb	0		;currently active drive.
E3FD: 00      	chgdrv:	defb	0		;change in drives flag (0=no change).
E3FE: 0000    	nbytes:	defw	0		;byte counter used by type.
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E400: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E404: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E406: C314E4  	fbase:	jp	fbase1
E409: C345F2  		jp	boot
              	;
              	;   bdos error table.
              	;
E40C: 9FE4    	badsctr:defw	error1		;bad sector on read or write.
E40E: ABE4    	badslct:defw	error2		;bad disk select.
E410: B1E4    	rodisk:	defw	error3		;disk is read only.
E412: B7E4    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E414: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E415: 2249E7  		ld	(params),hl
E418: EB      		ex	de,hl
E419: 7B      		ld	a,e		;and save register (e) in particular.
E41A: 32DCF1  		ld	(eparam),a
E41D: 210000  		ld	hl,0
E420: 224BE7  		ld	(status),hl	;clear return status.
E423: 39      		add	hl,sp
E424: 2215E7  		ld	(usrstack),hl	;save users stack pointer.
E427: 3147E7  		ld	sp,stkarea	;and set our own.
E42A: AF      		xor	a		;clear auto select storage space.
E42B: 32E6F1  		ld	(autoflag),a
E42E: 32E4F1  		ld	(auto),a
E431: 217AF1  		ld	hl,goback	;set return address.
E434: E5      		push	hl
E435: CD6DF3  		call	syshook		; see if anyone wants to intercept the call
E438: 79      		ld	a,c		;get function number.
E439: FE29    		cp	nfuncts		;valid function number?
E43B: D0      		ret	nc
E43C: 4B      		ld	c,e		;keep single register function here.
E43D: 214DE4  		ld	hl,functns	;now look thru the function table.
E440: 5F      		ld	e,a
E441: 1600    		ld	d,0		;(de)=function number.
E443: 19      		add	hl,de
E444: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E445: 5E      		ld	e,(hl)
E446: 23      		inc	hl
E447: 56      		ld	d,(hl)		;now (de)=address for this function.
E448: 2A49E7  		ld	hl,(params)	;retrieve parameters.
E44B: EB      		ex	de,hl		;now (de) has the original parameters.
E44C: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E44D: 53F2CEE6	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E451: 96E5D4E6	
E455: CBF2C7F2	
E459: DAE6F3E6	
E45D: F9E6FEE6		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E461: E7E504E7	
E465: 84F089F0	
E469: 4BF0A2F0	
E46D: ABF0B1F0		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E471: CEF0DDF0	
E475: E6F0ECF0	
E479: F2F0    	
E47B: FBF004F1		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E47F: 0AF110F1	
E483: 17F132E9	
E487: 1DF123F1	
E48B: 2CF133F1		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E48F: 47F14DF1	
E493: 53F114F0	
E497: 59F10AE7	
E49B: 0AE7A1F1		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E49F: 21D0E4  	error1:	ld	hl,badsec	;bad sector message.
E4A2: CDEBE4  		call	prterr		;print it and get a 1 char responce.
E4A5: FE03    		cp	cntrlc		;re-boot request (control-c)?
E4A7: CA0000  		jp	z,0		;yes.
E4AA: C9      		ret			;no, return to retry i/o function.
              	;
E4AB: 21DBE4  	error2:	ld	hl,badsel	;bad drive selected.
E4AE: C3BAE4  		jp	error5
              	;
E4B1: 21E7E4  	error3:	ld	hl,diskro	;disk is read only.
E4B4: C3BAE4  		jp	error5
              	;
E4B7: 21E2E4  	error4:	ld	hl,filero	;file is read only.
              	;
E4BA: CDEBE4  	error5:	call	prterr
E4BD: C30000  		jp	0		;always reboot on these errors.
              	;
E4C0: 42646F73	bdoserr:defb	'Bdos Err on '
E4C4: 20457272	
E4C8: 206F6E20	
E4CC: 203A2024	bdosdrv:defb	' : $'
E4D0: 42616420	badsec:	defb	'Bad Sector$'
E4D4: 53656374	
E4D8: 6F7224  	
E4DB: 53656C65	badsel:	defb	'Select$'
E4DF: 637424  	
E4E2: 46696C65	filero:	defb	'File '
E4E6: 20      	
E4E7: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E4EB: E5      	prterr:	push	hl		;save second message pointer.
E4EC: CDCFE5  		call	outcrlf		;send (cr)(lf).
E4EF: 3A48E7  		ld	a,(active)	;get active drive.
E4F2: C641    		add	a,'A'		;make ascii.
E4F4: 32CCE4  		ld	(bdosdrv),a	;and put in message.
E4F7: 01C0E4  		ld	bc,bdoserr	;and print it.
E4FA: CDD9E5  		call	prtmesg
E4FD: C1      		pop	bc		;print second message line now.
E4FE: CDD9E5  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E501: 2114E7  	getchar:ld	hl,charbuf	;check character buffer.
E504: 7E      		ld	a,(hl)		;anything present already?
E505: 3600    		ld	(hl),0		;...either case clear it.
E507: B7      		or	a
E508: C0      		ret	nz		;yes, use it.
E509: C3AFF2  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E50C: CD01E5  	getecho:call	getchar		;input a character.
E50F: CD1AE5  		call	chkchar		;carriage control?
E512: D8      		ret	c		;no, a regular control char so don't echo.
E513: F5      		push	af		;ok, save character now.
E514: 4F      		ld	c,a
E515: CD96E5  		call	outcon		;and echo it.
E518: F1      		pop	af		;get character and return.
E519: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E51A: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E51C: C8      		ret	z		;or a tab.
E51D: FE0A    		cp	lf
E51F: C8      		ret	z
E520: FE09    		cp	tab
E522: C8      		ret	z
E523: FE08    		cp	bs
E525: C8      		ret	z
E526: FE20    		cp	' '		;other control char? set carry flag.
E528: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E529: 3A14E7  	ckconsol: ld	a,(charbuf)	;check buffer.
E52C: B7      		or	a		;if anything, just return without checking.
E52D: C24BE5  		jp	nz,ckcon2
E530: CDA4F2  		call	const		;nothing in buffer. check console.
E533: E601    		and	01h		;look at bit 0.
E535: C8      		ret	z		;return if nothing.
E536: CDAFF2  		call	conin		;ok, get it.
E539: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E53B: C248E5  		jp	nz,ckcon1
E53E: CDAFF2  		call	conin		;halt processing until another char
E541: FE03    		cp	cntrlc		;is typed. control-c?
E543: CA0000  		jp	z,0		;yes, reboot now.
E546: AF      		xor	a		;no, just pretend nothing was ever ready.
E547: C9      		ret	
E548: 3214E7  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E54B: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E54D: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E54E: 3A10E7  	outchar:ld	a,(outflag)	;check output flag.
E551: B7      		or	a		;anything and we won't generate output.
E552: C268E5  		jp	nz,outchr1
E555: C5      		push	bc
E556: CD29E5  		call	ckconsol	;check console (we don't care whats there).
E559: C1      		pop	bc
E55A: C5      		push	bc
E55B: CDBBF2  		call	conout		;output (c) to the screen.
E55E: C1      		pop	bc
E55F: C5      		push	bc
E560: 3A13E7  		ld	a,(prtflag)	;check printer flip-flop flag.
E563: B7      		or	a
E564: C4C7F2  		call	nz,list		;print it also if non-zero.
E567: C1      		pop	bc
E568: 79      	outchr1:ld	a,c		;update cursors position.
E569: 2112E7  		ld	hl,curpos
E56C: FE7F    		cp	del		;rubouts don't do anything here.
E56E: C8      		ret	z
E56F: 34      		inc	(hl)		;bump line pointer.
E570: FE20    		cp	' '		;and return if a normal character.
E572: D0      		ret	nc
E573: 35      		dec	(hl)		;restore and check for the start of the line.
E574: 7E      		ld	a,(hl)
E575: B7      		or	a
E576: C8      		ret	z		;ingnore control characters at the start of the line.
E577: 79      		ld	a,c
E578: FE08    		cp	bs		;is it a backspace?
E57A: C27FE5  		jp	nz,outchr2
E57D: 35      		dec	(hl)		;yes, backup pointer.
E57E: C9      		ret	
E57F: FE0A    	outchr2:cp	lf		;is it a line feed?
E581: C0      		ret	nz		;ignore anything else.
E582: 3600    		ld	(hl),0		;reset pointer to start of line.
E584: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E585: 79      	showit:	ld	a,c
E586: CD1AE5  		call	chkchar		;check character.
E589: D296E5  		jp	nc,outcon	;not a control, use normal output.
E58C: F5      		push	af
E58D: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E58F: CD4EE5  		call	outchar
E592: F1      		pop	af
E593: F640    		or	'@'		;and then use the letter equivelant.
E595: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E596: 79      	outcon:	ld	a,c
E597: FE09    		cp	tab		;is it a tab?
E599: C24EE5  		jp	nz,outchar	;use regular output.
E59C: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E59E: CD4EE5  		call	outchar
E5A1: 3A12E7  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E5A4: E607    		and	07h		;position.
E5A6: C29CE5  		jp	nz,outcon1
E5A9: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E5AA: CDB2E5  	backup:	call	backup1		;backup the screen 1 place.
E5AD: 0E20    		ld	c,' '		;then blank that character.
E5AF: CDBBF2  		call	conout
E5B2: 0E08    	backup1:ld	c,bs		;then back space once more.
E5B4: C3BBF2  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E5B7: 0E23    	newline:ld	c,'#'
E5B9: CD4EE5  		call	outchar		;print this.
E5BC: CDCFE5  		call	outcrlf		;start new line.
E5BF: 3A12E7  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E5C2: 2111E7  		ld	hl,starting
E5C5: BE      		cp	(hl)
E5C6: D0      		ret	nc		;there yet?
E5C7: 0E20    		ld	c,' '
E5C9: CD4EE5  		call	outchar		;nope, keep going.
E5CC: C3BFE5  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E5CF: 0E0D    	outcrlf:ld	c,cr
E5D1: CD4EE5  		call	outchar
E5D4: 0E0A    		ld	c,lf
E5D6: C34EE5  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E5D9: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E5DA: FE24    		cp	'$'
E5DC: C8      		ret	z
E5DD: 03      		inc	bc
E5DE: C5      		push	bc		;otherwise, bump pointer and print it.
E5DF: 4F      		ld	c,a
E5E0: CD96E5  		call	outcon
E5E3: C1      		pop	bc
E5E4: C3D9E5  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E5E7: 3A12E7  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E5EA: 3211E7  		ld	(starting),a
E5ED: 2A49E7  		ld	hl,(params)	;get the maximum buffer space.
E5F0: 4E      		ld	c,(hl)
E5F1: 23      		inc	hl		;point to first available space.
E5F2: E5      		push	hl		;and save.
E5F3: 0600    		ld	b,0		;keep a character count.
E5F5: C5      	rdbuf1:	push	bc
E5F6: E5      		push	hl
E5F7: CD01E5  	rdbuf2:	call	getchar		;get the next input character.
E5FA: E67F    		and	7fh		;strip bit 7.
E5FC: E1      		pop	hl		;reset registers.
E5FD: C1      		pop	bc
E5FE: FE0D    		cp	cr		;en of the line?
E600: CAC7E6  		jp	z,rdbuf17
E603: FE0A    		cp	lf
E605: CAC7E6  		jp	z,rdbuf17
E608: FE08    		cp	bs		;how about a backspace?
E60A: C21CE6  		jp	nz,rdbuf3
E60D: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E60E: B7      		or	a
E60F: CAF5E5  		jp	z,rdbuf1
E612: 05      		dec	b		;ok, update counter.
E613: 3A12E7  		ld	a,(curpos)	;if we backspace to the start of the line,
E616: 3210E7  		ld	(outflag),a	;treat as a cancel (control-x).
E619: C376E6  		jp	rdbuf10
E61C: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E61E: C22CE6  		jp	nz,rdbuf4
E621: 78      		ld	a,b		;ignore at the start of the line.
E622: B7      		or	a
E623: CAF5E5  		jp	z,rdbuf1
E626: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E627: 05      		dec	b		;and reset pointers (counters).
E628: 2B      		dec	hl
E629: C3AFE6  		jp	rdbuf15
E62C: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E62E: C23DE6  		jp	nz,rdbuf5
E631: C5      		push	bc		;yes, do it.
E632: E5      		push	hl
E633: CDCFE5  		call	outcrlf
E636: AF      		xor	a		;and update starting position.
E637: 3211E7  		ld	(starting),a
E63A: C3F7E5  		jp	rdbuf2
E63D: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E63F: C24EE6  		jp	nz,rdbuf6
E642: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E643: 2113E7  		ld	hl,prtflag
E646: 3E01    		ld	a,1		;prtflag=1-prtflag
E648: 96      		sub	(hl)
E649: 77      		ld	(hl),a
E64A: E1      		pop	hl
E64B: C3F5E5  		jp	rdbuf1
E64E: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E650: C265E6  		jp	nz,rdbuf8
E653: E1      		pop	hl
E654: 3A11E7  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E657: 2112E7  		ld	hl,curpos
E65A: BE      		cp	(hl)
E65B: D2E7E5  		jp	nc,rdbuff	;done yet?
E65E: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E65F: CDAAE5  		call	backup
E662: C354E6  		jp	rdbuf7
E665: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E667: C271E6  		jp	nz,rdbuf9
E66A: CDB7E5  		call	newline		;start a new line.
E66D: E1      		pop	hl
E66E: C3E7E5  		jp	rdbuff
E671: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E673: C2ACE6  		jp	nz,rdbuf14
E676: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E677: CDB7E5  		call	newline
E67A: C1      		pop	bc
E67B: E1      		pop	hl
E67C: E5      		push	hl
E67D: C5      		push	bc
E67E: 78      	rdbuf11:ld	a,b		;done whole line yet?
E67F: B7      		or	a
E680: CA90E6  		jp	z,rdbuf12
E683: 23      		inc	hl		;nope, get next character.
E684: 4E      		ld	c,(hl)
E685: 05      		dec	b		;count it.
E686: C5      		push	bc
E687: E5      		push	hl
E688: CD85E5  		call	showit		;and display it.
E68B: E1      		pop	hl
E68C: C1      		pop	bc
E68D: C37EE6  		jp	rdbuf11
E690: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E691: 3A10E7  		ld	a,(outflag)	;then update cursor position.
E694: B7      		or	a
E695: CAF7E5  		jp	z,rdbuf2
E698: 2112E7  		ld	hl,curpos	;because this line is shorter, we must
E69B: 96      		sub	(hl)		;back up the cursor (not the screen however)
E69C: 3210E7  		ld	(outflag),a	;some number of positions.
E69F: CDAAE5  	rdbuf13:call	backup		;note that as long as (outflag) is non
E6A2: 2110E7  		ld	hl,outflag	;zero, the screen will not be changed.
E6A5: 35      		dec	(hl)
E6A6: C29FE6  		jp	nz,rdbuf13
E6A9: C3F7E5  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E6AC: 23      	rdbuf14:inc	hl
E6AD: 77      		ld	(hl),a		;store character.
E6AE: 04      		inc	b		;and count it.
E6AF: C5      	rdbuf15:push	bc
E6B0: E5      		push	hl
E6B1: 4F      		ld	c,a		;echo it now.
E6B2: CD85E5  		call	showit
E6B5: E1      		pop	hl
E6B6: C1      		pop	bc
E6B7: 7E      		ld	a,(hl)		;was it an abort request?
E6B8: FE03    		cp	cntrlc		;control-c abort?
E6BA: 78      		ld	a,b
E6BB: C2C3E6  		jp	nz,rdbuf16
E6BE: FE01    		cp	1		;only if at start of line.
E6C0: CA0000  		jp	z,0
E6C3: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E6C4: DAF5E5  		jp	c,rdbuf1
E6C7: E1      	rdbuf17:pop	hl		;yes end the line and return.
E6C8: 70      		ld	(hl),b
E6C9: 0E0D    		ld	c,cr
E6CB: C34EE5  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E6CE: CD0CE5  	getcon:	call	getecho		;get and echo.
E6D1: C307E7  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E6D4: CDCFF2  	getrdr:	call	reader		;get a character from reader, set status and return.
E6D7: C307E7  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E6DA: 79      	dircio:	ld	a,c		;test for (ff).
E6DB: 3C      		inc	a
E6DC: CAE6E6  		jp	z,dirc1
E6DF: 3C      		inc	a		;test for (fe).
E6E0: CAA4F2  		jp	z,const
E6E3: C3BBF2  		jp	conout		;just output (c).
E6E6: CDA4F2  	dirc1:	call	const		;this is an input request.
E6E9: B7      		or	a
E6EA: CA97F1  		jp	z,goback1	;not ready? just return (directly).
E6ED: CDAFF2  		call	conin		;yes, get character.
E6F0: C307E7  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E6F3: 3A0300  	getiob:	ld	a,(iobyte)
E6F6: C307E7  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E6F9: 210300  	setiob:	ld	hl,iobyte
E6FC: 71      		ld	(hl),c
E6FD: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E6FE: EB      	prtstr:	ex	de,hl
E6FF: 4D      		ld	c,l
E700: 44      		ld	b,h		;now (bc) points to it.
E701: C3D9E5  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E704: CD29E5  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E707: 324BE7  	setstat:ld	(status),a
E70A: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E70B: 3E01    	ioerr1:	ld	a,1
E70D: C307E7  		jp	setstat
              	;
E710: 00      	outflag:defb	0		;output flag (non zero means no output).
E711: 02      	starting: defb	2		;starting position for cursor.
E712: 00      	curpos:	defb	0		;cursor position (0=start of line).
E713: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E714: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E715: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E717: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E71B: 00...   	
E72F: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E733: 00...   	
E747:         	stkarea equ	$		;end of stack area.
              	;
E747: 00      	userno:	defb	0		;current user number.
E748: 00      	active:	defb	0		;currently active drive.
E749: 0000    	params:	defw	0		;save (de) parameters here on entry.
E74B: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E74D: 210EE4  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E750: 5E      	jumphl:	ld	e,(hl)
E751: 23      		inc	hl
E752: 56      		ld	d,(hl)		;now (de) contain the desired address.
E753: EB      		ex	de,hl
E754: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E755: 0C      	de2hl:	inc	c		;is count down to zero?
E756: 0D      	de2hl1:	dec	c
E757: C8      		ret	z		;yes, we are done.
E758: 1A      		ld	a,(de)		;no, move one more byte.
E759: 77      		ld	(hl),a
E75A: 13      		inc	de
E75B: 23      		inc	hl
E75C: C356E7  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E75F: 3A48E7  	select:	ld	a,(active)	;get active disk.
E762: 4F      		ld	c,a
E763: CDE2F2  		call	seldsk		;select it.
E766: 7C      		ld	a,h		;valid drive?
E767: B5      		or	l		;valid drive?
E768: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E769: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E76A: 23      		inc	hl
E76B: 56      		ld	d,(hl)
E76C: 23      		inc	hl
E76D: 22B9F1  		ld	(scratch1),hl	;save pointers to scratch areas.
E770: 23      		inc	hl
E771: 23      		inc	hl
E772: 22BBF1  		ld	(scratch2),hl	;ditto.
E775: 23      		inc	hl
E776: 23      		inc	hl
E777: 22BDF1  		ld	(scratch3),hl	;ditto.
E77A: 23      		inc	hl
E77B: 23      		inc	hl
E77C: EB      		ex	de,hl		;now save the translation table address.
E77D: 22D6F1  		ld	(xlate),hl
E780: 21BFF1  		ld	hl,dirbuf	;put the next 8 bytes here.
E783: 0E08    		ld	c,8		;they consist of the directory buffer
E785: CD55E7  		call	de2hl		;pointer, parameter block pointer,
E788: 2AC1F1  		ld	hl,(diskpb)	;check and allocation vectors.
E78B: EB      		ex	de,hl
E78C: 21C7F1  		ld	hl,sectors	;move parameter block into our ram.
E78F: 0E0F    		ld	c,15		;it is 15 bytes long.
E791: CD55E7  		call	de2hl
E794: 2ACCF1  		ld	hl,(dsksize)	;check disk size.
E797: 7C      		ld	a,h		;more than 256 blocks on this?
E798: 21E3F1  		ld	hl,bigdisk
E79B: 36FF    		ld	(hl),0ffh	;set to samll.
E79D: B7      		or	a
E79E: CAA3E7  		jp	z,select1
E7A1: 3600    		ld	(hl),0		;wrong, set to large.
E7A3: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E7A5: B7      		or	a
E7A6: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E7A7: CDDDF2  	homedrv:call	home		;home the head.
E7AA: AF      		xor	a
E7AB: 2ABBF1  		ld	hl,(scratch2)	;set our track pointer also.
E7AE: 77      		ld	(hl),a
E7AF: 23      		inc	hl
E7B0: 77      		ld	(hl),a
E7B1: 2ABDF1  		ld	hl,(scratch3)	;and our sector pointer.
E7B4: 77      		ld	(hl),a
E7B5: 23      		inc	hl
E7B6: 77      		ld	(hl),a
E7B7: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E7B8: CD0EF3  	doread:	call	read
E7BB: C3C1E7  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E7BE: CD12F3  	dowrite:call	write
E7C1: B7      	ioret:	or	a
E7C2: C8      		ret	z		;return unless an error occured.
E7C3: 210CE4  		ld	hl,badsctr	;bad read/write on this sector.
E7C6: C350E7  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E7C9: 2AF0F1  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E7CC: 0E02    		ld	c,2		;in directory and compute sector #.
E7CE: CDF0E8  		call	shiftr		;sector #=file-position/4.
E7D1: 22EBF1  		ld	(blknmbr),hl	;save this as the block number of interest.
E7D4: 22F2F1  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E7D7: 21EBF1  	trksec1:ld	hl,blknmbr
E7DA: 4E      		ld	c,(hl)		;move sector number into (bc).
E7DB: 23      		inc	hl
E7DC: 46      		ld	b,(hl)
E7DD: 2ABDF1  		ld	hl,(scratch3)	;get current sector number and
E7E0: 5E      		ld	e,(hl)		;move this into (de).
E7E1: 23      		inc	hl
E7E2: 56      		ld	d,(hl)
E7E3: 2ABBF1  		ld	hl,(scratch2)	;get current track number.
E7E6: 7E      		ld	a,(hl)		;and this into (hl).
E7E7: 23      		inc	hl
E7E8: 66      		ld	h,(hl)
E7E9: 6F      		ld	l,a
E7EA: 79      	trksec2:ld	a,c		;is desired sector before current one?
E7EB: 93      		sub	e
E7EC: 78      		ld	a,b
E7ED: 9A      		sbc	a,d
E7EE: D200E8  		jp	nc,trksec3
E7F1: E5      		push	hl		;yes, decrement sectors by one track.
E7F2: 2AC7F1  		ld	hl,(sectors)	;get sectors per track.
E7F5: 7B      		ld	a,e
E7F6: 95      		sub	l
E7F7: 5F      		ld	e,a
E7F8: 7A      		ld	a,d
E7F9: 9C      		sbc	a,h
E7FA: 57      		ld	d,a		;now we have backed up one full track.
E7FB: E1      		pop	hl
E7FC: 2B      		dec	hl		;adjust track counter.
E7FD: C3EAE7  		jp	trksec2
E800: E5      	trksec3:push	hl		;desired sector is after current one.
E801: 2AC7F1  		ld	hl,(sectors)	;get sectors per track.
E804: 19      		add	hl,de		;bump sector pointer to next track.
E805: DA15E8  		jp	c,trksec4
E808: 79      		ld	a,c		;is desired sector now before current one?
E809: 95      		sub	l
E80A: 78      		ld	a,b
E80B: 9C      		sbc	a,h
E80C: DA15E8  		jp	c,trksec4
E80F: EB      		ex	de,hl		;not yes, increment track counter
E810: E1      		pop	hl		;and continue until it is.
E811: 23      		inc	hl
E812: C300E8  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E815: E1      	trksec4:pop	hl		;get track number (hl).
E816: C5      		push	bc
E817: D5      		push	de
E818: E5      		push	hl
E819: EB      		ex	de,hl
E81A: 2AD4F1  		ld	hl,(offset)	;adjust for first track offset.
E81D: 19      		add	hl,de
E81E: 44      		ld	b,h
E81F: 4D      		ld	c,l
E820: CD00F3  		call	settrk		;select this track.
E823: D1      		pop	de		;reset current track pointer.
E824: 2ABBF1  		ld	hl,(scratch2)
E827: 73      		ld	(hl),e
E828: 23      		inc	hl
E829: 72      		ld	(hl),d
E82A: D1      		pop	de
E82B: 2ABDF1  		ld	hl,(scratch3)	;reset the first sector on this track.
E82E: 73      		ld	(hl),e
E82F: 23      		inc	hl
E830: 72      		ld	(hl),d
E831: C1      		pop	bc
E832: 79      		ld	a,c		;now subtract the desired one.
E833: 93      		sub	e		;to make it relative (1-# sectors/track).
E834: 4F      		ld	c,a
E835: 78      		ld	a,b
E836: 9A      		sbc	a,d
E837: 47      		ld	b,a
E838: 2AD6F1  		ld	hl,(xlate)	;translate this sector according to this table.
E83B: EB      		ex	de,hl
E83C: CD19F3  		call	sectrn		;let the bios translate it.
E83F: 4D      		ld	c,l
E840: 44      		ld	b,h
E841: C304F3  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E844: 21C9F1  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E847: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E848: 3AE9F1  		ld	a,(savnrec)	;get record number.
E84B: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E84C: 1F      		rra	
E84D: 0D      		dec	c
E84E: C24BE8  		jp	nz,getblk1
E851: 47      		ld	b,a		;save result in (b).
E852: 3E08    		ld	a,8
E854: 96      		sub	(hl)
E855: 4F      		ld	c,a		;compute (c)=8-blkshft.
E856: 3AE8F1  		ld	a,(savext)
E859: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E85A: CA62E8  		jp	z,getblk3
E85D: B7      		or	a
E85E: 17      		rla	
E85F: C359E8  		jp	getblk2
E862: 80      	getblk3:add	a,b
E863: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E864: 2A49E7  	extblk:	ld	hl,(params)	;get fcb address.
E867: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E86A: 19      		add	hl,de
E86B: 09      		add	hl,bc
E86C: 3AE3F1  		ld	a,(bigdisk)	;are we using a big-disk?
E86F: B7      		or	a
E870: CA77E8  		jp	z,extblk1
E873: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E874: 2600    		ld	h,0
E876: C9      		ret	
E877: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E878: 5E      		ld	e,(hl)
E879: 23      		inc	hl
E87A: 56      		ld	d,(hl)
E87B: EB      		ex	de,hl		;return in (hl).
E87C: C9      		ret	
              	;
              	;   compute block number.
              	;
E87D: CD44E8  	comblk:	call	getblock
E880: 4F      		ld	c,a
E881: 0600    		ld	b,0
E883: CD64E8  		call	extblk
E886: 22EBF1  		ld	(blknmbr),hl
E889: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E88A: 2AEBF1  	chkblk:	ld	hl,(blknmbr)
E88D: 7D      		ld	a,l		;is it zero?
E88E: B4      		or	h
E88F: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E890: 3AC9F1  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E893: 2AEBF1  		ld	hl,(blknmbr)	;get physical sector desired.
E896: 29      	logicl1:add	hl,hl		;compute logical sector number.
E897: 3D      		dec	a		;note logical sectors are 128 bytes long.
E898: C296E8  		jp	nz,logicl1
E89B: 22EDF1  		ld	(logsect),hl	;save logical sector.
E89E: 3ACAF1  		ld	a,(blkmask)	;get block mask.
E8A1: 4F      		ld	c,a
E8A2: 3AE9F1  		ld	a,(savnrec)	;get next sector to access.
E8A5: A1      		and	c		;extract the relative position within physical block.
E8A6: B5      		or	l		;and add it too logical sector.
E8A7: 6F      		ld	l,a
E8A8: 22EBF1  		ld	(blknmbr),hl	;and store.
E8AB: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E8AC: 2A49E7  	setext:	ld	hl,(params)
E8AF: 110C00  		ld	de,12		;it is the twelth byte.
E8B2: 19      		add	hl,de
E8B3: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E8B4: 2A49E7  	sethlde:ld	hl,(params)
E8B7: 110F00  		ld	de,15		;record count byte (#15).
E8BA: 19      		add	hl,de
E8BB: EB      		ex	de,hl
E8BC: 211100  		ld	hl,17		;next record number (#32).
E8BF: 19      		add	hl,de
E8C0: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E8C1: CDB4E8  	strdata:call	sethlde
E8C4: 7E      		ld	a,(hl)		;get and store record count byte.
E8C5: 32E9F1  		ld	(savnrec),a
E8C8: EB      		ex	de,hl
E8C9: 7E      		ld	a,(hl)		;get and store next record number byte.
E8CA: 32E7F1  		ld	(savnxt),a
E8CD: CDACE8  		call	setext		;point to extent byte.
E8D0: 3ACBF1  		ld	a,(extmask)	;get extent mask.
E8D3: A6      		and	(hl)
E8D4: 32E8F1  		ld	(savext),a	;and save extent here.
E8D7: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E8D8: CDB4E8  	setnrec:call	sethlde
E8DB: 3ADBF1  		ld	a,(mode)	;get sequential flag (=1).
E8DE: FE02    		cp	2		;a 2 indicates that no adder is needed.
E8E0: C2E4E8  		jp	nz,stnrec1
E8E3: AF      		xor	a		;clear adder (random access?).
E8E4: 4F      	stnrec1:ld	c,a
E8E5: 3AE9F1  		ld	a,(savnrec)	;get last record number.
E8E8: 81      		add	a,c		;increment record count.
E8E9: 77      		ld	(hl),a		;and set fcb's next record byte.
E8EA: EB      		ex	de,hl
E8EB: 3AE7F1  		ld	a,(savnxt)	;get next record byte from storage.
E8EE: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E8EF: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E8F0: 0C      	shiftr:	inc	c
E8F1: 0D      	shiftr1:dec	c
E8F2: C8      		ret	z
E8F3: 7C      		ld	a,h
E8F4: B7      		or	a
E8F5: 1F      		rra	
E8F6: 67      		ld	h,a
E8F7: 7D      		ld	a,l
E8F8: 1F      		rra	
E8F9: 6F      		ld	l,a
E8FA: C3F1E8  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E8FD: 0E80    	checksum: ld	c,128		;length of buffer.
E8FF: 2ABFF1  		ld	hl,(dirbuf)	;get its location.
E902: AF      		xor	a		;clear summation byte.
E903: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E904: 23      		inc	hl
E905: 0D      		dec	c
E906: C203E9  		jp	nz,chksum1
E909: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E90A: 0C      	shiftl:	inc	c
E90B: 0D      	shiftl1:dec	c
E90C: C8      		ret	z
E90D: 29      		add	hl,hl		;shift left 1 bit.
E90E: C30BE9  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E911: C5      	setbit:	push	bc		;save 16 bit word.
E912: 3A48E7  		ld	a,(active)	;get active drive.
E915: 4F      		ld	c,a
E916: 210100  		ld	hl,1
E919: CD0AE9  		call	shiftl		;shift bit 0 into place.
E91C: C1      		pop	bc		;now 'or' this with the original word.
E91D: 79      		ld	a,c
E91E: B5      		or	l
E91F: 6F      		ld	l,a		;low byte done, do high byte.
E920: 78      		ld	a,b
E921: B4      		or	h
E922: 67      		ld	h,a
E923: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E924: 2AB3F1  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E927: 3A48E7  		ld	a,(active)	;which drive is current?
E92A: 4F      		ld	c,a
E92B: CDF0E8  		call	shiftr		;shift status such that bit 0 is the
E92E: 7D      		ld	a,l		;one of interest for this drive.
E92F: E601    		and	01h		;and isolate it.
E931: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E932: 21B3F1  	wrtprtd:ld	hl,wrtprt	;point to status word.
E935: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E936: 23      		inc	hl
E937: 46      		ld	b,(hl)
E938: CD11E9  		call	setbit		;and set this bit according to current drive.
E93B: 22B3F1  		ld	(wrtprt),hl	;then save.
E93E: 2ACEF1  		ld	hl,(dirsize)	;now save directory size limit.
E941: 23      		inc	hl		;remember the last one.
E942: EB      		ex	de,hl
E943: 2AB9F1  		ld	hl,(scratch1)	;and store it here.
E946: 73      		ld	(hl),e		;put low byte.
E947: 23      		inc	hl
E948: 72      		ld	(hl),d		;then high byte.
E949: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E94A: CD64E9  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E94D: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E950: 19      		add	hl,de
E951: 7E      		ld	a,(hl)
E952: 17      		rla	
E953: D0      		ret	nc		;return if ok.
E954: 2112E4  		ld	hl,rofile	;else, print error message and terminate.
E957: C350E7  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E95A: CD24E9  	chkwprt:call	getwprt
E95D: C8      		ret	z		;return if ok.
E95E: 2110E4  		ld	hl,rodisk	;else print message and terminate.
E961: C350E7  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E964: 2ABFF1  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E967: 3AEFF1  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E96A: 85      	adda2hl:add	a,l
E96B: 6F      		ld	l,a
E96C: D0      		ret	nc
E96D: 24      		inc	h		;take care of any carry.
E96E: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E96F: 2A49E7  	gets2:	ld	hl,(params)	;get address of fcb.
E972: 110E00  		ld	de,14		;relative position of 's2'.
E975: 19      		add	hl,de
E976: 7E      		ld	a,(hl)		;extract this byte.
E977: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E978: CD6FE9  	clears2:call	gets2		;this sets (hl) pointing to it.
E97B: 3600    		ld	(hl),0		;now clear it.
E97D: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E97E: CD6FE9  	sets2b7:call	gets2		;get the byte.
E981: F680    		or	80h		;and set bit 7.
E983: 77      		ld	(hl),a		;then store.
E984: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E985: 2AF0F1  	morefls:ld	hl,(filepos)	;we are here.
E988: EB      		ex	de,hl
E989: 2AB9F1  		ld	hl,(scratch1)	;and don't go past here.
E98C: 7B      		ld	a,e		;compute difference but don't keep.
E98D: 96      		sub	(hl)
E98E: 23      		inc	hl
E98F: 7A      		ld	a,d
E990: 9E      		sbc	a,(hl)		;set carry if no more names.
E991: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E992: CD85E9  	chknmbr:call	morefls		;scratch1 too big?
E995: D8      		ret	c
E996: 13      		inc	de		;yes, reset it to (filepos).
E997: 72      		ld	(hl),d
E998: 2B      		dec	hl
E999: 73      		ld	(hl),e
E99A: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E99B: 7B      	subhl:	ld	a,e		;compute difference.
E99C: 95      		sub	l
E99D: 6F      		ld	l,a		;store low byte.
E99E: 7A      		ld	a,d
E99F: 9C      		sbc	a,h
E9A0: 67      		ld	h,a		;and then high byte.
E9A1: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E9A2: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E9A4: 2AF2F1  	checkdir: ld	hl,(cksumtbl)
E9A7: EB      		ex	de,hl
E9A8: 2AD2F1  		ld	hl,(alloc1)
E9AB: CD9BE9  		call	subhl
E9AE: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E9AF: C5      		push	bc
E9B0: CDFDE8  		call	checksum	;else compute checksum.
E9B3: 2AC3F1  		ld	hl,(chkvect)	;get address of checksum table.
E9B6: EB      		ex	de,hl
E9B7: 2AF2F1  		ld	hl,(cksumtbl)
E9BA: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E9BB: C1      		pop	bc
E9BC: 0C      		inc	c		;set or check ?
E9BD: CACAE9  		jp	z,chkdir1
E9C0: BE      		cp	(hl)		;check them.
E9C1: C8      		ret	z		;return if they are the same.
E9C2: CD85E9  		call	morefls		;not the same, do we care?
E9C5: D0      		ret	nc
E9C6: CD32E9  		call	wrtprtd		;yes, mark this as write protected.
E9C9: C9      		ret	
E9CA: 77      	chkdir1:ld	(hl),a		;just set the byte.
E9CB: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E9CC: CDA2E9  	dirwrite: call	setdir		;set checksum byte.
E9CF: CDE6E9  		call	dirdma		;set directory dma address.
E9D2: 0E01    		ld	c,1		;tell the bios to actually write.
E9D4: CDBEE7  		call	dowrite		;then do the write.
E9D7: C3E0E9  		jp	defdma
              	;
              	;   read from the directory.
              	;
E9DA: CDE6E9  	dirread:call	dirdma		;set the directory dma address.
E9DD: CDB8E7  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E9E0: 21B7F1  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E9E3: C3E9E9  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E9E6: 21BFF1  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E9E9: 4E      	dirdma1:ld	c,(hl)
E9EA: 23      		inc	hl
E9EB: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E9EC: C308F3  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E9EF: 2ABFF1  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E9F2: EB      		ex	de,hl
E9F3: 2AB7F1  		ld	hl,(userdma)	; put it here.
E9F6: 0E80    		ld	c,128		;this is its length.
E9F8: C355E7  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E9FB: 21F0F1  	ckfilpos: ld	hl,filepos
E9FE: 7E      		ld	a,(hl)
E9FF: 23      		inc	hl
EA00: BE      		cp	(hl)		;are both bytes the same?
EA01: C0      		ret	nz
EA02: 3C      		inc	a		;yes, but are they each 0ffh?
EA03: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
EA04: 21FFFF  	stfilpos: ld	hl,0ffffh
EA07: 22F0F1  		ld	(filepos),hl
EA0A: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
EA0B: 2ACEF1  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
EA0E: EB      		ex	de,hl
EA0F: 2AF0F1  		ld	hl,(filepos)	;get current count.
EA12: 23      		inc	hl		;go on to the next one.
EA13: 22F0F1  		ld	(filepos),hl
EA16: CD9BE9  		call	subhl		;(hl)=(dirsize)-(filepos)
EA19: D21FEA  		jp	nc,nxent1	;is there more room left?
EA1C: C304EA  		jp	stfilpos	;no. set this flag and return.
EA1F: 3AF0F1  	nxent1:	ld	a,(filepos)	;get file position within directory.
EA22: E603    		and	03h		;only look within this sector (only 4 entries fit).
EA24: 0605    		ld	b,5		;convert to relative position (32 bytes each).
EA26: 87      	nxent2:	add	a,a		;note that this is not efficient code.
EA27: 05      		dec	b		;5 'add a's would be better.
EA28: C226EA  		jp	nz,nxent2
EA2B: 32EFF1  		ld	(fcbpos),a	;save it as position of fcb.
EA2E: B7      		or	a
EA2F: C0      		ret	nz		;return if we are within buffer.
EA30: C5      		push	bc
EA31: CDC9E7  		call	trksec		;we need the next directory sector.
EA34: CDDAE9  		call	dirread
EA37: C1      		pop	bc
EA38: C3A4E9  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
EA3B: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
EA3C: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
EA3E: 3C      		inc	a
EA3F: 5F      		ld	e,a		;save particular bit number.
EA40: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
EA41: 79      		ld	a,c
EA42: 0F      		rrca			;now shift right 3 bits.
EA43: 0F      		rrca	
EA44: 0F      		rrca	
EA45: E61F    		and	1fh		;and clear bits 7,6,5.
EA47: 4F      		ld	c,a
EA48: 78      		ld	a,b
EA49: 87      		add	a,a		;now shift (b) into bits 7,6,5.
EA4A: 87      		add	a,a
EA4B: 87      		add	a,a
EA4C: 87      		add	a,a
EA4D: 87      		add	a,a
EA4E: B1      		or	c		;and add in (c).
EA4F: 4F      		ld	c,a		;ok, (c) ha been completed.
EA50: 78      		ld	a,b		;is there a better way of doing this?
EA51: 0F      		rrca	
EA52: 0F      		rrca	
EA53: 0F      		rrca	
EA54: E61F    		and	1fh
EA56: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
EA57: 2AC5F1  		ld	hl,(alocvect)
EA5A: 09      		add	hl,bc
EA5B: 7E      		ld	a,(hl)		;now get correct byte.
EA5C: 07      	ckbmap1:rlca			;get correct bit into position 0.
EA5D: 1D      		dec	e
EA5E: C25CEA  		jp	nz,ckbmap1
EA61: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
EA62: D5      	stbitmap: push	de
EA63: CD3BEA  		call	ckbitmap	;get the byte of interest.
EA66: E6FE    		and	0feh		;clear the affected bit.
EA68: C1      		pop	bc
EA69: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
EA6A: 0F      	stbmap1:rrca			;restore original bit position.
EA6B: 15      		dec	d
EA6C: C26AEA  		jp	nz,stbmap1
EA6F: 77      		ld	(hl),a		;and stor byte in table.
EA70: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
EA71: CD64E9  	setfile:call	fcb2hl		;get address of fcb
EA74: 111000  		ld	de,16
EA77: 19      		add	hl,de		;get to block number bytes.
EA78: C5      		push	bc
EA79: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
EA7B: D1      	setfl1:	pop	de
EA7C: 0D      		dec	c		;done all bytes yet?
EA7D: C8      		ret	z
EA7E: D5      		push	de
EA7F: 3AE3F1  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
EA82: B7      		or	a
EA83: CA8EEA  		jp	z,setfl2
EA86: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
EA87: E5      		push	hl
EA88: 4E      		ld	c,(hl)		;get low byte from table, always
EA89: 0600    		ld	b,0		;set high byte to zero.
EA8B: C394EA  		jp	setfl3
EA8E: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
EA8F: C5      		push	bc
EA90: 4E      		ld	c,(hl)		;now get both the low and high bytes.
EA91: 23      		inc	hl
EA92: 46      		ld	b,(hl)
EA93: E5      		push	hl
EA94: 79      	setfl3:	ld	a,c		;block used?
EA95: B0      		or	b
EA96: CAA3EA  		jp	z,setfl4
EA99: 2ACCF1  		ld	hl,(dsksize)	;is this block number within the
EA9C: 7D      		ld	a,l		;space on the disk?
EA9D: 91      		sub	c
EA9E: 7C      		ld	a,h
EA9F: 98      		sbc	a,b
EAA0: D462EA  		call	nc,stbitmap	;yes, set the proper bit.
EAA3: E1      	setfl4:	pop	hl		;point to next block number in fcb.
EAA4: 23      		inc	hl
EAA5: C1      		pop	bc
EAA6: C37BEA  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
EAA9: 2ACCF1  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
EAAC: 0E03    		ld	c,3
EAAE: CDF0E8  		call	shiftr		;(hl)=(hl)/8.
EAB1: 23      		inc	hl		;at lease 1 byte.
EAB2: 44      		ld	b,h
EAB3: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
EAB4: 2AC5F1  		ld	hl,(alocvect)	;now zero out the table now.
EAB7: 3600    	bitmap1:ld	(hl),0
EAB9: 23      		inc	hl
EABA: 0B      		dec	bc
EABB: 78      		ld	a,b
EABC: B1      		or	c
EABD: C2B7EA  		jp	nz,bitmap1
EAC0: 2AD0F1  		ld	hl,(alloc0)	;get initial space used by directory.
EAC3: EB      		ex	de,hl
EAC4: 2AC5F1  		ld	hl,(alocvect)	;and put this into map.
EAC7: 73      		ld	(hl),e
EAC8: 23      		inc	hl
EAC9: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
EACA: CDA7E7  		call	homedrv		;now home the drive.
EACD: 2AB9F1  		ld	hl,(scratch1)
EAD0: 3603    		ld	(hl),3		;force next directory request to read
EAD2: 23      		inc	hl		;in a sector.
EAD3: 3600    		ld	(hl),0
EAD5: CD04EA  		call	stfilpos	;clear initial file position also.
EAD8: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
EADA: CD0BEA  		call	nxentry		;and set checksum byte.
EADD: CDFBE9  		call	ckfilpos	;is there another file?
EAE0: C8      		ret	z
EAE1: CD64E9  		call	fcb2hl		;yes, get its address.
EAE4: 3EE5    		ld	a,0e5h
EAE6: BE      		cp	(hl)		;empty file entry?
EAE7: CAD8EA  		jp	z,bitmap2
EAEA: 3A47E7  		ld	a,(userno)	;no, correct user number?
EAED: BE      		cp	(hl)
EAEE: C2FCEA  		jp	nz,bitmap3
EAF1: 23      		inc	hl
EAF2: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
EAF3: D624    		sub	'$'
EAF5: C2FCEA  		jp	nz,bitmap3
EAF8: 3D      		dec	a		;yes, set atatus to minus one.
EAF9: 324BE7  		ld	(status),a
EAFC: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
EAFE: CD71EA  		call	setfile
EB01: CD92E9  		call	chknmbr		;keep (scratch1) in bounds.
EB04: C3D8EA  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
EB07: 3ADAF1  	ststatus: ld	a,(fndstat)
EB0A: C307E7  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
EB0D: C5      	samext:	push	bc
EB0E: F5      		push	af
EB0F: 3ACBF1  		ld	a,(extmask)	;get extent mask and use it to
EB12: 2F      		cpl			;to compare both extent numbers.
EB13: 47      		ld	b,a		;save resulting mask here.
EB14: 79      		ld	a,c		;mask first extent and save in (c).
EB15: A0      		and	b
EB16: 4F      		ld	c,a
EB17: F1      		pop	af		;now mask second extent and compare
EB18: A0      		and	b		;with the first one.
EB19: 91      		sub	c
EB1A: E61F    		and	1fh		;(* only check buts 0-4 *)
EB1C: C1      		pop	bc		;the zero flag is set if they are the same.
EB1D: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
EB1E: 3EFF    	findfst:ld	a,0ffh
EB20: 32DAF1  		ld	(fndstat),a
EB23: 21DEF1  		ld	hl,counter	;save character count.
EB26: 71      		ld	(hl),c
EB27: 2A49E7  		ld	hl,(params)	;get filename to match.
EB2A: 22DFF1  		ld	(savefcb),hl	;and save.
EB2D: CD04EA  		call	stfilpos	;clear initial file position (set to 0ffffh).
EB30: CDA7E7  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
EB33: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
EB35: CD0BEA  		call	nxentry		;get next filename entry in directory.
EB38: CDFBE9  		call	ckfilpos	;is file position = 0ffffh?
EB3B: CA9AEB  		jp	z,fndnxt6	;yes, exit now then.
EB3E: 2ADFF1  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
EB41: EB      		ex	de,hl
EB42: 1A      		ld	a,(de)
EB43: FEE5    		cp	0e5h		;empty directory entry?
EB45: CA50EB  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
EB48: D5      		push	de
EB49: CD85E9  		call	morefls		;more files in directory?
EB4C: D1      		pop	de
EB4D: D29AEB  		jp	nc,fndnxt6	;no more. exit now.
EB50: CD64E9  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
EB53: 3ADEF1  		ld	a,(counter)	;get number of bytes (characters) to check.
EB56: 4F      		ld	c,a
EB57: 0600    		ld	b,0		;initialize byte position counter.
EB59: 79      	fndnxt2:ld	a,c		;are we done with the compare?
EB5A: B7      		or	a
EB5B: CA89EB  		jp	z,fndnxt5
EB5E: 1A      		ld	a,(de)		;no, check next byte.
EB5F: FE3F    		cp	'?'		;don't care about this character?
EB61: CA82EB  		jp	z,fndnxt4
EB64: 78      		ld	a,b		;get bytes position in fcb.
EB65: FE0D    		cp	13		;don't care about the thirteenth byte either.
EB67: CA82EB  		jp	z,fndnxt4
EB6A: FE0C    		cp	12		;extent byte?
EB6C: 1A      		ld	a,(de)
EB6D: CA79EB  		jp	z,fndnxt3
EB70: 96      		sub	(hl)		;otherwise compare characters.
EB71: E67F    		and	7fh
EB73: C233EB  		jp	nz,findnxt	;not the same, check next entry.
EB76: C382EB  		jp	fndnxt4		;so far so good, keep checking.
EB79: C5      	fndnxt3:push	bc		;check the extent byte here.
EB7A: 4E      		ld	c,(hl)
EB7B: CD0DEB  		call	samext
EB7E: C1      		pop	bc
EB7F: C233EB  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
EB82: 13      	fndnxt4:inc	de		;bump pointers.
EB83: 23      		inc	hl
EB84: 04      		inc	b
EB85: 0D      		dec	c		;adjust character counter.
EB86: C359EB  		jp	fndnxt2
EB89: 3AF0F1  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
EB8C: E603    		and	03h
EB8E: 324BE7  		ld	(status),a
EB91: 21DAF1  		ld	hl,fndstat
EB94: 7E      		ld	a,(hl)
EB95: 17      		rla	
EB96: D0      		ret	nc
EB97: AF      		xor	a
EB98: 77      		ld	(hl),a
EB99: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
EB9A: CD04EA  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
EB9D: 3EFF    		ld	a,0ffh		;say not located.
EB9F: C307E7  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
EBA2: CD5AE9  	erafile:call	chkwprt		;is disk write protected?
EBA5: 0E0C    		ld	c,12		;only compare file names.
EBA7: CD1EEB  		call	findfst		;get first file name.
EBAA: CDFBE9  	erafil1:call	ckfilpos	;any found?
EBAD: C8      		ret	z		;nope, we must be done.
EBAE: CD4AE9  		call	chkrofl		;is file read only?
EBB1: CD64E9  		call	fcb2hl		;nope, get address of fcb and
EBB4: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
EBB6: 0E00    		ld	c,0		;clear the space from the bit map.
EBB8: CD71EA  		call	setfile
EBBB: CDCCE9  		call	dirwrite	;now write the directory sector back out.
EBBE: CD33EB  		call	findnxt		;find the next file name.
EBC1: C3AAEB  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
EBC4: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
EBC5: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
EBC6: 79      	fndspa1:ld	a,c		;is block 0 specified?
EBC7: B0      		or	b
EBC8: CAD7EB  		jp	z,fndspa2
EBCB: 0B      		dec	bc		;nope, check previous block.
EBCC: D5      		push	de
EBCD: C5      		push	bc
EBCE: CD3BEA  		call	ckbitmap
EBD1: 1F      		rra			;is this block empty?
EBD2: D2F2EB  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
EBD5: C1      		pop	bc		;nope, check some more.
EBD6: D1      		pop	de
              	;
              	;   now look after target block.
              	;
EBD7: 2ACCF1  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
EBDA: 7B      		ld	a,e
EBDB: 95      		sub	l
EBDC: 7A      		ld	a,d
EBDD: 9C      		sbc	a,h
EBDE: D2FAEB  		jp	nc,fndspa4
EBE1: 13      		inc	de		;yes, move on to next one.
EBE2: C5      		push	bc
EBE3: D5      		push	de
EBE4: 42      		ld	b,d
EBE5: 4B      		ld	c,e
EBE6: CD3BEA  		call	ckbitmap	;check it.
EBE9: 1F      		rra			;empty?
EBEA: D2F2EB  		jp	nc,fndspa3
EBED: D1      		pop	de		;nope, continue searching.
EBEE: C1      		pop	bc
EBEF: C3C6EB  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
EBF2: 17      	fndspa3:rla			;reset byte.
EBF3: 3C      		inc	a		;and set bit 0.
EBF4: CD6AEA  		call	stbmap1		;update bit map.
EBF7: E1      		pop	hl		;set return registers.
EBF8: D1      		pop	de
EBF9: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
EBFA: 79      	fndspa4:ld	a,c
EBFB: B0      		or	b
EBFC: C2C6EB  		jp	nz,fndspa1
EBFF: 210000  		ld	hl,0		;set 'not found' status.
EC02: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
EC03: 0E00    	fcbset:	ld	c,0
EC05: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
EC07: D5      	update:	push	de
EC08: 0600    		ld	b,0		;set (bc) to relative byte position.
EC0A: 2A49E7  		ld	hl,(params)	;get address of fcb.
EC0D: 09      		add	hl,bc		;compute starting byte.
EC0E: EB      		ex	de,hl
EC0F: CD64E9  		call	fcb2hl		;get address of fcb to update in directory.
EC12: C1      		pop	bc		;set (c) to number of bytes to change.
EC13: CD55E7  		call	de2hl
EC16: CDC9E7  	update1:call	trksec		;determine the track and sector affected.
EC19: C3CCE9  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
EC1C: CD5AE9  	chgnames: call	chkwprt		;check for a write protected disk.
EC1F: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
EC21: CD1EEB  		call	findfst		;get first name.
EC24: 2A49E7  		ld	hl,(params)	;get address of fcb.
EC27: 7E      		ld	a,(hl)		;get user number.
EC28: 111000  		ld	de,16		;move over to desired name.
EC2B: 19      		add	hl,de
EC2C: 77      		ld	(hl),a		;keep same user number.
EC2D: CDFBE9  	chgnam1:call	ckfilpos	;any matching file found?
EC30: C8      		ret	z		;no, we must be done.
EC31: CD4AE9  		call	chkrofl		;check for read only file.
EC34: 0E10    		ld	c,16		;start 16 bytes into fcb.
EC36: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
EC38: CD07EC  		call	update
EC3B: CD33EB  		call	findnxt		;get te next file name.
EC3E: C32DEC  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
EC41: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
EC43: CD1EEB  		call	findfst		;look for first filename.
EC46: CDFBE9  	savatr1:call	ckfilpos	;was one found?
EC49: C8      		ret	z		;nope, we must be done.
EC4A: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
EC4C: 1E0C    		ld	e,12
EC4E: CD07EC  		call	update		;update filename and write directory.
EC51: CD33EB  		call	findnxt		;and get the next file.
EC54: C346EC  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
EC57: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
EC59: CD1EEB  		call	findfst		;get the first one in directory.
EC5C: CDFBE9  		call	ckfilpos	;any at all?
EC5F: C8      		ret	z
EC60: CDACE8  	openit1:call	setext		;point to extent byte within users fcb.
EC63: 7E      		ld	a,(hl)		;and get it.
EC64: F5      		push	af		;save it and address.
EC65: E5      		push	hl
EC66: CD64E9  		call	fcb2hl		;point to fcb in directory.
EC69: EB      		ex	de,hl
EC6A: 2A49E7  		ld	hl,(params)	;this is the users copy.
EC6D: 0E20    		ld	c,32		;move it into users space.
EC6F: D5      		push	de
EC70: CD55E7  		call	de2hl
EC73: CD7EE9  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
EC76: D1      		pop	de		;now get the extent byte from this fcb.
EC77: 210C00  		ld	hl,12
EC7A: 19      		add	hl,de
EC7B: 4E      		ld	c,(hl)		;into (c).
EC7C: 210F00  		ld	hl,15		;now get the record count byte into (b).
EC7F: 19      		add	hl,de
EC80: 46      		ld	b,(hl)
EC81: E1      		pop	hl		;keep the same extent as the user had originally.
EC82: F1      		pop	af
EC83: 77      		ld	(hl),a
EC84: 79      		ld	a,c		;is it the same as in the directory fcb?
EC85: BE      		cp	(hl)
EC86: 78      		ld	a,b		;if yes, then use the same record count.
EC87: CA91EC  		jp	z,openit2
EC8A: 3E00    		ld	a,0		;if the user specified an extent greater than
EC8C: DA91EC  		jp	c,openit2	;the one in the directory, then set record count to 0.
EC8F: 3E80    		ld	a,128		;otherwise set to maximum.
EC91: 2A49E7  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
EC94: 110F00  		ld	de,15
EC97: 19      		add	hl,de		;compute relative position.
EC98: 77      		ld	(hl),a		;and set the record count.
EC99: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
EC9A: 7E      	moveword: ld	a,(hl)		;check for a zero word.
EC9B: 23      		inc	hl
EC9C: B6      		or	(hl)		;both bytes zero?
EC9D: 2B      		dec	hl
EC9E: C0      		ret	nz		;nope, just return.
EC9F: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
ECA0: 77      		ld	(hl),a		;this zero space.
ECA1: 13      		inc	de
ECA2: 23      		inc	hl
ECA3: 1A      		ld	a,(de)
ECA4: 77      		ld	(hl),a
ECA5: 1B      		dec	de		;don't disturb these registers.
ECA6: 2B      		dec	hl
ECA7: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
ECA8: AF      	closeit:xor	a		;clear status and file position bytes.
ECA9: 324BE7  		ld	(status),a
ECAC: 32F0F1  		ld	(filepos),a
ECAF: 32F1F1  		ld	(filepos+1),a
ECB2: CD24E9  		call	getwprt		;get write protect bit for this drive.
ECB5: C0      		ret	nz		;just return if it is set.
ECB6: CD6FE9  		call	gets2		;else get the 's2' byte.
ECB9: E680    		and	80h		;and look at bit 7 (file unmodified?).
ECBB: C0      		ret	nz		;just return if set.
ECBC: 0E0F    		ld	c,15		;else look up this file in directory.
ECBE: CD1EEB  		call	findfst
ECC1: CDFBE9  		call	ckfilpos	;was it found?
ECC4: C8      		ret	z		;just return if not.
ECC5: 011000  		ld	bc,16		;set (hl) pointing to records used section.
ECC8: CD64E9  		call	fcb2hl
ECCB: 09      		add	hl,bc
ECCC: EB      		ex	de,hl
ECCD: 2A49E7  		ld	hl,(params)	;do the same for users specified fcb.
ECD0: 09      		add	hl,bc
ECD1: 0E10    		ld	c,16		;this many bytes are present in this extent.
ECD3: 3AE3F1  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
ECD6: B7      		or	a
ECD7: CAEEEC  		jp	z,closeit4
ECDA: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
ECDB: B7      		or	a
ECDC: 1A      		ld	a,(de)		;now get one from directory fcb.
ECDD: C2E1EC  		jp	nz,closeit2
ECE0: 77      		ld	(hl),a		;users byte was zero. update from directory.
ECE1: B7      	closeit2: or	a
ECE2: C2E7EC  		jp	nz,closeit3
ECE5: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
ECE6: 12      		ld	(de),a
ECE7: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
ECE8: C225ED  		jp	nz,closeit7	;then close error if they are not the same.
ECEB: C303ED  		jp	closeit5	;ok so far, get to next byte in fcbs.
ECEE: CD9AEC  	closeit4: call	moveword	;update users fcb if it is zero.
ECF1: EB      		ex	de,hl
ECF2: CD9AEC  		call	moveword	;update directories fcb if it is zero.
ECF5: EB      		ex	de,hl
ECF6: 1A      		ld	a,(de)		;if these two values are no different,
ECF7: BE      		cp	(hl)		;then a close error occured.
ECF8: C225ED  		jp	nz,closeit7
ECFB: 13      		inc	de		;check second byte.
ECFC: 23      		inc	hl
ECFD: 1A      		ld	a,(de)
ECFE: BE      		cp	(hl)
ECFF: C225ED  		jp	nz,closeit7
ED02: 0D      		dec	c		;remember 16 bit values.
ED03: 13      	closeit5: inc	de		;bump to next item in table.
ED04: 23      		inc	hl
ED05: 0D      		dec	c		;there are 16 entries only.
ED06: C2D3EC  		jp	nz,closeit1	;continue if more to do.
ED09: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
ED0C: 09      		add	hl,bc
ED0D: EB      		ex	de,hl
ED0E: 09      		add	hl,bc
ED0F: 1A      		ld	a,(de)
ED10: BE      		cp	(hl)		;directory's extent already greater than the
ED11: DA1DED  		jp	c,closeit6	;users extent?
ED14: 77      		ld	(hl),a		;no, update directory extent.
ED15: 010300  		ld	bc,3		;and update the record count byte in
ED18: 09      		add	hl,bc		;directories fcb.
ED19: EB      		ex	de,hl
ED1A: 09      		add	hl,bc
ED1B: 7E      		ld	a,(hl)		;get from user.
ED1C: 12      		ld	(de),a		;and put in directory.
ED1D: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
ED1F: 32D8F1  		ld	(closeflg),a
ED22: C316EC  		jp	update1		;update the directory now.
ED25: 214BE7  	closeit7: ld	hl,status	;set return status and then return.
ED28: 35      		dec	(hl)
ED29: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
ED2A: CD5AE9  	getempty: call	chkwprt		;make sure disk is not write protected.
ED2D: 2A49E7  		ld	hl,(params)	;save current parameters (fcb).
ED30: E5      		push	hl
ED31: 21B2F1  		ld	hl,emptyfcb	;use special one for empty space.
ED34: 2249E7  		ld	(params),hl
ED37: 0E01    		ld	c,1		;search for first empty spot in directory.
ED39: CD1EEB  		call	findfst		;(* only check first byte *)
ED3C: CDFBE9  		call	ckfilpos	;none?
ED3F: E1      		pop	hl
ED40: 2249E7  		ld	(params),hl	;restore original fcb address.
ED43: C8      		ret	z		;return if no more space.
ED44: EB      		ex	de,hl
ED45: 210F00  		ld	hl,15		;point to number of records for this file.
ED48: 19      		add	hl,de
ED49: 0E11    		ld	c,17		;and clear all of this space.
ED4B: AF      		xor	a
ED4C: 77      	getmt1:	ld	(hl),a
ED4D: 23      		inc	hl
ED4E: 0D      		dec	c
ED4F: C24CED  		jp	nz,getmt1
ED52: 210D00  		ld	hl,13		;clear the 's1' byte also.
ED55: 19      		add	hl,de
ED56: 77      		ld	(hl),a
ED57: CD92E9  		call	chknmbr		;keep (scratch1) within bounds.
ED5A: CD03EC  		call	fcbset		;write out this fcb entry to directory.
ED5D: C37EE9  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
ED60: AF      	getnext:xor	a
ED61: 32D8F1  		ld	(closeflg),a	;clear close flag.
ED64: CDA8EC  		call	closeit		;close this extent.
ED67: CDFBE9  		call	ckfilpos
ED6A: C8      		ret	z		;not there???
ED6B: 2A49E7  		ld	hl,(params)	;get extent byte.
ED6E: 010C00  		ld	bc,12
ED71: 09      		add	hl,bc
ED72: 7E      		ld	a,(hl)		;and increment it.
ED73: 3C      		inc	a
ED74: E61F    		and	1fh		;keep within range 0-31.
ED76: 77      		ld	(hl),a
ED77: CA89ED  		jp	z,gtnext1	;overflow?
ED7A: 47      		ld	b,a		;mask extent byte.
ED7B: 3ACBF1  		ld	a,(extmask)
ED7E: A0      		and	b
ED7F: 21D8F1  		ld	hl,closeflg	;check close flag (0ffh is ok).
ED82: A6      		and	(hl)
ED83: CA94ED  		jp	z,gtnext2	;if zero, we must read in next extent.
ED86: C3B2ED  		jp	gtnext3		;else, it is already in memory.
ED89: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
ED8C: 09      		add	hl,bc
ED8D: 34      		inc	(hl)		;and bump it.
ED8E: 7E      		ld	a,(hl)		;too many extents?
ED8F: E60F    		and	0fh
ED91: CABCED  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
ED94: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
ED96: CD1EEB  		call	findfst		;find the first one.
ED99: CDFBE9  		call	ckfilpos	;none available?
ED9C: C2B2ED  		jp	nz,gtnext3
ED9F: 3AD9F1  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
EDA2: 3C      		inc	a		;0ffh means reading (so not possible).
EDA3: CABCED  		jp	z,gtnext5	;or an error.
EDA6: CD2AED  		call	getempty	;we are writing, get an empty entry.
EDA9: CDFBE9  		call	ckfilpos	;none?
EDAC: CABCED  		jp	z,gtnext5	;error if true.
EDAF: C3B5ED  		jp	gtnext4		;else we are almost done.
EDB2: CD60EC  	gtnext3:call	openit1		;open this extent.
EDB5: CDC1E8  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
EDB8: AF      		xor	a		;clear status and return.
EDB9: C307E7  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
EDBC: CD0BE7  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
EDBF: C37EE9  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
EDC2: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
EDC4: 32DBF1  		ld	(mode),a
EDC7: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
EDC9: 32D9F1  		ld	(rdwrtflg),a
EDCC: CDC1E8  		call	strdata		;put rec# and ext# into fcb.
EDCF: 3AE9F1  		ld	a,(savnrec)	;get next record to read.
EDD2: 21E7F1  		ld	hl,savnxt	;get number of records in extent.
EDD5: BE      		cp	(hl)		;within this extent?
EDD6: DAECED  		jp	c,rdseq2
EDD9: FE80    		cp	128		;no. is this extent fully used?
EDDB: C201EE  		jp	nz,rdseq3	;no. end-of-file.
EDDE: CD60ED  		call	getnext		;yes, open the next one.
EDE1: AF      		xor	a		;reset next record to read.
EDE2: 32E9F1  		ld	(savnrec),a
EDE5: 3A4BE7  		ld	a,(status)	;check on open, successful?
EDE8: B7      		or	a
EDE9: C201EE  		jp	nz,rdseq3	;no, error.
EDEC: CD7DE8  	rdseq2:	call	comblk		;ok. compute block number to read.
EDEF: CD8AE8  		call	chkblk		;check it. within bounds?
EDF2: CA01EE  		jp	z,rdseq3	;no, error.
EDF5: CD90E8  		call	logical		;convert (blknmbr) to logical sector (128 byte).
EDF8: CDD7E7  		call	trksec1		;set the track and sector for this block #.
EDFB: CDB8E7  		call	doread		;and read it.
EDFE: C3D8E8  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EE01: C30BE7  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EE04: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EE06: 32DBF1  		ld	(mode),a
EE09: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EE0B: 32D9F1  		ld	(rdwrtflg),a
EE0E: CD5AE9  		call	chkwprt		;check write protect status.
EE11: 2A49E7  		ld	hl,(params)
EE14: CD4DE9  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EE17: CDC1E8  		call	strdata		;put updated data into fcb.
EE1A: 3AE9F1  		ld	a,(savnrec)	;get record number to write.
EE1D: FE80    		cp	128		;within range?
EE1F: D20BE7  		jp	nc,ioerr1	;no, error(?).
EE22: CD7DE8  		call	comblk		;compute block number.
EE25: CD8AE8  		call	chkblk		;check number.
EE28: 0E00    		ld	c,0		;is there one to write to?
EE2A: C274EE  		jp	nz,wtseq6	;yes, go do it.
EE2D: CD44E8  		call	getblock	;get next block number within fcb to use.
EE30: 32DDF1  		ld	(relblock),a	;and save.
EE33: 010000  		ld	bc,0		;start looking for space from the start
EE36: B7      		or	a		;if none allocated as yet.
EE37: CA41EE  		jp	z,wtseq2
EE3A: 4F      		ld	c,a		;extract previous block number from fcb
EE3B: 0B      		dec	bc		;so we can be closest to it.
EE3C: CD64E8  		call	extblk
EE3F: 44      		ld	b,h
EE40: 4D      		ld	c,l
EE41: CDC4EB  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EE44: 7D      		ld	a,l		;check for a zero number.
EE45: B4      		or	h
EE46: C24EEE  		jp	nz,wtseq3
EE49: 3E02    		ld	a,2		;no more space?
EE4B: C307E7  		jp	setstat
EE4E: 22EBF1  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EE51: EB      		ex	de,hl		;put block number into (de).
EE52: 2A49E7  		ld	hl,(params)	;now we must update the fcb for this
EE55: 011000  		ld	bc,16		;newly allocated block.
EE58: 09      		add	hl,bc
EE59: 3AE3F1  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EE5C: B7      		or	a
EE5D: 3ADDF1  		ld	a,(relblock)	;(* update this entry *)
EE60: CA6AEE  		jp	z,wtseq4	;zero means 16 bit ones.
EE63: CD6AE9  		call	adda2hl		;(hl)=(hl)+(a)
EE66: 73      		ld	(hl),e		;store new block number.
EE67: C372EE  		jp	wtseq5
EE6A: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EE6B: 0600    		ld	b,0
EE6D: 09      		add	hl,bc
EE6E: 09      		add	hl,bc
EE6F: 73      		ld	(hl),e		;stuff block number (de) there.
EE70: 23      		inc	hl
EE71: 72      		ld	(hl),d
EE72: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EE74: 3A4BE7  	wtseq6:	ld	a,(status)	;are we ok so far?
EE77: B7      		or	a
EE78: C0      		ret	nz
EE79: C5      		push	bc		;yes, save write flag for bios (register c).
EE7A: CD90E8  		call	logical		;convert (blknmbr) over to loical sectors.
EE7D: 3ADBF1  		ld	a,(mode)	;get access mode flag (1=sequential,
EE80: 3D      		dec	a		;0=random, 2=special?).
EE81: 3D      		dec	a
EE82: C2C1EE  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EE85: C1      		pop	bc
EE86: C5      		push	bc
EE87: 79      		ld	a,c		;get write status flag (2=writing unused space).
EE88: 3D      		dec	a
EE89: 3D      		dec	a
EE8A: C2C1EE  		jp	nz,wtseq9
EE8D: E5      		push	hl
EE8E: 2ABFF1  		ld	hl,(dirbuf)	;zero out the directory buffer.
EE91: 57      		ld	d,a		;note that (a) is zero here.
EE92: 77      	wtseq7:	ld	(hl),a
EE93: 23      		inc	hl
EE94: 14      		inc	d		;do 128 bytes.
EE95: F292EE  		jp	p,wtseq7
EE98: CDE6E9  		call	dirdma		;tell the bios the dma address for directory access.
EE9B: 2AEDF1  		ld	hl,(logsect)	;get sector that starts current block.
EE9E: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EEA0: 22EBF1  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EEA3: C5      		push	bc
EEA4: CDD7E7  		call	trksec1		;determine its track and sector numbers.
EEA7: C1      		pop	bc
EEA8: CDBEE7  		call	dowrite		;now write out 128 bytes of zeros.
EEAB: 2AEBF1  		ld	hl,(blknmbr)	;get sector number.
EEAE: 0E00    		ld	c,0		;set normal write flag.
EEB0: 3ACAF1  		ld	a,(blkmask)	;determine if we have written the entire
EEB3: 47      		ld	b,a		;physical block.
EEB4: A5      		and	l
EEB5: B8      		cp	b
EEB6: 23      		inc	hl		;prepare for the next one.
EEB7: C2A0EE  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EEBA: E1      		pop	hl		;reset next sector number.
EEBB: 22EBF1  		ld	(blknmbr),hl
EEBE: CDE0E9  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EEC1: CDD7E7  	wtseq9:	call	trksec1		;determine track and sector for this write.
EEC4: C1      		pop	bc		;get write status flag.
EEC5: C5      		push	bc
EEC6: CDBEE7  		call	dowrite		;and write this out.
EEC9: C1      		pop	bc
EECA: 3AE9F1  		ld	a,(savnrec)	;get number of records in file.
EECD: 21E7F1  		ld	hl,savnxt	;get last record written.
EED0: BE      		cp	(hl)
EED1: DAD8EE  		jp	c,wtseq10
EED4: 77      		ld	(hl),a		;we have to update record count.
EED5: 34      		inc	(hl)
EED6: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EED8: 00      	wtseq10:nop			;was 'dcr c'
EED9: 00      		nop			;was 'dcr c'
EEDA: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EEDD: F5      		push	af
EEDE: CD6FE9  		call	gets2		;set 'extent written to' flag.
EEE1: E67F    		and	7fh		;(* clear bit 7 *)
EEE3: 77      		ld	(hl),a
EEE4: F1      		pop	af		;get record count for this extent.
EEE5: FE7F    	wtseq99:cp	127		;is it full?
EEE7: C206EF  		jp	nz,wtseq12
EEEA: 3ADBF1  		ld	a,(mode)	;yes, are we in sequential mode?
EEED: FE01    		cp	1
EEEF: C206EF  		jp	nz,wtseq12
EEF2: CDD8E8  		call	setnrec		;yes, set next record number.
EEF5: CD60ED  		call	getnext		;and get next empty space in directory.
EEF8: 214BE7  		ld	hl,status	;ok?
EEFB: 7E      		ld	a,(hl)
EEFC: B7      		or	a
EEFD: C204EF  		jp	nz,wtseq11
EF00: 3D      		dec	a		;yes, set record count to -1.
EF01: 32E9F1  		ld	(savnrec),a
EF04: 3600    	wtseq11:ld	(hl),0		;clear status.
EF06: C3D8E8  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EF09: AF      	position: xor	a		;set random i/o flag.
EF0A: 32DBF1  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EF0D: C5      	positn1:push	bc		;save read/write flag.
EF0E: 2A49E7  		ld	hl,(params)	;get address of fcb.
EF11: EB      		ex	de,hl
EF12: 212100  		ld	hl,33		;now get byte 'r0'.
EF15: 19      		add	hl,de
EF16: 7E      		ld	a,(hl)
EF17: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EF19: F5      		push	af
EF1A: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF1B: 17      		rla	
EF1C: 23      		inc	hl
EF1D: 7E      		ld	a,(hl)
EF1E: 17      		rla	
EF1F: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EF21: 4F      		ld	c,a		;this is the extent byte.
EF22: 7E      		ld	a,(hl)		;now get the extra extent byte.
EF23: 1F      		rra	
EF24: 1F      		rra	
EF25: 1F      		rra	
EF26: 1F      		rra	
EF27: E60F    		and	0fh
EF29: 47      		ld	b,a		;and save it in (b).
EF2A: F1      		pop	af		;get record number back to (a).
EF2B: 23      		inc	hl		;check overflow byte 'r2'.
EF2C: 6E      		ld	l,(hl)
EF2D: 2C      		inc	l
EF2E: 2D      		dec	l
EF2F: 2E06    		ld	l,6		;prepare for error.
EF31: C291EF  		jp	nz,positn5	;out of disk space error.
EF34: 212000  		ld	hl,32		;store record number into fcb.
EF37: 19      		add	hl,de
EF38: 77      		ld	(hl),a
EF39: 210C00  		ld	hl,12		;and now check the extent byte.
EF3C: 19      		add	hl,de
EF3D: 79      		ld	a,c
EF3E: 96      		sub	(hl)		;same extent as before?
EF3F: C24DEF  		jp	nz,positn2
EF42: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EF45: 19      		add	hl,de
EF46: 78      		ld	a,b
EF47: 96      		sub	(hl)
EF48: E67F    		and	7fh
EF4A: CA85EF  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EF4D: C5      	positn2:push	bc
EF4E: D5      		push	de
EF4F: CDA8EC  		call	closeit		;close current extent.
EF52: D1      		pop	de
EF53: C1      		pop	bc
EF54: 2E03    		ld	l,3		;prepare for error.
EF56: 3A4BE7  		ld	a,(status)
EF59: 3C      		inc	a
EF5A: CA8AEF  		jp	z,positn4	;close error.
EF5D: 210C00  		ld	hl,12		;put desired extent into fcb now.
EF60: 19      		add	hl,de
EF61: 71      		ld	(hl),c
EF62: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EF65: 19      		add	hl,de
EF66: 70      		ld	(hl),b
EF67: CD57EC  		call	openit		;try and get this extent.
EF6A: 3A4BE7  		ld	a,(status)	;was it there?
EF6D: 3C      		inc	a
EF6E: C285EF  		jp	nz,positn3
EF71: C1      		pop	bc		;no. can we create a new one (writing?).
EF72: C5      		push	bc
EF73: 2E04    		ld	l,4		;prepare for error.
EF75: 0C      		inc	c
EF76: CA8AEF  		jp	z,positn4	;nope, reading unwritten space error.
EF79: CD2AED  		call	getempty	;yes we can, try to find space.
EF7C: 2E05    		ld	l,5		;prepare for error.
EF7E: 3A4BE7  		ld	a,(status)
EF81: 3C      		inc	a
EF82: CA8AEF  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EF85: C1      	positn3:pop	bc		;restore stack.
EF86: AF      		xor	a		;and clear error code byte.
EF87: C307E7  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EF8A: E5      	positn4:push	hl
EF8B: CD6FE9  		call	gets2
EF8E: 36C0    		ld	(hl),0c0h
EF90: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EF91: C1      	positn5:pop	bc
EF92: 7D      		ld	a,l		;get error code.
EF93: 324BE7  		ld	(status),a
EF96: C37EE9  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EF99: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EF9B: CD09EF  		call	position	;position the file to proper record.
EF9E: CCC7ED  		call	z,rdseq1	;and read it as usual (if no errors).
EFA1: C9      		ret	
              	;
              	;   write to a random record.
              	;
EFA2: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EFA4: CD09EF  		call	position	;position the file to proper record.
EFA7: CC09EE  		call	z,wtseq1	;and write as usual (if no errors).
EFAA: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EFAB: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EFAC: 19      		add	hl,de		;compute relative position of record #.
EFAD: 4E      		ld	c,(hl)		;get record number into (bc).
EFAE: 0600    		ld	b,0
EFB0: 210C00  		ld	hl,12		;now get extent.
EFB3: 19      		add	hl,de
EFB4: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EFB5: 0F      		rrca			;move lower bit into bit 7.
EFB6: E680    		and	80h		;and ignore all other bits.
EFB8: 81      		add	a,c		;add to our record number.
EFB9: 4F      		ld	c,a
EFBA: 3E00    		ld	a,0		;take care of any carry.
EFBC: 88      		adc	a,b
EFBD: 47      		ld	b,a
EFBE: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EFBF: 0F      		rrca			;bit positions 0-3.
EFC0: E60F    		and	0fh		;and ignore all others.
EFC2: 80      		add	a,b		;add this in to 'r1' byte.
EFC3: 47      		ld	b,a
EFC4: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EFC7: 19      		add	hl,de
EFC8: 7E      		ld	a,(hl)
EFC9: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EFCA: 87      		add	a,a
EFCB: 87      		add	a,a
EFCC: 87      		add	a,a
EFCD: F5      		push	af		;save carry flag (bit 0 of flag byte).
EFCE: 80      		add	a,b		;now add extra extent into 'r1'.
EFCF: 47      		ld	b,a
EFD0: F5      		push	af		;and save carry (overflow byte 'r2').
EFD1: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EFD2: 7D      		ld	a,l
EFD3: E1      		pop	hl		;and same for first carry flag.
EFD4: B5      		or	l		;either one of these set?
EFD5: E601    		and	01h		;only check the carry flags.
EFD7: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EFD8: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EFDA: CD1EEB  		call	findfst		;this name.
EFDD: 2A49E7  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EFE0: 112100  		ld	de,33
EFE3: 19      		add	hl,de
EFE4: E5      		push	hl
EFE5: 72      		ld	(hl),d		;note that (d)=0.
EFE6: 23      		inc	hl
EFE7: 72      		ld	(hl),d
EFE8: 23      		inc	hl
EFE9: 72      		ld	(hl),d
EFEA: CDFBE9  	ransiz1:call	ckfilpos	;is there an extent to process?
EFED: CA12F0  		jp	z,ransiz3	;no, we are done.
EFF0: CD64E9  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EFF3: 110F00  		ld	de,15		;point to last record in extent.
EFF6: CDABEF  		call	comprand	;and compute random parameters.
EFF9: E1      		pop	hl
EFFA: E5      		push	hl		;now check these values against those
EFFB: 5F      		ld	e,a		;already in fcb.
EFFC: 79      		ld	a,c		;the carry flag will be set if those
EFFD: 96      		sub	(hl)		;in the fcb represent a larger size than
EFFE: 23      		inc	hl		;this extent does.
EFFF: 78      		ld	a,b
F000: 9E      		sbc	a,(hl)
F001: 23      		inc	hl
F002: 7B      		ld	a,e
F003: 9E      		sbc	a,(hl)
F004: DA0CF0  		jp	c,ransiz2
F007: 73      		ld	(hl),e		;we found a larger (in size) extent.
F008: 2B      		dec	hl		;stuff these values into fcb.
F009: 70      		ld	(hl),b
F00A: 2B      		dec	hl
F00B: 71      		ld	(hl),c
F00C: CD33EB  	ransiz2:call	findnxt		;now get the next extent.
F00F: C3EAEF  		jp	ransiz1		;continue til all done.
F012: E1      	ransiz3:pop	hl		;we are done, restore the stack and
F013: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F014: 2A49E7  	setran:	ld	hl,(params)	;point to fcb.
F017: 112000  		ld	de,32		;and to last used record.
F01A: CDABEF  		call	comprand	;compute random position.
F01D: 212100  		ld	hl,33		;now stuff these values into fcb.
F020: 19      		add	hl,de
F021: 71      		ld	(hl),c		;move 'r0'.
F022: 23      		inc	hl
F023: 70      		ld	(hl),b		;and 'r1'.
F024: 23      		inc	hl
F025: 77      		ld	(hl),a		;and lastly 'r2'.
F026: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F027: 2AB5F1  	logindrv: ld	hl,(login)	;get the login vector.
F02A: 3A48E7  		ld	a,(active)	;get the default drive.
F02D: 4F      		ld	c,a
F02E: CDF0E8  		call	shiftr		;position active bit for this drive
F031: E5      		push	hl		;into bit 0.
F032: EB      		ex	de,hl
F033: CD5FE7  		call	select		;select this drive.
F036: E1      		pop	hl
F037: CC4DE7  		call	z,slcterr	;valid drive?
F03A: 7D      		ld	a,l		;is this a newly activated drive?
F03B: 1F      		rra	
F03C: D8      		ret	c
F03D: 2AB5F1  		ld	hl,(login)	;yes, update the login vector.
F040: 4D      		ld	c,l
F041: 44      		ld	b,h
F042: CD11E9  		call	setbit
F045: 22B5F1  		ld	(login),hl	;and save.
F048: C3A9EA  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
F04B: 3ADCF1  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
F04E: 2148E7  		ld	hl,active	;represents a change in drives.
F051: BE      		cp	(hl)
F052: C8      		ret	z
F053: 77      		ld	(hl),a		;yes it does, log it in.
F054: C327F0  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
F057: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
F059: 32E4F1  		ld	(auto),a
F05C: 2A49E7  		ld	hl,(params)	;get drive specified.
F05F: 7E      		ld	a,(hl)
F060: E61F    		and	1fh		;look at lower 5 bits.
F062: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
F063: 32DCF1  		ld	(eparam),a	;and save for the select routine.
F066: FE1E    		cp	1eh		;check for 'no change' condition.
F068: D27BF0  		jp	nc,autosl1	;yes, don't change.
F06B: 3A48E7  		ld	a,(active)	;we must change, save currently active
F06E: 32E5F1  		ld	(olddrv),a	;drive.
F071: 7E      		ld	a,(hl)		;and save first byte of fcb also.
F072: 32E6F1  		ld	(autoflag),a	;this must be non-zero.
F075: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
F077: 77      		ld	(hl),a		;something)?
F078: CD4BF0  		call	setdsk		;select and log in this drive.
F07B: 3A47E7  	autosl1:ld	a,(userno)	;move user number into fcb.
F07E: 2A49E7  		ld	hl,(params)	;(* upper half of first byte *)
F081: B6      		or	(hl)
F082: 77      		ld	(hl),a
F083: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
F084: 3E22    	getver:	ld	a,022h		;version 2.2
F086: C307E7  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
F089: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
F08C: 22B3F1  		ld	(wrtprt),hl	;in vector.
F08F: 22B5F1  		ld	(login),hl
F092: AF      		xor	a		;select drive 'a'.
F093: 3248E7  		ld	(active),a
F096: 218000  		ld	hl,tbuff	;setup default dma address.
F099: 22B7F1  		ld	(userdma),hl
F09C: CDE0E9  		call	defdma
F09F: C327F0  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
F0A2: CD78E9  	openfil:call	clears2		;clear 's2' byte.
F0A5: CD57F0  		call	autosel		;select proper disk.
F0A8: C357EC  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
F0AB: CD57F0  	closefil: call	autosel		;select proper disk.
F0AE: C3A8EC  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F0B1: 0E00    	getfst:	ld	c,0		;prepare for special search.
F0B3: EB      		ex	de,hl
F0B4: 7E      		ld	a,(hl)		;is first byte a '?'?
F0B5: FE3F    		cp	'?'
F0B7: CAC8F0  		jp	z,getfst1	;yes, just get very first entry (zero length match).
F0BA: CDACE8  		call	setext		;get the extension byte from fcb.
F0BD: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
F0BE: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
F0C0: C478E9  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
F0C3: CD57F0  		call	autosel		;select proper drive.
F0C6: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
F0C8: CD1EEB  	getfst1:call	findfst		;find an entry and then move it into
F0CB: C3EFE9  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
F0CE: 2ADFF1  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
F0D1: 2249E7  		ld	(params),hl	;other dbos calls are allowed.
F0D4: CD57F0  		call	autosel		;no error will be returned, but the
F0D7: CD33EB  		call	findnxt		;results will be wrong.
F0DA: C3EFE9  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
F0DD: CD57F0  	delfile:call	autosel		;select proper drive.
F0E0: CDA2EB  		call	erafile		;erase the file.
F0E3: C307EB  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
F0E6: CD57F0  	readseq:call	autosel		;select proper drive then read.
F0E9: C3C2ED  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
F0EC: CD57F0  	wrtseq:	call	autosel		;select proper drive then write.
F0EF: C304EE  		jp	wtseq
              	;
              	;   create a file function.
              	;
F0F2: CD78E9  	fcreate:call	clears2		;clear the 's2' byte on all creates.
F0F5: CD57F0  		call	autosel		;select proper drive and get the next
F0F8: C32AED  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
F0FB: CD57F0  	renfile:call	autosel		;select proper drive and then switch
F0FE: CD1CEC  		call	chgnames	;file names.
F101: C307EB  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
F104: 2AB5F1  	getlog:	ld	hl,(login)
F107: C32FF1  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
F10A: 3A48E7  	getcrnt:ld	a,(active)
F10D: C307E7  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
F110: EB      	putdma:	ex	de,hl
F111: 22B7F1  		ld	(userdma),hl	;save in our space and then get to
F114: C3E0E9  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
F117: 2AC5F1  	getaloc:ld	hl,(alocvect)
F11A: C32FF1  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
F11D: 2AB3F1  	getrov:	ld	hl,(wrtprt)
F120: C32FF1  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
F123: CD57F0  	setattr:call	autosel		;select proper drive then save attributes.
F126: CD41EC  		call	saveattr
F129: C307EB  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
F12C: 2AC1F1  	getparm:ld	hl,(diskpb)
F12F: 224BE7  	getprm1:ld	(status),hl
F132: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
F133: 3ADCF1  	getuser:ld	a,(eparam)	;get parameter.
F136: FEFF    		cp	0ffh		;get user number?
F138: C241F1  		jp	nz,setuser
F13B: 3A47E7  		ld	a,(userno)	;yes, just do it.
F13E: C307E7  		jp	setstat
F141: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
F143: 3247E7  		ld	(userno),a	;bits (0-4) only.
F146: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
F147: CD57F0  	rdrandom: call	autosel		;select proper drive and read.
F14A: C399EF  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
F14D: CD57F0  	wtrandom: call	autosel		;select proper drive and write.
F150: C3A2EF  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
F153: CD57F0  	filesize: call	autosel		;select proper drive and check file length
F156: C3D8EF  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
F159: 2A49E7  	logoff:	ld	hl,(params)	;get drives to log off.
F15C: 7D      		ld	a,l		;for each bit that is set, we want
F15D: 2F      		cpl			;to clear that bit in (login)
F15E: 5F      		ld	e,a		;and (wrtprt).
F15F: 7C      		ld	a,h
F160: 2F      		cpl	
F161: 2AB5F1  		ld	hl,(login)	;reset the login vector.
F164: A4      		and	h
F165: 57      		ld	d,a
F166: 7D      		ld	a,l
F167: A3      		and	e
F168: 5F      		ld	e,a
F169: 2AB3F1  		ld	hl,(wrtprt)
F16C: EB      		ex	de,hl
F16D: 22B5F1  		ld	(login),hl	;and save.
F170: 7D      		ld	a,l		;now do the write protect vector.
F171: A3      		and	e
F172: 6F      		ld	l,a
F173: 7C      		ld	a,h
F174: A2      		and	d
F175: 67      		ld	h,a
F176: 22B3F1  		ld	(wrtprt),hl	;and save. all done.
F179: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
F17A: 3AE4F1  	goback:	ld	a,(auto)	;was auto select activated?
F17D: B7      		or	a
F17E: CA97F1  		jp	z,goback1
F181: 2A49E7  		ld	hl,(params)	;yes, but was a change made?
F184: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
F186: 3AE6F1  		ld	a,(autoflag)
F189: B7      		or	a
F18A: CA97F1  		jp	z,goback1
F18D: 77      		ld	(hl),a		;yes, reset first byte properly.
F18E: 3AE5F1  		ld	a,(olddrv)	;and get the old drive and select it.
F191: 32DCF1  		ld	(eparam),a
F194: CD4BF0  		call	setdsk
F197: 2A15E7  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
F19A: F9      		ld	sp,hl
F19B: 2A4BE7  		ld	hl,(status)	;get return status.
F19E: 7D      		ld	a,l		;force version 1.4 compatability.
F19F: 44      		ld	b,h
F1A0: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F1A1: CD57F0  	wtspecl:call	autosel		;select proper drive.
F1A4: 3E02    		ld	a,2		;use special write mode.
F1A6: 32DBF1  		ld	(mode),a
F1A9: 0E00    		ld	c,0		;set write indicator.
F1AB: CD0DEF  		call	positn1		;position the file.
F1AE: CC09EE  		call	z,wtseq1	;and write (if no errors).
F1B1: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
F1B2: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
F1B3: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
F1B5: 0000    	login:	defw	0		;drive active word (1 bit per drive).
F1B7: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
F1B9: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
F1BB: 0000    	scratch2: defw	0		;last selected track number.
F1BD: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
F1BF: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
F1C1: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
F1C3: 0000    	chkvect:defw	0		;address of check vector.
F1C5: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
F1C7: 0000    	sectors:defw	0		;sectors per track from bios.
F1C9: 00      	blkshft:defb	0		;block shift.
F1CA: 00      	blkmask:defb	0		;block mask.
F1CB: 00      	extmask:defb	0		;extent mask.
F1CC: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
F1CE: 0000    	dirsize:defw	0		;directory size.
F1D0: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
F1D2: 0000    	alloc1:	defw	0
F1D4: 0000    	offset:	defw	0		;first usable track number.
F1D6: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
F1D8: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
F1D9: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
F1DA: 00      	fndstat:defb	0		;filename found status (0=found first entry).
F1DB: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
F1DC: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
F1DD: 00      	relblock: defb	0		;relative position within fcb of block number written.
F1DE: 00      	counter:defb	0		;byte counter for directory name searches.
F1DF: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
F1E3: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
F1E4: 00      	auto:	defb	0		;if non-zero, then auto select activated.
F1E5: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
F1E6: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
F1E7: 00      	savnxt:	defb	0		;storage for next record number to access.
F1E8: 00      	savext:	defb	0		;storage for extent number of file.
F1E9: 0000    	savnrec:defw	0		;storage for number of records in file.
F1EB: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
F1ED: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
F1EF: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
F1F0: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
F1F2: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F1F6: 00...   	
              		
              	; Small routine to print a decimal 0-19
F202: FE3A    	printdc:cp	':'
F204: DA8CDC  		jp	c,print
F207: D60A    		sub	10
F209: F5      		push	af
F20A: 3E31    		ld	a,'1'
F20C: CD8CDC  		call	print
F20F: F1      		pop	af
F210: 18F0    		jr	printdc
              	
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS. 
              	;*
              	;**************************************************************
              	;
F212: C345F2  		jp	boot
F215: C353F2  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
F218: C3A4F2  		jp	const
F21B: C3AFF2  		jp	conin
F21E: C3BBF2  		jp	conout
F221: C3C7F2  		jp	list
F224: C3CBF2  		jp	punch
F227: C3CFF2  		jp	reader
F22A: C3DDF2  		jp	home
F22D: C3E2F2  		jp	seldsk
F230: C300F3  		jp	settrk
F233: C304F3  		jp	setsec
F236: C308F3  		jp	setdma
F239: C30EF3  		jp	read
F23C: C312F3  		jp	write
F23F: C316F3  		jp	prstat
F242: C319F3  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
F245: 3100DC  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
F248: CD66F2  		call	wbootr
              		
              		; Special conditions for a cold boot
F24B: CD64F3  		call	cbinit
              	
              		; Jump to CP/M
F24E: 0E00    		ld	c,0
F250: C300DC  		jp	cbase
              	
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
F253: 3100DC  	wboot:	ld	sp,cbase
              	
              		; Save IOBYTE
F256: 3A0300  		ld	a,(iobyte)
F259: F5      		push	af
              	
              		; Warm boot
F25A: CD66F2  		call	wbootr
              		
              		; Restore IOBYTE
F25D: F1      		pop	af
F25E: 320300  		ld	(iobyte),a
              		
F261: 0E00    		ld	c,0
F263: C300DC  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
F266: F3      	wbootr:	di
              		
              		; Zero out BSS
F267: AF      		xor	a
F268: 21A1F9  		ld	hl,_TEXT_end
F26B: 77      		ld	(hl),a
F26C: 11A2F9  		ld	de,_TEXT_end+1
F26F: 015E06  		ld	bc,0xFFFF-_TEXT_end
F272: EDB0    		ldir
              	
              		; Send init signals to all devices
F274: 0600    		ld	b,0
F276: C5      	wboot0:	push	bc
F277: 2174F3  		ld	hl,bdevsw
F27A: 78      		ld	a,b
F27B: CD2BF3  		call	swindir
F27E: AF      		xor	a
F27F: 14      		inc	d
F280: CC48F3  		call	z,callmj
F283: C1      		pop	bc
F284: 04      		inc	b
F285: 3E14    		ld	a,20
F287: B8      		cp	b
F288: 20EC    		jr	nz,wboot0
              	
              		; Call config init
F28A: CD4DF3  		call	wbinit
              	
              		; Load the CCP
F28D: CD6EF3  		call	resccp
              	
              		
              		; Set up lower memory
F290: 219CF2  		ld	hl,cpmlow
F293: 110000  		ld	de,0
F296: 010800  		ld	bc,8
F299: EDB0    		ldir
              	
              		; Return
F29B: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
F29C: C315F2  	cpmlow:	jp	wbootin	; Call jump table version instead
F29F: 81      		defb	0x81	; Default IOBYTE
F2A0: 00      		defb	0	; Default drive
F2A1: C302E4  		jp	fbase-4	; 4 bytes before BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
F2A4: 0600    	const:	ld	b,0
F2A6: CD1CF3  		call	cdindir
F2A9: 14      		inc	d
F2AA: C0      		ret	nz
F2AB: 3C      		inc	a
F2AC: C348F3  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
F2AF: 0600    	conin:	ld	b,0
F2B1: CD1CF3  		call	cdindir
F2B4: 14      		inc	d
F2B5: C0      		ret	nz
F2B6: 3E02    		ld	a,2
F2B8: C348F3  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
F2BB: 0600    	conout:	ld	b,0
F2BD: CD1CF3  	chrout:	call	cdindir
F2C0: 14      		inc	d
F2C1: C0      		ret	nz
F2C2: 3E03    		ld	a,3
F2C4: C348F3  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
F2C7: 0606    	list:	ld	b,6
F2C9: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
F2CB: 0604    	punch:	ld	b,4
F2CD: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
F2CF: 0602    	reader:	ld	b,2
F2D1: CD1CF3  		call	cdindir
F2D4: 14      		inc	d
F2D5: 3E1A    		ld	a,0x1A
F2D7: C0      		ret	nz
F2D8: 3E02    		ld	a,2
F2DA: C348F3  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
F2DD: 3E01    	home:	ld	a,1
F2DF: C3FAF2  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
F2E2: 79      	seldsk:	ld	a,c
F2E3: 43      		ld	b,e
F2E4: 2174F3  		ld	hl,bdevsw
F2E7: CD2BF3  		call	swindir
F2EA: 22FBF2  		ld	(callbd+1),hl
F2ED: 210000  		ld	hl,0
F2F0: 14      		inc	d
F2F1: C0      		ret	nz
F2F2: 2A49F3  		ld	hl,(callmj+1)
F2F5: 22FEF2  		ld	(callbd+4),hl
F2F8: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
F2FA: 21      	callbd:	defb	0x21
F2FB: 0000    		defw	0
F2FD: C3      		defb	0xC3
F2FE: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
F300: 3E03    	settrk:	ld	a,3
F302: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
F304: 3E04    	setsec:	ld	a,4
F306: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
F308: 60      	setdma:	ld	h,b
F309: 69      		ld	l,c
F30A: 224BF3  		ld	(biodma),hl
F30D: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
F30E: 3E05    	read:	ld	a,5
F310: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
F312: 3E06    	write:	ld	a,6
F314: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
F316: 3EFF    	prstat:	ld	a,0xFF
F318: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
F319: 60      	sectrn:	ld	h,b
F31A: 69      		ld	l,c
F31B: C9      		ret
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
F31C: 04      	cdindir:inc	b
F31D: 3A0300  		ld	a,(iobyte)
F320: 05      	cdindi0:dec	b
F321: 2803    		jr	z,cdindi1
F323: 1F      		rra
F324: 18FA    		jr	cdindi0
F326: E603    	cdindi1:and	0x03
F328: 21B4F3  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
F32B: 110400  	swindir:ld	de,4
F32E: B7      		or	a
F32F: 2804    	swindi0:jr	z,swindi1
F331: 19      		add	hl,de
F332: 3D      		dec	a
F333: 18FA    		jr	swindi0
F335: 7E      	swindi1:ld	a,(hl)
F336: 3249F3  		ld	(callmj+1),a
F339: 23      		inc	hl
F33A: BE      		cp	(hl)
F33B: C8      		ret	z
F33C: 7E      		ld	a,(hl)
F33D: 324AF3  		ld	(callmj+2),a
F340: 23      		inc	hl
F341: 7E      		ld	a,(hl)
F342: 23      		inc	hl
F343: 66      		ld	h,(hl)
F344: 6F      		ld	l,a
F345: 16FF    		ld	d,255
F347: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
F348: C3      	callmj: defb	0xC3
F349: 0000    		defw	0
              	
              	
              	
              	; Variables
F34B: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
F34D: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
F34F: D300    		out	(0x00),a
              		
F351: 3EC3    		ld	a,0xC3		; Set up IRQ handler
F353: 323800  		ld	(0x38),a	
F356: 216AF3  		ld	hl,cfirq
F359: 223900  		ld	(0x39),hl
              		
F35C: 3E0E    		ld	a,0x0E		; Enable clock
              		;out	(0x41),a
F35E: 3E10    		ld	a,0x10
              		;out	(0x40),a
              		
              		
F360: ED56    		im	1		; Start interrupts
F362: F3      		di
F363: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
F364: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
F366: 3207DC  		ld	(inbuff+1),a
F369: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
F36A: FB      	cfirq:	ei
F36B: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
F36D: C9      	syshook:ret
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
F36E: C392F5  	resccp:	jp	nf_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
F371: C38BF5  	resgrb:	jp	nf_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F374: F3F30000	bdevsw:	defw	nfddev,	0	; 'A'
F378: F3F30100		defw	nfddev,	1	; 'B'
F37C: 00000000		defw	0,	0	; 'C'
F380: 00000000		defw	0,	0	; 'D'
F384: 00000000		defw	0,	0	; 'E'
F388: 00000000		defw	0,	0	; 'F'
F38C: 00000000		defw	0,	0	; 'G'
F390: 00000000		defw	0,	0	; 'H'
F394: 00000000		defw	0,	0	; 'I'
F398: 00000000		defw	0,	0	; 'J'
F39C: 00000000		defw	0,	0	; 'K'
F3A0: 00000000		defw	0,	0	; 'L'
F3A4: 00000000		defw	0,	0	; 'M'
F3A8: 00000000		defw	0,	0	; 'N'
F3AC: 00000000		defw	0,	0	; 'O'
F3B0: 00000000		defw	0,	0	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F3B4: 13F90000	cdevsw:	defw	siodev,	0	; TTY device
F3B8: 12F60000		defw	vdpdev,	0	; Console device
F3BC: E9F80000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
F3C0: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	;#data	_BSS,imgtop
              	
              	#include "dev/nabu_fdc.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FA21: 00      	nf_io:	defs	1	; FDC address
FA22: 00      	nf_r2ks:defs	1	; Temp storaged used in nf_r2k
              	
FA23: 00      	nf_curd:defs	1	; Currently selected disk
FA24: 00      	nf_subs:defs	1	; Current subsector
FA25: 00      	nf_sync:defs	1	; Set if disk needs to be rehomed
FA26: 00      	nf_inco:defs	1	; Set if sector is in core already
FA27: 00      	nf_dirt:defs	1	; Set if cache is dirty
              	
FA28: 00000000	nf_asva:defs	26	; Misc CP/M buffer
FA2C: 00...   	
FA42: 00000000	nf_asvb:defs	26
FA46: 00...   	
FA5C: 00000000	nf_csva:defs	15
FA60: 00...   	
FA6B: 00000000	nf_csvb:defs	15
FA6F: 00...   	
              	
FA7A: 00000000	nf_cach:defs	1024	; Sector cache
FA7E: 00...   	
              	.area	_TEXT
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F3C4:         	nf_dpha:
F3C4: 00000000		defw	0,0,0,0
F3C8: 00000000	
F3CC: A1F9    		defw	dircbuf	; DIRBUF
F3CE: E4F3    		defw	nf_dpb	; DPB
F3D0: 5CFA    		defw	nf_csva	; CSV
F3D2: 28FA    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F3D4:         	nf_dphb:
F3D4: 00000000		defw	0,0,0,0
F3D8: 00000000	
F3DC: A1F9    		defw	dircbuf	; DIRBUF
F3DE: E4F3    		defw	nf_dpb	; DPB
F3E0: 6BFA    		defw	nf_csvb	; CSV
F3E2: 42FA    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F3E4:         	nf_dpb:
F3E4: 2800    		defw	40	; # sectors per track
F3E6: 03      		defb	3	; BSH
F3E7: 07      		defb	7	; BLM
F3E8: 00      		defb	0	; EXM
F3E9: B800    		defw	184	; DSM
F3EB: 3F00    		defw	63	; DRM
F3ED: C0      		defb	0xC0	; AL0
F3EE: 00      		defb	0	; AL1
F3EF: 1000    		defw	16	; Size of directory check vector
F3F1: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F3F3: B7      	nfddev:	or	a
F3F4: 2815    		jr	z,nf_init
F3F6: 3D      		dec	a
F3F7: 283D    		jr	z,nf_home
F3F9: 3D      		dec	a
F3FA: 2852    		jr	z,nf_sel
F3FC: 3D      		dec	a
F3FD: CAA2F4  		jp	z,nf_strk
F400: 3D      		dec	a
F401: CAD8F4  		jp	z,nf_ssec
F404: 3D      		dec	a
F405: CA29F5  		jp	z,nf_read
F408: C331F5  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F40B: AF      	nf_init:xor	a
F40C: 3221FA  		ld	(nf_io),a
              	
              		; Look for the FDC
F40F: 0ECF    		ld	c,0xCF
F411: ED78    	nf_ini1:in	a,(c)
F413: FE10    		cp	0x10
F415: 2808    		jr	z,nf_ini2
F417: 0C      		inc	c
F418: C8      		ret	z	; Should not be possible!
F419: 3E0F    		ld	a,0x0F
F41B: 81      		add	a,c
F41C: 4F      		ld	c,a
F41D: 18F2    		jr	nf_ini1
              		
              		; Get command register
F41F: 79      	nf_ini2:ld	a,c
F420: D60F    		sub	15
F422: 4F      		ld	c,a
F423: 3221FA  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F426: CB25    		sla	l
F428: 3E02    		ld	a,2
F42A: 85      		add	l
F42B: 3223FA  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F42E: 3ED0    		ld	a,0xD0
F430: ED79    		out	(c),a
              		
              		; Re-home drive
F432: CD36F4  		call	nf_home
              		
              		; De-select drive
              		
F435: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F436: CD49F5  	nf_home:call	nf_wdef
F439: CDF0F5  		call	nf_dvsc
              	
F43C: 3A21FA  		ld	a,(nf_io)
F43F: 4F      		ld	c,a
              		
              		; Restore to track 0
F440: 3E09    		ld	a,0x09
F442: ED79    		out	(c),a 
F444: CD07F6  		call	nf_busy
              		
              		; Reset sync flag
F447: AF      		xor	a
F448: 3225FA  		ld	(nf_sync),a
              		
              		; De-select drive
F44B: C3F5F5  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F44E: 3A21FA  	nf_sel:	ld	a,(nf_io)
F451: B7      		or	a
F452: FA59F4  		jp	m,nf_seld
              		
              		; no FDC card
F455: 210000  		ld	hl,0
F458: C9      		ret
              	
F459: 7D      	nf_seld:ld	a,l		; Select a disk
F45A: 0602    		ld	b,2
F45C: B7      		or	a
F45D: 2809    		jr	z,nf_sel0
F45F: 3D      		dec	a
F460: 0604    		ld	b,4
F462: 2804    		jr	z,nf_sel0
F464: 210000  		ld	hl,0
F467: C9      		ret
              	
              		; Move control of drive buffers
F468: CD49F5  	nf_sel0:call	nf_wdef		; Write back if needed
F46B: 3EFF    		ld	a,0xFF
F46D: 3225FA  		ld	(nf_sync),a	; Set sync flag
F470: 78      		ld	a,b
F471: 3223FA  		ld	(nf_curd),a	; Set current drive
F474: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F475: 16FF    	nf_selc	ld	d,255
F477: CDF0F5  		call	nf_dvsc
F47A: 3A21FA  		ld	a,(nf_io)
F47D: 4F      		ld	c,a
F47E: 3ED0    		ld	a,0xD0
F480: ED79    		out	(c),a		; Force FDC interrupt
F482: CD0DF6  	nf_sel1:call	nf_stal
F485: ED78    		in	a,(c)
F487: E602    		and	0x02
F489: 2009    		jr	nz,nf_sel2
F48B: 15      		dec	d
F48C: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F48E: 210000  		ld	hl,0
F491: C3F5F5  		jp	nf_udsl
              		
              		
              		; Output DPH
F494: CDF5F5  	nf_sel2:call	nf_udsl
F497: 21C4F3  		ld	hl,nf_dpha
F49A: 3E02    		ld	a,2
F49C: BB      		cp	e
F49D: C8      		ret	z
F49E: 21D4F3  		ld	hl,nf_dphb
F4A1: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F4A2: 51      	nf_strk:ld	d,c		; Track = d
F4A3: 3A21FA  		ld	a,(nf_io)
F4A6: 4F      		ld	c,a
F4A7: 3A25FA  		ld	a,(nf_sync)
F4AA: B7      		or	a
F4AB: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F4AD: CDF0F5  		call	nf_dvsc
              		
              		; Restore to track 0
F4B0: 3E09    		ld	a,0x09
F4B2: ED79    		out	(c),a 
F4B4: CD07F6  		call	nf_busy
              		
              		; Reset sync flag
F4B7: AF      		xor	a
F4B8: 3225FA  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F4BB: 59      	nf_str0:ld	e,c
F4BC: 0C      		inc	c
F4BD: ED78    		in	a,(c)
F4BF: BA      		cp	d
F4C0: CAF5F5  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F4C3: CD49F5  		call	nf_wdef
              	
              		; Seek to track
F4C6: CDF0F5  		call	nf_dvsc
F4C9: 0C      		inc	c
F4CA: 0C      		inc	c
F4CB: ED51    		out	(c),d
F4CD: 3E19    		ld	a,0x19
F4CF: 4B      		ld	c,e
F4D0: ED79    		out	(c),a 
F4D2: CD07F6  		call	nf_busy	
              		
F4D5: C3F5F5  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F4D8: 79      	nf_ssec:ld	a,c
F4D9: E607    		and	0x07
F4DB: 3224FA  		ld	(nf_subs),a
F4DE: 79      		ld	a,c
              		
              		; Compute physical sector
F4DF: CB3F    		srl	a
F4E1: CB3F    		srl	a
F4E3: CB3F    		srl	a
F4E5: 3C      		inc	a
F4E6: 47      		ld	b,a	; b = Physical sector
F4E7: 3A21FA  		ld	a,(nf_io)
F4EA: 3C      		inc	a
F4EB: 3C      		inc	a
F4EC: 4F      		ld	c,a
F4ED: ED78    		in	a,(c)
F4EF: B8      		cp	b
F4F0: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F4F1: CD49F5  		call	nf_wdef
F4F4: ED41    		out	(c),b
F4F6: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F4F7: 3A26FA  	nf_rdwr:ld	a,(nf_inco)
F4FA: B7      		or	a
F4FB: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F4FD: CDF0F5  		call	nf_dvsc
F500: 3A21FA  		ld	a,(nf_io)
F503: 4F      		ld	c,a
F504: 217AFA  		ld	hl,nf_cach
F507: CDD4F5  		call	nf_rphy
F50A: 47      		ld	b,a
F50B: CDF5F5  		call	nf_udsl
F50E: 78      		ld	a,b
              		
              		; Error checking
F50F: B7      		or	a
F510: 3E01    		ld	a,1
F512: C0      		ret	nz
F513: 3226FA  		ld	(nf_inco),a
              		
              		; DMA subsector
F516: 2A4BF3  	nf_rdw0:ld	hl,(biodma)
F519: EB      		ex	de,hl
              	
F51A: 3A24FA  		ld	a,(nf_subs)
F51D: 21FAF9  		ld	hl,nf_cach-128
F520: 018000  		ld	bc,128
F523: 3C      		inc	a
F524: 09      	nf_rdw1:add	hl,bc
F525: 3D      		dec	a
F526: 20FC    		jr	nz,nf_rdw1
F528: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F529: CDF7F4  	nf_read:call	nf_rdwr
F52C: B7      		or	a
F52D: C0      		ret	nz
F52E: EDB0    		ldir
F530: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F531: C5      	nf_writ:push	bc
F532: CDF7F4  		call	nf_rdwr
F535: B7      		or	a
F536: C1      		pop	bc
F537: C0      		ret	nz
F538: 3E01    		ld	a,1
F53A: 3227FA  		ld	(nf_dirt),a
F53D: 79      		ld	a,c
F53E: 018000  		ld	bc,128
F541: EB      		ex	de,hl
F542: EDB0    		ldir
F544: FE01    		cp	1
F546: 3E00    		ld	a,0
F548: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F549: 3A27FA  	nf_wdef:ld	a,(nf_dirt)
F54C: B7      		or	a
F54D: 2837    		jr	z,nf_wde4
              	
F54F: C5      		push	bc
F550: D5      		push	de
F551: E5      		push	hl
              		
              		; Write physical sector
F552: CDF0F5  		call	nf_dvsc
F555: 3A21FA  		ld	a,(nf_io)
F558: 4F      		ld	c,a
F559: C603    		add	a,3
F55B: 57      		ld	d,a
F55C: 59      		ld	e,c
F55D: 3EA8    		ld	a,0xA8		; Write command
F55F: ED79    		out	(c),a
F561: 217AFA  		ld	hl,nf_cach
F564: ED78    	nf_wde1:in	a,(c)
F566: 1F      		rra	
F567: 3009    		jr	nc,nf_wde2
F569: 1F      		rra
F56A: 30F8    		jr	nc,nf_wde1
F56C: 4A      		ld	c,d
F56D: EDA3    		outi 
F56F: 4B      		ld	c,e
F570: 18F2    		jr	nf_wde1
F572: ED78    	nf_wde2:in	a,(c)
              		
              		; Deselect drive
F574: 47      		ld	b,a
F575: CDF5F5  		call	nf_udsl
F578: 78      		ld	a,b
              		
F579: E1      		pop	hl
F57A: D1      		pop	de
F57B: C1      		pop	bc
              		
              		; Error checking
F57C: E6FC    		and	0xFC
F57E: 2803    		jr	z,nf_wde3
              		
F580: 3E01    		ld	a,1
F582: C9      		ret
              		
              		; Cache is no longer dirty
F583: 3227FA  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F586: AF      	nf_wde4:xor	a
F587: 3226FA  		ld	(nf_inco),a
              		
F58A: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F58B: 3E02    	nf_grb:	ld	a,2
F58D: 3222FA  		ld	(nf_r2ks),a
F590: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F592: 3E04    	nf_ccp:	ld	a,4
F594: 3222FA  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F597: 3E02    	nf_r2k: ld	a,nf_rdsk
F599: CDF6F5  		call	nf_dvsl
              		
              		; Restore to track 0
F59C: 3A21FA  		ld	a,(nf_io)
F59F: 4F      		ld	c,a
F5A0: 3E09    		ld	a,0x09
F5A2: ED79    		out	(c),a 
F5A4: CD07F6  		call	nf_busy
              		
              		; Set sector # to 4
F5A7: 3A22FA  		ld	a,(nf_r2ks)
F5AA: 0C      		inc	c
F5AB: 0C      		inc	c
F5AC: ED79    		out	(c),a
F5AE: C5      		push	bc
F5AF: 0D      		dec	c
F5B0: 0D      		dec	c
              		
              		; Read into memory
F5B1: 2100DC  		ld	hl,cbase
F5B4: CDD4F5  		call	nf_rphy
F5B7: C1      		pop	bc
F5B8: B7      		or	a
F5B9: 2805    		jr	z,nf_r2k0
F5BB: CD0BF4  		call	nf_init		; Error!
F5BE: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F5C0: ED78    	nf_r2k0:in	a,(c)
F5C2: 3C      		inc	a
F5C3: ED79    		out	(c),a
F5C5: 0D      		dec	c
F5C6: 0D      		dec	c
              		
              		; Read into memory again
F5C7: CDD4F5  		call	nf_rphy
F5CA: B7      		or	a
F5CB: C8      		ret	z
F5CC: CD0BF4  		call	nf_init		; Error!
F5CF: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F5D1: C3F5F5  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F5D4: 51      	nf_rphy:ld	d,c
F5D5: 59      		ld	e,c
F5D6: 14      		inc	d
F5D7: 14      		inc	d
F5D8: 14      		inc	d
              		
              		; Read command
F5D9: 3E88    		ld	a,0x88
F5DB: ED79    		out	(c),a
F5DD: ED78    	nf_rph1:in	a,(c)
F5DF: 1F      		rra	
F5E0: 3009    		jr	nc,nf_rph2
F5E2: 1F      		rra
F5E3: 30F8    		jr	nc,nf_rph1
F5E5: 4A      		ld	c,d
F5E6: EDA2    		ini
F5E8: 4B      		ld	c,e
F5E9: 18F2    		jr	nf_rph1
F5EB: ED78    	nf_rph2:in	a,(c)
F5ED: E6FC    		and	0xFC
F5EF: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F5F0: 3A23FA  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F5F3: 1801    		jr	nf_dvsl
F5F5: AF      	nf_udsl:xor	a		; Unselects a drive
F5F6: C5      	nf_dvsl:push	bc
F5F7: 47      		ld	b,a
F5F8: 3A21FA  		ld	a,(nf_io)
F5FB: C60F    		add	a,0x0F
F5FD: 4F      		ld	c,a
F5FE: ED41    		out	(c),b
F600: 06FF    		ld	b,0xFF
F602: CD0DF6  		call	nf_stal
F605: C1      		pop	bc
F606: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F607: ED78    	nf_busy:in	a,(c)
F609: 1F      		rra
F60A: 38FB    		jr	c,nf_busy
F60C: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F60D: C5      	nf_stal:push	bc
F60E: C1      		pop	bc
F60F: 10FC    		djnz	nf_stal
F611: C9      		ret
              	#include "dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FE7A: 00      	tm_curx:defs	1	; Cursor X
FE7B: 00      	tm_cury:defs	1	; Cursor Y
FE7C: 00      	tm_outc:defs	1	; Output character
FE7D: 00      	tm_scro:defs	1	; Scroll width
FE7E: 00      	tm_escs:defs	1	; Escape state
FE7F: 00      	tm_last:defs	1	; Last character read
FE80: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
FE84: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
              	; Driver jump table
F612: B7      	vdpdev:	or	a
F613: 2839    		jr	z,tm_init
F615: 3D      		dec	a
F616: 2819    		jr	z,tm_stat
F618: 3D      		dec	a
F619: CAB7F6  		jp	z,tm_read
F61C: C309F7  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F61F: F5      	tm_otir:push	af
F620: 7E      	tm_oti0:ld	a,(hl)
F621: ED79    		out	(c),a
F623: 23      		inc	hl
F624: 10FA    		djnz	tm_oti0
F626: F1      		pop	af
F627: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F628: F5      	tm_inir:push	af
F629: ED78    	tm_inr0:in	a,(c)
F62B: 77      		ld	(hl),a
F62C: 23      		inc	hl
F62D: 10FA    		djnz	tm_inr0
F62F: F1      		pop	af
F630: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
F631: 3A7FFE  	tm_stat:ld	a,(tm_last)
F634: FEE4    		cp	0xE4
F636: 2843    		jr	z,tm_scri
F638: FEE5    		cp	0xE5
F63A: 2851    		jr	z,tm_sclf
F63C: 3A7CFE  	tm_sta0:ld	a,(tm_outc)
F63F: 3C      		inc	a
F640: 3EFF    		ld	a,0xFF
F642: C0      		ret	nz
F643: CD22F8  		call	tm_getc
F646: 327CFE  		ld	(tm_outc),a
F649: 3C      		inc	a
F64A: C8      		ret	z
F64B: 3EFF    		ld	a,0xFF
F64D: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
F64E: CD71F3  	tm_init:call	resgrb
              	
              		; Set up registers
F651: CD97F6  		call	tm_setp
              		
              		; Set TMS pattern generator block to 0
F654: DBA1    		in	a,(tm_latc)
F656: AF      		xor	a
F657: D3A1    		out	(tm_latc),a
F659: 3E84    		ld	a,0x84
F65B: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F65D: 010040  		ld	bc,0x4000
F660: CDDCF8  		call	tm_addr
F663: 2100DC  		ld	hl,cbase
F666: 0EA0    		ld	c,tm_data
F668: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F66A: 0600    	tm_ini0:ld	b,0
F66C: CD1FF6  		call	tm_otir
F66F: 3D      		dec	a
F670: 20F8    		jr	nz,tm_ini0
              		
              		; Clear the terminal
F672: CDC9F8  		call	tm_cls
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F675: 3EFF    	tm_cloc:ld	a,0xFF
F677: 327CFE  		ld	(tm_outc),a
              	
F67A: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F67B: 3A7DFE  	tm_scri:ld	a,(tm_scro)
F67E: B7      		or	a
F67F: FE28    		cp	40
F681: 2808    		jr	z,tm_scr1
F683: C604    		add	a,4
F685: 327DFE  	tm_scr0:ld	(tm_scro),a
F688: CDA6F8  		call	tm_usco
F68B: 18AF    	tm_scr1:jr	tm_sta0
F68D: 3A7DFE  	tm_sclf:ld	a,(tm_scro)
F690: B7      		or	a
F691: 28F8    		jr	z,tm_scr1
F693: D604    		sub	4
F695: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
F697: 2AE7F8  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
F69A: DBA1    		in	a,(tm_latc)
F69C: 7C      		ld	a,h
F69D: D3A1    		out	(tm_latc),a
F69F: 3E80    		ld	a,0x80
F6A1: D3A1    		out	(tm_latc),a
F6A3: DBA1    		in	a,(tm_latc)
F6A5: 3EF0    		ld	a,0xF0
F6A7: D3A1    		out	(tm_latc),a
F6A9: 3E81    		ld	a,0x81
F6AB: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F6AD: DBA1    		in	a,(tm_latc)
F6AF: 7D      		ld	a,l
F6B0: D3A1    		out	(tm_latc),a
F6B2: 3E82    		ld	a,0x82
F6B4: D3A1    		out	(tm_latc),a
F6B6: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F6B7: 3A7AFE  	tm_read:ld	a,(tm_curx)
F6BA: 4F      		ld	c,a
F6BB: 3A7BFE  		ld	a,(tm_cury)
F6BE: 57      		ld	d,a
F6BF: 210010  		ld	hl,0x1000
F6C2: 3E50    		ld	a,80
F6C4: CD82F8  		call	tm_chat
F6C7: DBA0    		in	a,(tm_data)	; char is in A
F6C9: 57      		ld	d,a		; char key
F6CA: 5F      		ld	e,a		; blinking char
F6CB: 0601    		ld	b,1
              		
F6CD: D5      	tm_rea0:push	de
F6CE: CD31F6  		call	tm_stat
F6D1: D1      		pop	de
F6D2: 3C      		inc	a
F6D3: 200D    		jr	nz,tm_rea1
F6D5: 5A      		ld	e,d
F6D6: CDF2F6  		call	tm_rea2
F6D9: 3A7CFE  		ld	a,(tm_outc)
F6DC: 47      		ld	b,a
F6DD: CD75F6  		call	tm_cloc
F6E0: 78      		ld	a,b
F6E1: C9      		ret
              		
F6E2: CD00F7  	tm_rea1:call	tm_stal
F6E5: 10E6    		djnz	tm_rea0
F6E7: 3E80    		ld	a,0x80
F6E9: AB      		xor	e
F6EA: 5F      		ld	e,a
F6EB: CDF2F6  		call	tm_rea2
F6EE: 06BE    		ld	b,190
F6F0: 18DB    		jr	tm_rea0
              	
              	
F6F2: D5      	tm_rea2:push	de
F6F3: 3A7AFE  		ld	a,(tm_curx)
F6F6: 4F      		ld	c,a
F6F7: 3A7BFE  		ld	a,(tm_cury)
F6FA: 57      		ld	d,a
F6FB: CD5EF8  		call	tm_putc
F6FE: D1      		pop	de
F6FF: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F700: C5      	tm_stal:push	bc
F701: 06FF    		ld	b,255
F703: C5      	tm_sta1:push	bc
F704: C1      		pop	bc
F705: 10FC    		djnz	tm_sta1
F707: C1      		pop	bc
F708: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F709: 59      	tm_writ:ld	e,c
F70A: 3A7AFE  		ld	a,(tm_curx)
F70D: 4F      		ld	c,a
F70E: 3A7BFE  		ld	a,(tm_cury)
F711: 57      		ld	d,a
F712: CD1EF7  		call	tm_wri0
F715: 78      		ld	a,b
F716: 327BFE  		ld	(tm_cury),a
F719: 79      		ld	a,c
F71A: 327AFE  		ld	(tm_curx),a
F71D: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F71E: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F71F: 3A7EFE  		ld	a,(tm_escs)
F722: B7      		or	a		; Process escape code
F723: C28BF7  		jp	nz,tm_esc
F726: 3E1F    		ld	a,0x1F
F728: BB      		cp	e
F729: D25DF7  		jp	nc,tm_wri1	; Process control code
F72C: C5      		push	bc
F72D: CD5EF8  		call	tm_putc		; Write character
F730: C1      		pop	bc
              		
              		; Increment character
F731: 0C      	tm_ri	inc	c
F732: 3E50    		ld	a,80
F734: B9      		cp	c
F735: C0      		ret	nz
F736: AF      		xor	a
F737: 4F      		ld	c,a
F738: 04      	tm_lf:  inc	b	; Line feed
F739: 3E18    		ld	a,24
F73B: B8      		cp	b
F73C: C0      		ret	nz
F73D: C5      		push	bc
F73E: CDFCF7  		call	tm_dsco
F741: C1      		pop	bc
F742: 05      		dec	b
F743: C9      		ret
F744: AF      	tm_cr:	xor	a	; Carriage return
F745: 4F      		ld	c,a
F746: C9      		ret
F747: 0D      	tm_bs:	dec	c	; Backspace 
F748: F0      		ret	p
F749: 0E4F    		ld	c,79
F74B: 05      		dec	b
F74C: F0      		ret	p
F74D: AF      		xor	a
F74E: 47      		ld	b,a
F74F: 4F      		ld	c,a
F750: C9      		ret
F751: AF      	tm_up:	xor	a	; Move up
F752: B8      		cp	b
F753: C8      		ret	z
F754: 05      		dec	b
F755: C9      		ret
F756: CDC9F8  	tm_cshm:call	tm_cls
F759: AF      	tm_home:xor	a
F75A: 47      		ld	b,a
F75B: 4F      		ld	c,a
F75C: C9      		ret
              	
F75D: 7B      	tm_wri1:ld	a,e
F75E: FE08    		cp	0x08	; '\b' (Cursor left)
F760: 28E5    		jr	z,tm_bs
F762: FE12    		cp	0x12	; Cursor right
F764: 28CB    		jr	z,tm_ri
F766: FE0A    		cp	0x0A	; '\n' (Cursor down)
F768: 28CE    		jr	z,tm_lf
F76A: FE0B    		cp	0x0B	; Cursor up
F76C: 28E3    		jr	z,tm_up
F76E: FE0D    		cp	0x0D	; '\r' 
F770: 28D2    		jr	z,tm_cr
F772: FE17    		cp	0x17	; Clear end of screen
F774: 284E    		jr	z,tm_cles
F776: FE18    		cp	0x18	; Clear end of line
F778: 284C    		jr	z,tm_clea
F77A: FE1A    		cp	0x1A	; Clear screen, home cursor
F77C: 28D8    		jr	z,tm_cshm
F77E: FE1E    		cp	0x1E	; Home cursor
F780: 28D7    		jr	z,tm_home
F782: FE1B    		cp	0x1B	; Escape
F784: C0      		ret	nz
F785: 3E01    		ld	a,1
F787: 327EFE  		ld	(tm_escs),a
F78A: C9      		ret
              		
              		; Handle escape sequence
F78B: 3D      	tm_esc:	dec	a
F78C: 280B    		jr	z,tm_esc0
F78E: 3D      		dec	a
F78F: 281D    		jr	z,tm_esc1
F791: 3D      		dec	a
F792: 2825    		jr	z,tm_esc2
F794: AF      	tm_escd:xor	a	; Escape done
F795: 327EFE  	tm_escr:ld	(tm_escs),a
F798: C9      		ret
F799: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
F79B: BB      		cp	e
F79C: 284B    		jr	z,tm_40c
F79E: 3EFE    		ld	a,0xFE	; Do 80-col
F7A0: BB      		cp	e
F7A1: 2853    		jr	z,tm_80c
F7A3: 3E3D    		ld	a,0x3D	; '='
F7A5: BB      		cp	e
F7A6: 20EC    		jr	nz,tm_escd
F7A8: 3A7EFE  	tm_esci:ld	a,(tm_escs)
F7AB: 3C      		inc	a
F7AC: 18E7    		jr	tm_escr
F7AE: 7B      	tm_esc1:ld	a,e
F7AF: 1E20    		ld	e,0x20
F7B1: 93      		sub	e
F7B2: FE18    		cp	24
F7B4: 30DE    		jr	nc,tm_escd
F7B6: 47      		ld	b,a
F7B7: 18EF    		jr	tm_esci
F7B9: 7B      	tm_esc2:ld	a,e
F7BA: 1E20    		ld	e,0x20
F7BC: 93      		sub	e
F7BD: FE50    		cp	80
F7BF: 30D3    		jr	nc,tm_escd
F7C1: 4F      		ld	c,a
F7C2: 18D0    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F7C4: 0617    	tm_cles:ld	b,23
F7C6: 04      	tm_clea:inc	b
F7C7: 1E00    		ld	e,0
F7C9: C5      		push	bc
F7CA: D5      		push	de
F7CB: 3E50    		ld	a,80
F7CD: 210050  		ld	hl,0x5000
F7D0: CD82F8  		call	tm_chat
F7D3: D1      		pop	de
F7D4: C1      		pop	bc
F7D5: AF      	tm_cle0:xor	a
F7D6: D3A0    		out	(tm_data),a
F7D8: 0C      		inc	c
F7D9: 3E50    		ld	a,80
F7DB: B9      		cp	c
F7DC: 20F7    		jr	nz,tm_cle0
F7DE: 14      		inc	d
F7DF: AF      		xor	a
F7E0: 4F      		ld	c,a
F7E1: 7A      		ld	a,d
F7E2: B8      		cp	b
F7E3: 20F0    		jr	nz,tm_cle0
F7E5: D1      		pop	de	; Do not update character
F7E6: C3A6F8  		jp	tm_usco
              		
F7E9: E5      	tm_40c:	push	hl
F7EA: 210200  		ld	hl,0x0002
F7ED: 22E7F8  	tm_cupd:ld	(tm_mode),hl
F7F0: CD97F6  		call	tm_setp
F7F3: E1      		pop	hl
F7F4: 189E    		jr	tm_escd
              		
F7F6: E5      	tm_80c:	push	hl
F7F7: 210704  		ld	hl,0x0407
F7FA: 18F1    		jr	tm_cupd
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F7FC: 212808  	tm_dsco:ld	hl,0x0800+40
F7FF: 110048  		ld	de,0x4800
F802: 0618    		ld	b,24
F804: CD0FF8  		call	tm_dsc0
F807: 215010  		ld	hl,0x1000+80
F80A: 110050  		ld	de,0x5000
F80D: 0630    		ld	b,48
F80F: C5      	tm_dsc0:push	bc
F810: D5      		push	de
F811: E5      		push	hl
F812: CD8EF8  		call	tm_vcpy
F815: E1      		pop	hl
F816: D1      		pop	de
F817: 012800  		ld	bc,40
F81A: 09      		add	hl,bc
F81B: EB      		ex	de,hl
F81C: 09      		add	hl,bc
F81D: EB      		ex	de,hl
F81E: C1      		pop	bc
F81F: 10EE    		djnz	tm_dsc0
F821: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F822: DB91    	tm_getc:in	a,(tm_keys)
F824: E602    		and	2
F826: 3D      		dec	a
F827: F8      		ret	m
              		
              		; Grab the key
F828: DB90    		in	a,(tm_keyd)
F82A: 327FFE  		ld	(tm_last),a
F82D: CD32F8  		call	tm_map
F830: 79      		ld	a,c
F831: C9      		ret
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F832: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
F833: 2149F8  		ld	hl,tm_mapt
F836: 7E      	tm_map0:ld	a,(hl)
F837: B7      		or	a
F838: 2808    		jr	z,tm_map2
F83A: B9      		cp	c
F83B: 23      		inc	hl
F83C: 7E      		ld	a,(hl)
F83D: 23      		inc	hl
F83E: 20F6    		jr	nz,tm_map0
F840: 4F      		ld	c,a
F841: C9      		ret
              		
              		
              		; Filter non-ASCII
F842: 79      	tm_map2:ld	a,c
F843: E680    		and	0x80	
F845: C8      		ret	z
F846: 0EFF    		ld	c,0xFF
F848: C9      		ret
              		
              	; Map table
F849: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
F84B: E108    		defb	0xE1,0x08	; '<-' -> BS
F84D: EA7F    		defb	0xEA,0x7F	; TV -> DEL
F84F: E00C    		defb	0xE0,0x0C	; '->' -> Right
F851: E20B    		defb	0xE2,0x0B	; '/\' -> Up
F853: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
F855: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
F857: E860    		defb	0xE8,0x60	; SYM -> '@'
F859: E67C    		defb	0xE6,0x7C	; NO -> '|'
F85B: E77E    		defb	0xE7,0x7E	; YES -> '~'
F85D: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F85E: 210050  	tm_putc:ld	hl,0x5000
F861: 3E50    		ld	a,80
F863: C5      		push	bc
F864: D5      		push	de
F865: CD82F8  		call	tm_chat	; Place it in the 80 col buffer
F868: ED59    		out	(c),e
F86A: D1      		pop	de
F86B: C1      		pop	bc
F86C: 3A7DFE  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F86F: 47      		ld	b,a
F870: 79      		ld	a,c
F871: 90      		sub	b	; If character is less than scroll...
F872: 4F      		ld	c,a
F873: F8      		ret	m
F874: FE28    		cp	40	; If desired position is 40 or more
F876: D0      		ret	nc
F877: 210048  		ld	hl,0x4800
F87A: 3E28    		ld	a,40
F87C: CD82F8  		call	tm_chat	; Place it in the 40 col screen buffer
F87F: ED59    		out	(c),e
F881: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
F882: 0600    	tm_chat:ld	b,0
F884: 09      		add	hl,bc
F885: 4F      		ld	c,a
F886: AF      		xor	a
F887: BA      		cp	d
F888: 2850    	tm_cha0:jr	z,tm_addh
F88A: 09      		add	hl,bc
F88B: 15      		dec	d
F88C: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F88E: CDDAF8  	tm_vcpy:call	tm_addh
F891: 0628    		ld	b,40
F893: 2180FE  		ld	hl,tm_cbuf
F896: CD28F6  		call	tm_inir
F899: EB      		ex	de,hl
F89A: CDDAF8  		call	tm_addh
F89D: 0628    		ld	b,40
F89F: 2180FE  		ld	hl,tm_cbuf
F8A2: CD1FF6  		call	tm_otir
F8A5: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F8A6: 210010  	tm_usco:ld	hl,0x1000
F8A9: 110048  		ld	de,0x4800
F8AC: 3A7DFE  		ld	a,(tm_scro)
F8AF: 0600    		ld	b,0
F8B1: 4F      		ld	c,a
F8B2: 09      		add	hl,bc
F8B3: 0618    		ld	b,24
F8B5: C5      	tm_usc0:push	bc
F8B6: D5      		push	de
F8B7: E5      		push	hl
F8B8: CD8EF8  		call	tm_vcpy
F8BB: E1      		pop	hl
F8BC: D1      		pop	de
F8BD: 0E50    		ld	c,80
F8BF: 09      		add	hl,bc
F8C0: EB      		ex	de,hl
F8C1: 0E28    		ld	c,40
F8C3: 09      		add	hl,bc
F8C4: EB      		ex	de,hl
F8C5: C1      		pop	bc
F8C6: 10ED    		djnz	tm_usc0
F8C8: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F8C9: 010048  	tm_cls:	ld	bc,0x4800
F8CC: 110010  		ld	de,0x1000
F8CF: CDDCF8  		call	tm_addr
F8D2: ED71    	tm_cls0:out	(c),0
F8D4: 1B      		dec	de
F8D5: 7A      		ld	a,d
F8D6: B3      		or	e
F8D7: 20F9    		jr	nz,tm_cls0
F8D9: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; uses: af, bc
F8DA: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F8DB: 4D      		ld	c,l
F8DC: DBA1    	tm_addr:in	a,(tm_latc)
F8DE: 79      		ld	a,c
F8DF: D3A1    		out	(tm_latc),a
F8E1: 78      		ld	a,b
F8E2: D3A1    		out	(tm_latc),a
F8E4: 0EA0    		ld	c,tm_data
F8E6: C9      		ret
              		
              	; Variables
F8E7: 0200    	tm_mode:defw	0x0002
              	#include "dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F8E9: B7      	prtdev:	or	a
F8EA: 2808    		jr	z,pr_init
F8EC: 3D      		dec	a
F8ED: 2806    		jr	z,pr_stat
F8EF: 3D      		dec	a
F8F0: 2805    		jr	z,pr_read
F8F2: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F8F4: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F8F5: AF      	pr_stat:xor	a
F8F6: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F8F7: AF      	pr_read:xor	a
F8F8: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F8F9: 3E0F    	pr_writ:ld	a,0x0F
F8FB: D341    		out	(pr_atla),a	; AY register = 15
              		
F8FD: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F8FF: E610    		and	0x10
F901: 20FA    		jr	nz,pr_wri0
              		
F903: 79      		ld	a,c
F904: D3B0    		out	(pr_prnt),a	; Write data
              		
F906: 3E05    		ld	a,0x05		; Strobe
F908: D300    		out	(pr_ctrl),a
              		
F90A: 0620    		ld	b,32		
F90C: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
F90E: 3E01    		ld	a,0x01		; Strobe off
F910: D300    		out	(pr_ctrl),a
              		
F912: C9      		ret
              		
              	#include "dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
F913: B7      	siodev:	or	a
F914: 2808    		jr	z,so_init
F916: 3D      		dec	a
F917: 2833    		jr	z,so_stat
F919: 3D      		dec	a
F91A: 2841    		jr	z,so_read
F91C: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
F91E: 1183F9  	so_init:ld	de,so_atab
F921: 45      		ld	b,l
F922: 04      		inc	b		; Slot 1,2,3,...
F923: 19      		add	hl,de 		; Get address table entry
F924: 0ECF    		ld	c,0xCF		; First slot
              		
F926: ED78    	so_ini0:in	a,(c)
F928: FE08    		cp	0x08
F92A: 2807    		jr	z,so_ini2
              		
F92C: 3E10    	so_ini1:ld	a,0x10
F92E: 81      		add	c
F92F: F0      		ret	p		; Can't find, failure
F930: 4F      		ld	c,a
F931: 18F3    		jr	so_ini0
              		
F933: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
F935: 79      		ld	a,c
F936: D60F    		sub	0x0F
F938: 4F      		ld	c,a
F939: 71      		ld	(hl),c
F93A: 1187F9  		ld	de,so_conf
F93D: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
F93F: 1A      	so_ini3:ld	a,(de)
F940: 13      		inc	de
F941: 86      		add	a,(hl)
F942: 4F      		ld	c,a
F943: 1A      		ld	a,(de)
F944: 13      		inc	de
F945: ED79    		out	(c),a
F947: E5      		push	hl
F948: E1      		pop	hl	; Small delay
F949: 10F4    		djnz	so_ini3
F94B: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F94C: 1183F9  	so_stat:ld	de,so_atab
F94F: 19      		add	hl,de
F950: AF      		xor	a
F951: BE      		cp	(hl)
F952: C8      		ret	z	; No device, return 0
F953: 4E      		ld	c,(hl)
F954: 0C      		inc	c
F955: ED78    	so_sta0:in	a,(c)	; Check status register
F957: E602    		and	0x02
F959: C8      		ret	z
F95A: 3EFF    		ld	a,0xFF
F95C: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
F95D: 1183F9  	so_read:ld	de,so_atab
F960: 19      		add	hl,de
F961: AF      		xor	a
F962: BE      		cp	(hl)
F963: C8      		ret	z	; No device, return 0
F964: 4E      		ld	c,(hl)
F965: 0C      		inc	c
F966: CD55F9  	so_rea0:call	so_sta0	; Wait for a character
F969: 28FB    		jr	z,so_rea0
F96B: 0D      		dec	c
F96C: ED78    		in	a,(c)
F96E: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
F96F: 41      	so_writ:ld	b,c
F970: 1183F9  		ld	de,so_atab
F973: 19      		add	hl,de
F974: AF      		xor	a
F975: BE      		cp	(hl)
F976: C8      		ret	z	; No device, return 0
F977: 4E      		ld	c,(hl)
F978: 0C      		inc	c
F979: ED78    	so_wri0:in	a,(c)
F97B: E601    		and	0x01
F97D: 28FA    		jr	z,so_wri0
F97F: 0D      		dec	c
F980: ED41    		out	(c),b
F982: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
F983: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
F987: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
F989: 0412    		defb	0x04,0x12
F98B: 0400    		defb	0x04,0x00
F98D: 0777    		defb	0x07,0x77	; Counter 2 setup
F98F: 0512    		defb	0x05,0x12
F991: 0500    		defb	0x05,0x00
              		
F993: 0100    		defb	0x01,0x00	; 8251 setup
F995: 0100    		defb	0x01,0x00
F997: 0100    		defb	0x01,0x00
F999: 0100    		defb	0x01,0x00
F99B: 0140    		defb	0x01,0x40
F99D: 014E    		defb	0x01,0x4E
F99F: 0137    		defb	0x01,0x37


; +++ segments +++

#CODE _TEXT    = $DC00 = 56320,  size = $1DA1 =  7585
#DATA _BSS     = $F9A1 = 63905,  size = $0507 =  1287

; +++ global symbols +++

_BSS       = $F9A1 = 63905  _BSS    config\config_fdc.asm:39 (unused)
_BSS_end   = $FEA8 = 65192  _BSS    config\config_fdc.asm:39 (unused)
_BSS_size  = $0507 =  1287  _BSS    config\config_fdc.asm:39 (unused)
_TEXT      = $DC00 = 56320  _TEXT   config\config_fdc.asm:38 (unused)
_TEXT_end  = $F9A1 = 63905  _TEXT   config\config_fdc.asm:38
_TEXT_size = $1DA1 =  7585  _TEXT   config\config_fdc.asm:38 (unused)
active     = $E748 = 59208  _TEXT   CPM22.asm:1709
adda2hl    = $E96A = 59754  _TEXT   CPM22.asm:2138
addhl      = $DE59 = 56921  _TEXT   CPM22.asm:432
alloc0     = $F1D0 = 61904  _TEXT   CPM22.asm:3686
alloc1     = $F1D2 = 61906  _TEXT   CPM22.asm:3687
alocvect   = $F1C5 = 61893  _TEXT   CPM22.asm:3676
auto       = $F1E4 = 61924  _TEXT   CPM22.asm:3701
autoflag   = $F1E6 = 61926  _TEXT   CPM22.asm:3703
autosel    = $F057 = 61527  _TEXT   CPM22.asm:3416
autosl1    = $F07B = 61563  _TEXT   CPM22.asm:3432
backup     = $E5AA = 58794  _TEXT   CPM22.asm:1469
backup1    = $E5B2 = 58802  _TEXT   CPM22.asm:1472
badload    = $E387 = 58247  _TEXT   CPM22.asm:1201
badsctr    = $E40C = 58380  _TEXT   CPM22.asm:1252
badsec     = $E4D0 = 58576  _TEXT   CPM22.asm:1324
badsel     = $E4DB = 58587  _TEXT   CPM22.asm:1325
badslct    = $E40E = 58382  _TEXT   CPM22.asm:1253
batch      = $E3B8 = 58296  _TEXT   CPM22.asm:1224
batchfcb   = $E3B9 = 58297  _TEXT   CPM22.asm:1225
bdevsw     = $F374 = 62324  _TEXT   config\config_fdc.asm:156
bdosdrv    = $E4CC = 58572  _TEXT   CPM22.asm:1323
bdoserr    = $E4C0 = 58560  _TEXT   CPM22.asm:1322
bigdisk    = $F1E3 = 61923  _TEXT   CPM22.asm:3700
biodma     = $F34B = 62283  _TEXT   bios.asm:316
bitmap     = $EAA9 = 60073  _TEXT   CPM22.asm:2431
bitmap1    = $EAB7 = 60087  _TEXT   CPM22.asm:2446
bitmap2    = $EAD8 = 60120  _TEXT   CPM22.asm:2467
bitmap3    = $EAFC = 60156  _TEXT   CPM22.asm:2484
blkmask    = $F1CA = 61898  _TEXT   CPM22.asm:3682
blknmbr    = $F1EB = 61931  _TEXT   CPM22.asm:3707
blkshft    = $F1C9 = 61897  _TEXT   CPM22.asm:3681
boot       = $F245 = 62021  _TEXT   bios.asm:42
bs         = $0008 =     8  _TEXT   CPM22.asm:31
callbd     = $F2FA = 62202  _TEXT   bios.asm:215
callmj     = $F348 = 62280  _TEXT   bios.asm:310
cbase      = $DC00 = 56320  _TEXT   CPM22.asm:44
cbinit     = $F364 = 62308  _TEXT   config\config_fdc.asm:88
ccpstack   = $E3B8 = 58296  _TEXT   CPM22.asm:1220
cdevsw     = $F3B4 = 62388  _TEXT   config\config_fdc.asm:195
cdindi0    = $F320 = 62240  _TEXT   bios.asm:275
cdindi1    = $F326 = 62246  _TEXT   bios.asm:279
cdindir    = $F31C = 62236  _TEXT   bios.asm:273
cdrive     = $E3FC = 58364  _TEXT   CPM22.asm:1231
cfirq      = $F36A = 62314  _TEXT   config\config_fdc.asm:104
charbuf    = $E714 = 59156  _TEXT   CPM22.asm:1698
check      = $DE30 = 56880  _TEXT   CPM22.asm:398
checkdir   = $E9A4 = 59812  _TEXT   CPM22.asm:2211
checksum   = $E8FD = 59645  _TEXT   CPM22.asm:2050
chgdrv     = $E3FD = 58365  _TEXT   CPM22.asm:1232
chgnam1    = $EC2D = 60461  _TEXT   CPM22.asm:2723
chgnames   = $EC1C = 60444  _TEXT   CPM22.asm:2715
chkblk     = $E88A = 59530  _TEXT   CPM22.asm:1957
chkchar    = $E51A = 58650  _TEXT   CPM22.asm:1366
chkcon     = $DDC2 = 56770  _TEXT   CPM22.asm:323
chkdir1    = $E9CA = 59850  _TEXT   CPM22.asm:2231
chknmbr    = $E992 = 59794  _TEXT   CPM22.asm:2184
chkrofl    = $E94A = 59722  _TEXT   CPM22.asm:2114
chksum1    = $E903 = 59651  _TEXT   CPM22.asm:2053
chkvect    = $F1C3 = 61891  _TEXT   CPM22.asm:3675
chkwprt    = $E95A = 59738  _TEXT   CPM22.asm:2125
chrout     = $F2BD = 62141  _TEXT   bios.asm:156
ckbitmap   = $EA3B = 59963  _TEXT   CPM22.asm:2325
ckbmap1    = $EA5C = 59996  _TEXT   CPM22.asm:2360
ckcon1     = $E548 = 58696  _TEXT   CPM22.asm:1396
ckcon2     = $E54B = 58699  _TEXT   CPM22.asm:1397
ckconsol   = $E529 = 58665  _TEXT   CPM22.asm:1382
ckfilpos   = $E9FB = 59899  _TEXT   CPM22.asm:2274
ckrof1     = $E94D = 59725  _TEXT   CPM22.asm:2115
cksumtbl   = $F1F2 = 61938  _TEXT   CPM22.asm:3715
clearbuf   = $DF58 = 57176  _TEXT   CPM22.asm:598
clears2    = $E978 = 59768  _TEXT   CPM22.asm:2155
close      = $DCDA = 56538  _TEXT   CPM22.asm:138
closefil   = $F0AB = 61611  _TEXT   CPM22.asm:3463
closeflg   = $F1D8 = 61912  _TEXT   CPM22.asm:3692
closeit    = $ECA8 = 60584  _TEXT   CPM22.asm:2809
closeit1   = $ECD3 = 60627  _TEXT   CPM22.asm:2829
closeit2   = $ECE1 = 60641  _TEXT   CPM22.asm:2837
closeit3   = $ECE7 = 60647  _TEXT   CPM22.asm:2841
closeit4   = $ECEE = 60654  _TEXT   CPM22.asm:2844
closeit5   = $ED03 = 60675  _TEXT   CPM22.asm:2857
closeit6   = $ED1D = 60701  _TEXT   CPM22.asm:2875
closeit7   = $ED25 = 60709  _TEXT   CPM22.asm:2878
cmdadr     = $DFCE = 57294  _TEXT   CPM22.asm:680
cmdtbl     = $DF10 = 57104  _TEXT   CPM22.asm:552
cmmnd1     = $DF82 = 57218  _TEXT   CPM22.asm:633
cmmnd2     = $DFA5 = 57253  _TEXT   CPM22.asm:652
cntrlc     = $0003 =     3  _TEXT   CPM22.asm:29
cntrle     = $0005 =     5  _TEXT   CPM22.asm:30
cntrlp     = $0010 =    16  _TEXT   CPM22.asm:36
cntrlr     = $0012 =    18  _TEXT   CPM22.asm:37
cntrls     = $0013 =    19  _TEXT   CPM22.asm:38
cntrlu     = $0015 =    21  _TEXT   CPM22.asm:39
cntrlx     = $0018 =    24  _TEXT   CPM22.asm:40
cntrlz     = $001A =    26  _TEXT   CPM22.asm:41
comblk     = $E87D = 59517  _TEXT   CPM22.asm:1948
comfile    = $E390 = 58256  _TEXT   CPM22.asm:1202
command    = $DF5C = 57180  _TEXT   CPM22.asm:608
comprand   = $EFAB = 61355  _TEXT   CPM22.asm:3282
conin      = $F2AF = 62127  _TEXT   bios.asm:143
conout     = $F2BB = 62139  _TEXT   bios.asm:155
const      = $F2A4 = 62116  _TEXT   bios.asm:131
convert    = $DE60 = 56928  _TEXT   CPM22.asm:446
convfst    = $DE5E = 56926  _TEXT   CPM22.asm:440
convrt1    = $DE89 = 56969  _TEXT   CPM22.asm:469
convrt2    = $DE90 = 56976  _TEXT   CPM22.asm:472
convrt3    = $DE96 = 56982  _TEXT   CPM22.asm:479
convrt4    = $DE98 = 56984  _TEXT   CPM22.asm:480
convrt5    = $DEA9 = 57001  _TEXT   CPM22.asm:487
convrt6    = $DEAB = 57003  _TEXT   CPM22.asm:489
convrt7    = $DEAF = 57007  _TEXT   CPM22.asm:491
convrt8    = $DEB9 = 57017  _TEXT   CPM22.asm:495
counter    = $F1DE = 61918  _TEXT   CPM22.asm:3698
cpmlow     = $F29C = 62108  _TEXT   bios.asm:120
cr         = $000D =    13  _TEXT   CPM22.asm:35
create     = $DD09 = 56585  _TEXT   CPM22.asm:188
crlf       = $DC98 = 56472  _TEXT   CPM22.asm:80
curpos     = $E712 = 59154  _TEXT   CPM22.asm:1696
de2hl      = $E755 = 59221  _TEXT   CPM22.asm:1727
de2hl1     = $E756 = 59222  _TEXT   CPM22.asm:1728
decode     = $E005 = 57349  _TEXT   CPM22.asm:707
decode1    = $E015 = 57365  _TEXT   CPM22.asm:713
decode2    = $E037 = 57399  _TEXT   CPM22.asm:733 (unused)
decode3    = $E040 = 57408  _TEXT   CPM22.asm:738
decode4    = $E047 = 57415  _TEXT   CPM22.asm:742 (unused)
defdma     = $E9E0 = 59872  _TEXT   CPM22.asm:2249
del        = $007F =   127  _TEXT   CPM22.asm:42
delbatch   = $DDDD = 56797  _TEXT   CPM22.asm:348
delete     = $DCEF = 56559  _TEXT   CPM22.asm:159
delfile    = $F0DD = 61661  _TEXT   CPM22.asm:3494
dirbuf     = $F1BF = 61887  _TEXT   CPM22.asm:3673
dirc1      = $E6E6 = 59110  _TEXT   CPM22.asm:1654
dircbuf    = $F9A1 = 63905  _BSS    config\config_fdc.asm:40
dircio     = $E6DA = 59098  _TEXT   CPM22.asm:1648
dirdma     = $E9E6 = 59878  _TEXT   CPM22.asm:2254
dirdma1    = $E9E9 = 59881  _TEXT   CPM22.asm:2259
direct     = $E084 = 57476  _TEXT   CPM22.asm:804
direct1    = $E095 = 57493  _TEXT   CPM22.asm:811
direct2    = $E09C = 57500  _TEXT   CPM22.asm:815
direct3    = $E0A5 = 57509  _TEXT   CPM22.asm:819
direct4    = $E0D9 = 57561  _TEXT   CPM22.asm:846
direct5    = $E0E1 = 57569  _TEXT   CPM22.asm:849
direct6    = $E0E6 = 57574  _TEXT   CPM22.asm:851
direct7    = $E11B = 57627  _TEXT   CPM22.asm:875
direct8    = $E11C = 57628  _TEXT   CPM22.asm:876
direct9    = $E128 = 57640  _TEXT   CPM22.asm:880
dirread    = $E9DA = 59866  _TEXT   CPM22.asm:2244
dirsize    = $F1CE = 61902  _TEXT   CPM22.asm:3685
dirwrite   = $E9CC = 59852  _TEXT   CPM22.asm:2236
diskpb     = $F1C1 = 61889  _TEXT   CPM22.asm:3674
diskro     = $E4E7 = 58599  _TEXT   CPM22.asm:1327
dmaset     = $DDD8 = 56792  _TEXT   CPM22.asm:343
doread     = $E7B8 = 59320  _TEXT   CPM22.asm:1798
dowrite    = $E7BE = 59326  _TEXT   CPM22.asm:1803
drect63    = $E104 = 57604  _TEXT   CPM22.asm:865
drect65    = $E106 = 57606  _TEXT   CPM22.asm:866
dselect    = $E061 = 57441  _TEXT   CPM22.asm:774
dsksel     = $DCBD = 56509  _TEXT   CPM22.asm:112
dsksize    = $F1CC = 61900  _TEXT   CPM22.asm:3684
emptyfcb   = $F1B2 = 61874  _TEXT   CPM22.asm:3660
entry      = $0005 =     5  _TEXT   CPM22.asm:22
entry1     = $DCC3 = 56515  _TEXT   CPM22.asm:119
entry2     = $DCF4 = 56564  _TEXT   CPM22.asm:165
eparam     = $F1DC = 61916  _TEXT   CPM22.asm:3696
erafil1    = $EBAA = 60330  _TEXT   CPM22.asm:2601
erafile    = $EBA2 = 60322  _TEXT   CPM22.asm:2598
erase      = $E12C = 57644  _TEXT   CPM22.asm:889
erase1     = $E14F = 57679  _TEXT   CPM22.asm:904
error1     = $E49F = 58527  _TEXT   CPM22.asm:1305
error2     = $E4AB = 58539  _TEXT   CPM22.asm:1311
error3     = $E4B1 = 58545  _TEXT   CPM22.asm:1314
error4     = $E4B7 = 58551  _TEXT   CPM22.asm:1317
error5     = $E4BA = 58554  _TEXT   CPM22.asm:1319
exists     = $E28F = 57999  _TEXT   CPM22.asm:1066
extblk     = $E864 = 59492  _TEXT   CPM22.asm:1929
extblk1    = $E877 = 59511  _TEXT   CPM22.asm:1939
extmask    = $F1CB = 61899  _TEXT   CPM22.asm:3683
extract    = $E058 = 57432  _TEXT   CPM22.asm:764
fbase      = $E406 = 58374  _TEXT   CPM22.asm:1247
fbase1     = $E414 = 58388  _TEXT   CPM22.asm:1260
fcb        = $E3DA = 58330  _TEXT   CPM22.asm:1229
fcb2hl     = $E964 = 59748  _TEXT   CPM22.asm:2133
fcbpos     = $F1EF = 61935  _TEXT   CPM22.asm:3709
fcbset     = $EC03 = 60419  _TEXT   CPM22.asm:2693
fcreate    = $F0F2 = 61682  _TEXT   CPM22.asm:3511
ff         = $000C =    12  _TEXT   CPM22.asm:34 (unused)
filepos    = $F1F0 = 61936  _TEXT   CPM22.asm:3710
filero     = $E4E2 = 58594  _TEXT   CPM22.asm:1326
filesize   = $F153 = 61779  _TEXT   CPM22.asm:3585
findfst    = $EB1E = 60190  _TEXT   CPM22.asm:2518
findnxt    = $EB33 = 60211  _TEXT   CPM22.asm:2531
fndnxt1    = $EB50 = 60240  _TEXT   CPM22.asm:2544
fndnxt2    = $EB59 = 60249  _TEXT   CPM22.asm:2548
fndnxt3    = $EB79 = 60281  _TEXT   CPM22.asm:2564
fndnxt4    = $EB82 = 60290  _TEXT   CPM22.asm:2573
fndnxt5    = $EB89 = 60297  _TEXT   CPM22.asm:2578
fndnxt6    = $EB9A = 60314  _TEXT   CPM22.asm:2591
fndspa1    = $EBC6 = 60358  _TEXT   CPM22.asm:2631
fndspa2    = $EBD7 = 60375  _TEXT   CPM22.asm:2654
fndspa3    = $EBF2 = 60402  _TEXT   CPM22.asm:2675
fndspa4    = $EBFA = 60410  _TEXT   CPM22.asm:2685
fndspace   = $EBC4 = 60356  _TEXT   CPM22.asm:2625
fndstat    = $F1DA = 61914  _TEXT   CPM22.asm:3694
functns    = $E44D = 58445  _TEXT   CPM22.asm:1296
getaloc    = $F117 = 61719  _TEXT   CPM22.asm:3539
getback    = $E393 = 58259  _TEXT   CPM22.asm:1208
getback1   = $E396 = 58262  _TEXT   CPM22.asm:1209
getblk1    = $E84B = 59467  _TEXT   CPM22.asm:1907
getblk2    = $E859 = 59481  _TEXT   CPM22.asm:1916
getblk3    = $E862 = 59490  _TEXT   CPM22.asm:1921
getblock   = $E844 = 59460  _TEXT   CPM22.asm:1904
getchar    = $E501 = 58625  _TEXT   CPM22.asm:1344
getcon     = $E6CE = 59086  _TEXT   CPM22.asm:1636
getcrnt    = $F10A = 61706  _TEXT   CPM22.asm:3528
getcsts    = $E704 = 59140  _TEXT   CPM22.asm:1681
getdsk     = $DDD0 = 56784  _TEXT   CPM22.asm:334
getecho    = $E50C = 58636  _TEXT   CPM22.asm:1353
getempty   = $ED2A = 60714  _TEXT   CPM22.asm:2885
getext     = $DEC0 = 57024  _TEXT   CPM22.asm:502
getext1    = $DEC8 = 57032  _TEXT   CPM22.asm:506
getext2    = $DED9 = 57049  _TEXT   CPM22.asm:513
getext3    = $DEDB = 57051  _TEXT   CPM22.asm:515
getext4    = $DEDF = 57055  _TEXT   CPM22.asm:517
getext5    = $DEE9 = 57065  _TEXT   CPM22.asm:521
getext6    = $DEF0 = 57072  _TEXT   CPM22.asm:525
getext7    = $DEF2 = 57074  _TEXT   CPM22.asm:526
getext8    = $DF01 = 57089  _TEXT   CPM22.asm:538
getext9    = $DF09 = 57097  _TEXT   CPM22.asm:543
getfst     = $F0B1 = 61617  _TEXT   CPM22.asm:3470
getfst1    = $F0C8 = 61640  _TEXT   CPM22.asm:3481
getinp     = $DD39 = 56633  _TEXT   CPM22.asm:239
getinp1    = $DD96 = 56726  _TEXT   CPM22.asm:295
getinp2    = $DDA7 = 56743  _TEXT   CPM22.asm:304
getinp3    = $DDAB = 56747  _TEXT   CPM22.asm:306
getinp4    = $DDBA = 56762  _TEXT   CPM22.asm:315
getiob     = $E6F3 = 59123  _TEXT   CPM22.asm:1662
getlog     = $F104 = 61700  _TEXT   CPM22.asm:3523
getmt1     = $ED4C = 60748  _TEXT   CPM22.asm:2901
getnext    = $ED60 = 60768  _TEXT   CPM22.asm:2915
getnxt     = $F0CE = 61646  _TEXT   CPM22.asm:3486
getparm    = $F12C = 61740  _TEXT   CPM22.asm:3556
getprm1    = $F12F = 61743  _TEXT   CPM22.asm:3557
getrdr     = $E6D4 = 59092  _TEXT   CPM22.asm:1641
getrov     = $F11D = 61725  _TEXT   CPM22.asm:3544
gets2      = $E96F = 59759  _TEXT   CPM22.asm:2147
getsetuc   = $DD15 = 56597  _TEXT   CPM22.asm:204
getuser    = $F133 = 61747  _TEXT   CPM22.asm:3564
getusr     = $DD13 = 56595  _TEXT   CPM22.asm:199
getver     = $F084 = 61572  _TEXT   CPM22.asm:3440
getwprt    = $E924 = 59684  _TEXT   CPM22.asm:2087
goback     = $F17A = 61818  _TEXT   CPM22.asm:3620
goback1    = $F197 = 61847  _TEXT   CPM22.asm:3632
gtnext1    = $ED89 = 60809  _TEXT   CPM22.asm:2935
gtnext2    = $ED94 = 60820  _TEXT   CPM22.asm:2944
gtnext3    = $EDB2 = 60850  _TEXT   CPM22.asm:2955
gtnext4    = $EDB5 = 60853  _TEXT   CPM22.asm:2956
gtnext5    = $EDBC = 60860  _TEXT   CPM22.asm:2963
halt       = $DFDC = 57308  _TEXT   CPM22.asm:685
hl2de      = $E04F = 57423  _TEXT   CPM22.asm:754
home       = $F2DD = 62173  _TEXT   bios.asm:189
homedrv    = $E7A7 = 59303  _TEXT   CPM22.asm:1784
inbuff     = $DC06 = 56326  _TEXT   CPM22.asm:51
inpoint    = $DC88 = 56456  _TEXT   CPM22.asm:60
iobyte     = $0003 =     3  _TEXT   CPM22.asm:20
ioerr1     = $E70B = 59147  _TEXT   CPM22.asm:1691
ioret      = $E7C1 = 59329  _TEXT   CPM22.asm:1804
jumphl     = $E750 = 59216  _TEXT   CPM22.asm:1719
lf         = $000A =    10  _TEXT   CPM22.asm:33
list       = $F2C7 = 62151  _TEXT   bios.asm:166
logical    = $E890 = 59536  _TEXT   CPM22.asm:1968
logicl1    = $E896 = 59542  _TEXT   CPM22.asm:1970
login      = $F1B5 = 61877  _TEXT   CPM22.asm:3662
logindrv   = $F027 = 61479  _TEXT   CPM22.asm:3384
logoff     = $F159 = 61785  _TEXT   CPM22.asm:3594
logsect    = $F1ED = 61933  _TEXT   CPM22.asm:3708
mem        = $0037 =    55          config\config_fdc.asm:33
mode       = $F1DB = 61915  _TEXT   CPM22.asm:3695
morefls    = $E985 = 59781  _TEXT   CPM22.asm:2171
move3      = $E04D = 57421  _TEXT   CPM22.asm:750
movecd     = $DD29 = 56617  _TEXT   CPM22.asm:221
movedir    = $E9EF = 59887  _TEXT   CPM22.asm:2266
moveword   = $EC9A = 60570  _TEXT   CPM22.asm:2792
namepnt    = $DC8A = 56458  _TEXT   CPM22.asm:61
nbytes     = $E3FE = 58366  _TEXT   CPM22.asm:1233
newline    = $E5B7 = 58807  _TEXT   CPM22.asm:1478
newln1     = $E5BF = 58815  _TEXT   CPM22.asm:1481
nf_asva    = $FA28 = 64040  _BSS    nabu_fdc.asm:34
nf_asvb    = $FA42 = 64066  _BSS    nabu_fdc.asm:35
nf_busy    = $F607 = 62983  _TEXT   nabu_fdc.asm:524
nf_cach    = $FA7A = 64122  _BSS    nabu_fdc.asm:39
nf_ccp     = $F592 = 62866  _TEXT   nabu_fdc.asm:422
nf_csva    = $FA5C = 64092  _BSS    nabu_fdc.asm:36
nf_csvb    = $FA6B = 64107  _BSS    nabu_fdc.asm:37
nf_curd    = $FA23 = 64035  _BSS    nabu_fdc.asm:28
nf_dirt    = $FA27 = 64039  _BSS    nabu_fdc.asm:32
nf_dpb     = $F3E4 = 62436  _TEXT   nabu_fdc.asm:70
nf_dpha    = $F3C4 = 62404  _TEXT   nabu_fdc.asm:54
nf_dphb    = $F3D4 = 62420  _TEXT   nabu_fdc.asm:62
nf_dvsc    = $F5F0 = 62960  _TEXT   nabu_fdc.asm:505
nf_dvsl    = $F5F6 = 62966  _TEXT   nabu_fdc.asm:508
nf_grb     = $F58B = 62859  _TEXT   nabu_fdc.asm:417
nf_home    = $F436 = 62518  _TEXT   nabu_fdc.asm:144
nf_inco    = $FA26 = 64038  _BSS    nabu_fdc.asm:31
nf_ini1    = $F411 = 62481  _TEXT   nabu_fdc.asm:108
nf_ini2    = $F41F = 62495  _TEXT   nabu_fdc.asm:119
nf_init    = $F40B = 62475  _TEXT   nabu_fdc.asm:103
nf_io      = $FA21 = 64033  _BSS    nabu_fdc.asm:25
nf_r2k     = $F597 = 62871  _TEXT   nabu_fdc.asm:427
nf_r2k0    = $F5C0 = 62912  _TEXT   nabu_fdc.asm:456
nf_r2ks    = $FA22 = 64034  _BSS    nabu_fdc.asm:26
nf_rdsk    = $0002 =     2  _TEXT   nabu_fdc.asm:42
nf_rdw0    = $F516 = 62742  _TEXT   nabu_fdc.asm:319
nf_rdw1    = $F524 = 62756  _TEXT   nabu_fdc.asm:326
nf_rdwr    = $F4F7 = 62711  _TEXT   nabu_fdc.asm:298
nf_read    = $F529 = 62761  _TEXT   nabu_fdc.asm:332
nf_rph1    = $F5DD = 62941  _TEXT   nabu_fdc.asm:488
nf_rph2    = $F5EB = 62955  _TEXT   nabu_fdc.asm:497
nf_rphy    = $F5D4 = 62932  _TEXT   nabu_fdc.asm:479
nf_sel     = $F44E = 62542  _TEXT   nabu_fdc.asm:167
nf_sel0    = $F468 = 62568  _TEXT   nabu_fdc.asm:186
nf_sel1    = $F482 = 62594  _TEXT   nabu_fdc.asm:200
nf_sel2    = $F494 = 62612  _TEXT   nabu_fdc.asm:213
nf_selc    = $F475 = 62581  _TEXT   nabu_fdc.asm:194 (unused)
nf_seld    = $F459 = 62553  _TEXT   nabu_fdc.asm:175
nf_ssec    = $F4D8 = 62680  _TEXT   nabu_fdc.asm:271
nf_stal    = $F60D = 62989  _TEXT   nabu_fdc.asm:532
nf_str0    = $F4BB = 62651  _TEXT   nabu_fdc.asm:245
nf_strk    = $F4A2 = 62626  _TEXT   nabu_fdc.asm:226
nf_subs    = $FA24 = 64036  _BSS    nabu_fdc.asm:29
nf_sync    = $FA25 = 64037  _BSS    nabu_fdc.asm:30
nf_udsl    = $F5F5 = 62965  _TEXT   nabu_fdc.asm:507
nf_wde1    = $F564 = 62820  _TEXT   nabu_fdc.asm:380
nf_wde2    = $F572 = 62834  _TEXT   nabu_fdc.asm:389
nf_wde3    = $F583 = 62851  _TEXT   nabu_fdc.asm:408
nf_wde4    = $F586 = 62854  _TEXT   nabu_fdc.asm:411
nf_wdef    = $F549 = 62793  _TEXT   nabu_fdc.asm:362
nf_writ    = $F531 = 62769  _TEXT   nabu_fdc.asm:340
nfddev     = $F3F3 = 62451  _TEXT   nabu_fdc.asm:87
nfuncts    = $0029 =    41  _TEXT   CPM22.asm:1294
nofile     = $DFFD = 57341  _TEXT   CPM22.asm:700
nonblank   = $DE4F = 56911  _TEXT   CPM22.asm:422
none       = $DFF7 = 57335  _TEXT   CPM22.asm:698
nospace    = $E214 = 57876  _TEXT   CPM22.asm:1008
nulldev    = $F347 = 62279  _TEXT   bios.asm:307 (unused)
numcmds    = $0006 =     6  _TEXT   CPM22.asm:551
nxent1     = $EA1F = 59935  _TEXT   CPM22.asm:2304
nxent2     = $EA26 = 59942  _TEXT   CPM22.asm:2307
nxentry    = $EA0B = 59915  _TEXT   CPM22.asm:2296
offset     = $F1D4 = 61908  _TEXT   CPM22.asm:3688
olddrv     = $F1E5 = 61925  _TEXT   CPM22.asm:3702
open       = $DCCB = 56523  _TEXT   CPM22.asm:126
openfcb    = $DCD0 = 56528  _TEXT   CPM22.asm:131
openfil    = $F0A2 = 61602  _TEXT   CPM22.asm:3457
openit     = $EC57 = 60503  _TEXT   CPM22.asm:2749
openit1    = $EC60 = 60512  _TEXT   CPM22.asm:2753
openit2    = $EC91 = 60561  _TEXT   CPM22.asm:2781
outchar    = $E54E = 58702  _TEXT   CPM22.asm:1404
outchr1    = $E568 = 58728  _TEXT   CPM22.asm:1418
outchr2    = $E57F = 58751  _TEXT   CPM22.asm:1434
outcon     = $E596 = 58774  _TEXT   CPM22.asm:1455
outcon1    = $E59C = 58780  _TEXT   CPM22.asm:1458
outcrlf    = $E5CF = 58831  _TEXT   CPM22.asm:1491
outflag    = $E710 = 59152  _TEXT   CPM22.asm:1694
params     = $E749 = 59209  _TEXT   CPM22.asm:1710
pattrn1    = $DF28 = 57128  _TEXT   CPM22.asm:562
pattrn2    = $E400 = 58368  _TEXT   CPM22.asm:1239
pline      = $DCA7 = 56487  _TEXT   CPM22.asm:93
pline2     = $DCAC = 56492  _TEXT   CPM22.asm:96
position   = $EF09 = 61193  _TEXT   CPM22.asm:3159
positn1    = $EF0D = 61197  _TEXT   CPM22.asm:3164
positn2    = $EF4D = 61261  _TEXT   CPM22.asm:3210
positn3    = $EF85 = 61317  _TEXT   CPM22.asm:3242
positn4    = $EF8A = 61322  _TEXT   CPM22.asm:3248
positn5    = $EF91 = 61329  _TEXT   CPM22.asm:3255
pr_atla    = $0041 =    65  _TEXT   nabu_prt.asm:14
pr_ayda    = $0040 =    64  _TEXT   nabu_prt.asm:13
pr_ctrl    = $0000 =     0  _TEXT   nabu_prt.asm:16
pr_init    = $F8F4 = 63732  _TEXT   nabu_prt.asm:31
pr_prnt    = $00B0 =   176  _TEXT   nabu_prt.asm:15
pr_read    = $F8F7 = 63735  _TEXT   nabu_prt.asm:46
pr_stat    = $F8F5 = 63733  _TEXT   nabu_prt.asm:38
pr_wri0    = $F8FD = 63741  _TEXT   nabu_prt.asm:56
pr_wri1    = $F90C = 63756  _TEXT   nabu_prt.asm:67
pr_writ    = $F8F9 = 63737  _TEXT   nabu_prt.asm:53
print      = $DC8C = 56460  _TEXT   CPM22.asm:66
printb     = $DC92 = 56466  _TEXT   CPM22.asm:72
printdc    = $F202 = 61954  _TEXT   CPM22.asm:3718
prstat     = $F316 = 62230  _TEXT   bios.asm:261
prtdev     = $F8E9 = 63721  _TEXT   nabu_prt.asm:19
prterr     = $E4EB = 58603  _TEXT   CPM22.asm:1331
prtflag    = $E713 = 59155  _TEXT   CPM22.asm:1697
prtmesg    = $E5D9 = 58841  _TEXT   CPM22.asm:1498
prtstr     = $E6FE = 59134  _TEXT   CPM22.asm:1674
punch      = $F2CB = 62155  _TEXT   bios.asm:172
putdma     = $F110 = 61712  _TEXT   CPM22.asm:3533
ransiz1    = $EFEA = 61418  _TEXT   CPM22.asm:3338
ransiz2    = $F00C = 61452  _TEXT   CPM22.asm:3360
ransiz3    = $F012 = 61458  _TEXT   CPM22.asm:3362
ransize    = $EFD8 = 61400  _TEXT   CPM22.asm:3327
rdbuf1     = $E5F5 = 58869  _TEXT   CPM22.asm:1517
rdbuf10    = $E676 = 58998  _TEXT   CPM22.asm:1579
rdbuf11    = $E67E = 59006  _TEXT   CPM22.asm:1585
rdbuf12    = $E690 = 59024  _TEXT   CPM22.asm:1597
rdbuf13    = $E69F = 59039  _TEXT   CPM22.asm:1604
rdbuf14    = $E6AC = 59052  _TEXT   CPM22.asm:1612
rdbuf15    = $E6AF = 59055  _TEXT   CPM22.asm:1615
rdbuf16    = $E6C3 = 59075  _TEXT   CPM22.asm:1627
rdbuf17    = $E6C7 = 59079  _TEXT   CPM22.asm:1629
rdbuf2     = $E5F7 = 58871  _TEXT   CPM22.asm:1519
rdbuf3     = $E61C = 58908  _TEXT   CPM22.asm:1536
rdbuf4     = $E62C = 58924  _TEXT   CPM22.asm:1545
rdbuf5     = $E63D = 58941  _TEXT   CPM22.asm:1553
rdbuf6     = $E64E = 58958  _TEXT   CPM22.asm:1562
rdbuf7     = $E654 = 58964  _TEXT   CPM22.asm:1565
rdbuf8     = $E665 = 58981  _TEXT   CPM22.asm:1572
rdbuf9     = $E671 = 58993  _TEXT   CPM22.asm:1577
rdbuff     = $E5E7 = 58855  _TEXT   CPM22.asm:1510
rderr      = $DFEC = 57324  _TEXT   CPM22.asm:694
rderror    = $DFE6 = 57318  _TEXT   CPM22.asm:692
rdrandom   = $F147 = 61767  _TEXT   CPM22.asm:3575
rdrec      = $DCF9 = 56569  _TEXT   CPM22.asm:172
rdseq      = $EDC2 = 60866  _TEXT   CPM22.asm:2968
rdseq1     = $EDC7 = 60871  _TEXT   CPM22.asm:2970
rdseq2     = $EDEC = 60908  _TEXT   CPM22.asm:2985
rdseq3     = $EE01 = 60929  _TEXT   CPM22.asm:2995
rdwrtflg   = $F1D9 = 61913  _TEXT   CPM22.asm:3693
read       = $F30E = 62222  _TEXT   bios.asm:246
reader     = $F2CF = 62159  _TEXT   bios.asm:178
readfcb    = $DCFE = 56574  _TEXT   CPM22.asm:177
readran    = $EF99 = 61337  _TEXT   CPM22.asm:3262
readseq    = $F0E6 = 61670  _TEXT   CPM22.asm:3501
relblock   = $F1DD = 61917  _TEXT   CPM22.asm:3697
renam      = $DD0E = 56590  _TEXT   CPM22.asm:194
rename     = $E21D = 57885  _TEXT   CPM22.asm:1016
rename1    = $E24C = 57932  _TEXT   CPM22.asm:1034
rename2    = $E266 = 57958  _TEXT   CPM22.asm:1048
rename3    = $E26B = 57963  _TEXT   CPM22.asm:1051 (unused)
rename4    = $E27A = 57978  _TEXT   CPM22.asm:1059
rename5    = $E280 = 57984  _TEXT   CPM22.asm:1061
rename6    = $E286 = 57990  _TEXT   CPM22.asm:1063
renfile    = $F0FB = 61691  _TEXT   CPM22.asm:3517
resccp     = $F36E = 62318  _TEXT   config\config_fdc.asm:145
resdsk     = $DCB8 = 56504  _TEXT   CPM22.asm:107
resetdr    = $E073 = 57459  _TEXT   CPM22.asm:788
resgrb     = $F371 = 62321  _TEXT   config\config_fdc.asm:151
rodisk     = $E410 = 58384  _TEXT   CPM22.asm:1254
rofile     = $E412 = 58386  _TEXT   CPM22.asm:1255
rstdsk     = $F089 = 61577  _TEXT   CPM22.asm:3445
rtn        = $E70A = 59146  _TEXT   CPM22.asm:1687
rtncode    = $E3FB = 58363  _TEXT   CPM22.asm:1230
samext     = $EB0D = 60173  _TEXT   CPM22.asm:2499
savatr1    = $EC46 = 60486  _TEXT   CPM22.asm:2739
save       = $E1BA = 57786  _TEXT   CPM22.asm:961
save1      = $E1E1 = 57825  _TEXT   CPM22.asm:979
save2      = $E1FE = 57854  _TEXT   CPM22.asm:997
save3      = $E208 = 57864  _TEXT   CPM22.asm:1004
save4      = $E20E = 57870  _TEXT   CPM22.asm:1006
saveattr   = $EC41 = 60481  _TEXT   CPM22.asm:2737
savefcb    = $F1DF = 61919  _TEXT   CPM22.asm:3699
savext     = $F1E8 = 61928  _TEXT   CPM22.asm:3705
savnrec    = $F1E9 = 61929  _TEXT   CPM22.asm:3706
savnxt     = $F1E7 = 61927  _TEXT   CPM22.asm:3704
scratch1   = $F1B9 = 61881  _TEXT   CPM22.asm:3667
scratch2   = $F1BB = 61883  _TEXT   CPM22.asm:3668
scratch3   = $F1BD = 61885  _TEXT   CPM22.asm:3669
search     = $DF2E = 57134  _TEXT   CPM22.asm:570
search1    = $DF33 = 57139  _TEXT   CPM22.asm:572
search2    = $DF3C = 57148  _TEXT   CPM22.asm:577
search3    = $DF4F = 57167  _TEXT   CPM22.asm:589
search4    = $DF54 = 57172  _TEXT   CPM22.asm:592
sectors    = $F1C7 = 61895  _TEXT   CPM22.asm:3680
sectrn     = $F319 = 62233  _TEXT   bios.asm:266
seldsk     = $F2E2 = 62178  _TEXT   bios.asm:198
select     = $E75F = 59231  _TEXT   CPM22.asm:1738
select1    = $E7A3 = 59299  _TEXT   CPM22.asm:1778
setattr    = $F123 = 61731  _TEXT   CPM22.asm:3549
setbit     = $E911 = 59665  _TEXT   CPM22.asm:2070
setcdrv    = $DD1A = 56602  _TEXT   CPM22.asm:209
setdir     = $E9A2 = 59810  _TEXT   CPM22.asm:2204
setdma     = $F308 = 62216  _TEXT   bios.asm:238
setdsk     = $F04B = 61515  _TEXT   CPM22.asm:3405
setext     = $E8AC = 59564  _TEXT   CPM22.asm:1985
setfile    = $EA71 = 60017  _TEXT   CPM22.asm:2389
setfl1     = $EA7B = 60027  _TEXT   CPM22.asm:2394
setfl2     = $EA8E = 60046  _TEXT   CPM22.asm:2406
setfl3     = $EA94 = 60052  _TEXT   CPM22.asm:2412
setfl4     = $EAA3 = 60067  _TEXT   CPM22.asm:2421
sethlde    = $E8B4 = 59572  _TEXT   CPM22.asm:1993
setiob     = $E6F9 = 59129  _TEXT   CPM22.asm:1667
setnrec    = $E8D8 = 59608  _TEXT   CPM22.asm:2019
setran     = $F014 = 61460  _TEXT   CPM22.asm:3368
sets2b7    = $E97E = 59774  _TEXT   CPM22.asm:2161
setsec     = $F304 = 62212  _TEXT   bios.asm:231
setstat    = $E707 = 59143  _TEXT   CPM22.asm:1686
settrk     = $F300 = 62208  _TEXT   bios.asm:224
setuser    = $F141 = 61761  _TEXT   CPM22.asm:3569
shiftl     = $E90A = 59658  _TEXT   CPM22.asm:2061
shiftl1    = $E90B = 59659  _TEXT   CPM22.asm:2062
shiftr     = $E8F0 = 59632  _TEXT   CPM22.asm:2035
shiftr1    = $E8F1 = 59633  _TEXT   CPM22.asm:2036
showit     = $E585 = 58757  _TEXT   CPM22.asm:1442
siodev     = $F913 = 63763  _TEXT   nabu_sio.asm:20
slcterr    = $E74D = 59213  _TEXT   CPM22.asm:1715
so_atab    = $F983 = 63875  _TEXT   nabu_sio.asm:131
so_conf    = $F987 = 63879  _TEXT   nabu_sio.asm:135
so_ini0    = $F926 = 63782  _TEXT   nabu_sio.asm:39
so_ini1    = $F92C = 63788  _TEXT   nabu_sio.asm:43
so_ini2    = $F933 = 63795  _TEXT   nabu_sio.asm:49
so_ini3    = $F93F = 63807  _TEXT   nabu_sio.asm:59
so_init    = $F91E = 63774  _TEXT   nabu_sio.asm:33
so_rea0    = $F966 = 63846  _TEXT   nabu_sio.asm:102
so_read    = $F95D = 63837  _TEXT   nabu_sio.asm:95
so_sta0    = $F955 = 63829  _TEXT   nabu_sio.asm:83
so_stat    = $F94C = 63820  _TEXT   nabu_sio.asm:76
so_wri0    = $F979 = 63865  _TEXT   nabu_sio.asm:121
so_writ    = $F96F = 63855  _TEXT   nabu_sio.asm:113
space      = $DCA2 = 56482  _TEXT   CPM22.asm:87
srchfcb    = $DCE9 = 56553  _TEXT   CPM22.asm:154
srchfst    = $DCDF = 56543  _TEXT   CPM22.asm:144
srchnxt    = $DCE4 = 56548  _TEXT   CPM22.asm:149
starting   = $E711 = 59153  _TEXT   CPM22.asm:1695
status     = $E74B = 59211  _TEXT   CPM22.asm:1711
stbitmap   = $EA62 = 60002  _TEXT   CPM22.asm:2369
stbmap1    = $EA6A = 60010  _TEXT   CPM22.asm:2380
stddma     = $DDD5 = 56789  _TEXT   CPM22.asm:339
stfilpos   = $EA04 = 59908  _TEXT   CPM22.asm:2284
stkarea    = $E747 = 59207  _TEXT   CPM22.asm:1706
stnrec1    = $E8E4 = 59620  _TEXT   CPM22.asm:2024
strdata    = $E8C1 = 59585  _TEXT   CPM22.asm:2003
ststatus   = $EB07 = 60167  _TEXT   CPM22.asm:2491
subhl      = $E99B = 59803  _TEXT   CPM22.asm:2194
swindi0    = $F32F = 62255  _TEXT   bios.asm:290
swindi1    = $F335 = 62261  _TEXT   bios.asm:294
swindir    = $F32B = 62251  _TEXT   bios.asm:288
synerr     = $DE09 = 56841  _TEXT   CPM22.asm:377
synerr1    = $DE0F = 56847  _TEXT   CPM22.asm:379
synerr2    = $DE22 = 56866  _TEXT   CPM22.asm:389
syshook    = $F36D = 62317  _TEXT   config\config_fdc.asm:123
tab        = $0009 =     9  _TEXT   CPM22.asm:32
tbase      = $0100 =   256  _TEXT   CPM22.asm:25
tbuff      = $0080 =   128  _TEXT   CPM22.asm:24
tdrive     = $0004 =     4  _TEXT   CPM22.asm:21
tfcb       = $005C =    92  _TEXT   CPM22.asm:23
tm_40c     = $F7E9 = 63465  _TEXT   nabu_vdp.asm:399
tm_80c     = $F7F6 = 63478  _TEXT   nabu_vdp.asm:406
tm_addh    = $F8DA = 63706  _TEXT   nabu_vdp.asm:603
tm_addr    = $F8DC = 63708  _TEXT   nabu_vdp.asm:605
tm_bs      = $F747 = 63303  _TEXT   nabu_vdp.asm:290
tm_cbuf    = $FE80 = 65152  _BSS    nabu_vdp.asm:28
tm_cha0    = $F888 = 63624  _TEXT   nabu_vdp.asm:535
tm_chat    = $F882 = 63618  _TEXT   nabu_vdp.asm:530
tm_cle0    = $F7D5 = 63445  _TEXT   nabu_vdp.asm:384
tm_clea    = $F7C6 = 63430  _TEXT   nabu_vdp.asm:375
tm_cles    = $F7C4 = 63428  _TEXT   nabu_vdp.asm:374
tm_cloc    = $F675 = 63093  _TEXT   nabu_vdp.asm:129
tm_cls     = $F8C9 = 63689  _TEXT   nabu_vdp.asm:589
tm_cls0    = $F8D2 = 63698  _TEXT   nabu_vdp.asm:592
tm_cr      = $F744 = 63300  _TEXT   nabu_vdp.asm:287
tm_cshm    = $F756 = 63318  _TEXT   nabu_vdp.asm:304
tm_cupd    = $F7ED = 63469  _TEXT   nabu_vdp.asm:401
tm_curx    = $FE7A = 65146  _BSS    nabu_vdp.asm:22
tm_cury    = $FE7B = 65147  _BSS    nabu_vdp.asm:23
tm_data    = $00A0 =   160  _TEXT   nabu_vdp.asm:32
tm_dsc0    = $F80F = 63503  _TEXT   nabu_vdp.asm:421
tm_dsco    = $F7FC = 63484  _TEXT   nabu_vdp.asm:414
tm_esc     = $F78B = 63371  _TEXT   nabu_vdp.asm:336
tm_esc0    = $F799 = 63385  _TEXT   nabu_vdp.asm:345
tm_esc1    = $F7AE = 63406  _TEXT   nabu_vdp.asm:357
tm_esc2    = $F7B9 = 63417  _TEXT   nabu_vdp.asm:364
tm_escd    = $F794 = 63380  _TEXT   nabu_vdp.asm:342
tm_esci    = $F7A8 = 63400  _TEXT   nabu_vdp.asm:354
tm_escr    = $F795 = 63381  _TEXT   nabu_vdp.asm:343
tm_escs    = $FE7E = 65150  _BSS    nabu_vdp.asm:26
tm_getc    = $F822 = 63522  _TEXT   nabu_vdp.asm:442
tm_home    = $F759 = 63321  _TEXT   nabu_vdp.asm:305
tm_ini0    = $F66A = 63082  _TEXT   nabu_vdp.asm:116
tm_inir    = $F628 = 63016  _TEXT   nabu_vdp.asm:67
tm_init    = $F64E = 63054  _TEXT   nabu_vdp.asm:98
tm_inr0    = $F629 = 63017  _TEXT   nabu_vdp.asm:68
tm_keyd    = $0090 =   144  _TEXT   nabu_vdp.asm:35
tm_keys    = $0091 =   145  _TEXT   nabu_vdp.asm:36
tm_last    = $FE7F = 65151  _BSS    nabu_vdp.asm:27
tm_latc    = $00A1 =   161  _TEXT   nabu_vdp.asm:33
tm_lf      = $F738 = 63288  _TEXT   nabu_vdp.asm:278
tm_map     = $F832 = 63538  _TEXT   nabu_vdp.asm:459
tm_map0    = $F836 = 63542  _TEXT   nabu_vdp.asm:463
tm_map2    = $F842 = 63554  _TEXT   nabu_vdp.asm:476
tm_mapt    = $F849 = 63561  _TEXT   nabu_vdp.asm:483
tm_mode    = $F8E7 = 63719  _TEXT   nabu_vdp.asm:614
tm_oti0    = $F620 = 63008  _TEXT   nabu_vdp.asm:54
tm_otir    = $F61F = 63007  _TEXT   nabu_vdp.asm:53
tm_outc    = $FE7C = 65148  _BSS    nabu_vdp.asm:24
tm_putc    = $F85E = 63582  _TEXT   nabu_vdp.asm:501
tm_putf    = $F86C = 63596  _TEXT   nabu_vdp.asm:509 (unused)
tm_rea0    = $F6CD = 63181  _TEXT   nabu_vdp.asm:193
tm_rea1    = $F6E2 = 63202  _TEXT   nabu_vdp.asm:206
tm_rea2    = $F6F2 = 63218  _TEXT   nabu_vdp.asm:216
tm_read    = $F6B7 = 63159  _TEXT   nabu_vdp.asm:181
tm_ri      = $F731 = 63281  _TEXT   nabu_vdp.asm:272
tm_sclf    = $F68D = 63117  _TEXT   nabu_vdp.asm:145
tm_scr0    = $F685 = 63109  _TEXT   nabu_vdp.asm:142
tm_scr1    = $F68B = 63115  _TEXT   nabu_vdp.asm:144
tm_scri    = $F67B = 63099  _TEXT   nabu_vdp.asm:137
tm_scro    = $FE7D = 65149  _BSS    nabu_vdp.asm:25
tm_setp    = $F697 = 63127  _TEXT   nabu_vdp.asm:155
tm_sta0    = $F63C = 63036  _TEXT   nabu_vdp.asm:85
tm_sta1    = $F703 = 63235  _TEXT   nabu_vdp.asm:230
tm_stal    = $F700 = 63232  _TEXT   nabu_vdp.asm:228
tm_stat    = $F631 = 63025  _TEXT   nabu_vdp.asm:80
tm_up      = $F751 = 63313  _TEXT   nabu_vdp.asm:299
tm_usc0    = $F8B5 = 63669  _TEXT   nabu_vdp.asm:568
tm_usco    = $F8A6 = 63654  _TEXT   nabu_vdp.asm:561
tm_vcpy    = $F88E = 63630  _TEXT   nabu_vdp.asm:547
tm_wri0    = $F71E = 63262  _TEXT   nabu_vdp.asm:260
tm_wri1    = $F75D = 63325  _TEXT   nabu_vdp.asm:310
tm_writ    = $F709 = 63241  _TEXT   nabu_vdp.asm:242
trksec     = $E7C9 = 59337  _TEXT   CPM22.asm:1812
trksec1    = $E7D7 = 59351  _TEXT   CPM22.asm:1821
trksec2    = $E7EA = 59370  _TEXT   CPM22.asm:1834
trksec3    = $E800 = 59392  _TEXT   CPM22.asm:1850
trksec4    = $E815 = 59413  _TEXT   CPM22.asm:1867
type       = $E16A = 57706  _TEXT   CPM22.asm:918
type1      = $E181 = 57729  _TEXT   CPM22.asm:926
type2      = $E184 = 57732  _TEXT   CPM22.asm:927 (unused)
type3      = $E194 = 57748  _TEXT   CPM22.asm:936
type4      = $E1AD = 57773  _TEXT   CPM22.asm:949
type5      = $E1B4 = 57780  _TEXT   CPM22.asm:952
unknown    = $E2B2 = 58034  _TEXT   CPM22.asm:1090
unkwn0     = $E37E = 58238  _TEXT   CPM22.asm:1198
unkwn1     = $E2D1 = 58065  _TEXT   CPM22.asm:1105
unkwn2     = $E2DA = 58074  _TEXT   CPM22.asm:1109 (unused)
unkwn3     = $E2EE = 58094  _TEXT   CPM22.asm:1120
unkwn4     = $E30E = 58126  _TEXT   CPM22.asm:1139
unkwn5     = $E33D = 58173  _TEXT   CPM22.asm:1160
unkwn6     = $E34B = 58187  _TEXT   CPM22.asm:1170
unkwn7     = $E350 = 58192  _TEXT   CPM22.asm:1172
unkwn8     = $E35C = 58204  _TEXT   CPM22.asm:1180
unkwn9     = $E378 = 58232  _TEXT   CPM22.asm:1196
update     = $EC07 = 60423  _TEXT   CPM22.asm:2700
update1    = $EC16 = 60438  _TEXT   CPM22.asm:2708
upper      = $DD30 = 56624  _TEXT   CPM22.asm:228
user       = $E29B = 58011  _TEXT   CPM22.asm:1074
userdma    = $F1B7 = 61879  _TEXT   CPM22.asm:3663
userno     = $E747 = 59207  _TEXT   CPM22.asm:1708
usrstack   = $E715 = 59157  _TEXT   CPM22.asm:1702
vdpdev     = $F612 = 62994  _TEXT   nabu_vdp.asm:39
verify     = $DDF5 = 56821  _TEXT   CPM22.asm:363
verify1    = $DDFD = 56829  _TEXT   CPM22.asm:366
wbinit     = $F34D = 62285  _TEXT   config\config_fdc.asm:58
wboot      = $F253 = 62035  _TEXT   bios.asm:57
wboot0     = $F276 = 62070  _TEXT   bios.asm:88
wbootin    = $F215 = 61973  _TEXT   bios.asm:22
wbootr     = $F266 = 62054  _TEXT   bios.asm:76
write      = $F312 = 62226  _TEXT   bios.asm:253
writeran   = $EFA2 = 61346  _TEXT   CPM22.asm:3269
wrtprt     = $F1B3 = 61875  _TEXT   CPM22.asm:3661
wrtprtd    = $E932 = 59698  _TEXT   CPM22.asm:2097
wrtrec     = $DD04 = 56580  _TEXT   CPM22.asm:183
wrtseq     = $F0EC = 61676  _TEXT   CPM22.asm:3506
wtrandom   = $F14D = 61773  _TEXT   CPM22.asm:3580
wtseq      = $EE04 = 60932  _TEXT   CPM22.asm:2999
wtseq1     = $EE09 = 60937  _TEXT   CPM22.asm:3001
wtseq10    = $EED8 = 61144  _TEXT   CPM22.asm:3116
wtseq11    = $EF04 = 61188  _TEXT   CPM22.asm:3140
wtseq12    = $EF06 = 61190  _TEXT   CPM22.asm:3141
wtseq2     = $EE41 = 60993  _TEXT   CPM22.asm:3024
wtseq3     = $EE4E = 61006  _TEXT   CPM22.asm:3030
wtseq4     = $EE6A = 61034  _TEXT   CPM22.asm:3042
wtseq5     = $EE72 = 61042  _TEXT   CPM22.asm:3049
wtseq6     = $EE74 = 61044  _TEXT   CPM22.asm:3050
wtseq7     = $EE92 = 61074  _TEXT   CPM22.asm:3073
wtseq8     = $EEA0 = 61088  _TEXT   CPM22.asm:3080
wtseq9     = $EEC1 = 61121  _TEXT   CPM22.asm:3100
wtseq99    = $EEE5 = 61157  _TEXT   CPM22.asm:3127 (unused)
wtspecl    = $F1A1 = 61857  _TEXT   CPM22.asm:3646
xlate      = $F1D6 = 61910  _TEXT   CPM22.asm:3689
yesno      = $E15F = 57695  _TEXT   CPM22.asm:910


total time: 0.0660 sec.
no errors
